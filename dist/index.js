var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/viem/_esm/errors/version.js
var version = "2.22.17";

// node_modules/viem/_esm/errors/base.js
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== undefined)
    return walk(err.cause, fn);
  return fn ? null : err;
}
var errorConfig, BaseError;
var init_base = __esm(() => {
  errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : undefined,
    version: `viem@${version}`
  };
  BaseError = class BaseError extends Error {
    constructor(shortMessage, args = {}) {
      const details = (() => {
        if (args.cause instanceof BaseError)
          return args.cause.details;
        if (args.cause?.message)
          return args.cause.message;
        return args.details;
      })();
      const docsPath = (() => {
        if (args.cause instanceof BaseError)
          return args.cause.docsPath || args.docsPath;
        return args.docsPath;
      })();
      const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsUrl ? [`Docs: ${docsUrl}`] : [],
        ...details ? [`Details: ${details}`] : [],
        ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
      ].join(`
`);
      super(message, args.cause ? { cause: args.cause } : undefined);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseError"
      });
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.name = args.name ?? this.name;
      this.shortMessage = shortMessage;
      this.version = version;
    }
    walk(fn) {
      return walk(this, fn);
    }
  };
});

// node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, SizeOverflowError;
var init_encoding = __esm(() => {
  init_base();
  IntegerOutOfRangeError = class IntegerOutOfRangeError extends BaseError {
    constructor({ max, min, signed, size, value }) {
      super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
    }
  };
  InvalidBytesBooleanError = class InvalidBytesBooleanError extends BaseError {
    constructor(bytes) {
      super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
        name: "InvalidBytesBooleanError"
      });
    }
  };
  InvalidHexBooleanError = class InvalidHexBooleanError extends BaseError {
    constructor(hex) {
      super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
    }
  };
  SizeOverflowError = class SizeOverflowError extends BaseError {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
    }
  };
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

// node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = () => {
};

// node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0;i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// node_modules/viem/_esm/errors/data.js
var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;
var init_data = __esm(() => {
  init_base();
  SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends BaseError {
    constructor({ offset, position, size: size2 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`, { name: "SliceOffsetOutOfBoundsError" });
    }
  };
  SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends BaseError {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
    }
  };
  InvalidBytesLengthError = class InvalidBytesLengthError extends BaseError {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`, { name: "InvalidBytesLengthError" });
    }
  };
});

// node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0;i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm(() => {
  init_data();
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string = "";
  for (let i = 0;i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, opts);
}
var hexes, encoder;
var init_toHex = __esm(() => {
  init_encoding();
  init_pad();
  init_fromHex();
  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  encoder = /* @__PURE__ */ new TextEncoder;
});

// node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { size: opts.size });
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0;index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
var encoder2, charCodeMap;
var init_toBytes = __esm(() => {
  init_base();
  init_pad();
  init_fromHex();
  init_toHex();
  encoder2 = /* @__PURE__ */ new TextEncoder;
  charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
var init_fromHex = __esm(() => {
  init_encoding();
  init_size();
});

// node_modules/viem/_esm/utils/formatters/formatter.js
function defineFormatter(type, format) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type
    };
  };
}

// node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.authorizationList !== "undefined")
    rpcRequest.authorizationList = formatAuthorizationList2(request.authorizationList);
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x) => bytesToHex(x));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.contractAddress,
    r: authorization.r,
    s: authorization.s,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
  }));
}
var rpcTransactionType;
var init_transactionRequest = __esm(() => {
  init_toHex();
  rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3",
    eip7702: "0x4"
  };
});

// node_modules/viem/_esm/constants/number.js
var maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;
var init_number = __esm(() => {
  maxInt8 = 2n ** (8n - 1n) - 1n;
  maxInt16 = 2n ** (16n - 1n) - 1n;
  maxInt24 = 2n ** (24n - 1n) - 1n;
  maxInt32 = 2n ** (32n - 1n) - 1n;
  maxInt40 = 2n ** (40n - 1n) - 1n;
  maxInt48 = 2n ** (48n - 1n) - 1n;
  maxInt56 = 2n ** (56n - 1n) - 1n;
  maxInt64 = 2n ** (64n - 1n) - 1n;
  maxInt72 = 2n ** (72n - 1n) - 1n;
  maxInt80 = 2n ** (80n - 1n) - 1n;
  maxInt88 = 2n ** (88n - 1n) - 1n;
  maxInt96 = 2n ** (96n - 1n) - 1n;
  maxInt104 = 2n ** (104n - 1n) - 1n;
  maxInt112 = 2n ** (112n - 1n) - 1n;
  maxInt120 = 2n ** (120n - 1n) - 1n;
  maxInt128 = 2n ** (128n - 1n) - 1n;
  maxInt136 = 2n ** (136n - 1n) - 1n;
  maxInt144 = 2n ** (144n - 1n) - 1n;
  maxInt152 = 2n ** (152n - 1n) - 1n;
  maxInt160 = 2n ** (160n - 1n) - 1n;
  maxInt168 = 2n ** (168n - 1n) - 1n;
  maxInt176 = 2n ** (176n - 1n) - 1n;
  maxInt184 = 2n ** (184n - 1n) - 1n;
  maxInt192 = 2n ** (192n - 1n) - 1n;
  maxInt200 = 2n ** (200n - 1n) - 1n;
  maxInt208 = 2n ** (208n - 1n) - 1n;
  maxInt216 = 2n ** (216n - 1n) - 1n;
  maxInt224 = 2n ** (224n - 1n) - 1n;
  maxInt232 = 2n ** (232n - 1n) - 1n;
  maxInt240 = 2n ** (240n - 1n) - 1n;
  maxInt248 = 2n ** (248n - 1n) - 1n;
  maxInt256 = 2n ** (256n - 1n) - 1n;
  minInt8 = -(2n ** (8n - 1n));
  minInt16 = -(2n ** (16n - 1n));
  minInt24 = -(2n ** (24n - 1n));
  minInt32 = -(2n ** (32n - 1n));
  minInt40 = -(2n ** (40n - 1n));
  minInt48 = -(2n ** (48n - 1n));
  minInt56 = -(2n ** (56n - 1n));
  minInt64 = -(2n ** (64n - 1n));
  minInt72 = -(2n ** (72n - 1n));
  minInt80 = -(2n ** (80n - 1n));
  minInt88 = -(2n ** (88n - 1n));
  minInt96 = -(2n ** (96n - 1n));
  minInt104 = -(2n ** (104n - 1n));
  minInt112 = -(2n ** (112n - 1n));
  minInt120 = -(2n ** (120n - 1n));
  minInt128 = -(2n ** (128n - 1n));
  minInt136 = -(2n ** (136n - 1n));
  minInt144 = -(2n ** (144n - 1n));
  minInt152 = -(2n ** (152n - 1n));
  minInt160 = -(2n ** (160n - 1n));
  minInt168 = -(2n ** (168n - 1n));
  minInt176 = -(2n ** (176n - 1n));
  minInt184 = -(2n ** (184n - 1n));
  minInt192 = -(2n ** (192n - 1n));
  minInt200 = -(2n ** (200n - 1n));
  minInt208 = -(2n ** (208n - 1n));
  minInt216 = -(2n ** (216n - 1n));
  minInt224 = -(2n ** (224n - 1n));
  minInt232 = -(2n ** (232n - 1n));
  minInt240 = -(2n ** (240n - 1n));
  minInt248 = -(2n ** (248n - 1n));
  minInt256 = -(2n ** (256n - 1n));
  maxUint8 = 2n ** 8n - 1n;
  maxUint16 = 2n ** 16n - 1n;
  maxUint24 = 2n ** 24n - 1n;
  maxUint32 = 2n ** 32n - 1n;
  maxUint40 = 2n ** 40n - 1n;
  maxUint48 = 2n ** 48n - 1n;
  maxUint56 = 2n ** 56n - 1n;
  maxUint64 = 2n ** 64n - 1n;
  maxUint72 = 2n ** 72n - 1n;
  maxUint80 = 2n ** 80n - 1n;
  maxUint88 = 2n ** 88n - 1n;
  maxUint96 = 2n ** 96n - 1n;
  maxUint104 = 2n ** 104n - 1n;
  maxUint112 = 2n ** 112n - 1n;
  maxUint120 = 2n ** 120n - 1n;
  maxUint128 = 2n ** 128n - 1n;
  maxUint136 = 2n ** 136n - 1n;
  maxUint144 = 2n ** 144n - 1n;
  maxUint152 = 2n ** 152n - 1n;
  maxUint160 = 2n ** 160n - 1n;
  maxUint168 = 2n ** 168n - 1n;
  maxUint176 = 2n ** 176n - 1n;
  maxUint184 = 2n ** 184n - 1n;
  maxUint192 = 2n ** 192n - 1n;
  maxUint200 = 2n ** 200n - 1n;
  maxUint208 = 2n ** 208n - 1n;
  maxUint216 = 2n ** 216n - 1n;
  maxUint224 = 2n ** 224n - 1n;
  maxUint232 = 2n ** 232n - 1n;
  maxUint240 = 2n ** 240n - 1n;
  maxUint248 = 2n ** 248n - 1n;
  maxUint256 = 2n ** 256n - 1n;
});

// node_modules/viem/_esm/utils/data/concat.js
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes(values);
}
function concatBytes(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}

// node_modules/viem/_esm/errors/cursor.js
var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
var init_cursor = __esm(() => {
  init_base();
  NegativeOffsetError = class NegativeOffsetError extends BaseError {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`, {
        name: "NegativeOffsetError"
      });
    }
  };
  PositionOutOfBoundsError = class PositionOutOfBoundsError extends BaseError {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
    }
  };
  RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends BaseError {
    constructor({ count, limit }) {
      super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
    }
  };
});

// node_modules/viem/_esm/utils/cursor.js
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = new Map;
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var staticCursor;
var init_cursor2 = __esm(() => {
  init_cursor();
  staticCursor = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new PositionOutOfBoundsError({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes) {
      this.assertPosition(this.position + bytes.length - 1);
      this.bytes.set(bytes, this.position);
      this.position += bytes.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4294967040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size2) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size2 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
        return;
      const count = this.getReadCount();
      this.positionReadCount.set(this.position, count + 1);
      if (count > 0)
        this.recursiveReadCount++;
    }
  };
});

// node_modules/viem/_esm/constants/unit.js
var etherUnits, gweiUnits;
var init_unit = __esm(() => {
  etherUnits = {
    gwei: 9,
    wei: 18
  };
  gweiUnits = {
    ether: -9,
    wei: 9
  };
});

// node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
var init_formatEther = __esm(() => {
  init_unit();
});

// node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm(() => {
  init_unit();
});

// node_modules/viem/_esm/errors/transaction.js
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === undefined || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(`
`);
}
var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
var init_transaction = __esm(() => {
  init_formatEther();
  init_formatGwei();
  init_base();
  FeeConflictError = class FeeConflictError extends BaseError {
    constructor() {
      super([
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
      ].join(`
`), { name: "FeeConflictError" });
    }
  };
  InvalidLegacyVError = class InvalidLegacyVError extends BaseError {
    constructor({ v }) {
      super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
        name: "InvalidLegacyVError"
      });
    }
  };
  InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends BaseError {
    constructor({ transaction }) {
      super("Cannot infer a transaction type from provided transaction.", {
        metaMessages: [
          "Provided Transaction:",
          "{",
          prettyPrint(transaction),
          "}",
          "",
          "To infer the type, either provide:",
          "- a `type` to the Transaction, or",
          "- an EIP-1559 Transaction with `maxFeePerGas`, or",
          "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
          "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
          "- an EIP-7702 Transaction with `authorizationList`, or",
          "- a Legacy Transaction with `gasPrice`"
        ],
        name: "InvalidSerializableTransactionError"
      });
    }
  };
  InvalidStorageKeySizeError = class InvalidStorageKeySizeError extends BaseError {
    constructor({ storageKey }) {
      super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
    }
  };
  TransactionExecutionError = class TransactionExecutionError extends BaseError {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
      const prettyArgs = prettyPrint({
        chain: chain && `${chain?.name} (id: ${chain?.id})`,
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Request Arguments:",
          prettyArgs
        ].filter(Boolean),
        name: "TransactionExecutionError"
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.cause = cause;
    }
  };
  TransactionNotFoundError = class TransactionNotFoundError extends BaseError {
    constructor({ blockHash, blockNumber, blockTag, hash, index }) {
      let identifier = "Transaction";
      if (blockTag && index !== undefined)
        identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
      if (blockHash && index !== undefined)
        identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
      if (blockNumber && index !== undefined)
        identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
      if (hash)
        identifier = `Transaction with hash "${hash}"`;
      super(`${identifier} could not be found.`, {
        name: "TransactionNotFoundError"
      });
    }
  };
  TransactionReceiptNotFoundError = class TransactionReceiptNotFoundError extends BaseError {
    constructor({ hash }) {
      super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`, {
        name: "TransactionReceiptNotFoundError"
      });
    }
  };
  WaitForTransactionReceiptTimeoutError = class WaitForTransactionReceiptTimeoutError extends BaseError {
    constructor({ hash }) {
      super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
    }
  };
});

// node_modules/viem/node_modules/@noble/hashes/esm/_assert.js
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
var init__assert = () => {
};

// node_modules/viem/node_modules/@noble/hashes/esm/crypto.js
var crypto2;
var init_crypto = __esm(() => {
  crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
});

// node_modules/viem/node_modules/@noble/hashes/esm/utils.js
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0;i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}

class Hash {
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return crypto2.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var isLE;
var init_utils = __esm(() => {
  init_crypto();
  init__assert();
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
});

// node_modules/viem/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD;
var init__md = __esm(() => {
  init__assert();
  init_utils();
  HashMD = class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };
});

// node_modules/viem/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K, SHA256_IV, SHA256_W, SHA256, sha256;
var init_sha256 = __esm(() => {
  init__md();
  init_utils();
  SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  SHA256 = class SHA256 extends HashMD {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256);
});

// node_modules/viem/_esm/errors/address.js
var InvalidAddressError;
var init_address = __esm(() => {
  init_base();
  InvalidAddressError = class InvalidAddressError extends BaseError {
    constructor({ address }) {
      super(`Address "${address}" is invalid.`, {
        metaMessages: [
          "- Address must be a hex value of 20 bytes (40 hex characters).",
          "- Address must match its checksum counterpart."
        ],
        name: "InvalidAddressError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/chain.js
var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError, InvalidChainIdError;
var init_chain = __esm(() => {
  init_base();
  ChainDoesNotSupportContract = class ChainDoesNotSupportContract extends BaseError {
    constructor({ blockNumber, chain, contract }) {
      super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
        metaMessages: [
          "This could be due to any of the following:",
          ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
          ] : [
            `- The chain does not have the contract "${contract.name}" configured.`
          ]
        ],
        name: "ChainDoesNotSupportContract"
      });
    }
  };
  ChainMismatchError = class ChainMismatchError extends BaseError {
    constructor({ chain, currentChainId }) {
      super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
        metaMessages: [
          `Current Chain ID:  ${currentChainId}`,
          `Expected Chain ID: ${chain.id} – ${chain.name}`
        ],
        name: "ChainMismatchError"
      });
    }
  };
  ChainNotFoundError = class ChainNotFoundError extends BaseError {
    constructor() {
      super([
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
      ].join(`
`), {
        name: "ChainNotFoundError"
      });
    }
  };
  ClientChainNotConfiguredError = class ClientChainNotConfiguredError extends BaseError {
    constructor() {
      super("No chain was provided to the Client.", {
        name: "ClientChainNotConfiguredError"
      });
    }
  };
  InvalidChainIdError = class InvalidChainIdError extends BaseError {
    constructor({ chainId }) {
      super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
    }
  };
});

// node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
var init_node = __esm(() => {
  init_formatGwei();
  init_base();
  ExecutionRevertedError = class ExecutionRevertedError extends BaseError {
    constructor({ cause, message } = {}) {
      const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
      super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
        cause,
        name: "ExecutionRevertedError"
      });
    }
  };
  Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });
  FeeCapTooHighError = class FeeCapTooHighError extends BaseError {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
        cause,
        name: "FeeCapTooHighError"
      });
    }
  };
  Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });
  FeeCapTooLowError = class FeeCapTooLowError extends BaseError {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
        cause,
        name: "FeeCapTooLowError"
      });
    }
  };
  Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });
  NonceTooHighError = class NonceTooHighError extends BaseError {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
    }
  };
  Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });
  NonceTooLowError = class NonceTooLowError extends BaseError {
    constructor({ cause, nonce } = {}) {
      super([
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join(`
`), { cause, name: "NonceTooLowError" });
    }
  };
  Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });
  NonceMaxValueError = class NonceMaxValueError extends BaseError {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
    }
  };
  Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });
  InsufficientFundsError = class InsufficientFundsError extends BaseError {
    constructor({ cause } = {}) {
      super([
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join(`
`), {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ],
        name: "InsufficientFundsError"
      });
    }
  };
  Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds|exceeds transaction sender account balance/
  });
  IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends BaseError {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
        cause,
        name: "IntrinsicGasTooHighError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });
  IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends BaseError {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
        cause,
        name: "IntrinsicGasTooLowError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });
  TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends BaseError {
    constructor({ cause }) {
      super("The transaction type is not supported for this chain.", {
        cause,
        name: "TransactionTypeNotSupportedError"
      });
    }
  };
  Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });
  TipAboveFeeCapError = class TipAboveFeeCapError extends BaseError {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
      super([
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
      ].join(`
`), {
        cause,
        name: "TipAboveFeeCapError"
      });
    }
  };
  Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });
  UnknownNodeError = class UnknownNodeError extends BaseError {
    constructor({ cause }) {
      super(`An error occurred while executing: ${cause?.shortMessage}`, {
        cause,
        name: "UnknownNodeError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/lru.js
var LruMap;
var init_lru = __esm(() => {
  LruMap = class LruMap extends Map {
    constructor(size2) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.maxSize = size2;
    }
    get(key) {
      const value = super.get(key);
      if (super.has(key) && value !== undefined) {
        this.delete(key);
        super.set(key, value);
      }
      return value;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize) {
        const firstKey = this.keys().next().value;
        if (firstKey)
          this.delete(firstKey);
      }
      return this;
    }
  };
});

// node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK64, _32n, rotlSH = (h, l, s) => h << s | l >>> 32 - s, rotlSL = (h, l, s) => l << s | h >>> 32 - s, rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s, rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var init__u64 = __esm(() => {
  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  _32n = /* @__PURE__ */ BigInt(32);
});

// node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s), rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s), Keccak, gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen)), sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)), shake128, shake256;
var init_sha3 = __esm(() => {
  init__assert();
  init__u64();
  init_utils();
  SHA3_PI = [];
  SHA3_ROTL = [];
  _SHA3_IOTA = [];
  _0n = /* @__PURE__ */ BigInt(0);
  _1n = /* @__PURE__ */ BigInt(1);
  _2n = /* @__PURE__ */ BigInt(2);
  _7n = /* @__PURE__ */ BigInt(7);
  _256n = /* @__PURE__ */ BigInt(256);
  _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  Keccak = class Keccak extends Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      anumber(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      if (!isLE)
        byteSwap32(this.state32);
      keccakP(this.state32, this.rounds);
      if (!isLE)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      aexists(this);
      const { blockLen, state } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      aexists(this, false);
      abytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
});

// node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}
var init_keccak256 = __esm(() => {
  init_sha3();
  init_toBytes();
  init_toHex();
});

// node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0;i < 40; i += 2) {
    if (hash[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress(address, chainId) {
  if (!isAddress(address, { strict: false }))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId);
}
var checksumAddressCache;
var init_getAddress = __esm(() => {
  init_address();
  init_toBytes();
  init_keccak256();
  init_lru();
  init_isAddress();
  checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey))
    return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}
var addressRegex, isAddressCache;
var init_isAddress = __esm(() => {
  init_lru();
  init_getAddress();
  addressRegex = /^0x[a-fA-F0-9]{40}$/;
  isAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm(() => {
  init_data();
  init_size();
});

// node_modules/viem/_esm/utils/chain/getChainContractAddress.js
function getChainContractAddress({ blockNumber, chain, contract: name }) {
  const contract = chain?.contracts?.[name];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
var init_getChainContractAddress = __esm(() => {
  init_chain();
});

// node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}

// node_modules/viem/_esm/constants/solidity.js
var panicReasons, solidityError, solidityPanic;
var init_solidity = __esm(() => {
  panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  };
  solidityError = {
    inputs: [
      {
        name: "message",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  };
  solidityPanic = {
    inputs: [
      {
        name: "reason",
        type: "uint256"
      }
    ],
    name: "Panic",
    type: "error"
  };
});

// node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
var init_formatAbiItem = __esm(() => {
  init_abi();
});

// node_modules/viem/_esm/errors/abi.js
var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
var init_abi = __esm(() => {
  init_formatAbiItem();
  init_size();
  init_base();
  AbiConstructorNotFoundError = class AbiConstructorNotFoundError extends BaseError {
    constructor({ docsPath }) {
      super([
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiConstructorNotFoundError"
      });
    }
  };
  AbiConstructorParamsNotFoundError = class AbiConstructorParamsNotFoundError extends BaseError {
    constructor({ docsPath }) {
      super([
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
      ].join(`
`), {
        docsPath,
        name: "AbiConstructorParamsNotFoundError"
      });
    }
  };
  AbiDecodingDataSizeTooSmallError = class AbiDecodingDataSizeTooSmallError extends BaseError {
    constructor({ data, params, size: size2 }) {
      super([`Data size of ${size2} bytes is too small for given parameters.`].join(`
`), {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ],
        name: "AbiDecodingDataSizeTooSmallError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  AbiDecodingZeroDataError = class AbiDecodingZeroDataError extends BaseError {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.', {
        name: "AbiDecodingZeroDataError"
      });
    }
  };
  AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends BaseError {
    constructor({ expectedLength, givenLength, type }) {
      super([
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
    }
  };
  AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends BaseError {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
    }
  };
  AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends BaseError {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
    }
  };
  AbiErrorSignatureNotFoundError = class AbiErrorSignatureNotFoundError extends BaseError {
    constructor(signature, { docsPath }) {
      super([
        `Encoded error signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiErrorSignatureNotFoundError"
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.signature = signature;
    }
  };
  AbiEventSignatureEmptyTopicsError = class AbiEventSignatureEmptyTopicsError extends BaseError {
    constructor({ docsPath }) {
      super("Cannot extract event signature from empty topics.", {
        docsPath,
        name: "AbiEventSignatureEmptyTopicsError"
      });
    }
  };
  AbiEventSignatureNotFoundError = class AbiEventSignatureNotFoundError extends BaseError {
    constructor(signature, { docsPath }) {
      super([
        `Encoded event signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiEventSignatureNotFoundError"
      });
    }
  };
  AbiEventNotFoundError = class AbiEventNotFoundError extends BaseError {
    constructor(eventName, { docsPath } = {}) {
      super([
        `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiEventNotFoundError"
      });
    }
  };
  AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends BaseError {
    constructor(functionName, { docsPath } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionNotFoundError"
      });
    }
  };
  AbiFunctionOutputsNotFoundError = class AbiFunctionOutputsNotFoundError extends BaseError {
    constructor(functionName, { docsPath }) {
      super([
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionOutputsNotFoundError"
      });
    }
  };
  AbiItemAmbiguityError = class AbiItemAmbiguityError extends BaseError {
    constructor(x, y) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x.type}\` in \`${formatAbiItem(x.abiItem)}\`, and`,
          `\`${y.type}\` in \`${formatAbiItem(y.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ],
        name: "AbiItemAmbiguityError"
      });
    }
  };
  BytesSizeMismatchError = class BytesSizeMismatchError extends BaseError {
    constructor({ expectedSize, givenSize }) {
      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
        name: "BytesSizeMismatchError"
      });
    }
  };
  DecodeLogDataMismatch = class DecodeLogDataMismatch extends BaseError {
    constructor({ abiItem, data, params, size: size2 }) {
      super([
        `Data size of ${size2} bytes is too small for non-indexed event parameters.`
      ].join(`
`), {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ],
        name: "DecodeLogDataMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  DecodeLogTopicsMismatch = class DecodeLogTopicsMismatch extends BaseError {
    constructor({ abiItem, param }) {
      super([
        `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem(abiItem, { includeName: true })}".`
      ].join(`
`), { name: "DecodeLogTopicsMismatch" });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
    }
  };
  InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends BaseError {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiEncodingType" });
    }
  };
  InvalidAbiDecodingTypeError = class InvalidAbiDecodingTypeError extends BaseError {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiDecodingType" });
    }
  };
  InvalidArrayError = class InvalidArrayError extends BaseError {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join(`
`), {
        name: "InvalidArrayError"
      });
    }
  };
  InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends BaseError {
    constructor(type) {
      super([
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join(`
`), { name: "InvalidDefinitionTypeError" });
    }
  };
});

// node_modules/viem/_esm/utils/hash/hashSignature.js
function hashSignature(sig) {
  return hash(sig);
}
var hash = (value) => keccak256(toBytes(value));
var init_hashSignature = __esm(() => {
  init_toBytes();
  init_keccak256();
});

// node_modules/abitype/dist/esm/version.js
var version2 = "1.0.8";

// node_modules/abitype/dist/esm/errors.js
var BaseError2;
var init_errors = __esm(() => {
  BaseError2 = class BaseError2 extends Error {
    constructor(shortMessage, args = {}) {
      const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
      const docsPath = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: abitype@${version2}`
      ].join(`
`);
      super(message);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiTypeError"
      });
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
  };
});

// node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match?.groups;
}
var bytesRegex, integerRegex, isTupleRegex;
var init_regex = __esm(() => {
  bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  isTupleRegex = /^\(.+?\).*?$/;
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0;i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
var tupleRegex;
var init_formatAbiParameter = __esm(() => {
  init_regex();
  tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0;i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
var init_formatAbiParameters = __esm(() => {
  init_formatAbiParameter();
});

// node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem2(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}
var init_formatAbiItem2 = __esm(() => {
  init_formatAbiParameters();
});

// node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
function isErrorSignature(signature) {
  return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
  return execTyped(errorSignatureRegex, signature);
}
function isEventSignature(signature) {
  return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
  return execTyped(eventSignatureRegex, signature);
}
function isFunctionSignature(signature) {
  return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
  return execTyped(functionSignatureRegex, signature);
}
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
  return execTyped(structSignatureRegex, signature);
}
function isConstructorSignature(signature) {
  return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
  return execTyped(constructorSignatureRegex, signature);
}
function isFallbackSignature(signature) {
  return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
  return execTyped(fallbackSignatureRegex, signature);
}
function isReceiveSignature(signature) {
  return receiveSignatureRegex.test(signature);
}
var errorSignatureRegex, eventSignatureRegex, functionSignatureRegex, structSignatureRegex, constructorSignatureRegex, fallbackSignatureRegex, receiveSignatureRegex, modifiers, eventModifiers, functionModifiers;
var init_signatures = __esm(() => {
  init_regex();
  errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
  eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
  functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
  structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
  constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
  fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
  receiveSignatureRegex = /^receive\(\) external payable$/;
  modifiers = new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  eventModifiers = new Set(["indexed"]);
  functionModifiers = new Set([
    "calldata",
    "memory",
    "storage"
  ]);
});

// node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
var UnknownTypeError, UnknownSolidityTypeError;
var init_abiItem = __esm(() => {
  init_errors();
  UnknownTypeError = class UnknownTypeError extends BaseError2 {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [
          `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownTypeError"
      });
    }
  };
  UnknownSolidityTypeError = class UnknownSolidityTypeError extends BaseError2 {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSolidityTypeError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
var InvalidAbiParametersError, InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;
var init_abiParameter = __esm(() => {
  init_errors();
  InvalidAbiParametersError = class InvalidAbiParametersError extends BaseError2 {
    constructor({ params }) {
      super("Failed to parse ABI parameters.", {
        details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
        docsPath: "/api/human#parseabiparameters-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiParametersError"
      });
    }
  };
  InvalidParameterError = class InvalidParameterError extends BaseError2 {
    constructor({ param }) {
      super("Invalid ABI parameter.", {
        details: param
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParameterError"
      });
    }
  };
  SolidityProtectedKeywordError = class SolidityProtectedKeywordError extends BaseError2 {
    constructor({ param, name }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SolidityProtectedKeywordError"
      });
    }
  };
  InvalidModifierError = class InvalidModifierError extends BaseError2 {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidModifierError"
      });
    }
  };
  InvalidFunctionModifierError = class InvalidFunctionModifierError extends BaseError2 {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidFunctionModifierError"
      });
    }
  };
  InvalidAbiTypeParameterError = class InvalidAbiTypeParameterError extends BaseError2 {
    constructor({ abiParameter }) {
      super("Invalid ABI parameter.", {
        details: JSON.stringify(abiParameter, null, 2),
        metaMessages: ["ABI parameter type is invalid."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiTypeParameterError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/signature.js
var InvalidSignatureError, UnknownSignatureError, InvalidStructSignatureError;
var init_signature = __esm(() => {
  init_errors();
  InvalidSignatureError = class InvalidSignatureError extends BaseError2 {
    constructor({ signature, type }) {
      super(`Invalid ${type} signature.`, {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSignatureError"
      });
    }
  };
  UnknownSignatureError = class UnknownSignatureError extends BaseError2 {
    constructor({ signature }) {
      super("Unknown signature.", {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSignatureError"
      });
    }
  };
  InvalidStructSignatureError = class InvalidStructSignatureError extends BaseError2 {
    constructor({ signature }) {
      super("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidStructSignatureError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/struct.js
var CircularReferenceError;
var init_struct = __esm(() => {
  init_errors();
  CircularReferenceError = class CircularReferenceError extends BaseError2 {
    constructor({ type }) {
      super("Circular reference detected.", {
        metaMessages: [`Struct "${type}" is a circular reference.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CircularReferenceError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
var InvalidParenthesisError;
var init_splitParameters = __esm(() => {
  init_errors();
  InvalidParenthesisError = class InvalidParenthesisError extends BaseError2 {
    constructor({ current, depth }) {
      super("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParenthesisError"
      });
    }
  };
});

// node_modules/abitype/dist/esm/human-readable/runtime/cache.js
function getParameterCacheKey(param, type, structs) {
  let structKey = "";
  if (structs)
    for (const struct of Object.entries(structs)) {
      if (!struct)
        continue;
      let propertyKey = "";
      for (const property of struct[1]) {
        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
      }
      structKey += `(${struct[0]}{${propertyKey}})`;
    }
  if (type)
    return `${type}:${param}${structKey}`;
  return param;
}
var parameterCache;
var init_cache = __esm(() => {
  parameterCache = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);
});

// node_modules/abitype/dist/esm/human-readable/runtime/utils.js
function parseSignature(signature, structs = {}) {
  if (isFunctionSignature(signature))
    return parseFunctionSignature(signature, structs);
  if (isEventSignature(signature))
    return parseEventSignature(signature, structs);
  if (isErrorSignature(signature))
    return parseErrorSignature(signature, structs);
  if (isConstructorSignature(signature))
    return parseConstructorSignature(signature, structs);
  if (isFallbackSignature(signature))
    return parseFallbackSignature(signature);
  if (isReceiveSignature(signature))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature });
}
function parseFunctionSignature(signature, structs = {}) {
  const match = execFunctionSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "function" });
  const inputParams = splitParameters(match.parameters);
  const inputs = [];
  const inputLength = inputParams.length;
  for (let i = 0;i < inputLength; i++) {
    inputs.push(parseAbiParameter(inputParams[i], {
      modifiers: functionModifiers,
      structs,
      type: "function"
    }));
  }
  const outputs = [];
  if (match.returns) {
    const outputParams = splitParameters(match.returns);
    const outputLength = outputParams.length;
    for (let i = 0;i < outputLength; i++) {
      outputs.push(parseAbiParameter(outputParams[i], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
  }
  return {
    name: match.name,
    type: "function",
    stateMutability: match.stateMutability ?? "nonpayable",
    inputs,
    outputs
  };
}
function parseEventSignature(signature, structs = {}) {
  const match = execEventSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "event" });
  const params = splitParameters(match.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i = 0;i < length; i++)
    abiParameters.push(parseAbiParameter(params[i], {
      modifiers: eventModifiers,
      structs,
      type: "event"
    }));
  return { name: match.name, type: "event", inputs: abiParameters };
}
function parseErrorSignature(signature, structs = {}) {
  const match = execErrorSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "error" });
  const params = splitParameters(match.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i = 0;i < length; i++)
    abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
  return { name: match.name, type: "error", inputs: abiParameters };
}
function parseConstructorSignature(signature, structs = {}) {
  const match = execConstructorSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "constructor" });
  const params = splitParameters(match.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i = 0;i < length; i++)
    abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: match.stateMutability ?? "nonpayable",
    inputs: abiParameters
  };
}
function parseFallbackSignature(signature) {
  const match = execFallbackSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: match.stateMutability ?? "nonpayable"
  };
}
function parseAbiParameter(param, options) {
  const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match)
    throw new InvalidParameterError({ param });
  if (match.name && isSolidityKeyword(match.name))
    throw new SolidityProtectedKeywordError({ param, name: match.name });
  const name = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs = options?.structs ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match.type);
    const components_ = [];
    const length = params.length;
    for (let i = 0;i < length; i++) {
      components_.push(parseAbiParameter(params[i], { structs }));
    }
    components = { components: components_ };
  } else if (match.type in structs) {
    type = "tuple";
    components = { components: structs[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!(options?.type === "struct") && !isSolidityType(type))
      throw new UnknownSolidityTypeError({ type });
  }
  if (match.modifier) {
    if (!options?.modifiers?.has?.(match.modifier))
      throw new InvalidModifierError({
        param,
        type: options?.type,
        modifier: match.modifier
      });
    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
      throw new InvalidFunctionModifierError({
        param,
        type: options?.type,
        modifier: match.modifier
      });
  }
  const abiParameter = {
    type: `${type}${match.array ?? ""}`,
    ...name,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  const length = params.trim().length;
  for (let i = 0;i < length; i++) {
    const char = params[i];
    const tail = params.slice(i + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError({ current, depth });
  result.push(current.trim());
  return result;
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
}
function isSolidityKeyword(name) {
  return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type, isArray) {
  return isArray || type === "bytes" || type === "string" || type === "tuple";
}
var abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;
var init_utils2 = __esm(() => {
  init_regex();
  init_abiItem();
  init_abiParameter();
  init_signature();
  init_splitParameters();
  init_cache();
  init_signatures();
  abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  dynamicIntegerRegex = /^u?int$/;
  protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
});

// node_modules/abitype/dist/esm/human-readable/runtime/structs.js
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i = 0;i < signaturesLength; i++) {
    const signature = signatures[i];
    if (!isStructSignature(signature))
      continue;
    const match = execStructSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "struct" });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k = 0;k < propertiesLength; k++) {
      const property = properties[k];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new InvalidStructSignatureError({ signature });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i = 0;i < entriesLength; i++) {
    const [name, parameters] = entries[i];
    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
function resolveStructs(abiParameters, structs, ancestors = new Set) {
  const components = [];
  const length = abiParameters.length;
  for (let i = 0;i < length; i++) {
    const abiParameter = abiParameters[i];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!match?.type)
        throw new InvalidAbiTypeParameterError({ abiParameter });
      const { array, type } = match;
      if (type in structs) {
        if (ancestors.has(type))
          throw new CircularReferenceError({ type });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new UnknownTypeError({ type });
      }
    }
  }
  return components;
}
var typeWithoutTupleRegex;
var init_structs = __esm(() => {
  init_regex();
  init_abiItem();
  init_abiParameter();
  init_signature();
  init_struct();
  init_signatures();
  init_utils2();
  typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
});

// node_modules/abitype/dist/esm/human-readable/parseAbi.js
function parseAbi(signatures) {
  const structs = parseStructs(signatures);
  const abi = [];
  const length = signatures.length;
  for (let i = 0;i < length; i++) {
    const signature = signatures[i];
    if (isStructSignature(signature))
      continue;
    abi.push(parseSignature(signature, structs));
  }
  return abi;
}
var init_parseAbi = __esm(() => {
  init_signatures();
  init_structs();
  init_utils2();
});

// node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js
function parseAbiParameters(params) {
  const abiParameters = [];
  if (typeof params === "string") {
    const parameters = splitParameters(params);
    const length = parameters.length;
    for (let i = 0;i < length; i++) {
      abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));
    }
  } else {
    const structs = parseStructs(params);
    const length = params.length;
    for (let i = 0;i < length; i++) {
      const signature = params[i];
      if (isStructSignature(signature))
        continue;
      const parameters = splitParameters(signature);
      const length2 = parameters.length;
      for (let k = 0;k < length2; k++) {
        abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
      }
    }
  }
  if (abiParameters.length === 0)
    throw new InvalidAbiParametersError({ params });
  return abiParameters;
}
var init_parseAbiParameters = __esm(() => {
  init_abiParameter();
  init_signatures();
  init_structs();
  init_utils2();
  init_utils2();
});

// node_modules/abitype/dist/esm/exports/index.js
var init_exports = __esm(() => {
  init_formatAbiItem2();
  init_parseAbi();
  init_parseAbiParameters();
});

// node_modules/viem/_esm/utils/hash/normalizeSignature.js
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0;i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError("Unable to normalize signature.");
  return result;
}
var init_normalizeSignature = __esm(() => {
  init_base();
});

// node_modules/viem/_esm/utils/hash/toSignature.js
var toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem2(def);
  })();
  return normalizeSignature(def_);
};
var init_toSignature = __esm(() => {
  init_exports();
  init_normalizeSignature();
});

// node_modules/viem/_esm/utils/hash/toSignatureHash.js
function toSignatureHash(fn) {
  return hashSignature(toSignature(fn));
}
var init_toSignatureHash = __esm(() => {
  init_hashSignature();
  init_toSignature();
});

// node_modules/viem/_esm/utils/hash/toFunctionSelector.js
var toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
var init_toFunctionSelector = __esm(() => {
  init_slice();
  init_toSignatureHash();
});

// node_modules/viem/_esm/utils/encoding/fromBytes.js
function bytesToBigInt(bytes, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes, { size: opts.size });
  const hex = bytesToHex(bytes, opts);
  return hexToBigInt(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes);
  }
  if (bytes.length > 1 || bytes[0] > 1)
    throw new InvalidBytesBooleanError(bytes);
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes, { size: opts.size });
  const hex = bytesToHex(bytes, opts);
  return hexToNumber(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}
var init_fromBytes = __esm(() => {
  init_encoding();
  init_fromHex();
  init_toHex();
});

// node_modules/viem/_esm/utils/regex.js
var bytesRegex2, integerRegex2;
var init_regex2 = __esm(() => {
  bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
});

// node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0;i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    const [, , size2 = "256"] = integerRegex2.exec(param.type) ?? [];
    return encodeNumber(value, {
      signed,
      size: Number(size2)
    });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0;i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0;i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0;i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed, size: size2 = 256 }) {
  if (typeof size2 === "number") {
    const max = 2n ** (BigInt(size2) - (signed ? 1n : 0n)) - 1n;
    const min = signed ? -max - 1n : 0n;
    if (value > max || value < min)
      throw new IntegerOutOfRangeError({
        max: max.toString(),
        min: min.toString(),
        signed,
        size: size2 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let i = 0;i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(size(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0;i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}
var init_encodeAbiParameters = __esm(() => {
  init_abi();
  init_address();
  init_base();
  init_encoding();
  init_isAddress();
  init_pad();
  init_size();
  init_slice();
  init_toHex();
  init_regex2();
});

// node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
function decodeAbiParameters(params, data) {
  const bytes = typeof data === "string" ? hexToBytes(data) : data;
  const cursor = createCursor(bytes);
  if (size(bytes) === 0 && params.length > 0)
    throw new AbiDecodingZeroDataError;
  if (size(data) && size(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data === "string" ? data : bytesToHex(data),
      params,
      size: size(data)
    });
  let consumed = 0;
  const values = [];
  for (let i = 0;i < params.length; ++i) {
    const param = params[i];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    values.push(data2);
  }
  return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(cursor, { ...param, type }, { length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor);
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor, param, { length, staticPosition }) {
  if (!length) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0;i < length2; ++i) {
      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const value2 = [];
    for (let i = 0;i < length; ++i) {
      cursor.setPosition(start + i * 32);
      const [data] = decodeParameter(cursor, param, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i = 0;i < length; ++i) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
function decodeBool(cursor) {
  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = bytesToNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [bytesToHex(data), 32];
  }
  const value = bytesToHex(cursor.readBytes(Number.parseInt(size2), 32));
  return [value, 32];
}
function decodeNumber(cursor, param) {
  const signed = param.type.startsWith("int");
  const size2 = Number.parseInt(param.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),
    32
  ];
}
function decodeTuple(cursor, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    for (let i = 0;i < param.components.length; ++i) {
      const component = param.components[i];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i : component?.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i = 0;i < param.components.length; ++i) {
    const component = param.components[i];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i : component?.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset = bytesToNumber(cursor.readBytes(32));
  const start = staticPosition + offset;
  cursor.setPosition(start);
  const length = bytesToNumber(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = bytesToString(trim(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
var sizeOfLength = 32, sizeOfOffset = 32;
var init_decodeAbiParameters = __esm(() => {
  init_abi();
  init_getAddress();
  init_cursor2();
  init_size();
  init_slice();
  init_fromBytes();
  init_toBytes();
  init_toHex();
  init_encodeAbiParameters();
});

// node_modules/viem/_esm/utils/abi/decodeErrorResult.js
function decodeErrorResult(parameters) {
  const { abi, data } = parameters;
  const signature = slice(data, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError;
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature === toFunctionSelector(formatAbiItem(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : undefined,
    errorName: abiItem.name
  };
}
var init_decodeErrorResult = __esm(() => {
  init_solidity();
  init_abi();
  init_slice();
  init_toFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem();
});

// node_modules/viem/_esm/utils/stringify.js
var stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);

// node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`).join(", ")})`;
}
var init_formatAbiItemWithArgs = () => {
};

// node_modules/viem/_esm/utils/hash/toEventSelector.js
var toEventSelector;
var init_toEventSelector = __esm(() => {
  init_toSignatureHash();
  toEventSelector = toSignatureHash;
});

// node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem(parameters) {
  const { abi, args = [], name } = parameters;
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = undefined;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgOfType(Object.values(arg)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return isAddress(args[parameterIndex], { strict: false });
      if (types.includes("address") && types.includes("bytes"))
        return isAddress(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}
var init_getAbiItem = __esm(() => {
  init_abi();
  init_isAddress();
  init_toEventSelector();
  init_toFunctionSelector();
});

// node_modules/viem/_esm/errors/stateOverride.js
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let val = `${pretty}    ${address}:
`;
    if (state.nonce)
      val += `      nonce: ${state.nonce}
`;
    if (state.balance)
      val += `      balance: ${state.balance}
`;
    if (state.code)
      val += `      code: ${state.code}
`;
    if (state.state) {
      val += `      state:
`;
      val += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      val += `      stateDiff:
`;
      val += prettyStateMapping(state.stateDiff);
    }
    return val;
  }, `  State Override:
`).slice(0, -1);
}
var AccountStateConflictError, StateAssignmentConflictError;
var init_stateOverride = __esm(() => {
  init_base();
  AccountStateConflictError = class AccountStateConflictError extends BaseError {
    constructor({ address }) {
      super(`State for account "${address}" is set multiple times.`, {
        name: "AccountStateConflictError"
      });
    }
  };
  StateAssignmentConflictError = class StateAssignmentConflictError extends BaseError {
    constructor() {
      super("state and stateDiff are set on the same account.", {
        name: "StateAssignmentConflictError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/utils.js
var getContractAddress = (address) => address, getUrl = (url) => url;

// node_modules/viem/_esm/errors/contract.js
var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError;
var init_contract = __esm(() => {
  init_solidity();
  init_decodeErrorResult();
  init_formatAbiItem();
  init_formatAbiItemWithArgs();
  init_getAbiItem();
  init_formatEther();
  init_formatGwei();
  init_abi();
  init_base();
  init_stateOverride();
  init_transaction();
  CallExecutionError = class CallExecutionError extends BaseError {
    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
      const account = account_ ? parseAccount(account_) : undefined;
      let prettyArgs = prettyPrint({
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      if (stateOverride) {
        prettyArgs += `
${prettyStateOverride(stateOverride)}`;
      }
      super(cause.shortMessage, {
        cause,
        docsPath,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Raw Call Arguments:",
          prettyArgs
        ].filter(Boolean),
        name: "CallExecutionError"
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.cause = cause;
    }
  };
  ContractFunctionExecutionError = class ContractFunctionExecutionError extends BaseError {
    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender }) {
      const abiItem = getAbiItem({ abi, args, name: functionName });
      const formattedArgs = abiItem ? formatAbiItemWithArgs({
        abiItem,
        args,
        includeFunctionName: false,
        includeName: false
      }) : undefined;
      const functionWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : undefined;
      const prettyArgs = prettyPrint({
        address: contractAddress && getContractAddress(contractAddress),
        function: functionWithParams,
        args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
        sender
      });
      super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
        cause,
        docsPath,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          prettyArgs && "Contract Call:",
          prettyArgs
        ].filter(Boolean),
        name: "ContractFunctionExecutionError"
      });
      Object.defineProperty(this, "abi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "args", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "contractAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "formattedArgs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "functionName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "sender", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abi = abi;
      this.args = args;
      this.cause = cause;
      this.contractAddress = contractAddress;
      this.functionName = functionName;
      this.sender = sender;
    }
  };
  ContractFunctionRevertedError = class ContractFunctionRevertedError extends BaseError {
    constructor({ abi, data, functionName, message }) {
      let cause;
      let decodedData = undefined;
      let metaMessages;
      let reason;
      if (data && data !== "0x") {
        try {
          decodedData = decodeErrorResult({ abi, data });
          const { abiItem, errorName, args: errorArgs } = decodedData;
          if (errorName === "Error") {
            reason = errorArgs[0];
          } else if (errorName === "Panic") {
            const [firstArg] = errorArgs;
            reason = panicReasons[firstArg];
          } else {
            const errorWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : undefined;
            const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
              abiItem,
              args: errorArgs,
              includeFunctionName: false,
              includeName: false
            }) : undefined;
            metaMessages = [
              errorWithParams ? `Error: ${errorWithParams}` : "",
              formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
            ];
          }
        } catch (err) {
          cause = err;
        }
      } else if (message)
        reason = message;
      let signature;
      if (cause instanceof AbiErrorSignatureNotFoundError) {
        signature = cause.signature;
        metaMessages = [
          `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ];
      }
      super(reason && reason !== "execution reverted" || signature ? [
        `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
        reason || signature
      ].join(`
`) : `The contract function "${functionName}" reverted.`, {
        cause,
        metaMessages,
        name: "ContractFunctionRevertedError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "raw", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "reason", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = decodedData;
      this.raw = data;
      this.reason = reason;
      this.signature = signature;
    }
  };
  ContractFunctionZeroDataError = class ContractFunctionZeroDataError extends BaseError {
    constructor({ functionName }) {
      super(`The contract function "${functionName}" returned no data ("0x").`, {
        metaMessages: [
          "This could be due to any of the following:",
          `  - The contract does not have the function "${functionName}",`,
          "  - The parameters passed to the contract function may be invalid, or",
          "  - The address is not a contract."
        ],
        name: "ContractFunctionZeroDataError"
      });
    }
  };
  CounterfactualDeploymentFailedError = class CounterfactualDeploymentFailedError extends BaseError {
    constructor({ factory }) {
      super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ""}`, {
        metaMessages: [
          "Please ensure:",
          "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
          "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
        ],
        name: "CounterfactualDeploymentFailedError"
      });
    }
  };
  RawContractError = class RawContractError extends BaseError {
    constructor({ data, message }) {
      super(message || "", { name: "RawContractError" });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
    }
  };
});

// node_modules/viem/_esm/errors/request.js
var HttpRequestError, RpcRequestError, TimeoutError;
var init_request = __esm(() => {
  init_base();
  HttpRequestError = class HttpRequestError extends BaseError {
    constructor({ body, cause, details, headers, status, url }) {
      super("HTTP request failed.", {
        cause,
        details,
        metaMessages: [
          status && `Status: ${status}`,
          `URL: ${getUrl(url)}`,
          body && `Request body: ${stringify(body)}`
        ].filter(Boolean),
        name: "HttpRequestError"
      });
      Object.defineProperty(this, "body", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "headers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "url", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.body = body;
      this.headers = headers;
      this.status = status;
      this.url = url;
    }
  };
  RpcRequestError = class RpcRequestError extends BaseError {
    constructor({ body, error, url }) {
      super("RPC Request failed.", {
        cause: error,
        details: error.message,
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
        name: "RpcRequestError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.code = error.code;
      this.data = error.data;
    }
  };
  TimeoutError = class TimeoutError extends BaseError {
    constructor({ body, url }) {
      super("The request took too long to respond.", {
        details: "The request timed out.",
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
        name: "TimeoutError"
      });
    }
  };
});

// node_modules/viem/_esm/errors/rpc.js
var unknownErrorCode = -1, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnknownRpcError;
var init_rpc = __esm(() => {
  init_base();
  init_request();
  RpcError = class RpcError extends BaseError {
    constructor(cause, { code, docsPath, metaMessages, name, shortMessage }) {
      super(shortMessage, {
        cause,
        docsPath,
        metaMessages: metaMessages || cause?.metaMessages,
        name: name || "RpcError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.name = name || cause.name;
      this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
    }
  };
  ProviderRpcError = class ProviderRpcError extends RpcError {
    constructor(cause, options) {
      super(cause, options);
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = options.data;
    }
  };
  ParseRpcError = class ParseRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ParseRpcError.code,
        name: "ParseRpcError",
        shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      });
    }
  };
  Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
  });
  InvalidRequestRpcError = class InvalidRequestRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidRequestRpcError.code,
        name: "InvalidRequestRpcError",
        shortMessage: "JSON is not a valid request object."
      });
    }
  };
  Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
  });
  MethodNotFoundRpcError = class MethodNotFoundRpcError extends RpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: MethodNotFoundRpcError.code,
        name: "MethodNotFoundRpcError",
        shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
      });
    }
  };
  Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
  });
  InvalidParamsRpcError = class InvalidParamsRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidParamsRpcError.code,
        name: "InvalidParamsRpcError",
        shortMessage: [
          "Invalid parameters were provided to the RPC method.",
          "Double check you have provided the correct parameters."
        ].join(`
`)
      });
    }
  };
  Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
  });
  InternalRpcError = class InternalRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InternalRpcError.code,
        name: "InternalRpcError",
        shortMessage: "An internal error was received."
      });
    }
  };
  Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
  });
  InvalidInputRpcError = class InvalidInputRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidInputRpcError.code,
        name: "InvalidInputRpcError",
        shortMessage: [
          "Missing or invalid parameters.",
          "Double check you have provided the correct parameters."
        ].join(`
`)
      });
    }
  };
  Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
  });
  ResourceNotFoundRpcError = class ResourceNotFoundRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceNotFoundRpcError.code,
        name: "ResourceNotFoundRpcError",
        shortMessage: "Requested resource not found."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceNotFoundRpcError"
      });
    }
  };
  Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
  });
  ResourceUnavailableRpcError = class ResourceUnavailableRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceUnavailableRpcError.code,
        name: "ResourceUnavailableRpcError",
        shortMessage: "Requested resource not available."
      });
    }
  };
  Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
  });
  TransactionRejectedRpcError = class TransactionRejectedRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: TransactionRejectedRpcError.code,
        name: "TransactionRejectedRpcError",
        shortMessage: "Transaction creation failed."
      });
    }
  };
  Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
  });
  MethodNotSupportedRpcError = class MethodNotSupportedRpcError extends RpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: MethodNotSupportedRpcError.code,
        name: "MethodNotSupportedRpcError",
        shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
      });
    }
  };
  Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
  });
  LimitExceededRpcError = class LimitExceededRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: LimitExceededRpcError.code,
        name: "LimitExceededRpcError",
        shortMessage: "Request exceeds defined limit."
      });
    }
  };
  Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
  });
  JsonRpcVersionUnsupportedError = class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: JsonRpcVersionUnsupportedError.code,
        name: "JsonRpcVersionUnsupportedError",
        shortMessage: "Version of JSON-RPC protocol is not supported."
      });
    }
  };
  Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
  });
  UserRejectedRequestError = class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UserRejectedRequestError.code,
        name: "UserRejectedRequestError",
        shortMessage: "User rejected the request."
      });
    }
  };
  Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
  });
  UnauthorizedProviderError = class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnauthorizedProviderError.code,
        name: "UnauthorizedProviderError",
        shortMessage: "The requested method and/or account has not been authorized by the user."
      });
    }
  };
  Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
  });
  UnsupportedProviderMethodError = class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: UnsupportedProviderMethodError.code,
        name: "UnsupportedProviderMethodError",
        shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
      });
    }
  };
  Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
  });
  ProviderDisconnectedError = class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ProviderDisconnectedError.code,
        name: "ProviderDisconnectedError",
        shortMessage: "The Provider is disconnected from all chains."
      });
    }
  };
  Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
  });
  ChainDisconnectedError = class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ChainDisconnectedError.code,
        name: "ChainDisconnectedError",
        shortMessage: "The Provider is not connected to the requested chain."
      });
    }
  };
  Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
  });
  SwitchChainError = class SwitchChainError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: SwitchChainError.code,
        name: "SwitchChainError",
        shortMessage: "An error occurred when attempting to switch chain."
      });
    }
  };
  Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
  });
  UnknownRpcError = class UnknownRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        name: "UnknownRpcError",
        shortMessage: "An unknown RPC error occurred."
      });
    }
  };
});

// node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError ? err.walk((e) => e?.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError)
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
var init_getNodeError = __esm(() => {
  init_base();
  init_node();
});

// node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(err, { docsPath, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath,
    ...args
  });
}
var init_getCallError = __esm(() => {
  init_contract();
  init_node();
  init_getNodeError();
});

// node_modules/viem/_esm/utils/formatters/extract.js
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}

// node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError;
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var init_assertRequest = __esm(() => {
  init_number();
  init_address();
  init_node();
  init_transaction();
  init_isAddress();
});

// node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js
function prepareEncodeFunctionData(parameters) {
  const { abi, args, functionName } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath2 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem(abiItem))
  };
}
var docsPath2 = "/docs/contract/encodeFunctionData";
var init_prepareEncodeFunctionData = __esm(() => {
  init_abi();
  init_toFunctionSelector();
  init_formatAbiItem();
  init_getAbiItem();
});

// node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi, functionName } = (() => {
    if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi[0];
  const signature = functionName;
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : undefined;
  return concatHex([signature, data ?? "0x"]);
}
var init_encodeFunctionData = __esm(() => {
  init_encodeAbiParameters();
  init_prepareEncodeFunctionData();
});

// node_modules/viem/node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
var init_hmac = __esm(() => {
  init__assert();
  init_utils();
  HMAC = class HMAC extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash2);
      const key = toBytes2(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad2 = new Uint8Array(blockLen);
      pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0;i < pad2.length; i++)
        pad2[i] ^= 54;
      this.iHash.update(pad2);
      this.oHash = hash2.create();
      for (let i = 0;i < pad2.length; i++)
        pad2[i] ^= 54 ^ 92;
      this.oHash.update(pad2);
      pad2.fill(0);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  hmac.create = (hash2, key) => new HMAC(hash2, key);
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils = {};
__export(exports_utils, {
  validateObject: () => validateObject,
  utf8ToBytes: () => utf8ToBytes2,
  numberToVarBytesBE: () => numberToVarBytesBE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToBytesLE: () => numberToBytesLE,
  numberToBytesBE: () => numberToBytesBE,
  notImplemented: () => notImplemented,
  memoized: () => memoized,
  isBytes: () => isBytes2,
  inRange: () => inRange,
  hexToNumber: () => hexToNumber2,
  hexToBytes: () => hexToBytes2,
  equalBytes: () => equalBytes,
  ensureBytes: () => ensureBytes,
  createHmacDrbg: () => createHmacDrbg,
  concatBytes: () => concatBytes3,
  bytesToNumberLE: () => bytesToNumberLE,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToHex: () => bytesToHex2,
  bitSet: () => bitSet,
  bitMask: () => bitMask,
  bitLen: () => bitLen,
  bitGet: () => bitGet,
  abytes: () => abytes2,
  abool: () => abool,
  aInRange: () => aInRange
});
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function bytesToHex2(bytes) {
  abytes2(bytes);
  let hex = "";
  for (let i = 0;i < bytes.length; i++) {
    hex += hexes2[bytes[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n2 : BigInt("0x" + hex);
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes) {
  return hexToNumber2(bytesToHex2(bytes));
}
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0;i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v2.fill(1);
    k.fill(0);
    i = 0;
  };
  const h2 = (...b) => hmacFn(k, v2, ...b);
  const reseed = (seed = u8n()) => {
    k = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v2 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl = v2.slice();
      out.push(sl);
      len += v2.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var _0n2, _1n2, _2n2, hexes2, asciis, isPosBig = (n) => typeof n === "bigint" && _0n2 <= n, bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2, u8n = (data) => new Uint8Array(data), u8fr = (arr) => Uint8Array.from(arr), validatorFns, notImplemented = () => {
  throw new Error("not implemented");
};
var init_utils3 = __esm(() => {
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n2 = /* @__PURE__ */ BigInt(0);
  _1n2 = /* @__PURE__ */ BigInt(1);
  _2n2 = /* @__PURE__ */ BigInt(2);
  hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n3)
    throw new Error("invalid modulus");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n3)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n3)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number, modulo);
  let b = modulo;
  let x = _0n3, y2 = _1n3, u = _1n3, v2 = _0n3;
  while (a !== _0n3) {
    const q2 = b / a;
    const r = b % a;
    const m = x - u * q2;
    const n = y2 - v2 * q2;
    b = a, a = r, x = u, y2 = v2, u = m, v2 = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q2, S2, Z;
  for (Q2 = P - _1n3, S2 = 0;Q2 % _2n3 === _0n3; Q2 /= _2n3, S2++)
    ;
  for (Z = _2n3;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++) {
    if (Z > 1000)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S2 === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n3) / _2n3;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q2);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q2);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n3);
      const v2 = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v2);
      const i = Fp.mul(Fp.mul(nv, _2n3), v2);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n3)
    return f2.ONE;
  if (power === _1n3)
    return num;
  let p = f2.ONE;
  let d2 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f2.mul(p, d2);
    d2 = f2.sqr(d2);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f2 = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f2, n);
    }),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
var init_modular = __esm(() => {
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n3 = BigInt(0);
  _1n3 = BigInt(1);
  _2n3 = /* @__PURE__ */ BigInt(2);
  _3n = /* @__PURE__ */ BigInt(3);
  _4n = /* @__PURE__ */ BigInt(4);
  _5n = /* @__PURE__ */ BigInt(5);
  _8n = /* @__PURE__ */ BigInt(8);
  _9n = /* @__PURE__ */ BigInt(9);
  _16n = /* @__PURE__ */ BigInt(16);
  FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, bits) {
  validateW(W, bits);
  const windows = Math.ceil(bits / W) + 1;
  const windowSize = 2 ** (W - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    unsafeLadder(elm, n, p = c.ZERO) {
      let d2 = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i = 1;i < windowSize; i++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = calcWOpts(W, bits);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        if (n === _0n4)
          break;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
    },
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits;i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j2 = 0;j2 < scalars.length; j2++) {
      const scalar = scalars[j2];
      const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j2]);
    }
    let resI = zero;
    for (let j2 = buckets.length - 1, sumI = zero;j2 > 0; j2--) {
      sumI = sumI.add(buckets[j2]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j2 = 0;j2 < windowSize; j2++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n4, _1n4, pointPrecomputes, pointWindowSizes;
var init_curve = __esm(() => {
  init_modular();
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n4 = BigInt(0);
  _1n4 = BigInt(1);
  pointPrecomputes = new WeakMap;
  pointWindowSizes = new WeakMap;
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== undefined)
    abool("lowS", opts.lowS);
  if (opts.prehash !== undefined)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes3(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y2 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y: y2 };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n5, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod(num, N2);
    aInRange("private key", num, _1n5, N2);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y2, pz: z } = p;
    if (Fp.eql(z, Fp.ONE))
      return { x, y: y2 };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y2, iz);
    const zz = Fp.mul(z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y: y2 } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp.sqr(y2);
    const right = weierstrassEquation(x);
    if (!Fp.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(p) {
      const { x, y: y2 } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y2))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y2))
        return Point.ZERO;
      return new Point(x, y2, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    multiplyUnsafe(sc) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", sc, _0n5, N2);
      const I2 = Point.ZERO;
      if (sc === _0n5)
        return I2;
      if (this.is0() || sc === _1n5)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d2);
        if (k2 & _1n5)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      const { endo, n: N2 } = CURVE;
      aInRange("scalar", scalar, _1n5, N2);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(scalar);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q2, a, b) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q2, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes3(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes3;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n5, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y3;
        try {
          y3 = Fp.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp.neg(y3);
        return { x, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y2 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y: y2 };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n5;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      aInRange("r", this.r, _1n5, CURVE_ORDER);
      aInRange("s", this.s, _1n5, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n5, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes2(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes3(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q2 = Point.BASE.multiply(k).toAffine();
      const r = modN(q2.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d2));
      if (s === _0n5)
        return;
      let recovery = (q2.x === r ? 0 : 2) | Number(q2.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== undefined && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = undefined;
    let P;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h2 * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v2 = modN(R.x);
    return v2 === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp, Z) {
  const q2 = Fp.ORDER;
  let l = _0n5;
  for (let o = q2 - _1n5;o % _2n4 === _0n5; o /= _2n4)
    l += _1n5;
  const c1 = l;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c2 = (q2 - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n4;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp.pow(Z, c2);
  const c7 = Fp.pow(Z, (c2 + _1n5) / _2n4);
  let sqrtRatio = (u, v2) => {
    let tv1 = c6;
    let tv2 = Fp.pow(v2, c4);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v2);
    let tv5 = Fp.mul(u, tv3);
    tv5 = Fp.pow(tv5, c3);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v2);
    tv3 = Fp.mul(tv5, u);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c5);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c7);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i = c1;i > _1n5; i--) {
      let tv52 = i - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c12 = (Fp.ORDER - _3n2) / _4n2;
    const c22 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u, v2) => {
      let tv1 = Fp.sqr(v2);
      const tv2 = Fp.mul(u, v2);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y2 = Fp.mul(y1, c22);
      const tv3 = Fp.mul(Fp.sqr(y1), v2);
      const isQR = Fp.eql(tv3, u);
      let y3 = Fp.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y3 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
  if (!Fp.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y2;
    tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, opts.Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, opts.B);
    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, opts.A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, opts.A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, opts.B);
    tv2 = Fp.add(tv2, tv5);
    x = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y2 = Fp.mul(tv1, u);
    y2 = Fp.mul(y2, value);
    x = Fp.cmov(x, tv3, isValid);
    y2 = Fp.cmov(y2, value, isValid);
    const e1 = Fp.isOdd(u) === Fp.isOdd(y2);
    y2 = Fp.cmov(Fp.neg(y2), y2, e1);
    x = Fp.div(x, tv4);
    return { x, y: y2 };
  };
}
var b2n, h2b, DERErr, DER, _0n5, _1n5, _2n4, _3n2, _4n2;
var init_weierstrass = __esm(() => {
  init_curve();
  init_modular();
  init_utils3();
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  ({ bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils);
  DERErr = class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  DER = {
    Err: DERErr,
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lenLen + len + data;
      },
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lenLen;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v2 = data.subarray(pos, pos + length);
        if (v2.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v: v2, l: data.subarray(pos + length) };
      }
    },
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n5)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return b2n(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      abytes2(data);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  _0n5 = BigInt(0);
  _1n5 = BigInt(1);
  _2n4 = BigInt(2);
  _3n2 = BigInt(3);
  _4n2 = BigInt(4);
});

// node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes2(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return { ...create(defHash), create };
}
var init__shortw_utils = __esm(() => {
  init_hmac();
  init_utils();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
});

// node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1;i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0;i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes3(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes3(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes3(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes3(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1;i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes3(...args));
  }
  const pseudo_random_bytes = concatBytes3(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes2(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0;i < count; i++) {
    const e = new Array(m);
    for (let j2 = 0;j2 < m; j2++) {
      const elm_offset = L * (j2 + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j2] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y2) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y2 = field.mul(y2, field.div(yNum, yDen));
    return { x, y: y2 };
  };
}
function createHasher(Point, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point.fromAffine(mapToCurve(u[0]));
      const u1 = Point.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
var os2ip;
var init_hash_to_curve = __esm(() => {
  init_modular();
  init_utils3();
  os2ip = bytesToNumberBE;
});

// node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js
var exports_secp256k1 = {};
__export(exports_secp256k1, {
  secp256k1: () => secp256k1,
  schnorr: () => schnorr,
  hashToCurve: () => hashToCurve,
  encodeToCurve: () => encodeToCurve
});
function sqrtMod(y2) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P;
  const b3 = b2 * b2 * y2 % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === undefined) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes3(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes3(tagP, ...messages));
}
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n6, secp256k1P);
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y2 = sqrtMod(c);
  if (y2 % _2n5 !== _0n6)
    y2 = modP(-y2);
  const p = new Point(x, y2, _1n6);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d2 } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d2 ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(num(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d2)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n6, secp256k1P))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n6, secp256k1N))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var secp256k1P, secp256k1N, _1n6, _2n5, divNearest = (a, b) => (a + b / _2n5) / b, Fpk1, secp256k1, _0n6, TAGGED_HASH_PREFIXES, pointToBytes = (point) => point.toRawBytes(true).slice(1), numTo32b = (n) => numberToBytesBE(n, 32), modP = (x) => mod(x, secp256k1P), modN = (x) => mod(x, secp256k1N), Point, GmulAdd = (Q2, a, b) => Point.BASE.multiplyAndAddUnsafe(Q2, a, b), num, schnorr, isoMap, mapSWU, htf, hashToCurve, encodeToCurve;
var init_secp256k1 = __esm(() => {
  init_sha256();
  init_utils();
  init__shortw_utils();
  init_hash_to_curve();
  init_modular();
  init_utils3();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  _1n6 = BigInt(1);
  _2n5 = BigInt(2);
  Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fpk1,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  _0n6 = BigInt(0);
  TAGGED_HASH_PREFIXES = {};
  Point = secp256k1.ProjectivePoint;
  num = bytesToNumberBE;
  schnorr = /* @__PURE__ */ (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      taggedHash,
      mod
    }
  }))();
  isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i) => i.map((j2) => BigInt(j2)))))();
  mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fpk1.create(BigInt("-11"))
  }))();
  htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
    const { x, y: y2 } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y2);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256
  }))();
  hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();
  encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();
});

// node_modules/viem/_esm/utils/stateOverride.js
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return;
  return stateMapping.reduce((acc, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    acc[slot] = value;
    return acc;
  }, {});
}
function serializeAccountStateOverride(parameters) {
  const { balance, nonce, state, stateDiff, code } = parameters;
  const rpcAccountStateOverride = {};
  if (code !== undefined)
    rpcAccountStateOverride.code = code;
  if (balance !== undefined)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== undefined)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state !== undefined)
    rpcAccountStateOverride.state = serializeStateMapping(state);
  if (stateDiff !== undefined) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError;
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
  if (!parameters)
    return;
  const rpcStateOverride = {};
  for (const { address, ...accountState } of parameters) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}
var init_stateOverride2 = __esm(() => {
  init_address();
  init_data();
  init_stateOverride();
  init_isAddress();
  init_toHex();
});

// node_modules/viem/_esm/utils/address/isAddressEqual.js
function isAddressEqual(a, b) {
  if (!isAddress(a, { strict: false }))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b, { strict: false }))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}
var init_isAddressEqual = __esm(() => {
  init_address();
  init_isAddress();
});

// node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
function decodeFunctionResult(parameters) {
  const { abi, args, functionName, data } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, args, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath4 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return;
}
var docsPath4 = "/docs/contract/decodeFunctionResult";
var init_decodeFunctionResult = __esm(() => {
  init_abi();
  init_decodeAbiParameters();
  init_getAbiItem();
});

// node_modules/viem/_esm/constants/abis.js
var multicall3Abi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi;
var init_abis = __esm(() => {
  multicall3Abi = [
    {
      inputs: [
        {
          components: [
            {
              name: "target",
              type: "address"
            },
            {
              name: "allowFailure",
              type: "bool"
            },
            {
              name: "callData",
              type: "bytes"
            }
          ],
          name: "calls",
          type: "tuple[]"
        }
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            {
              name: "success",
              type: "bool"
            },
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "returnData",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ];
  universalResolverErrors = [
    {
      inputs: [],
      name: "ResolverNotFound",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverWildcardNotSupported",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverNotContract",
      type: "error"
    },
    {
      inputs: [
        {
          name: "returnData",
          type: "bytes"
        }
      ],
      name: "ResolverError",
      type: "error"
    },
    {
      inputs: [
        {
          components: [
            {
              name: "status",
              type: "uint16"
            },
            {
              name: "message",
              type: "string"
            }
          ],
          name: "errors",
          type: "tuple[]"
        }
      ],
      name: "HttpError",
      type: "error"
    }
  ];
  universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    },
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
        { name: "gateways", type: "string[]" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    }
  ];
  universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    },
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [
        { type: "bytes", name: "reverseName" },
        { type: "string[]", name: "gateways" }
      ],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    }
  ];
  textResolverAbi = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" }
      ],
      outputs: [{ name: "", type: "string" }]
    }
  ];
  addressResolverAbi = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }]
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" }
      ],
      outputs: [{ name: "", type: "bytes" }]
    }
  ];
  universalSignatureValidatorAbi = [
    {
      inputs: [
        {
          name: "_signer",
          type: "address"
        },
        {
          name: "_hash",
          type: "bytes32"
        },
        {
          name: "_signature",
          type: "bytes"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [
        {
          name: "_signer",
          type: "address"
        },
        {
          name: "_hash",
          type: "bytes32"
        },
        {
          name: "_signature",
          type: "bytes"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function",
      name: "isValidSig"
    }
  ];
});

// node_modules/viem/_esm/constants/contract.js
var aggregate3Signature = "0x82ad56cb";

// node_modules/viem/_esm/constants/contracts.js
var deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// node_modules/viem/_esm/utils/abi/encodeDeployData.js
function encodeDeployData(parameters) {
  const { abi, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x) => ("type" in x) && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath5 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
  const data = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data]);
}
var docsPath5 = "/docs/contract/encodeDeployData";
var init_encodeDeployData = __esm(() => {
  init_abi();
  init_encodeAbiParameters();
});

// node_modules/viem/_esm/utils/promise/withResolvers.js
function withResolvers() {
  let resolve = () => {
    return;
  };
  let reject = () => {
    return;
  };
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}

// node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i = 0;i < scheduler.length; i++) {
        const { resolve } = scheduler[i];
        resolve?.([data[i], data]);
      }
    }).catch((err) => {
      for (let i = 0;i < scheduler.length; i++) {
        const { reject } = scheduler[i];
        reject?.(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const { promise, resolve, reject } = withResolvers();
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject });
        return promise;
      }
      setScheduler({ args, resolve, reject });
      setTimeout(exec, wait);
      return promise;
    }
  };
}
var schedulerCache;
var init_createBatchScheduler = __esm(() => {
  schedulerCache = /* @__PURE__ */ new Map;
});

// node_modules/viem/_esm/errors/ccip.js
var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
var init_ccip = __esm(() => {
  init_base();
  OffchainLookupError = class OffchainLookupError extends BaseError {
    constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
      super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
        cause,
        metaMessages: [
          ...cause.metaMessages || [],
          cause.metaMessages?.length ? "" : [],
          "Offchain Gateway Call:",
          urls && [
            "  Gateway URL(s):",
            ...urls.map((url) => `    ${getUrl(url)}`)
          ],
          `  Sender: ${sender}`,
          `  Data: ${data}`,
          `  Callback selector: ${callbackSelector}`,
          `  Extra data: ${extraData}`
        ].flat(),
        name: "OffchainLookupError"
      });
    }
  };
  OffchainLookupResponseMalformedError = class OffchainLookupResponseMalformedError extends BaseError {
    constructor({ result, url }) {
      super("Offchain gateway response is malformed. Response data must be a hex value.", {
        metaMessages: [
          `Gateway URL: ${getUrl(url)}`,
          `Response: ${stringify(result)}`
        ],
        name: "OffchainLookupResponseMalformedError"
      });
    }
  };
  OffchainLookupSenderMismatchError = class OffchainLookupSenderMismatchError extends BaseError {
    constructor({ sender, to }) {
      super("Reverted sender address does not match target contract address (`to`).", {
        metaMessages: [
          `Contract address: ${to}`,
          `OffchainLookup sender address: ${sender}`
        ],
        name: "OffchainLookupSenderMismatchError"
      });
    }
  };
});

// node_modules/viem/_esm/utils/ccip.js
var exports_ccip = {};
__export(exports_ccip, {
  offchainLookupSignature: () => offchainLookupSignature,
  offchainLookupAbiItem: () => offchainLookupAbiItem,
  offchainLookup: () => offchainLookup,
  ccipRequest: () => ccipRequest
});
async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
  const { args } = decodeErrorResult({
    data,
    abi: [offchainLookupAbiItem]
  });
  const [sender, urls, callData, callbackSelector, extraData] = args;
  const { ccipRead } = client;
  const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest;
  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to });
    const result = await ccipRequest_({ data: callData, sender, urls });
    const { data: data_ } = await call(client, {
      blockNumber,
      blockTag,
      data: concat([
        callbackSelector,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
      ]),
      to
    });
    return data_;
  } catch (err) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: err,
      data,
      extraData,
      sender,
      urls
    });
  }
}
async function ccipRequest({ data, sender, urls }) {
  let error = new Error("An unknown error occurred.");
  for (let i = 0;i < urls.length; i++) {
    const url = urls[i];
    const method = url.includes("{data}") ? "GET" : "POST";
    const body = method === "POST" ? { data, sender } : undefined;
    const headers = method === "POST" ? { "Content-Type": "application/json" } : {};
    try {
      const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
        body: JSON.stringify(body),
        headers,
        method
      });
      let result;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = (await response.json()).data;
      } else {
        result = await response.text();
      }
      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: result?.error ? stringify(result.error) : response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
        continue;
      }
      if (!isHex(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url
        });
        continue;
      }
      return result;
    } catch (err) {
      error = new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  throw error;
}
var offchainLookupSignature = "0x556f1830", offchainLookupAbiItem;
var init_ccip2 = __esm(() => {
  init_call();
  init_ccip();
  init_request();
  init_decodeErrorResult();
  init_encodeAbiParameters();
  init_isAddressEqual();
  offchainLookupAbiItem = {
    name: "OffchainLookup",
    type: "error",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "urls",
        type: "string[]"
      },
      {
        name: "callData",
        type: "bytes"
      },
      {
        name: "callbackFunction",
        type: "bytes4"
      },
      {
        name: "extraData",
        type: "bytes"
      }
    ]
  };
});

// node_modules/viem/_esm/actions/public/call.js
async function call(client, args) {
  const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, blobs, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  if (code && (factory || factoryData))
    throw new BaseError("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (code && to)
    throw new BaseError("Cannot provide both `code` & `to` as parameters.");
  const deploylessCallViaBytecode = code && data_;
  const deploylessCallViaFactory = factory && factoryData && to && data_;
  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
  const data = (() => {
    if (deploylessCallViaBytecode)
      return toDeploylessCallViaBytecodeData({
        code,
        data: data_
      });
    if (deploylessCallViaFactory)
      return toDeploylessCallViaFactoryData({
        data: data_,
        factory,
        factoryData,
        to
      });
    return data_;
  })();
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: deploylessCall ? undefined : to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
      try {
        return await scheduleMulticall(client, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client.request({
      method: "eth_call",
      params: rpcStateOverride ? [
        request,
        block,
        rpcStateOverride
      ] : [request, block]
    });
    if (response === "0x")
      return { data: undefined };
    return { data: response };
  } catch (err) {
    const data2 = getRevertErrorData(err);
    const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), exports_ccip));
    if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
      return { data: await offchainLookup2(client, { data: data2, to }) };
    if (deploylessCall && data2?.slice(0, 10) === "0x101bb98d")
      throw new CounterfactualDeploymentFailedError({ factory });
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client, args) {
  const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new ClientChainNotConfiguredError;
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client.uid}.${block}`,
    wait,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data2 }) => size3 + (data2.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: undefined };
  return { data: returnData };
}
function toDeploylessCallViaBytecodeData(parameters) {
  const { code, data } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(bytes, bytes)"]),
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [code, data]
  });
}
function toDeploylessCallViaFactoryData(parameters) {
  const { data, factory, factoryData, to } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
    bytecode: deploylessCallViaFactoryBytecode,
    args: [to, data, factory, factoryData]
  });
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError))
    return;
  const error = err.walk();
  return typeof error?.data === "object" ? error.data?.data : error.data;
}
var init_call = __esm(() => {
  init_exports();
  init_abis();
  init_base();
  init_chain();
  init_contract();
  init_decodeFunctionResult();
  init_encodeDeployData();
  init_encodeFunctionData();
  init_getChainContractAddress();
  init_toHex();
  init_getCallError();
  init_transactionRequest();
  init_createBatchScheduler();
  init_stateOverride2();
  init_assertRequest();
});

// src/abi/ConceroVerifier.json
var require_ConceroVerifier = __commonJS((exports, module) => {
  module.exports = {
    _format: "hh-sol-artifact-1",
    contractName: "ConceroVerifier",
    sourceName: "contracts/ConceroVerifier/ConceroVerifier.sol",
    abi: [
      {
        inputs: [
          {
            internalType: "uint24",
            name: "chainSelector",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "USDC",
            type: "address"
          },
          {
            internalType: "address",
            name: "clfRouter",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "clfDonId",
            type: "bytes32"
          },
          {
            internalType: "uint64",
            name: "clfSubscriptionId",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "clfDonHostedSecretsVersion",
            type: "uint64"
          },
          {
            internalType: "uint8",
            name: "clfDonHostedSecretsSlotId",
            type: "uint8"
          },
          {
            internalType: "uint16",
            name: "clfPremiumFeeUsdBps",
            type: "uint16"
          },
          {
            internalType: "uint32",
            name: "clfCallbackGasLimit",
            type: "uint32"
          },
          {
            internalType: "bytes32",
            name: "requestCLFMessageReportJsCodeHash",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "requestOperatorRegistrationJsCodeHash",
            type: "bytes32"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "EmptyArgs",
        type: "error"
      },
      {
        inputs: [],
        name: "EmptySource",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "requiredAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "availableAmount",
            type: "uint256"
          }
        ],
        name: "InsufficientFee",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "provided",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "required",
            type: "uint256"
          }
        ],
        name: "InsufficientFee",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "provided",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "required",
            type: "uint256"
          }
        ],
        name: "InsufficientOperatorDeposit",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidAddress",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidNamespace",
        type: "error"
      },
      {
        inputs: [],
        name: "LengthMismatch",
        type: "error"
      },
      {
        inputs: [],
        name: "MessageAlreadyProcessed",
        type: "error"
      },
      {
        inputs: [],
        name: "NoInlineSecrets",
        type: "error"
      },
      {
        inputs: [],
        name: "NotOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyRouterCanFulfill",
        type: "error"
      },
      {
        inputs: [],
        name: "OperatorAddressMismatch",
        type: "error"
      },
      {
        inputs: [],
        name: "OperatorAlreadyRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "OperatorNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum CommonErrors.RequiredVariableUnsetType",
            name: "variableType",
            type: "uint8"
          }
        ],
        name: "RequiredVariableUnset",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "SafeERC20FailedOperation",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferFailed",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferFailed",
        type: "error"
      },
      {
        inputs: [],
        name: "UnauthorizedOperator",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes",
            name: "err",
            type: "bytes"
          }
        ],
        name: "CLFRequestError",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "messageId",
            type: "bytes32"
          }
        ],
        name: "MessageReport",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "OperatorDepositWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "OperatorDeposited",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "OperatorFeeWithdrawn",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "id",
            type: "bytes32"
          }
        ],
        name: "RequestFulfilled",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "id",
            type: "bytes32"
          }
        ],
        name: "RequestSent",
        type: "event"
      },
      {
        stateMutability: "payable",
        type: "fallback"
      },
      {
        inputs: [],
        name: "getCLFDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "depositNative",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getCohortsCount",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "getOperatorDeposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "getOperatorFeesEarned",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum CommonTypes.ChainType",
            name: "chainType",
            type: "uint8"
          }
        ],
        name: "getRegisteredOperators",
        outputs: [
          {
            internalType: "bytes[]",
            name: "",
            type: "bytes[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "namespace",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "offset",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "mappingKey",
            type: "bytes32"
          }
        ],
        name: "getStorage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getWithdrawableConceroFee",
        outputs: [
          {
            internalType: "uint256",
            name: "availableFees",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "requestId",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "response",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "err",
            type: "bytes"
          }
        ],
        name: "handleOracleFulfillment",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "i_owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isOperatorRegistered",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "operatorDeposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "internalMessageConfig",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "messageId",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "messageHashSum",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "srcChainData",
            type: "bytes"
          }
        ],
        name: "requestMessageReport",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum CommonTypes.ChainType[]",
            name: "chainTypes",
            type: "uint8[]"
          },
          {
            internalType: "enum Types.OperatorRegistrationAction[]",
            name: "operatorActions",
            type: "uint8[]"
          },
          {
            internalType: "bytes[]",
            name: "operatorAddresses",
            type: "bytes[]"
          }
        ],
        name: "requestOperatorRegistration",
        outputs: [
          {
            internalType: "bytes32",
            name: "clfRequestId",
            type: "bytes32"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "setNativeUsdRate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "namespace",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "offset",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "mappingKey",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setStorage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32[]",
            name: "namespaces",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "offsets",
            type: "uint256[]"
          },
          {
            internalType: "bytes32[]",
            name: "mappingKeys",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "setStorageBulk",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          }
        ],
        name: "withdrawConceroFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawOperatorDeposit",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawOperatorFee",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ],
    bytecode: "0x6102003461019b57601f61384438819003918201601f19168301916001600160401b038311848410176101a0578084926101609460405283398101031261019b5780519062ffffff8216820361019b5761005b602082016101b6565b91610068604083016101b6565b92606083015161007a608085016101ca565b61008660a086016101ca565b9060c08601519260ff8416840361019b5760e08701519461ffff8616860361019b576101008801519663ffffffff8816880361019b576101406101208a01519901519960018060a01b03166080523360a05260c05260e0526101405261016052610180526101e0526101a0526101c052610100526101205260405161366590816101df823960805181818161030a01526127dd015260a0518181816106f501528181610a6c01528181610d0101528181610d4a0152611336015260c0518161117d015260e0518150506101005181610e5d01526101205181611a4f01526101405181611fc901526101605181611feb0152610180518150506101a051816111f401526101c051816111b601526101e051815050f35b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b038216820361019b57565b51906001600160401b038216820361019b5756fe60806040526004361015610010575b005b60003560e01c80630306ec9f146101405780630ca761751461013b5780631feb291f146101365780632a65d9ab1461013157806331d491941461012c5780633ae56951146101275780635a8733b314610122578063624db6321461011d5780636b1906f8146101185780636ea101ab146101135780638e3438f51461010e57806390239ec7146101095780639a5d5ca914610104578063b91443e7146100ff578063cc766882146100fa578063d1053131146100f5578063dba6335f146100f0578063e716afde146100eb5763fbfbdff80361000e57610d83565b610d30565b610ceb565b610cd0565b610bc9565b610b31565b610a42565b6109b3565b6108ec565b61083b565b610801565b6107e6565b6106a2565b610627565b610553565b61051e565b61040a565b6102b5565b61023d565b634e487b7160e01b600052604160045260246000fd5b60e081019081106001600160401b0382111761017657604052565b610145565b604081019081106001600160401b0382111761017657604052565b90601f801991011681019081106001600160401b0382111761017657604052565b604051906101c660c083610196565b565b6001600160401b03811161017657601f01601f191660200190565b9291926101ef826101c8565b916101fd6040519384610196565b82948184528183011161021a578281602093846000960137010152565b600080fd5b9080601f8301121561021a5781602061023a933591016101e3565b90565b3461021a57608036600319011261021a576024356064356004356044356001600160401b03831161021a5760209361027c6102ad94369060040161021f565b926102a860ff6102a1606761028f611505565b33600090815291016020526040902090565b5416610daf565b610dc7565b604051908152f35b3461021a57606036600319011261021a576004356024356001600160401b03811161021a576102e890369060040161021f565b6044356001600160401b03811161021a5761030790369060040161021f565b907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633036103f957602081015160001a6103498161167e565b8061039f57509061035991612244565b6066610363611573565b0181600052602052604060002060ff1981541690557f85e1543bf2f84fe80c6badbce3648c8539ad1df4d2b3d822938ca0538be727e6600080a2005b806103ab60019261167e565b036103bf57906103ba91612078565b610359565b506103f17fbcf5ce4fda95e104d7172732bf495e532c7355ebce10657ed2161d41d3a2b0e5916040519182918261166d565b0390a1610359565b63c6829f8360e01b60005260046000fd5b3461021a57602036600319011261021a5760043561043060ff6102a1606761028f611505565b61045633606a61043e611505565b019060018060a01b0316600052602052604060002090565b54610462821515610faa565b610470818381811115610fc2565b8181039081116105085761048833606a61043e611505565b55610491611505565b908154818103908111610508576105049255600080808084335af1906104b5611016565b506104bf82611046565b60405190815233907fc43e057480321c0f9aec5029e2f42bb82383abd09bc79fd2fbcb50c5071735729080602081015b0390a260405190151581529081906020820190565b0390f35b610fe2565b6001600160a01b0381160361021a57565b3461021a57602036600319011261021a57602061054a6004356105408161050d565b606a61043e611505565b54604051908152f35b3461021a57602036600319011261021a5760043561057960ff6102a1606761028f611505565b61058733606861043e611505565b54610593821515610faa565b6105a182828082111561105e565b818103908111610508576105b933606861043e611505565b5560016105c4611505565b01908154818103908111610508576105049255600080808084335af1906105e9611016565b506105f382611046565b60405190815233907f84863957610e3c6567187cf240a9979c5c8d56d4dba4473b5ac46a10d32469749080602081016104ef565b3461021a57606036600319011261021a57602060243560443560043561064c816116cc565b811561066957604080519283529201838201522054604051908152f35b905001546102ad565b9181601f8401121561021a578235916001600160401b03831161021a576020808501948460051b01011161021a57565b3461021a57604036600319011261021a576004356001600160401b03811161021a576106d2903690600401610672565b6024356001600160401b03811161021a576106f1903690600401610672565b92907f0000000000000000000000000000000000000000000000000000000000000000610728336001600160a01b0383161461107e565b848414806107dd575b61073a90611096565b60006107446114da565b9360005b86811061075157005b61076461075f8289856110d2565b6110e2565b9284610771838b896110d2565b359461077e861515610faa565b6001600160a01b0316806107c9575050906107c360008080806107a389600198611124565b986107b28d8b81811115610fc2565b8a5af16107bd611016565b50611046565b01610748565b946107d8916001949396611721565b6107c3565b50831515610731565b3461021a57600036600319011261021a5760206102ad61116c565b3461021a57602036600319011261021a57602060ff61082f6004356108258161050d565b606761043e611505565b54166040519015158152f35b602036600319011261021a576004356108538161050d565b61086861085e61116c565b348134101561105e565b6001600160a01b038116156108db5761088590606861043e611505565b8054903482018092116105085755600161089d611505565b016108a9348254611124565b905560405134815233907f06653c045d0a3144153a51ac6909baae43b8d5b67184cb74e988b72858727fe490602090a2005b63e6c4247b60e01b60005260046000fd5b3461021a57600036600319011261021a57602060405160018152f35b6002111561021a57565b919082519283825260005b84811061093e575050826000602080949584010152601f8019910116010190565b8060208092840101518282860101520161091d565b602081016020825282518091526040820191602060408360051b8301019401926000915b83831061098657505050505090565b90919293946020806109a4600193603f198682030187528951610912565b97019301930191939290610977565b3461021a57602036600319011261021a576109e36004356109d381610908565b60666109dd611505565b0161123a565b80546109ee81610abd565b916109fc6040519384610196565b818352602083019060005260206000206000915b838310610a2557604051806105048782610953565b600160208192610a348561128c565b815201920192019190610a10565b3461021a57608036600319011261021a57606435602435604435600435610a936001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016331461107e565b610a9c816116cc565b8115610ab45760408051928352920160208201522055005b90500155600080f35b6001600160401b0381116101765760051b60200190565b9080601f8301121561021a578135610aeb81610abd565b92610af96040519485610196565b81845260208085019260051b82010192831161021a57602001905b828210610b215750505090565b8135815260209182019101610b14565b3461021a57608036600319011261021a576004356001600160401b03811161021a57610b61903690600401610ad4565b6024356001600160401b03811161021a57610b80903690600401610ad4565b906044356001600160401b03811161021a57610ba0903690600401610ad4565b606435926001600160401b03841161021a57610bc361000e943690600401610ad4565b9261132e565b3461021a57606036600319011261021a576004356001600160401b03811161021a57610bf9903690600401610672565b6024356001600160401b03811161021a57610c18903690600401610672565b919092604435926001600160401b03841161021a5761050494610c42610cb7953690600401610672565b949093610c71610c6c610c5d610c5885856110c4565b611496565b610c6681611147565b60ff1690565b6118c3565b610c84610c6c610c5d610c5887876110c4565b610ca0610c9b610c9488886114a0565b36916101e3565b6118f1565b83821480610cc7575b610cb290611096565b611a19565b6040519081529081906020820190565b50818614610ca9565b3461021a57600036600319011261021a5760206102ad6114da565b3461021a57600036600319011261021a576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461021a57602036600319011261021a57600435610d78337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461107e565b610d80611688565b55005b3461021a57602036600319011261021a57602061054a600435610da58161050d565b606861043e611505565b15610db657565b6326b9cdff60e11b60005260046000fd5b91906067610dd3611573565b018160005260205260ff60406000205416610f9957610f6b93610eba610f03610eba94610eba610edb610f26966067610e0a611573565b01816000526020526040600020600160ff19825416179055610e3c610e36610e30611688565b546117de565b33611b19565b50610eba610ec8610e4b6115ad565b9b8c610e9c60405191610e9783610e897f00000000000000000000000000000000000000000000000000000000000000006020830160209181520190565b03601f198101855284610196565b611425565b52610ea68d611425565b506040519283916020830160209181520190565b03601f198101835282610196565b610ed18b611432565b52610ea68a611432565b610ee488611442565b52610eee87611442565b50604051928391602083019190602083019252565b610f0c85611452565b52610f1684611452565b506040519283916020830161166d565b610f2f82611462565b52610f3981611462565b506040805133602082015290610f529082908101610eba565b610f5b82611472565b52610f6581611472565b50611b58565b61023a610f8c826066610f7c611573565b0190600052602052604060002090565b805460ff19166001179055565b637b04260960e01b60005260046000fd5b15610fb157565b63162908e360e11b60005260046000fd5b15610fcb575050565b63a458261b60e01b60005260045260245260446000fd5b634e487b7160e01b600052601160045260246000fd5b601f1981019190821161050857565b60001981019190821161050857565b3d15611041573d90611027826101c8565b916110356040519384610196565b82523d6000602084013e565b606090565b1561104d57565b6312171d8360e31b60005260046000fd5b15611067575050565b63052dcc5960e51b60005260045260245260446000fd5b1561108557565b6330cd747160e01b60005260046000fd5b1561109d57565b631fec674760e31b60005260046000fd5b634e487b7160e01b600052603260045260246000fd5b90156110cd5790565b6110ae565b91908110156110cd5760051b0190565b3561023a8161050d565b608401908160841161050857565b906020820180921161050857565b602601908160261161050857565b906002820180921161050857565b9190820180921161050857565b634e487b7160e01b600052602160045260246000fd5b6002111561115157565b611131565b908160011b918083046002149015171561050857565b6065611176611688565b0162ffffff7f00000000000000000000000000000000000000000000000000000000000000001660005260205260406000205480156112245763ffffffff7f000000000000000000000000000000000000000000000000000000000000000016818102918183041490151715610508576112186111f1611688565b547f0000000000000000000000000000000000000000000000000000000000000000611852565b81018091116105085790565b63c6af252960e01b600052600160045260246000fd5b9061124481611147565b600052602052604060002090565b90600182811c92168015611282575b602083101461126c57565b634e487b7160e01b600052602260045260246000fd5b91607f1691611261565b90604051918260008254926112a084611252565b808452936001811690811561130c57506001146112c5575b506101c692500383610196565b90506000929192526020600020906000915b8183106112f05750509060206101c692820101386112b8565b60209193508060019154838589010152019101909184926112d7565b9050602092506101c694915060ff191682840152151560051b820101386112b8565b9391611364337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461107e565b60005b855181101561138c578061138661138060019389611482565b516116cc565b01611367565b5090919284518351809114908161141a575b508061140f575b6113ae90611096565b60005b8551811015611407578060019160051b602081890101519060208188010151906020808289010151918701015192816000146113fe57604080519283529201602082015220555b016113b1565b905001556113f8565b505050509050565b5081518151146113a5565b90508251143861139e565b8051156110cd5760200190565b8051600110156110cd5760400190565b8051600210156110cd5760600190565b8051600310156110cd5760800190565b8051600410156110cd5760a00190565b8051600510156110cd5760c00190565b80518210156110cd5760209160051b010190565b3561023a81610908565b90156110cd57803590601e198136030182121561021a5701908135916001600160401b03831161021a57602001823603811361021a579190565b476114e3611505565b5460016114ee611505565b015481018091116105085781039081116105085790565b60405160208101907f636f6e6365726f76657269666965722e6f70657261746f722e73746f7261676582526020815261153f604082610196565b519020600019810190811161050857604051906020820190815260208252611568604083610196565b9051902060ff191690565b60405160208101907f636f6e6365726f76657269666965722e76657269666965722e73746f7261676582526020815261153f604082610196565b60405160e091906115be8382610196565b6006815291601f19018260005b8281106115d757505050565b8060606020809385010152016115cb565b60405160c091906115f98382610196565b6005815291601f19018260005b82811061161257505050565b806060602080938501015201611606565b9061162d82610abd565b61163a6040519182610196565b828152809261164b601f1991610abd565b019060005b82811061165c57505050565b806060602080938501015201611650565b90602061023a928181520190610912565b6003111561115157565b60405160208101907f636f6e6365726f76657269666965722e7072696365666565642e73746f7261678252606560f81b60408201526021815261153f604182610196565b6116d4611573565b811490811561170f575b81156116fe575b50156116ed57565b630a02739760e41b60005260046000fd5b9050611708611688565b14386116e5565b9050611719611505565b8114906116de565b60405163a9059cbb60e01b60208281019182526001600160a01b0390941660248301526044808301959095529381529092600091611760606482610196565b519082855af1156117b2576000513d6117a957506001600160a01b0381163b155b6117885750565b635274afe760e01b60009081526001600160a01b0391909116600452602490fd5b60011415611781565b6040513d6000823e3d90fd5b81156117c8570490565b634e487b7160e01b600052601260045260246000fd5b6000811561181857506000811561180457506e01ed09bead87c0378d8e64000000000490565b634e487b7160e01b81526012600452602490fd5b63c6af252960e01b81526004819052602490fd5b6000811561181857506000811561180457506e03da137d5b0f806f1b1cc8000000000490565b81156118ad5761ffff16670de0b6b3a7640000810290808204670de0b6b3a7640000149015171561050857612710900490670de0b6b3a7640000820291808304670de0b6b3a764000014901517156105085761023a916117be565b63c6af252960e01b600052600060045260246000fd5b6101c6906040519063f82c50f160e01b60208301526024820152602481526118ec604482610196565b612458565b610eba6118ec6101c6926040519283916305f3bfab60e11b60208401526020602484018181520190610912565b602080825281018390526040019160005b81811061193c5750505090565b909192602080600192863561195081610908565b61195981611147565b815201940192910161192f565b908060209392818452848401376000828201840152601f01601f1916010190565b9180602084016020855252604083019060408160051b8501019383600091601e1982360301905b8484106119bf575050505050505090565b90919293949596603f1982820301875287358381121561021a57840190602082359201916001600160401b03811161021a57803603831361021a57611a0a6020928392600195611966565b990197019594019291906119ae565b939092611ab4611ada93610f6b9795611a36610e36610e30611688565b50611aa1611a426115e8565b98604051611a7b81610eba7f00000000000000000000000000000000000000000000000000000000000000006020830160209181520190565b611a848b611425565b52611a8e8a611425565b50610eba6040519384926020840161191e565b611aaa88611432565b52611a8e87611432565b611abd85611442565b52611ac784611442565b50610eba60405193849260208401611987565b611ae382611452565b52611aed81611452565b506040805133602082015290611b069082908101610eba565b611b0f82611462565b52610f6581611462565b611b4790610da583611b2f83606861043e611505565b5481611b3f85606861043e611505565b54101561105e565b805490828203918211610508575590565b611fc761023a91611fc260405191611b6f8361015b565b60008352600060208401526000604084015260608084015260606080840152606060a0840152606060c0840152611fbc610380611baf6040519182610196565b61034981527f747279207b20636f6e7374205b742c20705d203d2061776169742050726f6d6960208201527f73652e616c6c285b206665746368282768747470733a2f2f7261772e6769746860408201527f756275736572636f6e74656e742e636f6d2f6574686572732d696f2f6574686560608201527f72732e6a732f76362e31302e302f646973742f6574686572732e756d642e6d6960808201527f6e2e6a7327292c206665746368282768747470733a2f2f7261772e676974687560a08201527f6275736572636f6e74656e742e636f6d2f636f6e6365726f2f76322d636f6e7460c08201527f72616374732f726566732f68656164732f6d61737465722f636c662f6469737460e08201527f2f726571756573745265706f72742e6d696e2e6a7327292c205d293b20636f6e6101008201527f7374205b652c20635d203d2061776169742050726f6d6973652e616c6c285b746101208201527f2e7465787428292c20702e7465787428295d293b20636f6e73742067203d20616101408201527f73796e632073203d3e207b2072657475726e20282027307827202b20417272616101608201527f792e66726f6d286e65772055696e7438417272617928617761697420637279706101808201527f746f2e737562746c652e64696765737428275348412d323536272c206e6577206101a08201527f54657874456e636f64657228292e656e636f6465287329292929202e6d6170286101c08201527f76203d3e2028273027202b20762e746f537472696e6728313629292e736c69636101e08201527f65282d32292e746f4c6f77657243617365282929202e6a6f696e2827272920296102008201527f3b207d3b20636f6e73742072203d20617761697420672863293b20636f6e73746102208201527f2078203d20617761697420672865293b20636f6e73742062203d2062797465736102408201527f417267735b305d2e746f4c6f7765724361736528293b20636f6e7374206f203d6102608201527f206279746573417267735b315d2e746f4c6f7765724361736528293b206966206102808201527f2872203d3d3d20622026262078203d3d3d206f29207b20636f6e7374206574686102a08201527f657273203d206e65772046756e6374696f6e2865202b20273b2072657475726e6102c08201527f206574686572733b272928293b2072657475726e206177616974206576616c286102e08201527f63293b207d207468726f77206e6577204572726f722860247b727d213d247b626103008201527f7d7c7c247b787d213d247b6f7d60293b207d20636174636820286529207b20746103208201527f68726f77206e6577204572726f7228652e6d6573736167652e736c6963652830610340820152682c2032353529293b7d60b81b61036082015284612de7565b82612473565b6125aa565b7f0000000000000000000000000000000000000000000000000000000000000000907f000000000000000000000000000000000000000000000000000000000000000090612786565b5161023a81611147565b9060208251920151916bffffffffffffffffffffffff1983169260148210612040575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b1561206757565b634265bbb960e11b60005260046000fd5b815161220d576120889150612951565b80516020820180515160608401805151909592936001600160a01b031692916120bd91811490816121fe575b50949394611096565b604060009301925b845180518210156121c957906120e56120e082600194611482565b612010565b6120f36120e0838851611482565b6120fc82611147565b811561210b575b5050016120c5565b61213e61212b61212561211f868d51611482565b5161201a565b60601c90565b60a086901b869003888116911614612060565b61214781611147565b80840361217d57506121659061215e838a51611482565b5190612c82565b612176610f8c85606761043e611505565b3880612103565b61218681611147565b15612192575b50612176565b6121a8906121a1838a51611482565b5190612afc565b6121c36121b985606761043e611505565b805460ff19169055565b3861218c565b505093509150506121fa6121f26121e76121e1611688565b5461182c565b92606861043e611505565b918254611124565b9055565b905060408601515114386120b4565b5061223f7fbcf5ce4fda95e104d7172732bf495e532c7355ebce10657ed2161d41d3a2b0e5916040519182918261166d565b0390a1565b919080516124245750612255612da3565b506000602083015192604081015192606082015160808301519560a084015160e01c61228081612929565b95805b8281106123eb575050612295906110ec565b9560026020888701015160f01c9701946122ae886128a9565b956000905b8961ffff8316106123c3575050506122ca87611623565b9560005b61ffff8116898110156123165761ffff9161230e828a6123076001958e60206122f5612904565b948860051b0101516020850152611482565b528b611482565b5001166122ce565b50509091945060a092965061236395939761232f6101b7565b928684526020840152604083019788526060830152608082015201528060f81c9160ff8260f01c169160018060a01b031690565b9150506123996121f26121e7612377611688565b54612381816117de565b6123926121f287606a61043e611505565b90556117de565b9055517fe926aaee2b4b6afb102e3dd8011621cf4b6e8eeae7dde6190388b45bbb39749c600080a2565b60016123e282602061ffff948701015160208660051b8d0101526110fa565b920116906122b3565b806124116124036123fd6001946110ec565b8a6128db565b516001600160f81b03191690565b831a61241d828b6128db565b5301612283565b7fbcf5ce4fda95e104d7172732bf495e532c7355ebce10657ed2161d41d3a2b0e591925061223f906040519182918261166d565b600080916020815191016a636f6e736f6c652e6c6f675afa50565b8151156124805760c00152565b63fe936cb760e01b60005260046000fd5b604051906124a0604083610196565b600c82526b31b7b232a637b1b0ba34b7b760a11b6020830152565b604051906124ca604083610196565b60088252676c616e677561676560c01b6020830152565b6001111561115157565b604051906124fa604083610196565b6006825265736f7572636560d01b6020830152565b6040519061251e604083610196565b60048252636172677360e01b6020830152565b60405190612540604083610196565b600f82526e39b2b1b932ba39a637b1b0ba34b7b760891b6020830152565b6040519061256d604083610196565b60078252667365637265747360c81b6020830152565b60405190612592604083610196565b600982526862797465734172677360b81b6020830152565b6125b2612e2a565b906125c46125be612491565b83612e5b565b6125e181516125d28161167e565b6125db8161167e565b83612f42565b6125ec6125be6124bb565b61260660408201516125fd816124e1565b6125db816124e1565b6126116125be6124eb565b61261f606082015183612e5b565b60a0810180515161271e575b50608081019081515161269f575b60c091500180515161264c575b50515190565b916126586125be612583565b61266182612f6f565b60005b8351805182101561268c579061268661267f82600194611482565b5185612fb4565b01612664565b5050915061269981612f91565b38612646565b6020810180516126ae8161167e565b6126b78161167e565b1561270d5760c0926126f0612708926126d76126d1612531565b88612e5b565b516126e18161167e565b6126ea8161167e565b86612f42565b6127016126fb61255e565b86612e5b565b5184612fb4565b612639565b63a80d31f760e01b60005260046000fd5b9261273061272a61250f565b84612e5b565b61273983612f6f565b60005b84518051821015612764579061275e61275782600194611482565b5186612e5b565b0161273c565b5050925061277182612f91565b3861262b565b9081602091031261021a575190565b916020916001600160401b03916127bf604051958694859463230e93b160e11b865216600485015260a0602485015260a4840190610912565b60016044840152620186a060648401526084830191909152038160007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af190811561286f57600091612840575b50807f1131472297a800fee664d1d89cfa8f7676ff07189ecc53f80bbb5f4969099db8600080a290565b612862915060203d602011612868575b61285a8183610196565b810190612777565b38612816565b503d612850565b6117b2565b60405190608082018281106001600160401b038211176101765760405260608083600081528160208201528160408201520152565b906128b382610abd565b6128c06040519182610196565b82815280926128d1601f1991610abd565b0190602036910137565b9081518110156110cd570160200190565b60ff1661023a81611147565b61290182611147565b52565b604080519091906129158382610196565b60208152918290601f190190369060200137565b90612933826101c8565b6129406040519182610196565b82815280926128d1601f19916101c8565b612959612874565b50612962612874565b50602081015190604051918060001a835360011a6001830153602281015160601c60208301908152604282015160e01c9061299c826128a9565b815260005b828110612adb5750506129b390611108565b60046020828401015160e01c91016129ca826128a9565b6040850190815260005b838110612a9e575050906129e791611124565b6020818301015160e01c9060046129fd83611623565b916060860192835201906000915b838310612a1a57505050505090565b612a2a8186015160f01c91611116565b83612a3483612929565b60005b848110612a6c575091612a5e60019492612a6494875190612a588383611482565b52611482565b50611124565b920191612a0b565b6001919250612a87612403612a818387611124565b8b6128db565b60001a612a9482856128db565b5301908591612a37565b80612ad5612ac5612ac0612aba612403612a816001978a611124565b60f81c90565b6128ec565b612ad0838651611482565b6128f8565b016129d4565b80612af6612ac5612ac0612aba6124036123fd600197611108565b016129a1565b612b0d612b149160666109dd611505565b918261304d565b9015612be7578154600019810190811161050857612b35612b3d9184612bf8565b509183612bf8565b919091612bcc57612b4d9161309e565b80548015612bd1576000190190612b648282612bf8565b612bcc57612b728154611252565b9081612b7d57505055565b601f8211600114612b9057600090555055565b612bb8612bc9926001601f612baa85600052602060002090565b920160051c82019101612c26565b600081815260208120918190559055565b55565b612c10565b634e487b7160e01b600052603160045260246000fd5b6325ec6c1f60e01b60005260046000fd5b80548210156110cd5760005260206000200190600090565b634e487b7160e01b600052600060045260246000fd5b818110612c31575050565b60008155600101612c26565b9190601f8111612c4c57505050565b6101c6926000526020600020906020601f840160051c83019310612c78575b601f0160051c0190612c26565b9091508190612c6b565b612c939092919260666109dd611505565b612c9d838261304d565b50612d925780546801000000000000000081101561017657612cc491600182018155612bf8565b612bcc5782516001600160401b03811161017657612cec81612ce68454611252565b84612c3d565b6020601f8211600114612d295781906121fa939495600092612d1e575b50508160011b916000199060031b1c19161790565b015190503880612d09565b601f19821690612d3e84600052602060002090565b9160005b818110612d7a57509583600195969710612d61575b505050811b019055565b015160001960f88460031b161c19169055388080612d57565b9192602060018192868b015181550194019201612d42565b6342ee68b560e01b60005260046000fd5b6040519060c082018281106001600160401b0382111761017657604052606060a0836000815260006020820152600060408201526000838201528260808201520152565b6000825115612e0157506000808252604082015260600152565b6322ce3edd60e01b8152600490fd5b60405190612e1d8261017b565b6000602083606081520152565b604051612e368161017b565b6000612e40612e10565b808352612e566101006020850192848452613186565b505290565b8151612eaa9291906001600160401b031660178111612ead578151612e9591612e8f90612e886060610c66565b1760ff1690565b90613308565b505b5190612ea1612e10565b50805191613572565b50565b60ff8111612eda578151612ed49190612ecc90601860605b1790613308565b5082516134f2565b50612e97565b61ffff8111612eff578151612ed49190612ef79060196060612ec5565b508251613479565b63ffffffff8111612f26578151612ed49190612f1e90601a6060612ec5565b508251613400565b8151612ed49190612f3a90601b6060612ec5565b508251613382565b906101c691612f518151613298565b5060405191602083015260208252612f6a604083610196565b612fb4565b602090612f7e609f8251613308565b5001805190600182018092116105085752565b602090612fa060ff8251613308565b500180516000198101919082116105085752565b8151612eaa9291906001600160401b031660178111612fe1578151612e9591612e8f90612e886040610c66565b60ff8111612ffd578151612ed49190612ecc9060186040612ec5565b61ffff811161301a578151612ed49190612ef79060196040612ec5565b63ffffffff8111613039578151612ed49190612f1e90601a6040612ec5565b8151612ed49190612f3a90601b6040612ec5565b919060005b83548110156130925761306e6130688286612bf8565b5061128c565b60208151910120825160208401201461308957600101613052565b92505060019190565b50509050600090600090565b919091828114613181576130b28354611252565b6001600160401b038111610176576130ce81612ce68454611252565b600093601f821160011461310b576121fa92939482916000926131005750508160011b916000199060031b1c19161790565b015490503880612d09565b61311f601f19831691600052602060002090565b9461312f84600052602060002090565b91815b8181106131695750958360019596971061315057505050811b019055565b015460001960f88460031b161c19169055388080612d57565b9192600180602092868b015481550194019201613132565b509050565b9061318f612e10565b50601f8116806131be575b508060208301526040519081835260008252810160200190811061021a5760405290565b60200360208111610508578101809111610508573861319a565b906131e1612e10565b5080516131ec612e10565b506131fa825182111561356b565b825151916132088284611124565b9060208501518211613281575b602091855183815196820101958211613279575b505001905b602081101561325357600019906020036101000a019081199051169082511617905290565b909161326e61326861327492855181526110fa565b936110fa565b91610ff8565b61322e565b523880613229565b61329361328d83611156565b86613618565b613215565b6132a0612e10565b5080515160018101908181116105085760208301518110156132d9575b60c2602084519283010153805182116132d557505090565b5290565b8160011b8281046002148315171561050857613302906132fb85519186613186565b50846131d8565b506132bd565b90613311612e10565b508151516001810191828211610508576020840151821015613344575b602084519283010153805182116132d557505090565b8260011b838104600214841517156105085761336d9061336686519187613186565b50856131d8565b5061332e565b601f8111610508576101000a90565b9061338b612e10565b5081515180600801918260081161050857602084015183116133d8575b6133ba6133b56008613373565b611007565b9060088551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576133fa9061336686519187613186565b506133a8565b90613409612e10565b508151518060040191826004116105085760208401518311613451575b6134336133b56004613373565b9060048551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576134739061336686519187613186565b50613426565b90613482612e10565b5081515180600201918260021161050857602084015183116134ca575b6134ac6133b56002613373565b9060028551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576134ec9061336686519187613186565b5061349f565b906134fb612e10565b508151518060010191826001116105085760208401518311613543575b6135256133b56001613373565b9060018551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576135659061336686519187613186565b50613518565b1561021a57565b9161357b612e10565b50613589825182111561356b565b6020835151926135998385611124565b828601518111613601575b8551838151968201019582116135f9575b505001905b60208110156135df57600019906020036101000a019081199051169082511617905290565b909161326e6132686135f492855181526110fa565b6135ba565b5238806135b5565b61361361360d82611156565b87613618565b6135a4565b90612eaa9161362981519282613186565b506131d856fea2646970667358221220017c74eda54b892bfec2a40a5dab0c00a341db512f246f02fa1d009837f9cc7764736f6c634300081c0033",
    deployedBytecode: "0x60806040526004361015610010575b005b60003560e01c80630306ec9f146101405780630ca761751461013b5780631feb291f146101365780632a65d9ab1461013157806331d491941461012c5780633ae56951146101275780635a8733b314610122578063624db6321461011d5780636b1906f8146101185780636ea101ab146101135780638e3438f51461010e57806390239ec7146101095780639a5d5ca914610104578063b91443e7146100ff578063cc766882146100fa578063d1053131146100f5578063dba6335f146100f0578063e716afde146100eb5763fbfbdff80361000e57610d83565b610d30565b610ceb565b610cd0565b610bc9565b610b31565b610a42565b6109b3565b6108ec565b61083b565b610801565b6107e6565b6106a2565b610627565b610553565b61051e565b61040a565b6102b5565b61023d565b634e487b7160e01b600052604160045260246000fd5b60e081019081106001600160401b0382111761017657604052565b610145565b604081019081106001600160401b0382111761017657604052565b90601f801991011681019081106001600160401b0382111761017657604052565b604051906101c660c083610196565b565b6001600160401b03811161017657601f01601f191660200190565b9291926101ef826101c8565b916101fd6040519384610196565b82948184528183011161021a578281602093846000960137010152565b600080fd5b9080601f8301121561021a5781602061023a933591016101e3565b90565b3461021a57608036600319011261021a576024356064356004356044356001600160401b03831161021a5760209361027c6102ad94369060040161021f565b926102a860ff6102a1606761028f611505565b33600090815291016020526040902090565b5416610daf565b610dc7565b604051908152f35b3461021a57606036600319011261021a576004356024356001600160401b03811161021a576102e890369060040161021f565b6044356001600160401b03811161021a5761030790369060040161021f565b907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633036103f957602081015160001a6103498161167e565b8061039f57509061035991612244565b6066610363611573565b0181600052602052604060002060ff1981541690557f85e1543bf2f84fe80c6badbce3648c8539ad1df4d2b3d822938ca0538be727e6600080a2005b806103ab60019261167e565b036103bf57906103ba91612078565b610359565b506103f17fbcf5ce4fda95e104d7172732bf495e532c7355ebce10657ed2161d41d3a2b0e5916040519182918261166d565b0390a1610359565b63c6829f8360e01b60005260046000fd5b3461021a57602036600319011261021a5760043561043060ff6102a1606761028f611505565b61045633606a61043e611505565b019060018060a01b0316600052602052604060002090565b54610462821515610faa565b610470818381811115610fc2565b8181039081116105085761048833606a61043e611505565b55610491611505565b908154818103908111610508576105049255600080808084335af1906104b5611016565b506104bf82611046565b60405190815233907fc43e057480321c0f9aec5029e2f42bb82383abd09bc79fd2fbcb50c5071735729080602081015b0390a260405190151581529081906020820190565b0390f35b610fe2565b6001600160a01b0381160361021a57565b3461021a57602036600319011261021a57602061054a6004356105408161050d565b606a61043e611505565b54604051908152f35b3461021a57602036600319011261021a5760043561057960ff6102a1606761028f611505565b61058733606861043e611505565b54610593821515610faa565b6105a182828082111561105e565b818103908111610508576105b933606861043e611505565b5560016105c4611505565b01908154818103908111610508576105049255600080808084335af1906105e9611016565b506105f382611046565b60405190815233907f84863957610e3c6567187cf240a9979c5c8d56d4dba4473b5ac46a10d32469749080602081016104ef565b3461021a57606036600319011261021a57602060243560443560043561064c816116cc565b811561066957604080519283529201838201522054604051908152f35b905001546102ad565b9181601f8401121561021a578235916001600160401b03831161021a576020808501948460051b01011161021a57565b3461021a57604036600319011261021a576004356001600160401b03811161021a576106d2903690600401610672565b6024356001600160401b03811161021a576106f1903690600401610672565b92907f0000000000000000000000000000000000000000000000000000000000000000610728336001600160a01b0383161461107e565b848414806107dd575b61073a90611096565b60006107446114da565b9360005b86811061075157005b61076461075f8289856110d2565b6110e2565b9284610771838b896110d2565b359461077e861515610faa565b6001600160a01b0316806107c9575050906107c360008080806107a389600198611124565b986107b28d8b81811115610fc2565b8a5af16107bd611016565b50611046565b01610748565b946107d8916001949396611721565b6107c3565b50831515610731565b3461021a57600036600319011261021a5760206102ad61116c565b3461021a57602036600319011261021a57602060ff61082f6004356108258161050d565b606761043e611505565b54166040519015158152f35b602036600319011261021a576004356108538161050d565b61086861085e61116c565b348134101561105e565b6001600160a01b038116156108db5761088590606861043e611505565b8054903482018092116105085755600161089d611505565b016108a9348254611124565b905560405134815233907f06653c045d0a3144153a51ac6909baae43b8d5b67184cb74e988b72858727fe490602090a2005b63e6c4247b60e01b60005260046000fd5b3461021a57600036600319011261021a57602060405160018152f35b6002111561021a57565b919082519283825260005b84811061093e575050826000602080949584010152601f8019910116010190565b8060208092840101518282860101520161091d565b602081016020825282518091526040820191602060408360051b8301019401926000915b83831061098657505050505090565b90919293946020806109a4600193603f198682030187528951610912565b97019301930191939290610977565b3461021a57602036600319011261021a576109e36004356109d381610908565b60666109dd611505565b0161123a565b80546109ee81610abd565b916109fc6040519384610196565b818352602083019060005260206000206000915b838310610a2557604051806105048782610953565b600160208192610a348561128c565b815201920192019190610a10565b3461021a57608036600319011261021a57606435602435604435600435610a936001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016331461107e565b610a9c816116cc565b8115610ab45760408051928352920160208201522055005b90500155600080f35b6001600160401b0381116101765760051b60200190565b9080601f8301121561021a578135610aeb81610abd565b92610af96040519485610196565b81845260208085019260051b82010192831161021a57602001905b828210610b215750505090565b8135815260209182019101610b14565b3461021a57608036600319011261021a576004356001600160401b03811161021a57610b61903690600401610ad4565b6024356001600160401b03811161021a57610b80903690600401610ad4565b906044356001600160401b03811161021a57610ba0903690600401610ad4565b606435926001600160401b03841161021a57610bc361000e943690600401610ad4565b9261132e565b3461021a57606036600319011261021a576004356001600160401b03811161021a57610bf9903690600401610672565b6024356001600160401b03811161021a57610c18903690600401610672565b919092604435926001600160401b03841161021a5761050494610c42610cb7953690600401610672565b949093610c71610c6c610c5d610c5885856110c4565b611496565b610c6681611147565b60ff1690565b6118c3565b610c84610c6c610c5d610c5887876110c4565b610ca0610c9b610c9488886114a0565b36916101e3565b6118f1565b83821480610cc7575b610cb290611096565b611a19565b6040519081529081906020820190565b50818614610ca9565b3461021a57600036600319011261021a5760206102ad6114da565b3461021a57600036600319011261021a576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461021a57602036600319011261021a57600435610d78337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461107e565b610d80611688565b55005b3461021a57602036600319011261021a57602061054a600435610da58161050d565b606861043e611505565b15610db657565b6326b9cdff60e11b60005260046000fd5b91906067610dd3611573565b018160005260205260ff60406000205416610f9957610f6b93610eba610f03610eba94610eba610edb610f26966067610e0a611573565b01816000526020526040600020600160ff19825416179055610e3c610e36610e30611688565b546117de565b33611b19565b50610eba610ec8610e4b6115ad565b9b8c610e9c60405191610e9783610e897f00000000000000000000000000000000000000000000000000000000000000006020830160209181520190565b03601f198101855284610196565b611425565b52610ea68d611425565b506040519283916020830160209181520190565b03601f198101835282610196565b610ed18b611432565b52610ea68a611432565b610ee488611442565b52610eee87611442565b50604051928391602083019190602083019252565b610f0c85611452565b52610f1684611452565b506040519283916020830161166d565b610f2f82611462565b52610f3981611462565b506040805133602082015290610f529082908101610eba565b610f5b82611472565b52610f6581611472565b50611b58565b61023a610f8c826066610f7c611573565b0190600052602052604060002090565b805460ff19166001179055565b637b04260960e01b60005260046000fd5b15610fb157565b63162908e360e11b60005260046000fd5b15610fcb575050565b63a458261b60e01b60005260045260245260446000fd5b634e487b7160e01b600052601160045260246000fd5b601f1981019190821161050857565b60001981019190821161050857565b3d15611041573d90611027826101c8565b916110356040519384610196565b82523d6000602084013e565b606090565b1561104d57565b6312171d8360e31b60005260046000fd5b15611067575050565b63052dcc5960e51b60005260045260245260446000fd5b1561108557565b6330cd747160e01b60005260046000fd5b1561109d57565b631fec674760e31b60005260046000fd5b634e487b7160e01b600052603260045260246000fd5b90156110cd5790565b6110ae565b91908110156110cd5760051b0190565b3561023a8161050d565b608401908160841161050857565b906020820180921161050857565b602601908160261161050857565b906002820180921161050857565b9190820180921161050857565b634e487b7160e01b600052602160045260246000fd5b6002111561115157565b611131565b908160011b918083046002149015171561050857565b6065611176611688565b0162ffffff7f00000000000000000000000000000000000000000000000000000000000000001660005260205260406000205480156112245763ffffffff7f000000000000000000000000000000000000000000000000000000000000000016818102918183041490151715610508576112186111f1611688565b547f0000000000000000000000000000000000000000000000000000000000000000611852565b81018091116105085790565b63c6af252960e01b600052600160045260246000fd5b9061124481611147565b600052602052604060002090565b90600182811c92168015611282575b602083101461126c57565b634e487b7160e01b600052602260045260246000fd5b91607f1691611261565b90604051918260008254926112a084611252565b808452936001811690811561130c57506001146112c5575b506101c692500383610196565b90506000929192526020600020906000915b8183106112f05750509060206101c692820101386112b8565b60209193508060019154838589010152019101909184926112d7565b9050602092506101c694915060ff191682840152151560051b820101386112b8565b9391611364337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461107e565b60005b855181101561138c578061138661138060019389611482565b516116cc565b01611367565b5090919284518351809114908161141a575b508061140f575b6113ae90611096565b60005b8551811015611407578060019160051b602081890101519060208188010151906020808289010151918701015192816000146113fe57604080519283529201602082015220555b016113b1565b905001556113f8565b505050509050565b5081518151146113a5565b90508251143861139e565b8051156110cd5760200190565b8051600110156110cd5760400190565b8051600210156110cd5760600190565b8051600310156110cd5760800190565b8051600410156110cd5760a00190565b8051600510156110cd5760c00190565b80518210156110cd5760209160051b010190565b3561023a81610908565b90156110cd57803590601e198136030182121561021a5701908135916001600160401b03831161021a57602001823603811361021a579190565b476114e3611505565b5460016114ee611505565b015481018091116105085781039081116105085790565b60405160208101907f636f6e6365726f76657269666965722e6f70657261746f722e73746f7261676582526020815261153f604082610196565b519020600019810190811161050857604051906020820190815260208252611568604083610196565b9051902060ff191690565b60405160208101907f636f6e6365726f76657269666965722e76657269666965722e73746f7261676582526020815261153f604082610196565b60405160e091906115be8382610196565b6006815291601f19018260005b8281106115d757505050565b8060606020809385010152016115cb565b60405160c091906115f98382610196565b6005815291601f19018260005b82811061161257505050565b806060602080938501015201611606565b9061162d82610abd565b61163a6040519182610196565b828152809261164b601f1991610abd565b019060005b82811061165c57505050565b806060602080938501015201611650565b90602061023a928181520190610912565b6003111561115157565b60405160208101907f636f6e6365726f76657269666965722e7072696365666565642e73746f7261678252606560f81b60408201526021815261153f604182610196565b6116d4611573565b811490811561170f575b81156116fe575b50156116ed57565b630a02739760e41b60005260046000fd5b9050611708611688565b14386116e5565b9050611719611505565b8114906116de565b60405163a9059cbb60e01b60208281019182526001600160a01b0390941660248301526044808301959095529381529092600091611760606482610196565b519082855af1156117b2576000513d6117a957506001600160a01b0381163b155b6117885750565b635274afe760e01b60009081526001600160a01b0391909116600452602490fd5b60011415611781565b6040513d6000823e3d90fd5b81156117c8570490565b634e487b7160e01b600052601260045260246000fd5b6000811561181857506000811561180457506e01ed09bead87c0378d8e64000000000490565b634e487b7160e01b81526012600452602490fd5b63c6af252960e01b81526004819052602490fd5b6000811561181857506000811561180457506e03da137d5b0f806f1b1cc8000000000490565b81156118ad5761ffff16670de0b6b3a7640000810290808204670de0b6b3a7640000149015171561050857612710900490670de0b6b3a7640000820291808304670de0b6b3a764000014901517156105085761023a916117be565b63c6af252960e01b600052600060045260246000fd5b6101c6906040519063f82c50f160e01b60208301526024820152602481526118ec604482610196565b612458565b610eba6118ec6101c6926040519283916305f3bfab60e11b60208401526020602484018181520190610912565b602080825281018390526040019160005b81811061193c5750505090565b909192602080600192863561195081610908565b61195981611147565b815201940192910161192f565b908060209392818452848401376000828201840152601f01601f1916010190565b9180602084016020855252604083019060408160051b8501019383600091601e1982360301905b8484106119bf575050505050505090565b90919293949596603f1982820301875287358381121561021a57840190602082359201916001600160401b03811161021a57803603831361021a57611a0a6020928392600195611966565b990197019594019291906119ae565b939092611ab4611ada93610f6b9795611a36610e36610e30611688565b50611aa1611a426115e8565b98604051611a7b81610eba7f00000000000000000000000000000000000000000000000000000000000000006020830160209181520190565b611a848b611425565b52611a8e8a611425565b50610eba6040519384926020840161191e565b611aaa88611432565b52611a8e87611432565b611abd85611442565b52611ac784611442565b50610eba60405193849260208401611987565b611ae382611452565b52611aed81611452565b506040805133602082015290611b069082908101610eba565b611b0f82611462565b52610f6581611462565b611b4790610da583611b2f83606861043e611505565b5481611b3f85606861043e611505565b54101561105e565b805490828203918211610508575590565b611fc761023a91611fc260405191611b6f8361015b565b60008352600060208401526000604084015260608084015260606080840152606060a0840152606060c0840152611fbc610380611baf6040519182610196565b61034981527f747279207b20636f6e7374205b742c20705d203d2061776169742050726f6d6960208201527f73652e616c6c285b206665746368282768747470733a2f2f7261772e6769746860408201527f756275736572636f6e74656e742e636f6d2f6574686572732d696f2f6574686560608201527f72732e6a732f76362e31302e302f646973742f6574686572732e756d642e6d6960808201527f6e2e6a7327292c206665746368282768747470733a2f2f7261772e676974687560a08201527f6275736572636f6e74656e742e636f6d2f636f6e6365726f2f76322d636f6e7460c08201527f72616374732f726566732f68656164732f6d61737465722f636c662f6469737460e08201527f2f726571756573745265706f72742e6d696e2e6a7327292c205d293b20636f6e6101008201527f7374205b652c20635d203d2061776169742050726f6d6973652e616c6c285b746101208201527f2e7465787428292c20702e7465787428295d293b20636f6e73742067203d20616101408201527f73796e632073203d3e207b2072657475726e20282027307827202b20417272616101608201527f792e66726f6d286e65772055696e7438417272617928617761697420637279706101808201527f746f2e737562746c652e64696765737428275348412d323536272c206e6577206101a08201527f54657874456e636f64657228292e656e636f6465287329292929202e6d6170286101c08201527f76203d3e2028273027202b20762e746f537472696e6728313629292e736c69636101e08201527f65282d32292e746f4c6f77657243617365282929202e6a6f696e2827272920296102008201527f3b207d3b20636f6e73742072203d20617761697420672863293b20636f6e73746102208201527f2078203d20617761697420672865293b20636f6e73742062203d2062797465736102408201527f417267735b305d2e746f4c6f7765724361736528293b20636f6e7374206f203d6102608201527f206279746573417267735b315d2e746f4c6f7765724361736528293b206966206102808201527f2872203d3d3d20622026262078203d3d3d206f29207b20636f6e7374206574686102a08201527f657273203d206e65772046756e6374696f6e2865202b20273b2072657475726e6102c08201527f206574686572733b272928293b2072657475726e206177616974206576616c286102e08201527f63293b207d207468726f77206e6577204572726f722860247b727d213d247b626103008201527f7d7c7c247b787d213d247b6f7d60293b207d20636174636820286529207b20746103208201527f68726f77206e6577204572726f7228652e6d6573736167652e736c6963652830610340820152682c2032353529293b7d60b81b61036082015284612de7565b82612473565b6125aa565b7f0000000000000000000000000000000000000000000000000000000000000000907f000000000000000000000000000000000000000000000000000000000000000090612786565b5161023a81611147565b9060208251920151916bffffffffffffffffffffffff1983169260148210612040575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b1561206757565b634265bbb960e11b60005260046000fd5b815161220d576120889150612951565b80516020820180515160608401805151909592936001600160a01b031692916120bd91811490816121fe575b50949394611096565b604060009301925b845180518210156121c957906120e56120e082600194611482565b612010565b6120f36120e0838851611482565b6120fc82611147565b811561210b575b5050016120c5565b61213e61212b61212561211f868d51611482565b5161201a565b60601c90565b60a086901b869003888116911614612060565b61214781611147565b80840361217d57506121659061215e838a51611482565b5190612c82565b612176610f8c85606761043e611505565b3880612103565b61218681611147565b15612192575b50612176565b6121a8906121a1838a51611482565b5190612afc565b6121c36121b985606761043e611505565b805460ff19169055565b3861218c565b505093509150506121fa6121f26121e76121e1611688565b5461182c565b92606861043e611505565b918254611124565b9055565b905060408601515114386120b4565b5061223f7fbcf5ce4fda95e104d7172732bf495e532c7355ebce10657ed2161d41d3a2b0e5916040519182918261166d565b0390a1565b919080516124245750612255612da3565b506000602083015192604081015192606082015160808301519560a084015160e01c61228081612929565b95805b8281106123eb575050612295906110ec565b9560026020888701015160f01c9701946122ae886128a9565b956000905b8961ffff8316106123c3575050506122ca87611623565b9560005b61ffff8116898110156123165761ffff9161230e828a6123076001958e60206122f5612904565b948860051b0101516020850152611482565b528b611482565b5001166122ce565b50509091945060a092965061236395939761232f6101b7565b928684526020840152604083019788526060830152608082015201528060f81c9160ff8260f01c169160018060a01b031690565b9150506123996121f26121e7612377611688565b54612381816117de565b6123926121f287606a61043e611505565b90556117de565b9055517fe926aaee2b4b6afb102e3dd8011621cf4b6e8eeae7dde6190388b45bbb39749c600080a2565b60016123e282602061ffff948701015160208660051b8d0101526110fa565b920116906122b3565b806124116124036123fd6001946110ec565b8a6128db565b516001600160f81b03191690565b831a61241d828b6128db565b5301612283565b7fbcf5ce4fda95e104d7172732bf495e532c7355ebce10657ed2161d41d3a2b0e591925061223f906040519182918261166d565b600080916020815191016a636f6e736f6c652e6c6f675afa50565b8151156124805760c00152565b63fe936cb760e01b60005260046000fd5b604051906124a0604083610196565b600c82526b31b7b232a637b1b0ba34b7b760a11b6020830152565b604051906124ca604083610196565b60088252676c616e677561676560c01b6020830152565b6001111561115157565b604051906124fa604083610196565b6006825265736f7572636560d01b6020830152565b6040519061251e604083610196565b60048252636172677360e01b6020830152565b60405190612540604083610196565b600f82526e39b2b1b932ba39a637b1b0ba34b7b760891b6020830152565b6040519061256d604083610196565b60078252667365637265747360c81b6020830152565b60405190612592604083610196565b600982526862797465734172677360b81b6020830152565b6125b2612e2a565b906125c46125be612491565b83612e5b565b6125e181516125d28161167e565b6125db8161167e565b83612f42565b6125ec6125be6124bb565b61260660408201516125fd816124e1565b6125db816124e1565b6126116125be6124eb565b61261f606082015183612e5b565b60a0810180515161271e575b50608081019081515161269f575b60c091500180515161264c575b50515190565b916126586125be612583565b61266182612f6f565b60005b8351805182101561268c579061268661267f82600194611482565b5185612fb4565b01612664565b5050915061269981612f91565b38612646565b6020810180516126ae8161167e565b6126b78161167e565b1561270d5760c0926126f0612708926126d76126d1612531565b88612e5b565b516126e18161167e565b6126ea8161167e565b86612f42565b6127016126fb61255e565b86612e5b565b5184612fb4565b612639565b63a80d31f760e01b60005260046000fd5b9261273061272a61250f565b84612e5b565b61273983612f6f565b60005b84518051821015612764579061275e61275782600194611482565b5186612e5b565b0161273c565b5050925061277182612f91565b3861262b565b9081602091031261021a575190565b916020916001600160401b03916127bf604051958694859463230e93b160e11b865216600485015260a0602485015260a4840190610912565b60016044840152620186a060648401526084830191909152038160007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af190811561286f57600091612840575b50807f1131472297a800fee664d1d89cfa8f7676ff07189ecc53f80bbb5f4969099db8600080a290565b612862915060203d602011612868575b61285a8183610196565b810190612777565b38612816565b503d612850565b6117b2565b60405190608082018281106001600160401b038211176101765760405260608083600081528160208201528160408201520152565b906128b382610abd565b6128c06040519182610196565b82815280926128d1601f1991610abd565b0190602036910137565b9081518110156110cd570160200190565b60ff1661023a81611147565b61290182611147565b52565b604080519091906129158382610196565b60208152918290601f190190369060200137565b90612933826101c8565b6129406040519182610196565b82815280926128d1601f19916101c8565b612959612874565b50612962612874565b50602081015190604051918060001a835360011a6001830153602281015160601c60208301908152604282015160e01c9061299c826128a9565b815260005b828110612adb5750506129b390611108565b60046020828401015160e01c91016129ca826128a9565b6040850190815260005b838110612a9e575050906129e791611124565b6020818301015160e01c9060046129fd83611623565b916060860192835201906000915b838310612a1a57505050505090565b612a2a8186015160f01c91611116565b83612a3483612929565b60005b848110612a6c575091612a5e60019492612a6494875190612a588383611482565b52611482565b50611124565b920191612a0b565b6001919250612a87612403612a818387611124565b8b6128db565b60001a612a9482856128db565b5301908591612a37565b80612ad5612ac5612ac0612aba612403612a816001978a611124565b60f81c90565b6128ec565b612ad0838651611482565b6128f8565b016129d4565b80612af6612ac5612ac0612aba6124036123fd600197611108565b016129a1565b612b0d612b149160666109dd611505565b918261304d565b9015612be7578154600019810190811161050857612b35612b3d9184612bf8565b509183612bf8565b919091612bcc57612b4d9161309e565b80548015612bd1576000190190612b648282612bf8565b612bcc57612b728154611252565b9081612b7d57505055565b601f8211600114612b9057600090555055565b612bb8612bc9926001601f612baa85600052602060002090565b920160051c82019101612c26565b600081815260208120918190559055565b55565b612c10565b634e487b7160e01b600052603160045260246000fd5b6325ec6c1f60e01b60005260046000fd5b80548210156110cd5760005260206000200190600090565b634e487b7160e01b600052600060045260246000fd5b818110612c31575050565b60008155600101612c26565b9190601f8111612c4c57505050565b6101c6926000526020600020906020601f840160051c83019310612c78575b601f0160051c0190612c26565b9091508190612c6b565b612c939092919260666109dd611505565b612c9d838261304d565b50612d925780546801000000000000000081101561017657612cc491600182018155612bf8565b612bcc5782516001600160401b03811161017657612cec81612ce68454611252565b84612c3d565b6020601f8211600114612d295781906121fa939495600092612d1e575b50508160011b916000199060031b1c19161790565b015190503880612d09565b601f19821690612d3e84600052602060002090565b9160005b818110612d7a57509583600195969710612d61575b505050811b019055565b015160001960f88460031b161c19169055388080612d57565b9192602060018192868b015181550194019201612d42565b6342ee68b560e01b60005260046000fd5b6040519060c082018281106001600160401b0382111761017657604052606060a0836000815260006020820152600060408201526000838201528260808201520152565b6000825115612e0157506000808252604082015260600152565b6322ce3edd60e01b8152600490fd5b60405190612e1d8261017b565b6000602083606081520152565b604051612e368161017b565b6000612e40612e10565b808352612e566101006020850192848452613186565b505290565b8151612eaa9291906001600160401b031660178111612ead578151612e9591612e8f90612e886060610c66565b1760ff1690565b90613308565b505b5190612ea1612e10565b50805191613572565b50565b60ff8111612eda578151612ed49190612ecc90601860605b1790613308565b5082516134f2565b50612e97565b61ffff8111612eff578151612ed49190612ef79060196060612ec5565b508251613479565b63ffffffff8111612f26578151612ed49190612f1e90601a6060612ec5565b508251613400565b8151612ed49190612f3a90601b6060612ec5565b508251613382565b906101c691612f518151613298565b5060405191602083015260208252612f6a604083610196565b612fb4565b602090612f7e609f8251613308565b5001805190600182018092116105085752565b602090612fa060ff8251613308565b500180516000198101919082116105085752565b8151612eaa9291906001600160401b031660178111612fe1578151612e9591612e8f90612e886040610c66565b60ff8111612ffd578151612ed49190612ecc9060186040612ec5565b61ffff811161301a578151612ed49190612ef79060196040612ec5565b63ffffffff8111613039578151612ed49190612f1e90601a6040612ec5565b8151612ed49190612f3a90601b6040612ec5565b919060005b83548110156130925761306e6130688286612bf8565b5061128c565b60208151910120825160208401201461308957600101613052565b92505060019190565b50509050600090600090565b919091828114613181576130b28354611252565b6001600160401b038111610176576130ce81612ce68454611252565b600093601f821160011461310b576121fa92939482916000926131005750508160011b916000199060031b1c19161790565b015490503880612d09565b61311f601f19831691600052602060002090565b9461312f84600052602060002090565b91815b8181106131695750958360019596971061315057505050811b019055565b015460001960f88460031b161c19169055388080612d57565b9192600180602092868b015481550194019201613132565b509050565b9061318f612e10565b50601f8116806131be575b508060208301526040519081835260008252810160200190811061021a5760405290565b60200360208111610508578101809111610508573861319a565b906131e1612e10565b5080516131ec612e10565b506131fa825182111561356b565b825151916132088284611124565b9060208501518211613281575b602091855183815196820101958211613279575b505001905b602081101561325357600019906020036101000a019081199051169082511617905290565b909161326e61326861327492855181526110fa565b936110fa565b91610ff8565b61322e565b523880613229565b61329361328d83611156565b86613618565b613215565b6132a0612e10565b5080515160018101908181116105085760208301518110156132d9575b60c2602084519283010153805182116132d557505090565b5290565b8160011b8281046002148315171561050857613302906132fb85519186613186565b50846131d8565b506132bd565b90613311612e10565b508151516001810191828211610508576020840151821015613344575b602084519283010153805182116132d557505090565b8260011b838104600214841517156105085761336d9061336686519187613186565b50856131d8565b5061332e565b601f8111610508576101000a90565b9061338b612e10565b5081515180600801918260081161050857602084015183116133d8575b6133ba6133b56008613373565b611007565b9060088551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576133fa9061336686519187613186565b506133a8565b90613409612e10565b508151518060040191826004116105085760208401518311613451575b6134336133b56004613373565b9060048551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576134739061336686519187613186565b50613426565b90613482612e10565b5081515180600201918260021161050857602084015183116134ca575b6134ac6133b56002613373565b9060028551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576134ec9061336686519187613186565b5061349f565b906134fb612e10565b508151518060010191826001116105085760208401518311613543575b6135256133b56001613373565b9060018551938401019119825116179052805182116132d557505090565b8260011b83810460021484151715610508576135659061336686519187613186565b50613518565b1561021a57565b9161357b612e10565b50613589825182111561356b565b6020835151926135998385611124565b828601518111613601575b8551838151968201019582116135f9575b505001905b60208110156135df57600019906020036101000a019081199051169082511617905290565b909161326e6132686135f492855181526110fa565b6135ba565b5238806135b5565b61361361360d82611156565b87613618565b6135a4565b90612eaa9161362981519282613186565b506131d856fea2646970667358221220017c74eda54b892bfec2a40a5dab0c00a341db512f246f02fa1d009837f9cc7764736f6c634300081c0033",
    linkReferences: {},
    deployedLinkReferences: {}
  };
});

// node_modules/logform/dist/format.js
var require_format = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _wrapNativeSuper(t) {
    var r = typeof Map == "function" ? new Map : undefined;
    return _wrapNativeSuper = function _wrapNativeSuper(t2) {
      if (t2 === null || !_isNativeFunction(t2))
        return t2;
      if (typeof t2 != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (r !== undefined) {
        if (r.has(t2))
          return r.get(t2);
        r.set(t2, Wrapper);
      }
      function Wrapper() {
        return _construct(t2, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
    }, _wrapNativeSuper(t);
  }
  function _construct(t, e, r) {
    if (_isNativeReflectConstruct())
      return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o));
    return r && _setPrototypeOf(p, r.prototype), p;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _isNativeFunction(t) {
    try {
      return Function.toString.call(t).indexOf("[native code]") !== -1;
    } catch (n) {
      return typeof t == "function";
    }
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  var InvalidFormatError = /* @__PURE__ */ function(_Error) {
    function InvalidFormatError2(formatFn) {
      var _this;
      _classCallCheck(this, InvalidFormatError2);
      _this = _callSuper(this, InvalidFormatError2, [`Format functions must be synchronous taking a two arguments: (info, opts)
Found: `.concat(formatFn.toString().split(`
`)[0], `
`)]);
      Error.captureStackTrace(_this, InvalidFormatError2);
      return _this;
    }
    _inherits(InvalidFormatError2, _Error);
    return _createClass(InvalidFormatError2);
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  module.exports = function(formatFn) {
    if (formatFn.length > 2) {
      throw new InvalidFormatError(formatFn);
    }
    function Format() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = options;
    }
    Format.prototype.transform = formatFn;
    function createFormatWrap(opts) {
      return new Format(opts);
    }
    createFormatWrap.Format = Format;
    return createFormatWrap;
  };
});

// node:util
var exports_util = {};
__export(exports_util, {
  default: () => so,
  TextEncoder: () => st,
  TextDecoder: () => ct
});
var pt, dr, lt, gt, dt, bt, p = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), At = (r, e) => {
  for (var t in e)
    dr(r, t, { get: e[t], enumerable: true });
}, gr = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o of gt(e))
      !bt.call(r, o) && o !== t && dr(r, o, { get: () => e[o], enumerable: !(n = lt(e, o)) || n.enumerable });
  return r;
}, F = (r, e, t) => (gr(r, e, "default"), t && gr(t, e, "default")), mt = (r, e, t) => (t = r != null ? pt(dt(r)) : {}, gr(e || !r || !r.__esModule ? dr(t, "default", { value: r, enumerable: true }) : t, r)), br, N2, Zr, Kr, V, re, H, ce, Y, Ae, Se, Pe, Fr, Br, Ur, Rr, qe, rt, tt, nt, yt, E, st, ct, so;
var init_util = __esm(() => {
  pt = Object.create;
  dr = Object.defineProperty;
  lt = Object.getOwnPropertyDescriptor;
  gt = Object.getOwnPropertyNames;
  dt = Object.getPrototypeOf;
  bt = Object.prototype.hasOwnProperty;
  br = p((po, Vr) => {
    Vr.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var e = {}, t = Symbol("test"), n = Object(t);
      if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var o = 42;
      e[t] = o;
      for (t in e)
        return false;
      if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
        return false;
      var i = Object.getOwnPropertySymbols(e);
      if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a = Object.getOwnPropertyDescriptor(e, t);
        if (a.value !== o || a.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  N2 = p((lo, Jr) => {
    var ht = br();
    Jr.exports = function() {
      return ht() && !!Symbol.toStringTag;
    };
  });
  Zr = p((go, Hr) => {
    var Lr = typeof Symbol < "u" && Symbol, St = br();
    Hr.exports = function() {
      return typeof Lr != "function" || typeof Symbol != "function" || typeof Lr("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : St();
    };
  });
  Kr = p((bo, Yr) => {
    var vt = "Function.prototype.bind called on incompatible ", Ar = Array.prototype.slice, Ot = Object.prototype.toString, jt = "[object Function]";
    Yr.exports = function(e) {
      var t = this;
      if (typeof t != "function" || Ot.call(t) !== jt)
        throw new TypeError(vt + t);
      for (var n = Ar.call(arguments, 1), o, i = function() {
        if (this instanceof o) {
          var g = t.apply(this, n.concat(Ar.call(arguments)));
          return Object(g) === g ? g : this;
        } else
          return t.apply(e, n.concat(Ar.call(arguments)));
      }, a = Math.max(0, t.length - n.length), f2 = [], c = 0;c < a; c++)
        f2.push("$" + c);
      if (o = Function("binder", "return function (" + f2.join(",") + "){ return binder.apply(this,arguments); }")(i), t.prototype) {
        var l = function() {
        };
        l.prototype = t.prototype, o.prototype = new l, l.prototype = null;
      }
      return o;
    };
  });
  V = p((Ao, Qr) => {
    var Pt = Kr();
    Qr.exports = Function.prototype.bind || Pt;
  });
  re = p((mo, Xr) => {
    var wt = V();
    Xr.exports = wt.call(Function.call, Object.prototype.hasOwnProperty);
  });
  H = p((ho, ie) => {
    var s, x = SyntaxError, oe = Function, U = TypeError, mr = function(r) {
      try {
        return oe('"use strict"; return (' + r + ").constructor;")();
      } catch {
      }
    }, v2 = Object.getOwnPropertyDescriptor;
    if (v2)
      try {
        v2({}, "");
      } catch {
        v2 = null;
      }
    var hr = function() {
      throw new U;
    }, Et = v2 ? function() {
      try {
        return arguments.callee, hr;
      } catch {
        try {
          return v2(arguments, "callee").get;
        } catch {
          return hr;
        }
      }
    }() : hr, I2 = Zr()(), m = Object.getPrototypeOf || function(r) {
      return r.__proto__;
    }, B = {}, Tt = typeof Uint8Array > "u" ? s : m(Uint8Array), O = { "%AggregateError%": typeof AggregateError > "u" ? s : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? s : ArrayBuffer, "%ArrayIteratorPrototype%": I2 ? m([][Symbol.iterator]()) : s, "%AsyncFromSyncIteratorPrototype%": s, "%AsyncFunction%": B, "%AsyncGenerator%": B, "%AsyncGeneratorFunction%": B, "%AsyncIteratorPrototype%": B, "%Atomics%": typeof Atomics > "u" ? s : Atomics, "%BigInt%": typeof BigInt > "u" ? s : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? s : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? s : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? s : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? s : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? s : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? s : FinalizationRegistry, "%Function%": oe, "%GeneratorFunction%": B, "%Int8Array%": typeof Int8Array > "u" ? s : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? s : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? s : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": I2 ? m(m([][Symbol.iterator]())) : s, "%JSON%": typeof JSON == "object" ? JSON : s, "%Map%": typeof Map > "u" ? s : Map, "%MapIteratorPrototype%": typeof Map > "u" || !I2 ? s : m(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? s : Promise, "%Proxy%": typeof Proxy > "u" ? s : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? s : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? s : Set, "%SetIteratorPrototype%": typeof Set > "u" || !I2 ? s : m(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? s : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": I2 ? m(""[Symbol.iterator]()) : s, "%Symbol%": I2 ? Symbol : s, "%SyntaxError%": x, "%ThrowTypeError%": Et, "%TypedArray%": Tt, "%TypeError%": U, "%Uint8Array%": typeof Uint8Array > "u" ? s : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? s : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? s : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? s : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? s : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? s : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? s : WeakSet };
    try {
      null.error;
    } catch (r) {
      ee = m(m(r)), O["%Error.prototype%"] = ee;
    }
    var ee, Ft = function r(e) {
      var t;
      if (e === "%AsyncFunction%")
        t = mr("async function () {}");
      else if (e === "%GeneratorFunction%")
        t = mr("function* () {}");
      else if (e === "%AsyncGeneratorFunction%")
        t = mr("async function* () {}");
      else if (e === "%AsyncGenerator%") {
        var n = r("%AsyncGeneratorFunction%");
        n && (t = n.prototype);
      } else if (e === "%AsyncIteratorPrototype%") {
        var o = r("%AsyncGenerator%");
        o && (t = m(o.prototype));
      }
      return O[e] = t, t;
    }, te = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C2 = V(), J = re(), It = C2.call(Function.call, Array.prototype.concat), Bt = C2.call(Function.apply, Array.prototype.splice), ne = C2.call(Function.call, String.prototype.replace), L = C2.call(Function.call, String.prototype.slice), Ut = C2.call(Function.call, RegExp.prototype.exec), xt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Dt = /\\(\\)?/g, Rt = function(e) {
      var t = L(e, 0, 1), n = L(e, -1);
      if (t === "%" && n !== "%")
        throw new x("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && t !== "%")
        throw new x("invalid intrinsic syntax, expected opening `%`");
      var o = [];
      return ne(e, xt, function(i, a, f2, c) {
        o[o.length] = f2 ? ne(c, Dt, "$1") : a || i;
      }), o;
    }, kt = function(e, t) {
      var n = e, o;
      if (J(te, n) && (o = te[n], n = "%" + o[0] + "%"), J(O, n)) {
        var i = O[n];
        if (i === B && (i = Ft(n)), typeof i > "u" && !t)
          throw new U("intrinsic " + e + " exists, but is not available. Please file an issue!");
        return { alias: o, name: n, value: i };
      }
      throw new x("intrinsic " + e + " does not exist!");
    };
    ie.exports = function(e, t) {
      if (typeof e != "string" || e.length === 0)
        throw new U("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t != "boolean")
        throw new U('"allowMissing" argument must be a boolean');
      if (Ut(/^%?[^%]*%?$/, e) === null)
        throw new x("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var n = Rt(e), o = n.length > 0 ? n[0] : "", i = kt("%" + o + "%", t), a = i.name, f2 = i.value, c = false, l = i.alias;
      l && (o = l[0], Bt(n, It([0, 1], l)));
      for (var g = 1, S2 = true;g < n.length; g += 1) {
        var d2 = n[g], T2 = L(d2, 0, 1), _ = L(d2, -1);
        if ((T2 === '"' || T2 === "'" || T2 === "`" || _ === '"' || _ === "'" || _ === "`") && T2 !== _)
          throw new x("property names with quotes must have matching quotes");
        if ((d2 === "constructor" || !S2) && (c = true), o += "." + d2, a = "%" + o + "%", J(O, a))
          f2 = O[a];
        else if (f2 != null) {
          if (!(d2 in f2)) {
            if (!t)
              throw new U("base intrinsic for " + e + " exists, but the property is not available.");
            return;
          }
          if (v2 && g + 1 >= n.length) {
            var z = v2(f2, d2);
            S2 = !!z, S2 && "get" in z && !("originalValue" in z.get) ? f2 = z.get : f2 = f2[d2];
          } else
            S2 = J(f2, d2), f2 = f2[d2];
          S2 && !c && (O[a] = f2);
        }
      }
      return f2;
    };
  });
  ce = p((So, Z) => {
    var Sr = V(), D = H(), ue = D("%Function.prototype.apply%"), ye = D("%Function.prototype.call%"), se = D("%Reflect.apply%", true) || Sr.call(ye, ue), ae = D("%Object.getOwnPropertyDescriptor%", true), j2 = D("%Object.defineProperty%", true), Mt = D("%Math.max%");
    if (j2)
      try {
        j2({}, "a", { value: 1 });
      } catch {
        j2 = null;
      }
    Z.exports = function(e) {
      var t = se(Sr, ye, arguments);
      if (ae && j2) {
        var n = ae(t, "length");
        n.configurable && j2(t, "length", { value: 1 + Mt(0, e.length - (arguments.length - 1)) });
      }
      return t;
    };
    var fe = function() {
      return se(Sr, ue, arguments);
    };
    j2 ? j2(Z.exports, "apply", { value: fe }) : Z.exports.apply = fe;
  });
  Y = p((vo, ge) => {
    var pe = H(), le = ce(), Nt = le(pe("String.prototype.indexOf"));
    ge.exports = function(e, t) {
      var n = pe(e, !!t);
      return typeof n == "function" && Nt(e, ".prototype.") > -1 ? le(n) : n;
    };
  });
  Ae = p((Oo, be) => {
    var Ct = N2()(), $t = Y(), vr = $t("Object.prototype.toString"), K = function(e) {
      return Ct && e && typeof e == "object" && Symbol.toStringTag in e ? false : vr(e) === "[object Arguments]";
    }, de = function(e) {
      return K(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && vr(e) !== "[object Array]" && vr(e.callee) === "[object Function]";
    }, qt = function() {
      return K(arguments);
    }();
    K.isLegacyArguments = de;
    be.exports = qt ? K : de;
  });
  Se = p((jo, he) => {
    var Gt = Object.prototype.toString, Wt = Function.prototype.toString, _t = /^\s*(?:function)?\*/, me = N2()(), Or = Object.getPrototypeOf, zt = function() {
      if (!me)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {
      }
    }, jr;
    he.exports = function(e) {
      if (typeof e != "function")
        return false;
      if (_t.test(Wt.call(e)))
        return true;
      if (!me) {
        var t = Gt.call(e);
        return t === "[object GeneratorFunction]";
      }
      if (!Or)
        return false;
      if (typeof jr > "u") {
        var n = zt();
        jr = n ? Or(n) : false;
      }
      return Or(e) === jr;
    };
  });
  Pe = p((Po, je) => {
    var Oe = Function.prototype.toString, R = typeof Reflect == "object" && Reflect !== null && Reflect.apply, wr, Q2;
    if (typeof R == "function" && typeof Object.defineProperty == "function")
      try {
        wr = Object.defineProperty({}, "length", { get: function() {
          throw Q2;
        } }), Q2 = {}, R(function() {
          throw 42;
        }, null, wr);
      } catch (r) {
        r !== Q2 && (R = null);
      }
    else
      R = null;
    var Vt = /^\s*class\b/, Er = function(e) {
      try {
        var t = Oe.call(e);
        return Vt.test(t);
      } catch {
        return false;
      }
    }, Pr = function(e) {
      try {
        return Er(e) ? false : (Oe.call(e), true);
      } catch {
        return false;
      }
    }, X = Object.prototype.toString, Jt = "[object Object]", Lt = "[object Function]", Ht = "[object GeneratorFunction]", Zt = "[object HTMLAllCollection]", Yt = "[object HTML document.all class]", Kt = "[object HTMLCollection]", Qt = typeof Symbol == "function" && !!Symbol.toStringTag, Xt = !(0 in [,]), Tr = function() {
      return false;
    };
    typeof document == "object" && (ve = document.all, X.call(ve) === X.call(document.all) && (Tr = function(e) {
      if ((Xt || !e) && (typeof e > "u" || typeof e == "object"))
        try {
          var t = X.call(e);
          return (t === Zt || t === Yt || t === Kt || t === Jt) && e("") == null;
        } catch {
        }
      return false;
    }));
    var ve;
    je.exports = R ? function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      try {
        R(e, null, wr);
      } catch (t) {
        if (t !== Q2)
          return false;
      }
      return !Er(e) && Pr(e);
    } : function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      if (Qt)
        return Pr(e);
      if (Er(e))
        return false;
      var t = X.call(e);
      return t !== Lt && t !== Ht && !/^\[object HTML/.test(t) ? false : Pr(e);
    };
  });
  Fr = p((wo, Ee) => {
    var rn = Pe(), en = Object.prototype.toString, we = Object.prototype.hasOwnProperty, tn = function(e, t, n) {
      for (var o = 0, i = e.length;o < i; o++)
        we.call(e, o) && (n == null ? t(e[o], o, e) : t.call(n, e[o], o, e));
    }, nn = function(e, t, n) {
      for (var o = 0, i = e.length;o < i; o++)
        n == null ? t(e.charAt(o), o, e) : t.call(n, e.charAt(o), o, e);
    }, on = function(e, t, n) {
      for (var o in e)
        we.call(e, o) && (n == null ? t(e[o], o, e) : t.call(n, e[o], o, e));
    }, an = function(e, t, n) {
      if (!rn(t))
        throw new TypeError("iterator must be a function");
      var o;
      arguments.length >= 3 && (o = n), en.call(e) === "[object Array]" ? tn(e, t, o) : typeof e == "string" ? nn(e, t, o) : on(e, t, o);
    };
    Ee.exports = an;
  });
  Br = p((Eo, Te) => {
    var Ir = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], fn = typeof globalThis > "u" ? global : globalThis;
    Te.exports = function() {
      for (var e = [], t = 0;t < Ir.length; t++)
        typeof fn[Ir[t]] == "function" && (e[e.length] = Ir[t]);
      return e;
    };
  });
  Ur = p((To, Fe) => {
    var un = H(), rr = un("%Object.getOwnPropertyDescriptor%", true);
    if (rr)
      try {
        rr([], "length");
      } catch {
        rr = null;
      }
    Fe.exports = rr;
  });
  Rr = p((Fo, De) => {
    var Ie = Fr(), yn = Br(), Dr = Y(), sn = Dr("Object.prototype.toString"), Be = N2()(), er = Ur(), cn = typeof globalThis > "u" ? global : globalThis, Ue = yn(), pn = Dr("Array.prototype.indexOf", true) || function(e, t) {
      for (var n = 0;n < e.length; n += 1)
        if (e[n] === t)
          return n;
      return -1;
    }, ln = Dr("String.prototype.slice"), xe = {}, xr = Object.getPrototypeOf;
    Be && er && xr && Ie(Ue, function(r) {
      var e = new cn[r];
      if (Symbol.toStringTag in e) {
        var t = xr(e), n = er(t, Symbol.toStringTag);
        if (!n) {
          var o = xr(t);
          n = er(o, Symbol.toStringTag);
        }
        xe[r] = n.get;
      }
    });
    var gn = function(e) {
      var t = false;
      return Ie(xe, function(n, o) {
        if (!t)
          try {
            t = n.call(e) === o;
          } catch {
          }
      }), t;
    };
    De.exports = function(e) {
      if (!e || typeof e != "object")
        return false;
      if (!Be || !(Symbol.toStringTag in e)) {
        var t = ln(sn(e), 8, -1);
        return pn(Ue, t) > -1;
      }
      return er ? gn(e) : false;
    };
  });
  qe = p((Io, $e) => {
    var ke = Fr(), dn = Br(), Me = Y(), kr = Ur(), bn = Me("Object.prototype.toString"), Ne = N2()(), Re = typeof globalThis > "u" ? global : globalThis, An = dn(), mn = Me("String.prototype.slice"), Ce = {}, Mr = Object.getPrototypeOf;
    Ne && kr && Mr && ke(An, function(r) {
      if (typeof Re[r] == "function") {
        var e = new Re[r];
        if (Symbol.toStringTag in e) {
          var t = Mr(e), n = kr(t, Symbol.toStringTag);
          if (!n) {
            var o = Mr(t);
            n = kr(o, Symbol.toStringTag);
          }
          Ce[r] = n.get;
        }
      }
    });
    var hn = function(e) {
      var t = false;
      return ke(Ce, function(n, o) {
        if (!t)
          try {
            var i = n.call(e);
            i === o && (t = i);
          } catch {
          }
      }), t;
    }, Sn = Rr();
    $e.exports = function(e) {
      return Sn(e) ? !Ne || !(Symbol.toStringTag in e) ? mn(bn(e), 8, -1) : hn(e) : false;
    };
  });
  rt = p((u) => {
    var vn = Ae(), On = Se(), A2 = qe(), Ge = Rr();
    function k(r) {
      return r.call.bind(r);
    }
    var We = typeof BigInt < "u", _e = typeof Symbol < "u", b = k(Object.prototype.toString), jn = k(Number.prototype.valueOf), Pn = k(String.prototype.valueOf), wn = k(Boolean.prototype.valueOf);
    We && (ze = k(BigInt.prototype.valueOf));
    var ze;
    _e && (Ve = k(Symbol.prototype.valueOf));
    var Ve;
    function q2(r, e) {
      if (typeof r != "object")
        return false;
      try {
        return e(r), true;
      } catch {
        return false;
      }
    }
    u.isArgumentsObject = vn;
    u.isGeneratorFunction = On;
    u.isTypedArray = Ge;
    function En(r) {
      return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
    }
    u.isPromise = En;
    function Tn(r) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Ge(r) || Le(r);
    }
    u.isArrayBufferView = Tn;
    function Fn(r) {
      return A2(r) === "Uint8Array";
    }
    u.isUint8Array = Fn;
    function In(r) {
      return A2(r) === "Uint8ClampedArray";
    }
    u.isUint8ClampedArray = In;
    function Bn(r) {
      return A2(r) === "Uint16Array";
    }
    u.isUint16Array = Bn;
    function Un(r) {
      return A2(r) === "Uint32Array";
    }
    u.isUint32Array = Un;
    function xn(r) {
      return A2(r) === "Int8Array";
    }
    u.isInt8Array = xn;
    function Dn(r) {
      return A2(r) === "Int16Array";
    }
    u.isInt16Array = Dn;
    function Rn(r) {
      return A2(r) === "Int32Array";
    }
    u.isInt32Array = Rn;
    function kn(r) {
      return A2(r) === "Float32Array";
    }
    u.isFloat32Array = kn;
    function Mn(r) {
      return A2(r) === "Float64Array";
    }
    u.isFloat64Array = Mn;
    function Nn(r) {
      return A2(r) === "BigInt64Array";
    }
    u.isBigInt64Array = Nn;
    function Cn(r) {
      return A2(r) === "BigUint64Array";
    }
    u.isBigUint64Array = Cn;
    function tr(r) {
      return b(r) === "[object Map]";
    }
    tr.working = typeof Map < "u" && tr(new Map);
    function $n(r) {
      return typeof Map > "u" ? false : tr.working ? tr(r) : r instanceof Map;
    }
    u.isMap = $n;
    function nr(r) {
      return b(r) === "[object Set]";
    }
    nr.working = typeof Set < "u" && nr(new Set);
    function qn(r) {
      return typeof Set > "u" ? false : nr.working ? nr(r) : r instanceof Set;
    }
    u.isSet = qn;
    function or(r) {
      return b(r) === "[object WeakMap]";
    }
    or.working = typeof WeakMap < "u" && or(new WeakMap);
    function Gn(r) {
      return typeof WeakMap > "u" ? false : or.working ? or(r) : r instanceof WeakMap;
    }
    u.isWeakMap = Gn;
    function Cr(r) {
      return b(r) === "[object WeakSet]";
    }
    Cr.working = typeof WeakSet < "u" && Cr(new WeakSet);
    function Wn(r) {
      return Cr(r);
    }
    u.isWeakSet = Wn;
    function ir(r) {
      return b(r) === "[object ArrayBuffer]";
    }
    ir.working = typeof ArrayBuffer < "u" && ir(new ArrayBuffer);
    function Je(r) {
      return typeof ArrayBuffer > "u" ? false : ir.working ? ir(r) : r instanceof ArrayBuffer;
    }
    u.isArrayBuffer = Je;
    function ar(r) {
      return b(r) === "[object DataView]";
    }
    ar.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ar(new DataView(new ArrayBuffer(1), 0, 1));
    function Le(r) {
      return typeof DataView > "u" ? false : ar.working ? ar(r) : r instanceof DataView;
    }
    u.isDataView = Le;
    var Nr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
    function $(r) {
      return b(r) === "[object SharedArrayBuffer]";
    }
    function He(r) {
      return typeof Nr > "u" ? false : (typeof $.working > "u" && ($.working = $(new Nr)), $.working ? $(r) : r instanceof Nr);
    }
    u.isSharedArrayBuffer = He;
    function _n(r) {
      return b(r) === "[object AsyncFunction]";
    }
    u.isAsyncFunction = _n;
    function zn(r) {
      return b(r) === "[object Map Iterator]";
    }
    u.isMapIterator = zn;
    function Vn(r) {
      return b(r) === "[object Set Iterator]";
    }
    u.isSetIterator = Vn;
    function Jn(r) {
      return b(r) === "[object Generator]";
    }
    u.isGeneratorObject = Jn;
    function Ln(r) {
      return b(r) === "[object WebAssembly.Module]";
    }
    u.isWebAssemblyCompiledModule = Ln;
    function Ze(r) {
      return q2(r, jn);
    }
    u.isNumberObject = Ze;
    function Ye(r) {
      return q2(r, Pn);
    }
    u.isStringObject = Ye;
    function Ke(r) {
      return q2(r, wn);
    }
    u.isBooleanObject = Ke;
    function Qe(r) {
      return We && q2(r, ze);
    }
    u.isBigIntObject = Qe;
    function Xe(r) {
      return _e && q2(r, Ve);
    }
    u.isSymbolObject = Xe;
    function Hn(r) {
      return Ze(r) || Ye(r) || Ke(r) || Qe(r) || Xe(r);
    }
    u.isBoxedPrimitive = Hn;
    function Zn(r) {
      return typeof Uint8Array < "u" && (Je(r) || He(r));
    }
    u.isAnyArrayBuffer = Zn;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
      Object.defineProperty(u, r, { enumerable: false, value: function() {
        throw new Error(r + " is not supported in userland");
      } });
    });
  });
  tt = p((Uo, et) => {
    et.exports = function(e) {
      return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
    };
  });
  nt = p((xo, $r) => {
    typeof Object.create == "function" ? $r.exports = function(e, t) {
      t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : $r.exports = function(e, t) {
      if (t) {
        e.super_ = t;
        var n = function() {
        };
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
      }
    };
  });
  yt = p((y2) => {
    var ot = Object.getOwnPropertyDescriptors || function(e) {
      for (var t = Object.keys(e), n = {}, o = 0;o < t.length; o++)
        n[t[o]] = Object.getOwnPropertyDescriptor(e, t[o]);
      return n;
    }, Yn = /%[sdj%]/g;
    y2.format = function(r) {
      if (!lr(r)) {
        for (var e = [], t = 0;t < arguments.length; t++)
          e.push(h2(arguments[t]));
        return e.join(" ");
      }
      for (var t = 1, n = arguments, o = n.length, i = String(r).replace(Yn, function(f2) {
        if (f2 === "%%")
          return "%";
        if (t >= o)
          return f2;
        switch (f2) {
          case "%s":
            return String(n[t++]);
          case "%d":
            return Number(n[t++]);
          case "%j":
            try {
              return JSON.stringify(n[t++]);
            } catch {
              return "[Circular]";
            }
          default:
            return f2;
        }
      }), a = n[t];t < o; a = n[++t])
        pr(a) || !M(a) ? i += " " + a : i += " " + h2(a);
      return i;
    };
    y2.deprecate = function(r, e) {
      if (typeof process < "u" && process.noDeprecation === true)
        return r;
      if (typeof process > "u")
        return function() {
          return y2.deprecate(r, e).apply(this, arguments);
        };
      var t = false;
      function n() {
        if (!t) {
          if (process.throwDeprecation)
            throw new Error(e);
          process.traceDeprecation ? console.trace(e) : console.error(e), t = true;
        }
        return r.apply(this, arguments);
      }
      return n;
    };
    var fr = {}, it = /^$/;
    process.env.NODE_DEBUG && (ur = process.env.NODE_DEBUG, ur = ur.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), it = new RegExp("^" + ur + "$", "i"));
    var ur;
    y2.debuglog = function(r) {
      if (r = r.toUpperCase(), !fr[r])
        if (it.test(r)) {
          var e = process.pid;
          fr[r] = function() {
            var t = y2.format.apply(y2, arguments);
            console.error("%s %d: %s", r, e, t);
          };
        } else
          fr[r] = function() {
          };
      return fr[r];
    };
    function h2(r, e) {
      var t = { seen: [], stylize: Qn };
      return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), _r(e) ? t.showHidden = e : e && y2._extend(t, e), w(t.showHidden) && (t.showHidden = false), w(t.depth) && (t.depth = 2), w(t.colors) && (t.colors = false), w(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Kn), sr(t, r, t.depth);
    }
    y2.inspect = h2;
    h2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    h2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function Kn(r, e) {
      var t = h2.styles[e];
      return t ? "\x1B[" + h2.colors[t][0] + "m" + r + "\x1B[" + h2.colors[t][1] + "m" : r;
    }
    function Qn(r, e) {
      return r;
    }
    function Xn(r) {
      var e = {};
      return r.forEach(function(t, n) {
        e[t] = true;
      }), e;
    }
    function sr(r, e, t) {
      if (r.customInspect && e && yr(e.inspect) && e.inspect !== y2.inspect && !(e.constructor && e.constructor.prototype === e)) {
        var n = e.inspect(t, r);
        return lr(n) || (n = sr(r, n, t)), n;
      }
      var o = ro(r, e);
      if (o)
        return o;
      var i = Object.keys(e), a = Xn(i);
      if (r.showHidden && (i = Object.getOwnPropertyNames(e)), W(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
        return qr(e);
      if (i.length === 0) {
        if (yr(e)) {
          var f2 = e.name ? ": " + e.name : "";
          return r.stylize("[Function" + f2 + "]", "special");
        }
        if (G(e))
          return r.stylize(RegExp.prototype.toString.call(e), "regexp");
        if (cr(e))
          return r.stylize(Date.prototype.toString.call(e), "date");
        if (W(e))
          return qr(e);
      }
      var c = "", l = false, g = ["{", "}"];
      if (at(e) && (l = true, g = ["[", "]"]), yr(e)) {
        var S2 = e.name ? ": " + e.name : "";
        c = " [Function" + S2 + "]";
      }
      if (G(e) && (c = " " + RegExp.prototype.toString.call(e)), cr(e) && (c = " " + Date.prototype.toUTCString.call(e)), W(e) && (c = " " + qr(e)), i.length === 0 && (!l || e.length == 0))
        return g[0] + c + g[1];
      if (t < 0)
        return G(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
      r.seen.push(e);
      var d2;
      return l ? d2 = eo(r, e, t, a, i) : d2 = i.map(function(T2) {
        return Wr(r, e, t, a, T2, l);
      }), r.seen.pop(), to(d2, c, g);
    }
    function ro(r, e) {
      if (w(e))
        return r.stylize("undefined", "undefined");
      if (lr(e)) {
        var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return r.stylize(t, "string");
      }
      if (ft(e))
        return r.stylize("" + e, "number");
      if (_r(e))
        return r.stylize("" + e, "boolean");
      if (pr(e))
        return r.stylize("null", "null");
    }
    function qr(r) {
      return "[" + Error.prototype.toString.call(r) + "]";
    }
    function eo(r, e, t, n, o) {
      for (var i = [], a = 0, f2 = e.length;a < f2; ++a)
        ut(e, String(a)) ? i.push(Wr(r, e, t, n, String(a), true)) : i.push("");
      return o.forEach(function(c) {
        c.match(/^\d+$/) || i.push(Wr(r, e, t, n, c, true));
      }), i;
    }
    function Wr(r, e, t, n, o, i) {
      var a, f2, c;
      if (c = Object.getOwnPropertyDescriptor(e, o) || { value: e[o] }, c.get ? c.set ? f2 = r.stylize("[Getter/Setter]", "special") : f2 = r.stylize("[Getter]", "special") : c.set && (f2 = r.stylize("[Setter]", "special")), ut(n, o) || (a = "[" + o + "]"), f2 || (r.seen.indexOf(c.value) < 0 ? (pr(t) ? f2 = sr(r, c.value, null) : f2 = sr(r, c.value, t - 1), f2.indexOf(`
`) > -1 && (i ? f2 = f2.split(`
`).map(function(l) {
        return "  " + l;
      }).join(`
`).slice(2) : f2 = `
` + f2.split(`
`).map(function(l) {
        return "   " + l;
      }).join(`
`))) : f2 = r.stylize("[Circular]", "special")), w(a)) {
        if (i && o.match(/^\d+$/))
          return f2;
        a = JSON.stringify("" + o), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.slice(1, -1), a = r.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = r.stylize(a, "string"));
      }
      return a + ": " + f2;
    }
    function to(r, e, t) {
      var n = 0, o = r.reduce(function(i, a) {
        return n++, a.indexOf(`
`) >= 0 && n++, i + a.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return o > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
    }
    y2.types = rt();
    function at(r) {
      return Array.isArray(r);
    }
    y2.isArray = at;
    function _r(r) {
      return typeof r == "boolean";
    }
    y2.isBoolean = _r;
    function pr(r) {
      return r === null;
    }
    y2.isNull = pr;
    function no(r) {
      return r == null;
    }
    y2.isNullOrUndefined = no;
    function ft(r) {
      return typeof r == "number";
    }
    y2.isNumber = ft;
    function lr(r) {
      return typeof r == "string";
    }
    y2.isString = lr;
    function oo(r) {
      return typeof r == "symbol";
    }
    y2.isSymbol = oo;
    function w(r) {
      return r === undefined;
    }
    y2.isUndefined = w;
    function G(r) {
      return M(r) && zr(r) === "[object RegExp]";
    }
    y2.isRegExp = G;
    y2.types.isRegExp = G;
    function M(r) {
      return typeof r == "object" && r !== null;
    }
    y2.isObject = M;
    function cr(r) {
      return M(r) && zr(r) === "[object Date]";
    }
    y2.isDate = cr;
    y2.types.isDate = cr;
    function W(r) {
      return M(r) && (zr(r) === "[object Error]" || r instanceof Error);
    }
    y2.isError = W;
    y2.types.isNativeError = W;
    function yr(r) {
      return typeof r == "function";
    }
    y2.isFunction = yr;
    function io(r) {
      return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
    }
    y2.isPrimitive = io;
    y2.isBuffer = tt();
    function zr(r) {
      return Object.prototype.toString.call(r);
    }
    function Gr(r) {
      return r < 10 ? "0" + r.toString(10) : r.toString(10);
    }
    var ao = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function fo() {
      var r = new Date, e = [Gr(r.getHours()), Gr(r.getMinutes()), Gr(r.getSeconds())].join(":");
      return [r.getDate(), ao[r.getMonth()], e].join(" ");
    }
    y2.log = function() {
      console.log("%s - %s", fo(), y2.format.apply(y2, arguments));
    };
    y2.inherits = nt();
    y2._extend = function(r, e) {
      if (!e || !M(e))
        return r;
      for (var t = Object.keys(e), n = t.length;n--; )
        r[t[n]] = e[t[n]];
      return r;
    };
    function ut(r, e) {
      return Object.prototype.hasOwnProperty.call(r, e);
    }
    var P = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
    y2.promisify = function(e) {
      if (typeof e != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (P && e[P]) {
        var t = e[P];
        if (typeof t != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, P, { value: t, enumerable: false, writable: false, configurable: true }), t;
      }
      function t() {
        for (var n, o, i = new Promise(function(c, l) {
          n = c, o = l;
        }), a = [], f2 = 0;f2 < arguments.length; f2++)
          a.push(arguments[f2]);
        a.push(function(c, l) {
          c ? o(c) : n(l);
        });
        try {
          e.apply(this, a);
        } catch (c) {
          o(c);
        }
        return i;
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P && Object.defineProperty(t, P, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, ot(e));
    };
    y2.promisify.custom = P;
    function uo(r, e) {
      if (!r) {
        var t = new Error("Promise was rejected with a falsy value");
        t.reason = r, r = t;
      }
      return e(r);
    }
    function yo(r) {
      if (typeof r != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function e() {
        for (var t = [], n = 0;n < arguments.length; n++)
          t.push(arguments[n]);
        var o = t.pop();
        if (typeof o != "function")
          throw new TypeError("The last argument must be of type Function");
        var i = this, a = function() {
          return o.apply(i, arguments);
        };
        r.apply(this, t).then(function(f2) {
          process.nextTick(a.bind(null, null, f2));
        }, function(f2) {
          process.nextTick(uo.bind(null, f2, a));
        });
      }
      return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, ot(r)), e;
    }
    y2.callbackify = yo;
  });
  E = {};
  At(E, { TextDecoder: () => ct, TextEncoder: () => st, default: () => so });
  F(E, mt(yt()));
  st = globalThis.TextEncoder;
  ct = globalThis.TextDecoder;
  so = { TextEncoder: st, TextDecoder: ct };
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles = {};
  module["exports"] = styles;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// node:os
var exports_os = {};
__export(exports_os, {
  uptime: () => A2,
  type: () => V2,
  totalmem: () => N3,
  tmpdir: () => U,
  release: () => x,
  platform: () => O,
  networkInterfaces: () => j2,
  loadavg: () => y2,
  hostname: () => k,
  homedir: () => _,
  getNetworkInterfaces: () => B,
  freemem: () => I2,
  endianness: () => L,
  default: () => E2,
  cpus: () => b,
  arch: () => M,
  EOL: () => X
});
var c, a, m, s, p2, d2, l = (r, n) => () => (n || r((n = { exports: {} }).exports, n), n.exports), h2 = (r, n, t, i) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let o of s(n))
      !d2.call(r, o) && o !== t && a(r, o, { get: () => n[o], enumerable: !(i = m(n, o)) || i.enumerable });
  return r;
}, g = (r, n, t) => (t = r != null ? c(p2(r)) : {}, h2(n || !r || !r.__esModule ? a(t, "default", { value: r, enumerable: true }) : t, r)), f2, u, E2, L, k, y2, A2, I2, N3, b, V2, x, M, O, U, X, _, j2, B;
var init_os = __esm(() => {
  c = Object.create;
  a = Object.defineProperty;
  m = Object.getOwnPropertyDescriptor;
  s = Object.getOwnPropertyNames;
  p2 = Object.getPrototypeOf;
  d2 = Object.prototype.hasOwnProperty;
  f2 = l((e) => {
    e.endianness = function() {
      return "LE";
    };
    e.hostname = function() {
      return typeof location < "u" ? location.hostname : "";
    };
    e.loadavg = function() {
      return [];
    };
    e.uptime = function() {
      return 0;
    };
    e.freemem = function() {
      return Number.MAX_VALUE;
    };
    e.totalmem = function() {
      return Number.MAX_VALUE;
    };
    e.cpus = function() {
      return [];
    };
    e.type = function() {
      return "Browser";
    };
    e.release = function() {
      return typeof navigator < "u" ? navigator.appVersion : "";
    };
    e.networkInterfaces = e.getNetworkInterfaces = function() {
      return {};
    };
    e.arch = function() {
      return "javascript";
    };
    e.platform = function() {
      return "browser";
    };
    e.tmpdir = e.tmpDir = function() {
      return "/tmp";
    };
    e.EOL = `
`;
    e.homedir = function() {
      return "/";
    };
  });
  u = g(f2());
  E2 = u.default;
  ({ endianness: L, hostname: k, loadavg: y2, uptime: A2, freemem: I2, totalmem: N3, cpus: b, type: V2, release: x, arch: M, platform: O, tmpdir: U, EOL: X, homedir: _, networkInterfaces: j2, getNetworkInterfaces: B } = u.default);
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv || [];
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var os = (init_os(), __toCommonJS(exports_os));
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor = undefined;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env;
      }) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env) {
      var version4 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version4 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "Ą", "Ⱥ", "Ʌ", "Δ", "Λ", "Д"],
      b: ["ß", "Ɓ", "Ƀ", "ɮ", "β", "฿"],
      c: ["©", "Ȼ", "Ͼ"],
      d: ["Ð", "Ɗ", "Ԁ", "ԁ", "Ԃ", "ԃ"],
      e: [
        "Ë",
        "ĕ",
        "Ǝ",
        "ɘ",
        "Σ",
        "ξ",
        "Ҽ",
        "੬"
      ],
      f: ["Ӻ"],
      g: ["ɢ"],
      h: ["Ħ", "ƕ", "Ң", "Һ", "Ӈ", "Ԋ"],
      i: ["༏"],
      j: ["Ĵ"],
      k: ["ĸ", "Ҡ", "Ӄ", "Ԟ"],
      l: ["Ĺ"],
      m: ["ʍ", "Ӎ", "ӎ", "Ԡ", "ԡ", "൩"],
      n: ["Ñ", "ŋ", "Ɲ", "Ͷ", "Π", "Ҋ"],
      o: [
        "Ø",
        "õ",
        "ø",
        "Ǿ",
        "ʘ",
        "Ѻ",
        "ם",
        "۝",
        "๏"
      ],
      p: ["Ƿ", "Ҏ"],
      q: ["্"],
      r: ["®", "Ʀ", "Ȑ", "Ɍ", "ʀ", "Я"],
      s: ["§", "Ϟ", "ϟ", "Ϩ"],
      t: ["Ł", "Ŧ", "ͳ"],
      u: ["Ʊ", "Ս"],
      v: ["ט"],
      w: ["Ш", "Ѡ", "Ѽ", "൰"],
      x: ["Ҳ", "Ӿ", "Ӽ", "ӽ"],
      y: ["¥", "Ұ", "Ӌ"],
      z: ["Ƶ", "ɀ"]
    };
    text.forEach(function(c2) {
      c2 = c2.toLowerCase();
      var chars = trap[c2] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c2] !== "undefined") {
        result += trap[c2][rand];
      } else {
        result += c2;
      }
    });
    return result;
  };
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "̍",
        "̎",
        "̄",
        "̅",
        "̿",
        "̑",
        "̆",
        "̐",
        "͒",
        "͗",
        "͑",
        "̇",
        "̈",
        "̊",
        "͂",
        "̓",
        "̈",
        "͊",
        "͋",
        "͌",
        "̃",
        "̂",
        "̌",
        "͐",
        "̀",
        "́",
        "̋",
        "̏",
        "̒",
        "̓",
        "̔",
        "̽",
        "̉",
        "ͣ",
        "ͤ",
        "ͥ",
        "ͦ",
        "ͧ",
        "ͨ",
        "ͩ",
        "ͪ",
        "ͫ",
        "ͬ",
        "ͭ",
        "ͮ",
        "ͯ",
        "̾",
        "͛",
        "͆",
        "̚"
      ],
      down: [
        "̖",
        "̗",
        "̘",
        "̙",
        "̜",
        "̝",
        "̞",
        "̟",
        "̠",
        "̤",
        "̥",
        "̦",
        "̩",
        "̪",
        "̫",
        "̬",
        "̭",
        "̮",
        "̯",
        "̰",
        "̱",
        "̲",
        "̳",
        "̹",
        "̺",
        "̻",
        "̼",
        "ͅ",
        "͇",
        "͈",
        "͉",
        "͍",
        "͎",
        "͓",
        "͔",
        "͕",
        "͖",
        "͙",
        "͚",
        "̣"
      ],
      mid: [
        "̕",
        "̛",
        "̀",
        "́",
        "͘",
        "̡",
        "̢",
        "̧",
        "̨",
        "̴",
        "̵",
        "̶",
        "͜",
        "͝",
        "͞",
        "͟",
        "͠",
        "͢",
        "̸",
        "̷",
        "͡",
        " ҉"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i) {
        bool = i === character;
      });
      return bool;
    }
    function heComes(text2, options2) {
      var result = "";
      var counts;
      var l2;
      options2 = options2 || {};
      options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
      options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
      options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
      options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
      text2 = text2.split("");
      for (l2 in text2) {
        if (isChar(l2)) {
          continue;
        }
        result = result + text2[l2];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options2.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d3 in arr) {
          var index2 = arr[d3];
          for (var i = 0;i <= counts[index2]; i++) {
            if (options2[index2]) {
              result = result + soul[index2][randomNumber(soul[index2].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options);
  };
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      if (letter === " ")
        return letter;
      switch (i % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i++ % rainbowColors.length]](letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util = (init_util(), __toCommonJS(exports_util));
  var ansiStyles = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles[style];
    if (!styleMap && style in colors) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  function build(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  }
  var styles = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto = defineProps(function colors() {
  }, styles);
  function applyStyle() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util.inspect(arg);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf(`
`) != -1;
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    while (i--) {
      var code = ansiStyles[nestedStyles[i]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  }
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  " + "If you are trying to set a theme from a file, it is now your (the " + "caller's) responsibility to require the file.  The old syntax " + "looked like colors.setTheme(__dirname + " + "'/../themes/generic-logging.js'); The new syntax looks like " + "colors.setTheme(require(__dirname + " + "'/../themes/generic-logging.js'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i in theme[style2]) {
              out = colors[theme[style2][i]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  function init() {
    var ret = {};
    Object.keys(styles).forEach(function(name) {
      ret[name] = {
        get: function() {
          return build([name]);
        }
      };
    });
    return ret;
  }
  var sequencer = function sequencer(map2, str) {
    var exploded = str.split("");
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america()(colors);
  colors.maps.zebra = require_zebra()(colors);
  colors.maps.rainbow = require_rainbow()(colors);
  colors.maps.random = require_random()(colors);
  for (map in colors.maps) {
    (function(map2) {
      colors[map2] = function(str) {
        return sequencer(colors.maps[map2], str);
      };
    })(map);
  }
  var map;
  defineProps(colors, init());
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
  };
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
  };
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS((exports) => {
  exports.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
  };
  exports.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
  };
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "cli", {
    value: require_cli()
  });
  Object.defineProperty(exports, "npm", {
    value: require_npm()
  });
  Object.defineProperty(exports, "syslog", {
    value: require_syslog()
  });
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS((exports) => {
  Object.defineProperty(exports, "LEVEL", {
    value: Symbol.for("level")
  });
  Object.defineProperty(exports, "MESSAGE", {
    value: Symbol.for("message")
  });
  Object.defineProperty(exports, "SPLAT", {
    value: Symbol.for("splat")
  });
  Object.defineProperty(exports, "configs", {
    value: require_config()
  });
});

// node_modules/logform/dist/colorize.js
var require_colorize = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _classCallCheck(a2, n) {
    if (!(a2 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var colors = require_safe();
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var MESSAGE = _require.MESSAGE;
  colors.enabled = true;
  var hasSpace = /\s+/;
  var Colorizer = /* @__PURE__ */ function() {
    function Colorizer2() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Colorizer2);
      if (opts.colors) {
        this.addColors(opts.colors);
      }
      this.options = opts;
    }
    return _createClass(Colorizer2, [{
      key: "addColors",
      value: function addColors(clrs) {
        return Colorizer2.addColors(clrs);
      }
    }, {
      key: "colorize",
      value: function colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(Colorizer2.allColors[lookup])) {
          return colors[Colorizer2.allColors[lookup]](message);
        }
        for (var i = 0, len = Colorizer2.allColors[lookup].length;i < len; i++) {
          message = colors[Colorizer2.allColors[lookup][i]](message);
        }
        return message;
      }
    }, {
      key: "transform",
      value: function transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    }], [{
      key: "addColors",
      value: function addColors(clrs) {
        var nextColors = Object.keys(clrs).reduce(function(acc, level) {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        Colorizer2.allColors = Object.assign({}, Colorizer2.allColors || {}, nextColors);
        return Colorizer2.allColors;
      }
    }]);
  }();
  module.exports = function(opts) {
    return new Colorizer(opts);
  };
  module.exports.Colorizer = module.exports.Format = Colorizer;
});

// node_modules/logform/dist/levels.js
var require_levels = __commonJS((exports, module) => {
  var _require = require_colorize();
  var Colorizer = _require.Colorizer;
  module.exports = function(config) {
    Colorizer.addColors(config.colors || config);
    return config;
  };
});

// node_modules/logform/dist/align.js
var require_align = __commonJS((exports, module) => {
  var format = require_format();
  module.exports = format(function(info) {
    info.message = "\t".concat(info.message);
    return info;
  });
});

// node_modules/logform/dist/pad-levels.js
var require_pad_levels = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _unsupportedIterableToArray(r, a2) {
    if (r) {
      if (typeof r == "string")
        return _arrayLikeToArray(r, a2);
      var t = {}.toString.call(r).slice(8, -1);
      return t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set" ? Array.from(r) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a2) : undefined;
    }
  }
  function _iterableToArray(r) {
    if (typeof Symbol != "undefined" && r[Symbol.iterator] != null || r["@@iterator"] != null)
      return Array.from(r);
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r))
      return _arrayLikeToArray(r);
  }
  function _arrayLikeToArray(r, a2) {
    (a2 == null || a2 > r.length) && (a2 = r.length);
    for (var e = 0, n = Array(a2);e < a2; e++)
      n[e] = r[e];
    return n;
  }
  function _classCallCheck(a2, n) {
    if (!(a2 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var _require = require_triple_beam();
  var configs = _require.configs;
  var LEVEL = _require.LEVEL;
  var MESSAGE = _require.MESSAGE;
  var Padder = /* @__PURE__ */ function() {
    function Padder2() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        levels: configs.npm.levels
      };
      _classCallCheck(this, Padder2);
      this.paddings = Padder2.paddingForLevels(opts.levels, opts.filler);
      this.options = opts;
    }
    return _createClass(Padder2, [{
      key: "transform",
      value: function transform(info, opts) {
        info.message = "".concat(this.paddings[info[LEVEL]]).concat(info.message);
        if (info[MESSAGE]) {
          info[MESSAGE] = "".concat(this.paddings[info[LEVEL]]).concat(info[MESSAGE]);
        }
        return info;
      }
    }], [{
      key: "getLongestLevel",
      value: function getLongestLevel(levels) {
        var lvls = Object.keys(levels).map(function(level) {
          return level.length;
        });
        return Math.max.apply(Math, _toConsumableArray(lvls));
      }
    }, {
      key: "paddingForLevel",
      value: function paddingForLevel(level, filler, maxLength) {
        var targetLen = maxLength + 1 - level.length;
        var rep = Math.floor(targetLen / filler.length);
        var padding = "".concat(filler).concat(filler.repeat(rep));
        return padding.slice(0, targetLen);
      }
    }, {
      key: "paddingForLevels",
      value: function paddingForLevels(levels) {
        var filler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : " ";
        var maxLength = Padder2.getLongestLevel(levels);
        return Object.keys(levels).reduce(function(acc, level) {
          acc[level] = Padder2.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
    }]);
  }();
  module.exports = function(opts) {
    return new Padder(opts);
  };
  module.exports.Padder = module.exports.Format = Padder;
});

// node_modules/logform/dist/cli.js
var require_cli2 = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _classCallCheck(a2, n) {
    if (!(a2 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var _require = require_colorize();
  var Colorizer = _require.Colorizer;
  var _require2 = require_pad_levels();
  var Padder = _require2.Padder;
  var _require3 = require_triple_beam();
  var configs = _require3.configs;
  var MESSAGE = _require3.MESSAGE;
  var CliFormat = /* @__PURE__ */ function() {
    function CliFormat2() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, CliFormat2);
      if (!opts.levels) {
        opts.levels = configs.cli.levels;
      }
      this.colorizer = new Colorizer(opts);
      this.padder = new Padder(opts);
      this.options = opts;
    }
    return _createClass(CliFormat2, [{
      key: "transform",
      value: function transform(info, opts) {
        this.colorizer.transform(this.padder.transform(info, opts), opts);
        info[MESSAGE] = "".concat(info.level, ":").concat(info.message);
        return info;
      }
    }]);
  }();
  module.exports = function(opts) {
    return new CliFormat(opts);
  };
  module.exports.Format = CliFormat;
});

// node_modules/logform/dist/combine.js
var require_combine = __commonJS((exports, module) => {
  var format = require_format();
  function cascade(formats) {
    if (!formats.every(isValidFormat)) {
      return;
    }
    return function(info) {
      var obj = info;
      for (var i = 0;i < formats.length; i++) {
        obj = formats[i].transform(obj, formats[i].options);
        if (!obj) {
          return false;
        }
      }
      return obj;
    };
  }
  function isValidFormat(fmt) {
    if (typeof fmt.transform !== "function") {
      throw new Error(["No transform function found on format. Did you create a format instance?", "const myFormat = format(formatFn);", "const instance = myFormat();"].join(`
`));
    }
    return true;
  }
  module.exports = function() {
    for (var _len = arguments.length, formats = new Array(_len), _key = 0;_key < _len; _key++) {
      formats[_key] = arguments[_key];
    }
    var combinedFormat = format(cascade(formats));
    var instance = combinedFormat();
    instance.Format = combinedFormat.Format;
    return instance;
  };
  module.exports.cascade = cascade;
});

// node_modules/logform/dist/errors.js
var require_errors = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var format = require_format();
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var MESSAGE = _require.MESSAGE;
  module.exports = format(function(einfo, _ref) {
    var { stack, cause } = _ref;
    if (einfo instanceof Error) {
      var info = Object.assign({}, einfo, _defineProperty(_defineProperty(_defineProperty({
        level: einfo.level
      }, LEVEL, einfo[LEVEL] || einfo.level), "message", einfo.message), MESSAGE, einfo[MESSAGE] || einfo.message));
      if (stack)
        info.stack = einfo.stack;
      if (cause)
        info.cause = einfo.cause;
      return info;
    }
    if (!(einfo.message instanceof Error))
      return einfo;
    var err = einfo.message;
    Object.assign(einfo, err);
    einfo.message = err.message;
    einfo[MESSAGE] = err.message;
    if (stack)
      einfo.stack = err.stack;
    if (cause)
      einfo.cause = err.cause;
    return einfo;
  });
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var { hasOwnProperty } = Object.prototype;
  var stringify2 = configure();
  stringify2.configure = configure;
  stringify2.stringify = stringify2;
  stringify2.default = stringify2;
  exports.stringify = stringify2;
  exports.configure = configure;
  module.exports = stringify2;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  function strEscape(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  }
  function sort(array, comparator) {
    if (array.length > 200 || comparator) {
      return array.sort(comparator);
    }
    for (let i = 1;i < array.length; i++) {
      const currentValue = array[i];
      let position = i;
      while (position !== 0 && array[position - 1] > currentValue) {
        array[position] = array[position - 1];
        position--;
      }
      array[position] = currentValue;
    }
    return array;
  }
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
  function isTypedArrayWithEntries(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  }
  function stringifyTypedArray(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
      maximumBreadth = array.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
  }
  function getCircularValueOption(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function getDeterministicOption(options) {
    let value;
    if (hasOwnProperty.call(options, "deterministic")) {
      value = options.deterministic;
      if (typeof value !== "boolean" && typeof value !== "function") {
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      }
    }
    return value === undefined ? true : value;
  }
  function getBooleanOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  }
  function getPositiveIntegerOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  }
  function getItemCount(number) {
    if (number === 1) {
      return "1 item";
    }
    return `${number} items`;
  }
  function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  }
  function getStrictOption(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value = options.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message += ` (${value2.toString()})`;
          throw new Error(message);
        };
      }
    }
  }
  function configure(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getDeterministicOption(options);
    const comparator = typeof deterministic === "function" ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `
${indentation}`;
              join = `,
${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join;
            }
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `
${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join = `,
${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `
${indentation}`;
              join = `,
${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join;
            }
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `
${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join = `,
${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `
${indentation}`;
            const join2 = `,
${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join2;
            }
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `
${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join = `,
${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join;
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join;
          }
          if (separator !== "") {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          const hasLength = value.length !== undefined;
          if (hasLength && Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (hasLength && isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify3(value, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify3;
  }
});

// node_modules/logform/dist/json.js
var require_json = __commonJS((exports, module) => {
  var format = require_format();
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  var stringify2 = require_safe_stable_stringify();
  function replacer(key, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  }
  module.exports = format(function(info, opts) {
    var jsonStringify = stringify2.configure(opts);
    info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
    return info;
  });
});

// node_modules/logform/dist/label.js
var require_label = __commonJS((exports, module) => {
  var format = require_format();
  module.exports = format(function(info, opts) {
    if (opts.message) {
      info.message = "[".concat(opts.label, "] ").concat(info.message);
      return info;
    }
    info.label = opts.label;
    return info;
  });
});

// node_modules/logform/dist/logstash.js
var require_logstash = __commonJS((exports, module) => {
  var format = require_format();
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format(function(info) {
    var logstash = {};
    if (info.message) {
      logstash["@message"] = info.message;
      delete info.message;
    }
    if (info.timestamp) {
      logstash["@timestamp"] = info.timestamp;
      delete info.timestamp;
    }
    logstash["@fields"] = info;
    info[MESSAGE] = jsonStringify(logstash);
    return info;
  });
});

// node_modules/logform/dist/metadata.js
var require_metadata = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var format = require_format();
  function fillExcept(info, fillExceptKeys, metadataKey) {
    var savedKeys = fillExceptKeys.reduce(function(acc, key) {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    var metadata = Object.keys(info).reduce(function(acc, key) {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    Object.assign(info, savedKeys, _defineProperty({}, metadataKey, metadata));
    return info;
  }
  function fillWith(info, fillWithKeys, metadataKey) {
    info[metadataKey] = fillWithKeys.reduce(function(acc, key) {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    return info;
  }
  module.exports = format(function(info) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var metadataKey = "metadata";
    if (opts.key) {
      metadataKey = opts.key;
    }
    var fillExceptKeys = [];
    if (!opts.fillExcept && !opts.fillWith) {
      fillExceptKeys.push("level");
      fillExceptKeys.push("message");
    }
    if (opts.fillExcept) {
      fillExceptKeys = opts.fillExcept;
    }
    if (fillExceptKeys.length > 0) {
      return fillExcept(info, fillExceptKeys, metadataKey);
    }
    if (opts.fillWith) {
      return fillWith(info, opts.fillWith, metadataKey);
    }
    return info;
  });
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s2 = 1000;
  var m2 = s2 * 60;
  var h3 = m2 * 60;
  var d3 = h3 * 24;
  var w = d3 * 7;
  var y3 = d3 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y3;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d3;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h3;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return Math.round(ms / d3) + "d";
    }
    if (msAbs >= h3) {
      return Math.round(ms / h3) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms / s2) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return plural(ms, msAbs, d3, "day");
    }
    if (msAbs >= h3) {
      return plural(ms, msAbs, h3, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms, msAbs, s2, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/logform/dist/ms.js
var require_ms2 = __commonJS((exports, module) => {
  var _this = undefined;
  var format = require_format();
  var ms = require_ms();
  module.exports = format(function(info) {
    var curr = +new Date;
    _this.diff = curr - (_this.prevTime || curr);
    _this.prevTime = curr;
    info.ms = "+".concat(ms(_this.diff));
    return info;
  });
});

// node_modules/logform/dist/pretty-print.js
var require_pretty_print = __commonJS((exports, module) => {
  var inspect = (init_util(), __toCommonJS(exports_util)).inspect;
  var format = require_format();
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var MESSAGE = _require.MESSAGE;
  var SPLAT = _require.SPLAT;
  module.exports = format(function(info) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var stripped = Object.assign({}, info);
    delete stripped[LEVEL];
    delete stripped[MESSAGE];
    delete stripped[SPLAT];
    info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
    return info;
  });
});

// node_modules/logform/dist/printf.js
var require_printf = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _classCallCheck(a2, n) {
    if (!(a2 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  var Printf = /* @__PURE__ */ function() {
    function Printf2(templateFn) {
      _classCallCheck(this, Printf2);
      this.template = templateFn;
    }
    return _createClass(Printf2, [{
      key: "transform",
      value: function transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    }]);
  }();
  module.exports = function(opts) {
    return new Printf(opts);
  };
  module.exports.Printf = module.exports.Format = Printf;
});

// node_modules/logform/dist/simple.js
var require_simple = __commonJS((exports, module) => {
  var format = require_format();
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format(function(info) {
    var stringifiedRest = jsonStringify(Object.assign({}, info, {
      level: undefined,
      message: undefined,
      splat: undefined
    }));
    var padding = info.padding && info.padding[info.level] || "";
    if (stringifiedRest !== "{}") {
      info[MESSAGE] = "".concat(info.level, ":").concat(padding, " ").concat(info.message, " ").concat(stringifiedRest);
    } else {
      info[MESSAGE] = "".concat(info.level, ":").concat(padding, " ").concat(info.message);
    }
    return info;
  });
});

// node_modules/logform/dist/splat.js
var require_splat = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _unsupportedIterableToArray(r, a2) {
    if (r) {
      if (typeof r == "string")
        return _arrayLikeToArray(r, a2);
      var t = {}.toString.call(r).slice(8, -1);
      return t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set" ? Array.from(r) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a2) : undefined;
    }
  }
  function _iterableToArray(r) {
    if (typeof Symbol != "undefined" && r[Symbol.iterator] != null || r["@@iterator"] != null)
      return Array.from(r);
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r))
      return _arrayLikeToArray(r);
  }
  function _arrayLikeToArray(r, a2) {
    (a2 == null || a2 > r.length) && (a2 = r.length);
    for (var e = 0, n = Array(a2);e < a2; e++)
      n[e] = r[e];
    return n;
  }
  function _classCallCheck(a2, n) {
    if (!(a2 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var util = (init_util(), __toCommonJS(exports_util));
  var _require = require_triple_beam();
  var SPLAT = _require.SPLAT;
  var formatRegExp = /%[scdjifoO%]/g;
  var escapedPercent = /%%/g;
  var Splatter = /* @__PURE__ */ function() {
    function Splatter2(opts) {
      _classCallCheck(this, Splatter2);
      this.options = opts;
    }
    return _createClass(Splatter2, [{
      key: "_splat",
      value: function _splat(info, tokens) {
        var msg = info.message;
        var splat = info[SPLAT] || info.splat || [];
        var percents = msg.match(escapedPercent);
        var escapes = percents && percents.length || 0;
        var expectedSplat = tokens.length - escapes;
        var extraSplat = expectedSplat - splat.length;
        var metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        var metalen = metas.length;
        if (metalen) {
          for (var i = 0;i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format.apply(util, [msg].concat(_toConsumableArray(splat)));
        return info;
      }
    }, {
      key: "transform",
      value: function transform(info) {
        var msg = info.message;
        var splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        var tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          var metas = splat.length > 1 ? splat.splice(0) : splat;
          var metalen = metas.length;
          if (metalen) {
            for (var i = 0;i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    }]);
  }();
  module.exports = function(opts) {
    return new Splatter(opts);
  };
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
  })(exports, function(exports2) {
    var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    var twoDigitsOptional = "\\d\\d?";
    var twoDigits = "\\d\\d";
    var threeDigits = "\\d{3}";
    var fourDigits = "\\d{4}";
    var word = "[^\\s]+";
    var literal = /\[([^]*?)\]/gm;
    function shorten2(arr, sLen) {
      var newArr = [];
      for (var i = 0, len = arr.length;i < len; i++) {
        newArr.push(arr[i].substr(0, sLen));
      }
      return newArr;
    }
    var monthUpdate = function(arrName) {
      return function(v2, i18n) {
        var lowerCaseArr = i18n[arrName].map(function(v3) {
          return v3.toLowerCase();
        });
        var index2 = lowerCaseArr.indexOf(v2.toLowerCase());
        if (index2 > -1) {
          return index2;
        }
        return null;
      };
    };
    function assign(origObj) {
      var args = [];
      for (var _i = 1;_i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      for (var _a = 0, args_1 = args;_a < args_1.length; _a++) {
        var obj = args_1[_a];
        for (var key in obj) {
          origObj[key] = obj[key];
        }
      }
      return origObj;
    }
    var dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    var monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthNamesShort = shorten2(monthNames, 3);
    var dayNamesShort = shorten2(dayNames, 3);
    var defaultI18n = {
      dayNamesShort,
      dayNames,
      monthNamesShort,
      monthNames,
      amPm: ["am", "pm"],
      DoFn: function(dayOfMonth) {
        return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
      }
    };
    var globalI18n = assign({}, defaultI18n);
    var setGlobalDateI18n = function(i18n) {
      return globalI18n = assign(globalI18n, i18n);
    };
    var regexEscape = function(str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    };
    var pad3 = function(val, len) {
      if (len === undefined) {
        len = 2;
      }
      val = String(val);
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    };
    var formatFlags = {
      D: function(dateObj) {
        return String(dateObj.getDate());
      },
      DD: function(dateObj) {
        return pad3(dateObj.getDate());
      },
      Do: function(dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
      },
      d: function(dateObj) {
        return String(dateObj.getDay());
      },
      dd: function(dateObj) {
        return pad3(dateObj.getDay());
      },
      ddd: function(dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function(dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
      },
      M: function(dateObj) {
        return String(dateObj.getMonth() + 1);
      },
      MM: function(dateObj) {
        return pad3(dateObj.getMonth() + 1);
      },
      MMM: function(dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function(dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function(dateObj) {
        return pad3(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function(dateObj) {
        return pad3(dateObj.getFullYear(), 4);
      },
      h: function(dateObj) {
        return String(dateObj.getHours() % 12 || 12);
      },
      hh: function(dateObj) {
        return pad3(dateObj.getHours() % 12 || 12);
      },
      H: function(dateObj) {
        return String(dateObj.getHours());
      },
      HH: function(dateObj) {
        return pad3(dateObj.getHours());
      },
      m: function(dateObj) {
        return String(dateObj.getMinutes());
      },
      mm: function(dateObj) {
        return pad3(dateObj.getMinutes());
      },
      s: function(dateObj) {
        return String(dateObj.getSeconds());
      },
      ss: function(dateObj) {
        return pad3(dateObj.getSeconds());
      },
      S: function(dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function(dateObj) {
        return pad3(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function(dateObj) {
        return pad3(dateObj.getMilliseconds(), 3);
      },
      a: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
      },
      ZZ: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad3(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
      },
      Z: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad3(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad3(Math.abs(offset) % 60, 2);
      }
    };
    var monthParse = function(v2) {
      return +v2 - 1;
    };
    var emptyDigits = [null, twoDigitsOptional];
    var emptyWord = [null, word];
    var amPm = [
      "isPm",
      word,
      function(v2, i18n) {
        var val = v2.toLowerCase();
        if (val === i18n.amPm[0]) {
          return 0;
        } else if (val === i18n.amPm[1]) {
          return 1;
        }
        return null;
      }
    ];
    var timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function(v2) {
        var parts = (v2 + "").match(/([+-]|\d\d)/gi);
        if (parts) {
          var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
          return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
      }
    ];
    var parseFlags = {
      D: ["day", twoDigitsOptional],
      DD: ["day", twoDigits],
      Do: ["day", twoDigitsOptional + word, function(v2) {
        return parseInt(v2, 10);
      }],
      M: ["month", twoDigitsOptional, monthParse],
      MM: ["month", twoDigits, monthParse],
      YY: [
        "year",
        twoDigits,
        function(v2) {
          var now = new Date;
          var cent = +("" + now.getFullYear()).substr(0, 2);
          return +("" + (+v2 > 68 ? cent - 1 : cent) + v2);
        }
      ],
      h: ["hour", twoDigitsOptional, undefined, "isPm"],
      hh: ["hour", twoDigits, undefined, "isPm"],
      H: ["hour", twoDigitsOptional],
      HH: ["hour", twoDigits],
      m: ["minute", twoDigitsOptional],
      mm: ["minute", twoDigits],
      s: ["second", twoDigitsOptional],
      ss: ["second", twoDigits],
      YYYY: ["year", fourDigits],
      S: ["millisecond", "\\d", function(v2) {
        return +v2 * 100;
      }],
      SS: ["millisecond", twoDigits, function(v2) {
        return +v2 * 10;
      }],
      SSS: ["millisecond", threeDigits],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: ["month", word, monthUpdate("monthNamesShort")],
      MMMM: ["month", word, monthUpdate("monthNames")],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
    };
    var globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
    };
    var setGlobalDateMasks = function(masks) {
      return assign(globalMasks, masks);
    };
    var format = function(dateObj, mask, i18n) {
      if (mask === undefined) {
        mask = globalMasks["default"];
      }
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      mask = mask.replace(literal, function($0, $1) {
        literals.push($1);
        return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      mask = mask.replace(token, function($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      return mask.replace(/@@@/g, function() {
        return literals.shift();
      });
    };
    function parse(dateStr, format2, i18n) {
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof format2 !== "string") {
        throw new Error("Invalid format in fecha parse");
      }
      format2 = globalMasks[format2] || format2;
      if (dateStr.length > 1000) {
        return null;
      }
      var today = new Date;
      var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
      };
      var parseInfo = [];
      var literals = [];
      var newFormat = format2.replace(literal, function($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
      });
      var specifiedFields = {};
      var requiredFields = {};
      newFormat = regexEscape(newFormat).replace(token, function($0) {
        var info = parseFlags[$0];
        var field2 = info[0], regex = info[1], requiredField = info[3];
        if (specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " specified twice in format");
        }
        specifiedFields[field2] = true;
        if (requiredField) {
          requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex + ")";
      });
      Object.keys(requiredFields).forEach(function(field2) {
        if (!specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " is required in specified format");
        }
      });
      newFormat = newFormat.replace(/@@@/g, function() {
        return literals.shift();
      });
      var matches = dateStr.match(new RegExp(newFormat, "i"));
      if (!matches) {
        return null;
      }
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      for (var i = 1;i < matches.length; i++) {
        var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
        var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
        if (value == null) {
          return null;
        }
        dateInfo[field] = value;
      }
      if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
      } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
      }
      var dateTZ;
      if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
          ["month", "getMonth"],
          ["day", "getDate"],
          ["hour", "getHours"],
          ["minute", "getMinutes"],
          ["second", "getSeconds"]
        ];
        for (var i = 0, len = validateFields.length;i < len; i++) {
          if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
            return null;
          }
        }
      } else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
          return null;
        }
      }
      return dateTZ;
    }
    var fecha = {
      format,
      parse,
      defaultI18n,
      setGlobalDateI18n,
      setGlobalDateMasks
    };
    exports2.assign = assign;
    exports2.default = fecha;
    exports2.format = format;
    exports2.parse = parse;
    exports2.defaultI18n = defaultI18n;
    exports2.setGlobalDateI18n = setGlobalDateI18n;
    exports2.setGlobalDateMasks = setGlobalDateMasks;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/logform/dist/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  var fecha = require_fecha_umd();
  var format = require_format();
  module.exports = format(function(info) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (opts.format) {
      info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date, opts.format);
    }
    if (!info.timestamp) {
      info.timestamp = new Date().toISOString();
    }
    if (opts.alias) {
      info[opts.alias] = info.timestamp;
    }
    return info;
  });
});

// node_modules/logform/dist/uncolorize.js
var require_uncolorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var format = require_format();
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  module.exports = format(function(info, opts) {
    if (opts.level !== false) {
      info.level = colors.strip(info.level);
    }
    if (opts.message !== false) {
      info.message = colors.strip(String(info.message));
    }
    if (opts.raw !== false && info[MESSAGE]) {
      info[MESSAGE] = colors.strip(String(info[MESSAGE]));
    }
    return info;
  });
});

// node_modules/logform/dist/browser.js
var require_browser = __commonJS((exports) => {
  var format = exports.format = require_format();
  exports.levels = require_levels();
  Object.defineProperty(format, "align", {
    value: require_align()
  });
  Object.defineProperty(format, "cli", {
    value: require_cli2()
  });
  Object.defineProperty(format, "colorize", {
    value: require_colorize()
  });
  Object.defineProperty(format, "combine", {
    value: require_combine()
  });
  Object.defineProperty(format, "errors", {
    value: require_errors()
  });
  Object.defineProperty(format, "json", {
    value: require_json()
  });
  Object.defineProperty(format, "label", {
    value: require_label()
  });
  Object.defineProperty(format, "logstash", {
    value: require_logstash()
  });
  Object.defineProperty(format, "metadata", {
    value: require_metadata()
  });
  Object.defineProperty(format, "ms", {
    value: require_ms2()
  });
  Object.defineProperty(format, "padLevels", {
    value: require_pad_levels()
  });
  Object.defineProperty(format, "prettyPrint", {
    value: require_pretty_print()
  });
  Object.defineProperty(format, "printf", {
    value: require_printf()
  });
  Object.defineProperty(format, "simple", {
    value: require_simple()
  });
  Object.defineProperty(format, "splat", {
    value: require_splat()
  });
  Object.defineProperty(format, "timestamp", {
    value: require_timestamp()
  });
  Object.defineProperty(format, "uncolorize", {
    value: require_uncolorize()
  });
});

// node_modules/winston/dist/winston/common.js
var require_common = __commonJS((exports) => {
  var _require = (init_util(), __toCommonJS(exports_util));
  var format = _require.format;
  exports.warn = {
    deprecated: function deprecated(prop) {
      return function() {
        throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
      };
    },
    useFormat: function useFormat(prop) {
      return function() {
        throw new Error([format("{ %s } was removed in winston@3.0.0.", prop), "Use a custom winston.format = winston.format(function) instead."].join(`
`));
      };
    },
    forFunctions: function forFunctions(obj, type, props) {
      props.forEach(function(prop) {
        obj[prop] = exports.warn[type](prop);
      });
    },
    forProperties: function forProperties(obj, type, props) {
      props.forEach(function(prop) {
        var notice = exports.warn[type](prop);
        Object.defineProperty(obj, prop, {
          get: notice,
          set: notice
        });
      });
    }
  };
});

// node_modules/winston/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "winston",
    description: "A logger for just about everything.",
    version: "3.17.0",
    author: "Charlie Robbins <charlie.robbins@gmail.com>",
    maintainers: [
      "David Hyde <dabh@alumni.stanford.edu>"
    ],
    repository: {
      type: "git",
      url: "https://github.com/winstonjs/winston.git"
    },
    keywords: [
      "winston",
      "logger",
      "logging",
      "logs",
      "sysadmin",
      "bunyan",
      "pino",
      "loglevel",
      "tools",
      "json",
      "stream"
    ],
    dependencies: {
      "@dabh/diagnostics": "^2.0.2",
      "@colors/colors": "^1.6.0",
      async: "^3.2.3",
      "is-stream": "^2.0.0",
      logform: "^2.7.0",
      "one-time": "^1.0.0",
      "readable-stream": "^3.4.0",
      "safe-stable-stringify": "^2.3.1",
      "stack-trace": "0.0.x",
      "triple-beam": "^1.3.0",
      "winston-transport": "^4.9.0"
    },
    devDependencies: {
      "@babel/cli": "^7.23.9",
      "@babel/core": "^7.24.0",
      "@babel/preset-env": "^7.24.0",
      "@dabh/eslint-config-populist": "^4.4.0",
      "@types/node": "^20.11.24",
      "abstract-winston-transport": "^0.5.1",
      assume: "^2.2.0",
      "cross-spawn-async": "^2.2.5",
      eslint: "^8.57.0",
      hock: "^1.4.1",
      mocha: "^10.3.0",
      nyc: "^17.1.0",
      rimraf: "5.0.1",
      split2: "^4.1.0",
      "std-mocks": "^2.0.0",
      through2: "^4.0.2",
      "winston-compat": "^0.1.5"
    },
    main: "./lib/winston.js",
    browser: "./dist/winston",
    types: "./index.d.ts",
    scripts: {
      lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
      test: "rimraf test/fixtures/logs/* && mocha",
      "test:coverage": "nyc npm run test:unit",
      "test:unit": "mocha test/unit",
      "test:integration": "mocha test/integration",
      build: "rimraf dist && babel lib -d dist",
      prepublishOnly: "npm run build"
    },
    engines: {
      node: ">= 12.0.0"
    },
    license: "MIT"
  };
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS((exports, module) => {
  module.exports = deprecate;
  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!global.localStorage)
        return false;
    } catch (_2) {
      return false;
    }
    var val = global.localStorage[name];
    if (val == null)
      return false;
    return String(val).toLowerCase() === "true";
  }
});

// node:events
var exports_events = {};
__export(exports_events, {
  prototype: () => P,
  once: () => M2,
  default: () => A3,
  EventEmitter: () => o
});
function x2(t) {
  console && console.warn && console.warn(t);
}
function o() {
  o.init.call(this);
}
function v2(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
function m2(t) {
  return t._maxListeners === undefined ? o.defaultMaxListeners : t._maxListeners;
}
function y3(t, e, n, r) {
  var i, f3, s2;
  if (v2(n), f3 = t._events, f3 === undefined ? (f3 = t._events = Object.create(null), t._eventsCount = 0) : (f3.newListener !== undefined && (t.emit("newListener", e, n.listener ? n.listener : n), f3 = t._events), s2 = f3[e]), s2 === undefined)
    s2 = f3[e] = n, ++t._eventsCount;
  else if (typeof s2 == "function" ? s2 = f3[e] = r ? [n, s2] : [s2, n] : r ? s2.unshift(n) : s2.push(n), i = m2(t), i > 0 && s2.length > i && !s2.warned) {
    s2.warned = true;
    var u2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u2.name = "MaxListenersExceededWarning", u2.emitter = t, u2.type = e, u2.count = s2.length, x2(u2);
  }
  return t;
}
function C2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function g2(t, e, n) {
  var r = { fired: false, wrapFn: undefined, target: t, type: e, listener: n }, i = C2.bind(r);
  return i.listener = n, r.wrapFn = i, i;
}
function _2(t, e, n) {
  var r = t._events;
  if (r === undefined)
    return [];
  var i = r[e];
  return i === undefined ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? R(i) : b2(i, i.length);
}
function w(t) {
  var e = this._events;
  if (e !== undefined) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== undefined)
      return n.length;
  }
  return 0;
}
function b2(t, e) {
  for (var n = new Array(e), r = 0;r < e; ++r)
    n[r] = t[r];
  return n;
}
function j3(t, e) {
  for (;e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function R(t) {
  for (var e = new Array(t.length), n = 0;n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function M2(t, e) {
  return new Promise(function(n, r) {
    function i(s2) {
      t.removeListener(e, f3), r(s2);
    }
    function f3() {
      typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
    }
    E3(t, e, f3, { once: true }), e !== "error" && N4(t, i, { once: true });
  });
}
function N4(t, e, n) {
  typeof t.on == "function" && E3(t, "error", e, n);
}
function E3(t, e, n, r) {
  if (typeof t.on == "function")
    r.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(f3) {
      r.once && t.removeEventListener(e, i), n(f3);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var a2, d3, l2, L2, h3 = 10, A3, P;
var init_events = __esm(() => {
  a2 = typeof Reflect == "object" ? Reflect : null;
  d3 = a2 && typeof a2.apply == "function" ? a2.apply : function(e, n, r) {
    return Function.prototype.apply.call(e, n, r);
  };
  a2 && typeof a2.ownKeys == "function" ? l2 = a2.ownKeys : Object.getOwnPropertySymbols ? l2 = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : l2 = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  L2 = Number.isNaN || function(e) {
    return e !== e;
  };
  o.EventEmitter = o;
  o.prototype._events = undefined;
  o.prototype._eventsCount = 0;
  o.prototype._maxListeners = undefined;
  Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
    return h3;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || L2(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    h3 = t;
  } });
  o.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  o.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || L2(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  o.prototype.getMaxListeners = function() {
    return m2(this);
  };
  o.prototype.emit = function(e) {
    for (var n = [], r = 1;r < arguments.length; r++)
      n.push(arguments[r]);
    var i = e === "error", f3 = this._events;
    if (f3 !== undefined)
      i = i && f3.error === undefined;
    else if (!i)
      return false;
    if (i) {
      var s2;
      if (n.length > 0 && (s2 = n[0]), s2 instanceof Error)
        throw s2;
      var u2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
      throw u2.context = s2, u2;
    }
    var c2 = f3[e];
    if (c2 === undefined)
      return false;
    if (typeof c2 == "function")
      d3(c2, this, n);
    else
      for (var p3 = c2.length, O2 = b2(c2, p3), r = 0;r < p3; ++r)
        d3(O2[r], this, n);
    return true;
  };
  o.prototype.addListener = function(e, n) {
    return y3(this, e, n, false);
  };
  o.prototype.on = o.prototype.addListener;
  o.prototype.prependListener = function(e, n) {
    return y3(this, e, n, true);
  };
  o.prototype.once = function(e, n) {
    return v2(n), this.on(e, g2(this, e, n)), this;
  };
  o.prototype.prependOnceListener = function(e, n) {
    return v2(n), this.prependListener(e, g2(this, e, n)), this;
  };
  o.prototype.removeListener = function(e, n) {
    var r, i, f3, s2, u2;
    if (v2(n), i = this._events, i === undefined)
      return this;
    if (r = i[e], r === undefined)
      return this;
    if (r === n || r.listener === n)
      --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
      for (f3 = -1, s2 = r.length - 1;s2 >= 0; s2--)
        if (r[s2] === n || r[s2].listener === n) {
          u2 = r[s2].listener, f3 = s2;
          break;
        }
      if (f3 < 0)
        return this;
      f3 === 0 ? r.shift() : j3(r, f3), r.length === 1 && (i[e] = r[0]), i.removeListener !== undefined && this.emit("removeListener", e, u2 || n);
    }
    return this;
  };
  o.prototype.off = o.prototype.removeListener;
  o.prototype.removeAllListeners = function(e) {
    var n, r, i;
    if (r = this._events, r === undefined)
      return this;
    if (r.removeListener === undefined)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
      var f3 = Object.keys(r), s2;
      for (i = 0;i < f3.length; ++i)
        s2 = f3[i], s2 !== "removeListener" && this.removeAllListeners(s2);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (n = r[e], typeof n == "function")
      this.removeListener(e, n);
    else if (n !== undefined)
      for (i = n.length - 1;i >= 0; i--)
        this.removeListener(e, n[i]);
    return this;
  };
  o.prototype.listeners = function(e) {
    return _2(this, e, true);
  };
  o.prototype.rawListeners = function(e) {
    return _2(this, e, false);
  };
  o.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : w.call(t, e);
  };
  o.prototype.listenerCount = w;
  o.prototype.eventNames = function() {
    return this._eventsCount > 0 ? l2(this._events) : [];
  };
  A3 = o;
  P = o.prototype;
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS((exports, module) => {
  module.exports = (init_events(), __toCommonJS(exports_events)).EventEmitter;
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  transcode: () => at,
  resolveObjectURL: () => lt2,
  kStringMaxLength: () => K,
  isUtf8: () => pt2,
  isAscii: () => ct2,
  default: () => export_default,
  createObjectURL: () => ft,
  constants: () => st2,
  btoa: () => ht,
  atob: () => ut,
  File: () => ot,
  Buffer: () => export_Buffer,
  Blob: () => nt2
});
function lt2(i) {
  throw new Error("Not implemented");
}
function at(i, r, t) {
  throw new Error("Not implemented");
}
var gr2, $, mr, Ir, Fr2, Ar, P2 = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports), Ur2 = (i, r) => {
  for (var t in r)
    $(i, t, { get: r[t], enumerable: true });
}, D = (i, r, t, e) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n of Ir(r))
      !Ar.call(i, n) && n !== t && $(i, n, { get: () => r[n], enumerable: !(e = mr(r, n)) || e.enumerable });
  return i;
}, x3 = (i, r, t) => (D(i, r, "default"), t && D(t, r, "default")), O2 = (i, r, t) => (t = i != null ? gr2(Fr2(i)) : {}, D(r || !i || !i.__esModule ? $(t, "default", { value: i, enumerable: true }) : t, i)), v3, rr, b3, w2, Br2, Er, K, nt2, ot, ut, ht, ft, ct2 = (i) => ArrayBuffer.isView(i) ? i.every((r) => r < 128) : i.split("").every((r) => r.charCodeAt(0) < 128), pt2 = (i) => {
  throw new Error("Not implemented");
}, st2, export_Buffer, export_default;
var init_buffer = __esm(() => {
  gr2 = Object.create;
  $ = Object.defineProperty;
  mr = Object.getOwnPropertyDescriptor;
  Ir = Object.getOwnPropertyNames;
  Fr2 = Object.getPrototypeOf;
  Ar = Object.prototype.hasOwnProperty;
  v3 = P2((L3) => {
    L3.byteLength = Tr;
    L3.toByteArray = _r;
    L3.fromByteArray = Nr;
    var d4 = [], B2 = [], Rr2 = typeof Uint8Array < "u" ? Uint8Array : Array, G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (F2 = 0, Z = G.length;F2 < Z; ++F2)
      d4[F2] = G[F2], B2[G.charCodeAt(F2)] = F2;
    var F2, Z;
    B2[45] = 62;
    B2[95] = 63;
    function Q2(i) {
      var r = i.length;
      if (r % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var t = i.indexOf("=");
      t === -1 && (t = r);
      var e = t === r ? 0 : 4 - t % 4;
      return [t, e];
    }
    function Tr(i) {
      var r = Q2(i), t = r[0], e = r[1];
      return (t + e) * 3 / 4 - e;
    }
    function Cr(i, r, t) {
      return (r + t) * 3 / 4 - t;
    }
    function _r(i) {
      var r, t = Q2(i), e = t[0], n = t[1], o2 = new Rr2(Cr(i, e, n)), u2 = 0, f3 = n > 0 ? e - 4 : e, c2;
      for (c2 = 0;c2 < f3; c2 += 4)
        r = B2[i.charCodeAt(c2)] << 18 | B2[i.charCodeAt(c2 + 1)] << 12 | B2[i.charCodeAt(c2 + 2)] << 6 | B2[i.charCodeAt(c2 + 3)], o2[u2++] = r >> 16 & 255, o2[u2++] = r >> 8 & 255, o2[u2++] = r & 255;
      return n === 2 && (r = B2[i.charCodeAt(c2)] << 2 | B2[i.charCodeAt(c2 + 1)] >> 4, o2[u2++] = r & 255), n === 1 && (r = B2[i.charCodeAt(c2)] << 10 | B2[i.charCodeAt(c2 + 1)] << 4 | B2[i.charCodeAt(c2 + 2)] >> 2, o2[u2++] = r >> 8 & 255, o2[u2++] = r & 255), o2;
    }
    function Sr(i) {
      return d4[i >> 18 & 63] + d4[i >> 12 & 63] + d4[i >> 6 & 63] + d4[i & 63];
    }
    function Lr(i, r, t) {
      for (var e, n = [], o2 = r;o2 < t; o2 += 3)
        e = (i[o2] << 16 & 16711680) + (i[o2 + 1] << 8 & 65280) + (i[o2 + 2] & 255), n.push(Sr(e));
      return n.join("");
    }
    function Nr(i) {
      for (var r, t = i.length, e = t % 3, n = [], o2 = 16383, u2 = 0, f3 = t - e;u2 < f3; u2 += o2)
        n.push(Lr(i, u2, u2 + o2 > f3 ? f3 : u2 + o2));
      return e === 1 ? (r = i[t - 1], n.push(d4[r >> 2] + d4[r << 4 & 63] + "==")) : e === 2 && (r = (i[t - 2] << 8) + i[t - 1], n.push(d4[r >> 10] + d4[r >> 4 & 63] + d4[r << 2 & 63] + "=")), n.join("");
    }
  });
  rr = P2((Y2) => {
    Y2.read = function(i, r, t, e, n) {
      var o2, u2, f3 = n * 8 - e - 1, c2 = (1 << f3) - 1, l3 = c2 >> 1, s2 = -7, p3 = t ? n - 1 : 0, U2 = t ? -1 : 1, E4 = i[r + p3];
      for (p3 += U2, o2 = E4 & (1 << -s2) - 1, E4 >>= -s2, s2 += f3;s2 > 0; o2 = o2 * 256 + i[r + p3], p3 += U2, s2 -= 8)
        ;
      for (u2 = o2 & (1 << -s2) - 1, o2 >>= -s2, s2 += e;s2 > 0; u2 = u2 * 256 + i[r + p3], p3 += U2, s2 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l3;
      else {
        if (o2 === c2)
          return u2 ? NaN : (E4 ? -1 : 1) * (1 / 0);
        u2 = u2 + Math.pow(2, e), o2 = o2 - l3;
      }
      return (E4 ? -1 : 1) * u2 * Math.pow(2, o2 - e);
    };
    Y2.write = function(i, r, t, e, n, o2) {
      var u2, f3, c2, l3 = o2 * 8 - n - 1, s2 = (1 << l3) - 1, p3 = s2 >> 1, U2 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E4 = e ? 0 : o2 - 1, k2 = e ? 1 : -1, dr2 = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
      for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f3 = isNaN(r) ? 1 : 0, u2 = s2) : (u2 = Math.floor(Math.log(r) / Math.LN2), r * (c2 = Math.pow(2, -u2)) < 1 && (u2--, c2 *= 2), u2 + p3 >= 1 ? r += U2 / c2 : r += U2 * Math.pow(2, 1 - p3), r * c2 >= 2 && (u2++, c2 /= 2), u2 + p3 >= s2 ? (f3 = 0, u2 = s2) : u2 + p3 >= 1 ? (f3 = (r * c2 - 1) * Math.pow(2, n), u2 = u2 + p3) : (f3 = r * Math.pow(2, p3 - 1) * Math.pow(2, n), u2 = 0));n >= 8; i[t + E4] = f3 & 255, E4 += k2, f3 /= 256, n -= 8)
        ;
      for (u2 = u2 << n | f3, l3 += n;l3 > 0; i[t + E4] = u2 & 255, E4 += k2, u2 /= 256, l3 -= 8)
        ;
      i[t + E4 - k2] |= dr2 * 128;
    };
  });
  b3 = P2((_3) => {
    var j4 = v3(), T2 = rr(), tr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _3.Buffer = h4;
    _3.SlowBuffer = Pr;
    _3.INSPECT_MAX_BYTES = 50;
    var N5 = 2147483647;
    _3.kMaxLength = N5;
    h4.TYPED_ARRAY_SUPPORT = Mr();
    !h4.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Mr() {
      try {
        let i = new Uint8Array(1), r = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h4.prototype, "parent", { enumerable: true, get: function() {
      if (!!h4.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h4.prototype, "offset", { enumerable: true, get: function() {
      if (!!h4.isBuffer(this))
        return this.byteOffset;
    } });
    function m3(i) {
      if (i > N5)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
      let r = new Uint8Array(i);
      return Object.setPrototypeOf(r, h4.prototype), r;
    }
    function h4(i, r, t) {
      if (typeof i == "number") {
        if (typeof r == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return X2(i);
      }
      return or(i, r, t);
    }
    h4.poolSize = 8192;
    function or(i, r, t) {
      if (typeof i == "string")
        return kr(i, r);
      if (ArrayBuffer.isView(i))
        return Dr(i);
      if (i == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
      if (g3(i, ArrayBuffer) || i && g3(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (g3(i, SharedArrayBuffer) || i && g3(i.buffer, SharedArrayBuffer)))
        return W(i, r, t);
      if (typeof i == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let e = i.valueOf && i.valueOf();
      if (e != null && e !== i)
        return h4.from(e, r, t);
      let n = $r(i);
      if (n)
        return n;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
        return h4.from(i[Symbol.toPrimitive]("string"), r, t);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h4.from = function(i, r, t) {
      return or(i, r, t);
    };
    Object.setPrototypeOf(h4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h4, Uint8Array);
    function ur(i) {
      if (typeof i != "number")
        throw new TypeError('"size" argument must be of type number');
      if (i < 0)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function br2(i, r, t) {
      return ur(i), i <= 0 ? m3(i) : r !== undefined ? typeof t == "string" ? m3(i).fill(r, t) : m3(i).fill(r) : m3(i);
    }
    h4.alloc = function(i, r, t) {
      return br2(i, r, t);
    };
    function X2(i) {
      return ur(i), m3(i < 0 ? 0 : V3(i) | 0);
    }
    h4.allocUnsafe = function(i) {
      return X2(i);
    };
    h4.allocUnsafeSlow = function(i) {
      return X2(i);
    };
    function kr(i, r) {
      if ((typeof r != "string" || r === "") && (r = "utf8"), !h4.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      let t = hr(i, r) | 0, e = m3(t), n = e.write(i, r);
      return n !== t && (e = e.slice(0, n)), e;
    }
    function q2(i) {
      let r = i.length < 0 ? 0 : V3(i.length) | 0, t = m3(r);
      for (let e = 0;e < r; e += 1)
        t[e] = i[e] & 255;
      return t;
    }
    function Dr(i) {
      if (g3(i, Uint8Array)) {
        let r = new Uint8Array(i);
        return W(r.buffer, r.byteOffset, r.byteLength);
      }
      return q2(i);
    }
    function W(i, r, t) {
      if (r < 0 || i.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (i.byteLength < r + (t || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let e;
      return r === undefined && t === undefined ? e = new Uint8Array(i) : t === undefined ? e = new Uint8Array(i, r) : e = new Uint8Array(i, r, t), Object.setPrototypeOf(e, h4.prototype), e;
    }
    function $r(i) {
      if (h4.isBuffer(i)) {
        let r = V3(i.length) | 0, t = m3(r);
        return t.length === 0 || i.copy(t, 0, 0, r), t;
      }
      if (i.length !== undefined)
        return typeof i.length != "number" || J(i.length) ? m3(0) : q2(i);
      if (i.type === "Buffer" && Array.isArray(i.data))
        return q2(i.data);
    }
    function V3(i) {
      if (i >= N5)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N5.toString(16) + " bytes");
      return i | 0;
    }
    function Pr(i) {
      return +i != i && (i = 0), h4.alloc(+i);
    }
    h4.isBuffer = function(r) {
      return r != null && r._isBuffer === true && r !== h4.prototype;
    };
    h4.compare = function(r, t) {
      if (g3(r, Uint8Array) && (r = h4.from(r, r.offset, r.byteLength)), g3(t, Uint8Array) && (t = h4.from(t, t.offset, t.byteLength)), !h4.isBuffer(r) || !h4.isBuffer(t))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (r === t)
        return 0;
      let e = r.length, n = t.length;
      for (let o2 = 0, u2 = Math.min(e, n);o2 < u2; ++o2)
        if (r[o2] !== t[o2]) {
          e = r[o2], n = t[o2];
          break;
        }
      return e < n ? -1 : n < e ? 1 : 0;
    };
    h4.isEncoding = function(r) {
      switch (String(r).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h4.concat = function(r, t) {
      if (!Array.isArray(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (r.length === 0)
        return h4.alloc(0);
      let e;
      if (t === undefined)
        for (t = 0, e = 0;e < r.length; ++e)
          t += r[e].length;
      let n = h4.allocUnsafe(t), o2 = 0;
      for (e = 0;e < r.length; ++e) {
        let u2 = r[e];
        if (g3(u2, Uint8Array))
          o2 + u2.length > n.length ? (h4.isBuffer(u2) || (u2 = h4.from(u2)), u2.copy(n, o2)) : Uint8Array.prototype.set.call(n, u2, o2);
        else if (h4.isBuffer(u2))
          u2.copy(n, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += u2.length;
      }
      return n;
    };
    function hr(i, r) {
      if (h4.isBuffer(i))
        return i.length;
      if (ArrayBuffer.isView(i) || g3(i, ArrayBuffer))
        return i.byteLength;
      if (typeof i != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
      let t = i.length, e = arguments.length > 2 && arguments[2] === true;
      if (!e && t === 0)
        return 0;
      let n = false;
      for (;; )
        switch (r) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return H2(i).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return xr(i).length;
          default:
            if (n)
              return e ? -1 : H2(i).length;
            r = ("" + r).toLowerCase(), n = true;
        }
    }
    h4.byteLength = hr;
    function Or(i, r, t) {
      let e = false;
      if ((r === undefined || r < 0) && (r = 0), r > this.length || ((t === undefined || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
        return "";
      for (i || (i = "utf8");; )
        switch (i) {
          case "hex":
            return Jr(this, r, t);
          case "utf8":
          case "utf-8":
            return cr(this, r, t);
          case "ascii":
            return Vr(this, r, t);
          case "latin1":
          case "binary":
            return zr(this, r, t);
          case "base64":
            return Hr(this, r, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Kr2(this, r, t);
          default:
            if (e)
              throw new TypeError("Unknown encoding: " + i);
            i = (i + "").toLowerCase(), e = true;
        }
    }
    h4.prototype._isBuffer = true;
    function A4(i, r, t) {
      let e = i[r];
      i[r] = i[t], i[t] = e;
    }
    h4.prototype.swap16 = function() {
      let r = this.length;
      if (r % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t = 0;t < r; t += 2)
        A4(this, t, t + 1);
      return this;
    };
    h4.prototype.swap32 = function() {
      let r = this.length;
      if (r % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t = 0;t < r; t += 4)
        A4(this, t, t + 3), A4(this, t + 1, t + 2);
      return this;
    };
    h4.prototype.swap64 = function() {
      let r = this.length;
      if (r % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0;t < r; t += 8)
        A4(this, t, t + 7), A4(this, t + 1, t + 6), A4(this, t + 2, t + 5), A4(this, t + 3, t + 4);
      return this;
    };
    h4.prototype.toString = function() {
      let r = this.length;
      return r === 0 ? "" : arguments.length === 0 ? cr(this, 0, r) : Or.apply(this, arguments);
    };
    h4.prototype.toLocaleString = h4.prototype.toString;
    h4.prototype.equals = function(r) {
      if (!h4.isBuffer(r))
        throw new TypeError("Argument must be a Buffer");
      return this === r ? true : h4.compare(this, r) === 0;
    };
    h4.prototype.inspect = function() {
      let r = "", t = _3.INSPECT_MAX_BYTES;
      return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    tr && (h4.prototype[tr] = h4.prototype.inspect);
    h4.prototype.compare = function(r, t, e, n, o2) {
      if (g3(r, Uint8Array) && (r = h4.from(r, r.offset, r.byteLength)), !h4.isBuffer(r))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
      if (t === undefined && (t = 0), e === undefined && (e = r ? r.length : 0), n === undefined && (n = 0), o2 === undefined && (o2 = this.length), t < 0 || e > r.length || n < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (n >= o2 && t >= e)
        return 0;
      if (n >= o2)
        return -1;
      if (t >= e)
        return 1;
      if (t >>>= 0, e >>>= 0, n >>>= 0, o2 >>>= 0, this === r)
        return 0;
      let u2 = o2 - n, f3 = e - t, c2 = Math.min(u2, f3), l3 = this.slice(n, o2), s2 = r.slice(t, e);
      for (let p3 = 0;p3 < c2; ++p3)
        if (l3[p3] !== s2[p3]) {
          u2 = l3[p3], f3 = s2[p3];
          break;
        }
      return u2 < f3 ? -1 : f3 < u2 ? 1 : 0;
    };
    function fr(i, r, t, e, n) {
      if (i.length === 0)
        return -1;
      if (typeof t == "string" ? (e = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, J(t) && (t = n ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
        if (n)
          return -1;
        t = i.length - 1;
      } else if (t < 0)
        if (n)
          t = 0;
        else
          return -1;
      if (typeof r == "string" && (r = h4.from(r, e)), h4.isBuffer(r))
        return r.length === 0 ? -1 : ir(i, r, t, e, n);
      if (typeof r == "number")
        return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir(i, [r], t, e, n);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ir(i, r, t, e, n) {
      let o2 = 1, u2 = i.length, f3 = r.length;
      if (e !== undefined && (e = String(e).toLowerCase(), e === "ucs2" || e === "ucs-2" || e === "utf16le" || e === "utf-16le")) {
        if (i.length < 2 || r.length < 2)
          return -1;
        o2 = 2, u2 /= 2, f3 /= 2, t /= 2;
      }
      function c2(s2, p3) {
        return o2 === 1 ? s2[p3] : s2.readUInt16BE(p3 * o2);
      }
      let l3;
      if (n) {
        let s2 = -1;
        for (l3 = t;l3 < u2; l3++)
          if (c2(i, l3) === c2(r, s2 === -1 ? 0 : l3 - s2)) {
            if (s2 === -1 && (s2 = l3), l3 - s2 + 1 === f3)
              return s2 * o2;
          } else
            s2 !== -1 && (l3 -= l3 - s2), s2 = -1;
      } else
        for (t + f3 > u2 && (t = u2 - f3), l3 = t;l3 >= 0; l3--) {
          let s2 = true;
          for (let p3 = 0;p3 < f3; p3++)
            if (c2(i, l3 + p3) !== c2(r, p3)) {
              s2 = false;
              break;
            }
          if (s2)
            return l3;
        }
      return -1;
    }
    h4.prototype.includes = function(r, t, e) {
      return this.indexOf(r, t, e) !== -1;
    };
    h4.prototype.indexOf = function(r, t, e) {
      return fr(this, r, t, e, true);
    };
    h4.prototype.lastIndexOf = function(r, t, e) {
      return fr(this, r, t, e, false);
    };
    function Gr(i, r, t, e) {
      t = Number(t) || 0;
      let n = i.length - t;
      e ? (e = Number(e), e > n && (e = n)) : e = n;
      let o2 = r.length;
      e > o2 / 2 && (e = o2 / 2);
      let u2;
      for (u2 = 0;u2 < e; ++u2) {
        let f3 = parseInt(r.substr(u2 * 2, 2), 16);
        if (J(f3))
          return u2;
        i[t + u2] = f3;
      }
      return u2;
    }
    function Yr(i, r, t, e) {
      return M3(H2(r, i.length - t), i, t, e);
    }
    function jr(i, r, t, e) {
      return M3(rt2(r), i, t, e);
    }
    function qr(i, r, t, e) {
      return M3(xr(r), i, t, e);
    }
    function Wr(i, r, t, e) {
      return M3(tt2(r, i.length - t), i, t, e);
    }
    h4.prototype.write = function(r, t, e, n) {
      if (t === undefined)
        n = "utf8", e = this.length, t = 0;
      else if (e === undefined && typeof t == "string")
        n = t, e = this.length, t = 0;
      else if (isFinite(t))
        t = t >>> 0, isFinite(e) ? (e = e >>> 0, n === undefined && (n = "utf8")) : (n = e, e = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - t;
      if ((e === undefined || e > o2) && (e = o2), r.length > 0 && (e < 0 || t < 0) || t > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      let u2 = false;
      for (;; )
        switch (n) {
          case "hex":
            return Gr(this, r, t, e);
          case "utf8":
          case "utf-8":
            return Yr(this, r, t, e);
          case "ascii":
          case "latin1":
          case "binary":
            return jr(this, r, t, e);
          case "base64":
            return qr(this, r, t, e);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Wr(this, r, t, e);
          default:
            if (u2)
              throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), u2 = true;
        }
    };
    h4.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Hr(i, r, t) {
      return r === 0 && t === i.length ? j4.fromByteArray(i) : j4.fromByteArray(i.slice(r, t));
    }
    function cr(i, r, t) {
      t = Math.min(i.length, t);
      let e = [], n = r;
      for (;n < t; ) {
        let o2 = i[n], u2 = null, f3 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (n + f3 <= t) {
          let c2, l3, s2, p3;
          switch (f3) {
            case 1:
              o2 < 128 && (u2 = o2);
              break;
            case 2:
              c2 = i[n + 1], (c2 & 192) === 128 && (p3 = (o2 & 31) << 6 | c2 & 63, p3 > 127 && (u2 = p3));
              break;
            case 3:
              c2 = i[n + 1], l3 = i[n + 2], (c2 & 192) === 128 && (l3 & 192) === 128 && (p3 = (o2 & 15) << 12 | (c2 & 63) << 6 | l3 & 63, p3 > 2047 && (p3 < 55296 || p3 > 57343) && (u2 = p3));
              break;
            case 4:
              c2 = i[n + 1], l3 = i[n + 2], s2 = i[n + 3], (c2 & 192) === 128 && (l3 & 192) === 128 && (s2 & 192) === 128 && (p3 = (o2 & 15) << 18 | (c2 & 63) << 12 | (l3 & 63) << 6 | s2 & 63, p3 > 65535 && p3 < 1114112 && (u2 = p3));
          }
        }
        u2 === null ? (u2 = 65533, f3 = 1) : u2 > 65535 && (u2 -= 65536, e.push(u2 >>> 10 & 1023 | 55296), u2 = 56320 | u2 & 1023), e.push(u2), n += f3;
      }
      return Xr(e);
    }
    var er = 4096;
    function Xr(i) {
      let r = i.length;
      if (r <= er)
        return String.fromCharCode.apply(String, i);
      let t = "", e = 0;
      for (;e < r; )
        t += String.fromCharCode.apply(String, i.slice(e, e += er));
      return t;
    }
    function Vr(i, r, t) {
      let e = "";
      t = Math.min(i.length, t);
      for (let n = r;n < t; ++n)
        e += String.fromCharCode(i[n] & 127);
      return e;
    }
    function zr(i, r, t) {
      let e = "";
      t = Math.min(i.length, t);
      for (let n = r;n < t; ++n)
        e += String.fromCharCode(i[n]);
      return e;
    }
    function Jr(i, r, t) {
      let e = i.length;
      (!r || r < 0) && (r = 0), (!t || t < 0 || t > e) && (t = e);
      let n = "";
      for (let o2 = r;o2 < t; ++o2)
        n += it[i[o2]];
      return n;
    }
    function Kr2(i, r, t) {
      let e = i.slice(r, t), n = "";
      for (let o2 = 0;o2 < e.length - 1; o2 += 2)
        n += String.fromCharCode(e[o2] + e[o2 + 1] * 256);
      return n;
    }
    h4.prototype.slice = function(r, t) {
      let e = this.length;
      r = ~~r, t = t === undefined ? e : ~~t, r < 0 ? (r += e, r < 0 && (r = 0)) : r > e && (r = e), t < 0 ? (t += e, t < 0 && (t = 0)) : t > e && (t = e), t < r && (t = r);
      let n = this.subarray(r, t);
      return Object.setPrototypeOf(n, h4.prototype), n;
    };
    function a3(i, r, t) {
      if (i % 1 !== 0 || i < 0)
        throw new RangeError("offset is not uint");
      if (i + r > t)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h4.prototype.readUintLE = h4.prototype.readUIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = this[r], o2 = 1, u2 = 0;
      for (;++u2 < t && (o2 *= 256); )
        n += this[r + u2] * o2;
      return n;
    };
    h4.prototype.readUintBE = h4.prototype.readUIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = this[r + --t], o2 = 1;
      for (;t > 0 && (o2 *= 256); )
        n += this[r + --t] * o2;
      return n;
    };
    h4.prototype.readUint8 = h4.prototype.readUInt8 = function(r, t) {
      return r = r >>> 0, t || a3(r, 1, this.length), this[r];
    };
    h4.prototype.readUint16LE = h4.prototype.readUInt16LE = function(r, t) {
      return r = r >>> 0, t || a3(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h4.prototype.readUint16BE = h4.prototype.readUInt16BE = function(r, t) {
      return r = r >>> 0, t || a3(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h4.prototype.readUint32LE = h4.prototype.readUInt32LE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h4.prototype.readUint32BE = h4.prototype.readUInt32BE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h4.prototype.readBigUInt64LE = I3(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o2 = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + e * 2 ** 24;
      return BigInt(n) + (BigInt(o2) << BigInt(32));
    });
    h4.prototype.readBigUInt64BE = I3(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o2 = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e;
      return (BigInt(n) << BigInt(32)) + BigInt(o2);
    });
    h4.prototype.readIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = this[r], o2 = 1, u2 = 0;
      for (;++u2 < t && (o2 *= 256); )
        n += this[r + u2] * o2;
      return o2 *= 128, n >= o2 && (n -= Math.pow(2, 8 * t)), n;
    };
    h4.prototype.readIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = t, o2 = 1, u2 = this[r + --n];
      for (;n > 0 && (o2 *= 256); )
        u2 += this[r + --n] * o2;
      return o2 *= 128, u2 >= o2 && (u2 -= Math.pow(2, 8 * t)), u2;
    };
    h4.prototype.readInt8 = function(r, t) {
      return r = r >>> 0, t || a3(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h4.prototype.readInt16LE = function(r, t) {
      r = r >>> 0, t || a3(r, 2, this.length);
      let e = this[r] | this[r + 1] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h4.prototype.readInt16BE = function(r, t) {
      r = r >>> 0, t || a3(r, 2, this.length);
      let e = this[r + 1] | this[r] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h4.prototype.readInt32LE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h4.prototype.readInt32BE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h4.prototype.readBigInt64LE = I3(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (e << 24);
      return (BigInt(n) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h4.prototype.readBigInt64BE = I3(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
      return (BigInt(n) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e);
    });
    h4.prototype.readFloatLE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), T2.read(this, r, true, 23, 4);
    };
    h4.prototype.readFloatBE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), T2.read(this, r, false, 23, 4);
    };
    h4.prototype.readDoubleLE = function(r, t) {
      return r = r >>> 0, t || a3(r, 8, this.length), T2.read(this, r, true, 52, 8);
    };
    h4.prototype.readDoubleBE = function(r, t) {
      return r = r >>> 0, t || a3(r, 8, this.length), T2.read(this, r, false, 52, 8);
    };
    function y4(i, r, t, e, n, o2) {
      if (!h4.isBuffer(i))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > n || r < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (t + e > i.length)
        throw new RangeError("Index out of range");
    }
    h4.prototype.writeUintLE = h4.prototype.writeUIntLE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n) {
        let f3 = Math.pow(2, 8 * e) - 1;
        y4(this, r, t, e, f3, 0);
      }
      let o2 = 1, u2 = 0;
      for (this[t] = r & 255;++u2 < e && (o2 *= 256); )
        this[t + u2] = r / o2 & 255;
      return t + e;
    };
    h4.prototype.writeUintBE = h4.prototype.writeUIntBE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n) {
        let f3 = Math.pow(2, 8 * e) - 1;
        y4(this, r, t, e, f3, 0);
      }
      let o2 = e - 1, u2 = 1;
      for (this[t + o2] = r & 255;--o2 >= 0 && (u2 *= 256); )
        this[t + o2] = r / u2 & 255;
      return t + e;
    };
    h4.prototype.writeUint8 = h4.prototype.writeUInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h4.prototype.writeUint16LE = h4.prototype.writeUInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h4.prototype.writeUint16BE = h4.prototype.writeUInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h4.prototype.writeUint32LE = h4.prototype.writeUInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h4.prototype.writeUint32BE = h4.prototype.writeUInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function pr(i, r, t, e, n) {
      wr(r, e, n, i, t, 7);
      let o2 = Number(r & BigInt(4294967295));
      i[t++] = o2, o2 = o2 >> 8, i[t++] = o2, o2 = o2 >> 8, i[t++] = o2, o2 = o2 >> 8, i[t++] = o2;
      let u2 = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t++] = u2, u2 = u2 >> 8, i[t++] = u2, u2 = u2 >> 8, i[t++] = u2, u2 = u2 >> 8, i[t++] = u2, t;
    }
    function sr(i, r, t, e, n) {
      wr(r, e, n, i, t, 7);
      let o2 = Number(r & BigInt(4294967295));
      i[t + 7] = o2, o2 = o2 >> 8, i[t + 6] = o2, o2 = o2 >> 8, i[t + 5] = o2, o2 = o2 >> 8, i[t + 4] = o2;
      let u2 = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t + 3] = u2, u2 = u2 >> 8, i[t + 2] = u2, u2 = u2 >> 8, i[t + 1] = u2, u2 = u2 >> 8, i[t] = u2, t + 8;
    }
    h4.prototype.writeBigUInt64LE = I3(function(r, t = 0) {
      return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h4.prototype.writeBigUInt64BE = I3(function(r, t = 0) {
      return sr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h4.prototype.writeIntLE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, !n) {
        let c2 = Math.pow(2, 8 * e - 1);
        y4(this, r, t, e, c2 - 1, -c2);
      }
      let o2 = 0, u2 = 1, f3 = 0;
      for (this[t] = r & 255;++o2 < e && (u2 *= 256); )
        r < 0 && f3 === 0 && this[t + o2 - 1] !== 0 && (f3 = 1), this[t + o2] = (r / u2 >> 0) - f3 & 255;
      return t + e;
    };
    h4.prototype.writeIntBE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, !n) {
        let c2 = Math.pow(2, 8 * e - 1);
        y4(this, r, t, e, c2 - 1, -c2);
      }
      let o2 = e - 1, u2 = 1, f3 = 0;
      for (this[t + o2] = r & 255;--o2 >= 0 && (u2 *= 256); )
        r < 0 && f3 === 0 && this[t + o2 + 1] !== 0 && (f3 = 1), this[t + o2] = (r / u2 >> 0) - f3 & 255;
      return t + e;
    };
    h4.prototype.writeInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h4.prototype.writeInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h4.prototype.writeInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h4.prototype.writeInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h4.prototype.writeInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y4(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h4.prototype.writeBigInt64LE = I3(function(r, t = 0) {
      return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h4.prototype.writeBigInt64BE = I3(function(r, t = 0) {
      return sr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function lr(i, r, t, e, n, o2) {
      if (t + e > i.length)
        throw new RangeError("Index out of range");
      if (t < 0)
        throw new RangeError("Index out of range");
    }
    function ar(i, r, t, e, n) {
      return r = +r, t = t >>> 0, n || lr(i, r, t, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T2.write(i, r, t, e, 23, 4), t + 4;
    }
    h4.prototype.writeFloatLE = function(r, t, e) {
      return ar(this, r, t, true, e);
    };
    h4.prototype.writeFloatBE = function(r, t, e) {
      return ar(this, r, t, false, e);
    };
    function yr(i, r, t, e, n) {
      return r = +r, t = t >>> 0, n || lr(i, r, t, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T2.write(i, r, t, e, 52, 8), t + 8;
    }
    h4.prototype.writeDoubleLE = function(r, t, e) {
      return yr(this, r, t, true, e);
    };
    h4.prototype.writeDoubleBE = function(r, t, e) {
      return yr(this, r, t, false, e);
    };
    h4.prototype.copy = function(r, t, e, n) {
      if (!h4.isBuffer(r))
        throw new TypeError("argument should be a Buffer");
      if (e || (e = 0), !n && n !== 0 && (n = this.length), t >= r.length && (t = r.length), t || (t = 0), n > 0 && n < e && (n = e), n === e || r.length === 0 || this.length === 0)
        return 0;
      if (t < 0)
        throw new RangeError("targetStart out of bounds");
      if (e < 0 || e >= this.length)
        throw new RangeError("Index out of range");
      if (n < 0)
        throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), r.length - t < n - e && (n = r.length - t + e);
      let o2 = n - e;
      return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e, n) : Uint8Array.prototype.set.call(r, this.subarray(e, n), t), o2;
    };
    h4.prototype.fill = function(r, t, e, n) {
      if (typeof r == "string") {
        if (typeof t == "string" ? (n = t, t = 0, e = this.length) : typeof e == "string" && (n = e, e = this.length), n !== undefined && typeof n != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n == "string" && !h4.isEncoding(n))
          throw new TypeError("Unknown encoding: " + n);
        if (r.length === 1) {
          let u2 = r.charCodeAt(0);
          (n === "utf8" && u2 < 128 || n === "latin1") && (r = u2);
        }
      } else
        typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
      if (t < 0 || this.length < t || this.length < e)
        throw new RangeError("Out of range index");
      if (e <= t)
        return this;
      t = t >>> 0, e = e === undefined ? this.length : e >>> 0, r || (r = 0);
      let o2;
      if (typeof r == "number")
        for (o2 = t;o2 < e; ++o2)
          this[o2] = r;
      else {
        let u2 = h4.isBuffer(r) ? r : h4.from(r, n), f3 = u2.length;
        if (f3 === 0)
          throw new TypeError('The value "' + r + '" is invalid for argument "value"');
        for (o2 = 0;o2 < e - t; ++o2)
          this[o2 + t] = u2[o2 % f3];
      }
      return this;
    };
    var R2 = {};
    function z(i, r, t) {
      R2[i] = class extends t {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
        }
        get code() {
          return i;
        }
        set code(n) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
        }
        toString() {
          return `${this.name} [${i}]: ${this.message}`;
        }
      };
    }
    z("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    z("ERR_INVALID_ARG_TYPE", function(i, r) {
      return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    z("ERR_OUT_OF_RANGE", function(i, r, t) {
      let e = `The value of "${i}" is out of range.`, n = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n = nr(String(t)) : typeof t == "bigint" && (n = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n = nr(n)), n += "n"), e += ` It must be ${r}. Received ${n}`, e;
    }, RangeError);
    function nr(i) {
      let r = "", t = i.length, e = i[0] === "-" ? 1 : 0;
      for (;t >= e + 4; t -= 3)
        r = `_${i.slice(t - 3, t)}${r}`;
      return `${i.slice(0, t)}${r}`;
    }
    function Zr2(i, r, t) {
      C3(r, "offset"), (i[r] === undefined || i[r + t] === undefined) && S2(r, i.length - (t + 1));
    }
    function wr(i, r, t, e, n, o2) {
      if (i > t || i < r) {
        let u2 = typeof r == "bigint" ? "n" : "", f3;
        throw o2 > 3 ? r === 0 || r === BigInt(0) ? f3 = `>= 0${u2} and < 2${u2} ** ${(o2 + 1) * 8}${u2}` : f3 = `>= -(2${u2} ** ${(o2 + 1) * 8 - 1}${u2}) and < 2 ** ${(o2 + 1) * 8 - 1}${u2}` : f3 = `>= ${r}${u2} and <= ${t}${u2}`, new R2.ERR_OUT_OF_RANGE("value", f3, i);
      }
      Zr2(e, n, o2);
    }
    function C3(i, r) {
      if (typeof i != "number")
        throw new R2.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function S2(i, r, t) {
      throw Math.floor(i) !== i ? (C3(i, t), new R2.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new R2.ERR_BUFFER_OUT_OF_BOUNDS : new R2.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Qr = /[^+/0-9A-Za-z-_]/g;
    function vr(i) {
      if (i = i.split("=")[0], i = i.trim().replace(Qr, ""), i.length < 2)
        return "";
      for (;i.length % 4 !== 0; )
        i = i + "=";
      return i;
    }
    function H2(i, r) {
      r = r || 1 / 0;
      let t, e = i.length, n = null, o2 = [];
      for (let u2 = 0;u2 < e; ++u2) {
        if (t = i.charCodeAt(u2), t > 55295 && t < 57344) {
          if (!n) {
            if (t > 56319) {
              (r -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (u2 + 1 === e) {
              (r -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            n = t;
            continue;
          }
          if (t < 56320) {
            (r -= 3) > -1 && o2.push(239, 191, 189), n = t;
            continue;
          }
          t = (n - 55296 << 10 | t - 56320) + 65536;
        } else
          n && (r -= 3) > -1 && o2.push(239, 191, 189);
        if (n = null, t < 128) {
          if ((r -= 1) < 0)
            break;
          o2.push(t);
        } else if (t < 2048) {
          if ((r -= 2) < 0)
            break;
          o2.push(t >> 6 | 192, t & 63 | 128);
        } else if (t < 65536) {
          if ((r -= 3) < 0)
            break;
          o2.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
        } else if (t < 1114112) {
          if ((r -= 4) < 0)
            break;
          o2.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function rt2(i) {
      let r = [];
      for (let t = 0;t < i.length; ++t)
        r.push(i.charCodeAt(t) & 255);
      return r;
    }
    function tt2(i, r) {
      let t, e, n, o2 = [];
      for (let u2 = 0;u2 < i.length && !((r -= 2) < 0); ++u2)
        t = i.charCodeAt(u2), e = t >> 8, n = t % 256, o2.push(n), o2.push(e);
      return o2;
    }
    function xr(i) {
      return j4.toByteArray(vr(i));
    }
    function M3(i, r, t, e) {
      let n;
      for (n = 0;n < e && !(n + t >= r.length || n >= i.length); ++n)
        r[n + t] = i[n];
      return n;
    }
    function g3(i, r) {
      return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function J(i) {
      return i !== i;
    }
    var it = function() {
      let i = "0123456789abcdef", r = new Array(256);
      for (let t = 0;t < 16; ++t) {
        let e = t * 16;
        for (let n = 0;n < 16; ++n)
          r[e + n] = i[t] + i[n];
      }
      return r;
    }();
    function I3(i) {
      return typeof BigInt > "u" ? et : i;
    }
    function et() {
      throw new Error("BigInt not supported");
    }
  });
  w2 = {};
  Ur2(w2, { Blob: () => nt2, Buffer: () => Er.Buffer, File: () => ot, atob: () => ut, btoa: () => ht, constants: () => st2, createObjectURL: () => ft, default: () => Br2.Buffer, isAscii: () => ct2, isUtf8: () => pt2, kStringMaxLength: () => K, resolveObjectURL: () => lt2, transcode: () => at });
  x3(w2, O2(b3()));
  Br2 = O2(b3());
  Er = O2(b3());
  K = 2 ** 32 - 1;
  ({ Blob: nt2, File: ot, atob: ut, btoa: ht } = globalThis);
  ({ createObjectURL: ft } = URL);
  st2 = { __proto__: null, MAX_LENGTH: K, MAX_STRING_LENGTH: K, BYTES_PER_ELEMENT: 1 };
  export_Buffer = Er.Buffer;
  export_default = Br2.Buffer;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS((exports, module) => {
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = (init_buffer(), __toCommonJS(exports_buffer));
  var Buffer2 = _require.Buffer;
  var _require2 = (init_util(), __toCommonJS(exports_util));
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v4) {
        var entry = {
          data: v4,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v4) {
        var entry = {
          data: v4,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0)
          return "";
        var p3 = this.head;
        var ret = "" + p3.data;
        while (p3 = p3.next)
          ret += s2 + p3.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p3 = this.head;
        var i = 0;
        while (p3) {
          copyBuffer(p3.data, ret, i);
          i += p3.data.length;
          p3 = p3.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p3 = this.head;
        var c2 = 1;
        var ret = p3.data;
        n -= ret.length;
        while (p3 = p3.next) {
          var str = p3.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p3 = this.head;
        var c2 = 1;
        p3.data.copy(ret);
        n -= p3.data.length;
        while (p3 = p3.next) {
          var buf = p3.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p3.next)
                this.head = p3.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p3;
              p3.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_3, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer2 = (init_buffer(), __toCommonJS(exports_buffer));
  var Buffer2 = buffer2.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size4, fill, encoding) {
    if (typeof size4 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size4);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size4) {
    if (typeof size4 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size4);
  };
  SafeBuffer.allocUnsafeSlow = function(size4) {
    if (typeof size4 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size4);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j4 = buf.length - 1;
    if (j4 < i)
      return 0;
    var nb = utf8CheckByte(buf[j4]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j4 < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j4]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j4 < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j4]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p3) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p3 = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p3);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p3, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p3, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS((exports, module) => {
  module.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = (init_events(), __toCommonJS(exports_events)).EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream_browser();
  var Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = (init_util(), __toCommonJS(exports_util));
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors_browser().codes;
  var ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p3 = this._readableState.buffer.head;
    var content = "";
    while (p3 !== null) {
      content += decoder.write(p3.data);
      p3 = p3.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index2 = indexOf(state.pipes, dest);
    if (index2 === -1)
      return this;
    state.pipes.splice(index2, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from_browser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x4) {
    for (var i = 0, l3 = xs.length;i < l3; i++) {
      if (xs[i] === x4)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  require_inherits_browser()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v4 = 0;v4 < keys.length; v4++) {
      method = keys[v4];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v4;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_browser2()
  };
  var Stream = require_stream_browser();
  var Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors_browser().codes;
  var ERR_INVALID_ARG_TYPE2 = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_3) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l3 = state.bufferedRequestCount;
      var buffer2 = new Array(l3);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/winston-transport/dist/modern.js
var require_modern = __commonJS((exports, module) => {
  var util = (init_util(), __toCommonJS(exports_util));
  var Writable = require__stream_writable();
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var TransportStream = module.exports = function TransportStream() {
    var _this = this;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log)
      this.log = options.log;
    if (options.logv)
      this.logv = options.logv;
    if (options.close)
      this.close = options.close;
    this.once("pipe", function(logger) {
      _this.levels = logger.levels;
      _this.parent = logger;
    });
    this.once("unpipe", function(src) {
      if (src === _this.parent) {
        _this.parent = null;
        if (_this.close) {
          _this.close();
        }
      }
    });
  };
  util.inherits(TransportStream, Writable);
  TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    var level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (info && !this.format) {
        return this.log(info, callback);
      }
      var errState = undefined;
      var transformed = undefined;
      try {
        transformed = this.format.transform(Object.assign({}, info), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        callback();
        if (errState)
          throw errState;
        return;
      }
      return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
  };
  TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
      var infos = chunks.filter(this._accept, this);
      if (!infos.length) {
        return callback(null);
      }
      return this.logv(infos, callback);
    }
    for (var i = 0;i < chunks.length; i++) {
      if (!this._accept(chunks[i]))
        continue;
      if (chunks[i].chunk && !this.format) {
        this.log(chunks[i].chunk, chunks[i].callback);
        continue;
      }
      var errState = undefined;
      var transformed = undefined;
      try {
        transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        chunks[i].callback();
        if (errState) {
          callback(null);
          throw errState;
        }
      } else {
        this.log(transformed, chunks[i].callback);
      }
    }
    return callback(null);
  };
  TransportStream.prototype._accept = function _accept(write) {
    var info = write.chunk;
    if (this.silent) {
      return false;
    }
    var level = this.level || this.parent && this.parent.level;
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (this.handleExceptions || info.exception !== true) {
        return true;
      }
    }
    return false;
  };
  TransportStream.prototype._nop = function _nop() {
    return;
  };
});

// node_modules/winston-transport/dist/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var util = (init_util(), __toCommonJS(exports_util));
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var TransportStream = require_modern();
  var LegacyTransportStream = module.exports = function LegacyTransportStream() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
      throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    this._deprecated();
    function transportError(err) {
      this.emit("error", err, this.transport);
    }
    if (!this.transport.__winstonError) {
      this.transport.__winstonError = transportError.bind(this);
      this.transport.on("error", this.transport.__winstonError);
    }
  };
  util.inherits(LegacyTransportStream, TransportStream);
  LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
      this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
  };
  LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for (var i = 0;i < chunks.length; i++) {
      if (this._accept(chunks[i])) {
        this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
        chunks[i].callback();
      }
    }
    return callback(null);
  };
  LegacyTransportStream.prototype._deprecated = function _deprecated() {
    console.error([this.transport.name + " is a legacy winston transport. Consider upgrading: ", "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"].join(`
`));
  };
  LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
      this.transport.close();
    }
    if (this.transport.__winstonError) {
      this.transport.removeListener("error", this.transport.__winstonError);
      this.transport.__winstonError = null;
    }
  };
});

// node_modules/winston-transport/dist/index.js
var require_dist = __commonJS((exports, module) => {
  module.exports = require_modern();
  module.exports.LegacyTransportStream = require_legacy();
});

// node_modules/winston/dist/winston/transports/console.js
var require_console = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var os = (init_os(), __toCommonJS(exports_os));
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var MESSAGE = _require.MESSAGE;
  var TransportStream = require_dist();
  module.exports = /* @__PURE__ */ function(_TransportStream) {
    function Console() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Console);
      _this = _callSuper(this, Console, [options]);
      _this.name = options.name || "console";
      _this.stderrLevels = _this._stringArrayToSet(options.stderrLevels);
      _this.consoleWarnLevels = _this._stringArrayToSet(options.consoleWarnLevels);
      _this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      _this.forceConsole = options.forceConsole || false;
      _this._consoleLog = console.log.bind(console);
      _this._consoleWarn = console.warn.bind(console);
      _this._consoleError = console.error.bind(console);
      _this.setMaxListeners(30);
      return _this;
    }
    _inherits(Console, _TransportStream);
    return _createClass(Console, [{
      key: "log",
      value: function log(info, callback) {
        var _this2 = this;
        setImmediate(function() {
          return _this2.emit("logged", info);
        });
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write("".concat(info[MESSAGE]).concat(this.eol));
          } else {
            this._consoleError(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write("".concat(info[MESSAGE]).concat(this.eol));
          } else {
            this._consoleWarn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout && !this.forceConsole) {
          console._stdout.write("".concat(info[MESSAGE]).concat(this.eol));
        } else {
          this._consoleLog(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
    }, {
      key: "_stringArrayToSet",
      value: function _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce(function(set, el) {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    }]);
  }(TransportStream);
});

// node:path
var exports_path = {};
__export(exports_path, {
  win32: () => y4,
  toNamespacedPath: () => U2,
  sep: () => I3,
  resolve: () => B2,
  relative: () => Q2,
  posix: () => g3,
  parse: () => $2,
  normalize: () => G,
  join: () => K2,
  isAbsolute: () => H2,
  format: () => Z,
  extname: () => Y2,
  dirname: () => V3,
  delimiter: () => O3,
  default: () => q2,
  basename: () => X2
});
var L3, h4, D2, T2, _3, E4, R2 = (s2, e) => () => (e || s2((e = { exports: {} }).exports, e), e.exports), N5 = (s2, e, r, t) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of T2(e))
      !E4.call(s2, i) && i !== r && h4(s2, i, { get: () => e[i], enumerable: !(t = D2(e, i)) || t.enumerable });
  return s2;
}, j4 = (s2, e, r) => (r = s2 != null ? L3(_3(s2)) : {}, N5(e || !s2 || !s2.__esModule ? h4(r, "default", { value: s2, enumerable: true }) : r, s2)), k2, x4, u2, J, P3 = function(s2) {
  return s2;
}, S2 = function() {
  throw new Error("Not implemented");
}, g3, y4, q2, B2, G, H2, K2, Q2, U2, V3, X2, Y2, Z, $2, I3, O3;
var init_path = __esm(() => {
  L3 = Object.create;
  h4 = Object.defineProperty;
  D2 = Object.getOwnPropertyDescriptor;
  T2 = Object.getOwnPropertyNames;
  _3 = Object.getPrototypeOf;
  E4 = Object.prototype.hasOwnProperty;
  k2 = R2((W, w3) => {
    function v4(s2) {
      if (typeof s2 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(s2));
    }
    function C3(s2, e) {
      for (var r = "", t = 0, i = -1, a3 = 0, n, l3 = 0;l3 <= s2.length; ++l3) {
        if (l3 < s2.length)
          n = s2.charCodeAt(l3);
        else {
          if (n === 47)
            break;
          n = 47;
        }
        if (n === 47) {
          if (!(i === l3 - 1 || a3 === 1))
            if (i !== l3 - 1 && a3 === 2) {
              if (r.length < 2 || t !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                if (r.length > 2) {
                  var f3 = r.lastIndexOf("/");
                  if (f3 !== r.length - 1) {
                    f3 === -1 ? (r = "", t = 0) : (r = r.slice(0, f3), t = r.length - 1 - r.lastIndexOf("/")), i = l3, a3 = 0;
                    continue;
                  }
                } else if (r.length === 2 || r.length === 1) {
                  r = "", t = 0, i = l3, a3 = 0;
                  continue;
                }
              }
              e && (r.length > 0 ? r += "/.." : r = "..", t = 2);
            } else
              r.length > 0 ? r += "/" + s2.slice(i + 1, l3) : r = s2.slice(i + 1, l3), t = l3 - i - 1;
          i = l3, a3 = 0;
        } else
          n === 46 && a3 !== -1 ? ++a3 : a3 = -1;
      }
      return r;
    }
    function F2(s2, e) {
      var r = e.dir || e.root, t = e.base || (e.name || "") + (e.ext || "");
      return r ? r === e.root ? r + t : r + s2 + t : t;
    }
    var m3 = { resolve: function() {
      for (var e = "", r = false, t, i = arguments.length - 1;i >= -1 && !r; i--) {
        var a3;
        i >= 0 ? a3 = arguments[i] : (t === undefined && (t = process.cwd()), a3 = t), v4(a3), a3.length !== 0 && (e = a3 + "/" + e, r = a3.charCodeAt(0) === 47);
      }
      return e = C3(e, !r), r ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
    }, normalize: function(e) {
      if (v4(e), e.length === 0)
        return ".";
      var r = e.charCodeAt(0) === 47, t = e.charCodeAt(e.length - 1) === 47;
      return e = C3(e, !r), e.length === 0 && !r && (e = "."), e.length > 0 && t && (e += "/"), r ? "/" + e : e;
    }, isAbsolute: function(e) {
      return v4(e), e.length > 0 && e.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var e, r = 0;r < arguments.length; ++r) {
        var t = arguments[r];
        v4(t), t.length > 0 && (e === undefined ? e = t : e += "/" + t);
      }
      return e === undefined ? "." : m3.normalize(e);
    }, relative: function(e, r) {
      if (v4(e), v4(r), e === r || (e = m3.resolve(e), r = m3.resolve(r), e === r))
        return "";
      for (var t = 1;t < e.length && e.charCodeAt(t) === 47; ++t)
        ;
      for (var i = e.length, a3 = i - t, n = 1;n < r.length && r.charCodeAt(n) === 47; ++n)
        ;
      for (var l3 = r.length, f3 = l3 - n, c2 = a3 < f3 ? a3 : f3, d4 = -1, o2 = 0;o2 <= c2; ++o2) {
        if (o2 === c2) {
          if (f3 > c2) {
            if (r.charCodeAt(n + o2) === 47)
              return r.slice(n + o2 + 1);
            if (o2 === 0)
              return r.slice(n + o2);
          } else
            a3 > c2 && (e.charCodeAt(t + o2) === 47 ? d4 = o2 : o2 === 0 && (d4 = 0));
          break;
        }
        var A4 = e.charCodeAt(t + o2), z = r.charCodeAt(n + o2);
        if (A4 !== z)
          break;
        A4 === 47 && (d4 = o2);
      }
      var b4 = "";
      for (o2 = t + d4 + 1;o2 <= i; ++o2)
        (o2 === i || e.charCodeAt(o2) === 47) && (b4.length === 0 ? b4 += ".." : b4 += "/..");
      return b4.length > 0 ? b4 + r.slice(n + d4) : (n += d4, r.charCodeAt(n) === 47 && ++n, r.slice(n));
    }, _makeLong: function(e) {
      return e;
    }, dirname: function(e) {
      if (v4(e), e.length === 0)
        return ".";
      for (var r = e.charCodeAt(0), t = r === 47, i = -1, a3 = true, n = e.length - 1;n >= 1; --n)
        if (r = e.charCodeAt(n), r === 47) {
          if (!a3) {
            i = n;
            break;
          }
        } else
          a3 = false;
      return i === -1 ? t ? "/" : "." : t && i === 1 ? "//" : e.slice(0, i);
    }, basename: function(e, r) {
      if (r !== undefined && typeof r != "string")
        throw new TypeError('"ext" argument must be a string');
      v4(e);
      var t = 0, i = -1, a3 = true, n;
      if (r !== undefined && r.length > 0 && r.length <= e.length) {
        if (r.length === e.length && r === e)
          return "";
        var l3 = r.length - 1, f3 = -1;
        for (n = e.length - 1;n >= 0; --n) {
          var c2 = e.charCodeAt(n);
          if (c2 === 47) {
            if (!a3) {
              t = n + 1;
              break;
            }
          } else
            f3 === -1 && (a3 = false, f3 = n + 1), l3 >= 0 && (c2 === r.charCodeAt(l3) ? --l3 === -1 && (i = n) : (l3 = -1, i = f3));
        }
        return t === i ? i = f3 : i === -1 && (i = e.length), e.slice(t, i);
      } else {
        for (n = e.length - 1;n >= 0; --n)
          if (e.charCodeAt(n) === 47) {
            if (!a3) {
              t = n + 1;
              break;
            }
          } else
            i === -1 && (a3 = false, i = n + 1);
        return i === -1 ? "" : e.slice(t, i);
      }
    }, extname: function(e) {
      v4(e);
      for (var r = -1, t = 0, i = -1, a3 = true, n = 0, l3 = e.length - 1;l3 >= 0; --l3) {
        var f3 = e.charCodeAt(l3);
        if (f3 === 47) {
          if (!a3) {
            t = l3 + 1;
            break;
          }
          continue;
        }
        i === -1 && (a3 = false, i = l3 + 1), f3 === 46 ? r === -1 ? r = l3 : n !== 1 && (n = 1) : r !== -1 && (n = -1);
      }
      return r === -1 || i === -1 || n === 0 || n === 1 && r === i - 1 && r === t + 1 ? "" : e.slice(r, i);
    }, format: function(e) {
      if (e === null || typeof e != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
      return F2("/", e);
    }, parse: function(e) {
      v4(e);
      var r = { root: "", dir: "", base: "", ext: "", name: "" };
      if (e.length === 0)
        return r;
      var t = e.charCodeAt(0), i = t === 47, a3;
      i ? (r.root = "/", a3 = 1) : a3 = 0;
      for (var n = -1, l3 = 0, f3 = -1, c2 = true, d4 = e.length - 1, o2 = 0;d4 >= a3; --d4) {
        if (t = e.charCodeAt(d4), t === 47) {
          if (!c2) {
            l3 = d4 + 1;
            break;
          }
          continue;
        }
        f3 === -1 && (c2 = false, f3 = d4 + 1), t === 46 ? n === -1 ? n = d4 : o2 !== 1 && (o2 = 1) : n !== -1 && (o2 = -1);
      }
      return n === -1 || f3 === -1 || o2 === 0 || o2 === 1 && n === f3 - 1 && n === l3 + 1 ? f3 !== -1 && (l3 === 0 && i ? r.base = r.name = e.slice(1, f3) : r.base = r.name = e.slice(l3, f3)) : (l3 === 0 && i ? (r.name = e.slice(1, n), r.base = e.slice(1, f3)) : (r.name = e.slice(l3, n), r.base = e.slice(l3, f3)), r.ext = e.slice(n, f3)), l3 > 0 ? r.dir = e.slice(0, l3 - 1) : i && (r.dir = "/"), r;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    m3.posix = m3;
    w3.exports = m3;
  });
  x4 = j4(k2());
  u2 = x4;
  J = x4;
  u2.parse ??= S2;
  J.parse ??= S2;
  g3 = { resolve: u2.resolve.bind(u2), normalize: u2.normalize.bind(u2), isAbsolute: u2.isAbsolute.bind(u2), join: u2.join.bind(u2), relative: u2.relative.bind(u2), toNamespacedPath: P3, dirname: u2.dirname.bind(u2), basename: u2.basename.bind(u2), extname: u2.extname.bind(u2), format: u2.format.bind(u2), parse: u2.parse.bind(u2), sep: "/", delimiter: ":", win32: undefined, posix: undefined, _makeLong: P3 };
  y4 = { sep: "\\", delimiter: ";", win32: undefined, ...g3, posix: g3 };
  g3.win32 = y4.win32 = y4;
  g3.posix = g3;
  q2 = g3;
  ({ resolve: B2, normalize: G, isAbsolute: H2, join: K2, relative: Q2, toNamespacedPath: U2, dirname: V3, basename: X2, extname: Y2, format: Z, parse: $2, sep: I3, delimiter: O3 } = g3);
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayLike;
  function isArrayLike(value) {
    return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
  }
  module.exports = exports.default;
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(fn) {
    return function(...args) {
      var callback = args.pop();
      return fn.call(this, args, callback);
    };
  };
  module.exports = exports.default;
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fallback = fallback2;
  exports.wrap = wrap;
  var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  function fallback2(fn) {
    setTimeout(fn, 0);
  }
  function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
  }
  var _defer;
  if (hasQueueMicrotask) {
    _defer = queueMicrotask;
  } else if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback2;
  }
  exports.default = wrap(_defer);
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncify;
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _wrapAsync = require_wrapAsync();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function asyncify(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function(...args) {
        const callback = args.pop();
        const promise = func.apply(this, args);
        return handlePromise(promise, callback);
      };
    }
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e) {
        return callback(e);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  }
  function handlePromise(promise, callback) {
    return promise.then((value) => {
      invokeCallback(callback, null, value);
    }, (err) => {
      invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
  }
  function invokeCallback(callback, error, value) {
    try {
      callback(error, value);
    } catch (err) {
      (0, _setImmediate2.default)((e) => {
        throw e;
      }, err);
    }
  }
  module.exports = exports.default;
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function isAsync(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
  }
  function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
  }
  function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
  }
  function wrapAsync(asyncFn) {
    if (typeof asyncFn !== "function")
      throw new Error("expected a function");
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  }
  exports.default = wrapAsync;
  exports.isAsync = isAsync;
  exports.isAsyncGenerator = isAsyncGenerator;
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = awaitify;
  function awaitify(asyncFn, arity) {
    if (!arity)
      arity = asyncFn.length;
    if (!arity)
      throw new Error("arity is undefined");
    function awaitable(...args) {
      if (typeof args[arity - 1] === "function") {
        return asyncFn.apply(this, args);
      }
      return new Promise((resolve, reject) => {
        args[arity - 1] = (err, ...cbArgs) => {
          if (err)
            return reject(err);
          resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this, args);
      });
    }
    return awaitable;
  }
  module.exports = exports.default;
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, (task, key, taskCb) => {
      (0, _wrapAsync2.default)(task)((err, ...result) => {
        if (result.length < 2) {
          [result] = result;
        }
        results[key] = result;
        taskCb(err);
      });
    }, (err) => callback(err, results));
  }, 3);
  module.exports = exports.default;
});

// node_modules/async/internal/once.js
var require_once = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = once;
  function once(fn) {
    function wrapper(...args) {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  }
  module.exports = exports.default;
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module.exports = exports.default;
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIterator;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
      return ++i < len ? { value: coll[i], key: i } : null;
    };
  }
  function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
      var item = iterator.next();
      if (item.done)
        return null;
      i++;
      return { value: item.value, key: i };
    };
  }
  function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i];
      if (key === "__proto__") {
        return next();
      }
      return i < len ? { value: obj[key], key } : null;
    };
  }
  function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  }
  module.exports = exports.default;
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = onlyOnce;
  function onlyOnce(fn) {
    return function(...args) {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  }
  module.exports = exports.default;
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakLoop = {};
  exports.default = breakLoop;
  module.exports = exports.default;
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncEachOfLimit;
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done)
        return;
      awaiting = true;
      generator.next().then(({ value, done: iterDone }) => {
        if (canceled || done)
          return;
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err, result) {
      running -= 1;
      if (canceled)
        return;
      if (err)
        return handleError(err);
      if (err === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err) {
      if (canceled)
        return;
      awaiting = false;
      done = true;
      callback(err);
    }
    replenish();
  }
  module.exports = exports.default;
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _asyncEachOfLimit = require_asyncEachOfLimit();
  var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  exports.default = (limit) => {
    return (obj, iteratee, callback) => {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value) {
        if (canceled)
          return;
        running -= 1;
        if (err) {
          done = true;
          callback(err);
        } else if (err === false) {
          done = true;
          canceled = true;
        } else if (value === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module.exports = exports.default;
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = require_eachOfLimit();
  var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfLimit(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  }
  exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
  module.exports = exports.default;
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfSeries(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  }
  exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
  module.exports = exports.default;
});

// node_modules/async/series.js
var require_series = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = series;
  var _parallel2 = require_parallel();
  var _parallel3 = _interopRequireDefault(_parallel2);
  var _eachOfSeries = require_eachOfSeries();
  var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function series(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
  }
  module.exports = exports.default;
});

// node:zlib
var exports_zlib = {};
__export(exports_zlib, {
  default: () => EA
});
var Vy, Dn, Yy, Ky, Xy, Jy, wo = (e, t) => () => (e && (t = e(e = 0)), t), g4 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Bn = (e, t) => {
  for (var r in t)
    Dn(e, r, { get: t[r], enumerable: true });
}, Ln = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Ky(t))
      !Jy.call(e, i) && i !== r && Dn(e, i, { get: () => t[i], enumerable: !(n = Yy(t, i)) || n.enumerable });
  return e;
}, X3 = (e, t, r) => (Ln(e, t, "default"), r && Ln(r, t, "default")), vt = (e, t, r) => (r = e != null ? Vy(Xy(e)) : {}, Ln(t || !e || !e.__esModule ? Dn(r, "default", { value: e, enumerable: true }) : r, e)), se = (e) => Ln(Dn({}, "__esModule", { value: true }), e), sl, cl, xe, V4, Pe2, qn, ne, Ur3, Mo, ye, I0, it, ot2, at2, Eu, Tt, Qn, ri, ii, Zu, ai, Yu, Ju, Qo, zr, da, Us, Ce, wa, va, gi, ic, Ia, yc, Na, br2, EE, _c, ka, Hr, vc, Sc, wi, Rc, Yr, Si, Ai, zc, $c, Yc, Wa, $a, Ga, Ya, cd, xd, Id, Td, ff, be, Dd, Bd, cm, Ir2, cf, Wd, Gd, yf, nh, fh, uh, un, Ef, vf, bh, mf, Sf, Af, xh, Oh, Vh, tn, dp, yn, Bp, Cf, zf, Up, Vp, Kp, ny, jy, qy, zy, ol, Tn, EA;
var init_zlib = __esm(() => {
  Vy = Object.create;
  Dn = Object.defineProperty;
  Yy = Object.getOwnPropertyDescriptor;
  Ky = Object.getOwnPropertyNames;
  Xy = Object.getPrototypeOf;
  Jy = Object.prototype.hasOwnProperty;
  sl = g4((Pn) => {
    Pn.byteLength = e_;
    Pn.toByteArray = r_;
    Pn.fromByteArray = o_;
    var De = [], pe = [], Qy = typeof Uint8Array < "u" ? Uint8Array : Array, Eo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (mt2 = 0, ll = Eo.length;mt2 < ll; ++mt2)
      De[mt2] = Eo[mt2], pe[Eo.charCodeAt(mt2)] = mt2;
    var mt2, ll;
    pe[45] = 62;
    pe[95] = 63;
    function ul(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function e_(e) {
      var t = ul(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function t_(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function r_(e) {
      var t, r = ul(e), n = r[0], i = r[1], o2 = new Qy(t_(e, n, i)), a3 = 0, f3 = i > 0 ? n - 4 : n, u3;
      for (u3 = 0;u3 < f3; u3 += 4)
        t = pe[e.charCodeAt(u3)] << 18 | pe[e.charCodeAt(u3 + 1)] << 12 | pe[e.charCodeAt(u3 + 2)] << 6 | pe[e.charCodeAt(u3 + 3)], o2[a3++] = t >> 16 & 255, o2[a3++] = t >> 8 & 255, o2[a3++] = t & 255;
      return i === 2 && (t = pe[e.charCodeAt(u3)] << 2 | pe[e.charCodeAt(u3 + 1)] >> 4, o2[a3++] = t & 255), i === 1 && (t = pe[e.charCodeAt(u3)] << 10 | pe[e.charCodeAt(u3 + 1)] << 4 | pe[e.charCodeAt(u3 + 2)] >> 2, o2[a3++] = t >> 8 & 255, o2[a3++] = t & 255), o2;
    }
    function n_(e) {
      return De[e >> 18 & 63] + De[e >> 12 & 63] + De[e >> 6 & 63] + De[e & 63];
    }
    function i_(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(n_(n));
      return i.join("");
    }
    function o_(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, a3 = 0, f3 = r - n;a3 < f3; a3 += o2)
        i.push(i_(e, a3, a3 + o2 > f3 ? f3 : a3 + o2));
      return n === 1 ? (t = e[r - 1], i.push(De[t >> 2] + De[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(De[t >> 10] + De[t >> 4 & 63] + De[t << 2 & 63] + "=")), i.join("");
    }
  });
  cl = g4((vo) => {
    vo.read = function(e, t, r, n, i) {
      var o2, a3, f3 = i * 8 - n - 1, u3 = (1 << f3) - 1, l3 = u3 >> 1, s2 = -7, c2 = r ? i - 1 : 0, h5 = r ? -1 : 1, d4 = e[t + c2];
      for (c2 += h5, o2 = d4 & (1 << -s2) - 1, d4 >>= -s2, s2 += f3;s2 > 0; o2 = o2 * 256 + e[t + c2], c2 += h5, s2 -= 8)
        ;
      for (a3 = o2 & (1 << -s2) - 1, o2 >>= -s2, s2 += n;s2 > 0; a3 = a3 * 256 + e[t + c2], c2 += h5, s2 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l3;
      else {
        if (o2 === u3)
          return a3 ? NaN : (d4 ? -1 : 1) * (1 / 0);
        a3 = a3 + Math.pow(2, n), o2 = o2 - l3;
      }
      return (d4 ? -1 : 1) * a3 * Math.pow(2, o2 - n);
    };
    vo.write = function(e, t, r, n, i, o2) {
      var a3, f3, u3, l3 = o2 * 8 - i - 1, s2 = (1 << l3) - 1, c2 = s2 >> 1, h5 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d4 = n ? 0 : o2 - 1, y5 = n ? 1 : -1, b4 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (f3 = isNaN(t) ? 1 : 0, a3 = s2) : (a3 = Math.floor(Math.log(t) / Math.LN2), t * (u3 = Math.pow(2, -a3)) < 1 && (a3--, u3 *= 2), a3 + c2 >= 1 ? t += h5 / u3 : t += h5 * Math.pow(2, 1 - c2), t * u3 >= 2 && (a3++, u3 /= 2), a3 + c2 >= s2 ? (f3 = 0, a3 = s2) : a3 + c2 >= 1 ? (f3 = (t * u3 - 1) * Math.pow(2, i), a3 = a3 + c2) : (f3 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), a3 = 0));i >= 8; e[r + d4] = f3 & 255, d4 += y5, f3 /= 256, i -= 8)
        ;
      for (a3 = a3 << i | f3, l3 += i;l3 > 0; e[r + d4] = a3 & 255, d4 += y5, a3 /= 256, l3 -= 8)
        ;
      e[r + d4 - y5] |= b4 * 128;
    };
  });
  xe = g4((or) => {
    var mo = sl(), nr = cl(), dl = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    or.Buffer = p3;
    or.SlowBuffer = c_;
    or.INSPECT_MAX_BYTES = 50;
    var Mn = 2147483647;
    or.kMaxLength = Mn;
    p3.TYPED_ARRAY_SUPPORT = a_();
    !p3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function a_() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(p3.prototype, "parent", { enumerable: true, get: function() {
      if (!!p3.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(p3.prototype, "offset", { enumerable: true, get: function() {
      if (!!p3.isBuffer(this))
        return this.byteOffset;
    } });
    function Ye(e) {
      if (e > Mn)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, p3.prototype), t;
    }
    function p3(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Ro(e);
      }
      return _l(e, t, r);
    }
    p3.poolSize = 8192;
    function _l(e, t, r) {
      if (typeof e == "string")
        return l_(e, t);
      if (ArrayBuffer.isView(e))
        return u_(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (Be(e, ArrayBuffer) || e && Be(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Be(e, SharedArrayBuffer) || e && Be(e.buffer, SharedArrayBuffer)))
        return Ao(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return p3.from(n, t, r);
      let i = s_(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return p3.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    p3.from = function(e, t, r) {
      return _l(e, t, r);
    };
    Object.setPrototypeOf(p3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(p3, Uint8Array);
    function gl(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function f_(e, t, r) {
      return gl(e), e <= 0 ? Ye(e) : t !== undefined ? typeof r == "string" ? Ye(e).fill(t, r) : Ye(e).fill(t) : Ye(e);
    }
    p3.alloc = function(e, t, r) {
      return f_(e, t, r);
    };
    function Ro(e) {
      return gl(e), Ye(e < 0 ? 0 : Io(e) | 0);
    }
    p3.allocUnsafe = function(e) {
      return Ro(e);
    };
    p3.allocUnsafeSlow = function(e) {
      return Ro(e);
    };
    function l_(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !p3.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = bl(e, t) | 0, n = Ye(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function So(e) {
      let t = e.length < 0 ? 0 : Io(e.length) | 0, r = Ye(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function u_(e) {
      if (Be(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Ao(t.buffer, t.byteOffset, t.byteLength);
      }
      return So(e);
    }
    function Ao(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, p3.prototype), n;
    }
    function s_(e) {
      if (p3.isBuffer(e)) {
        let t = Io(e.length) | 0, r = Ye(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Oo(e.length) ? Ye(0) : So(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return So(e.data);
    }
    function Io(e) {
      if (e >= Mn)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Mn.toString(16) + " bytes");
      return e | 0;
    }
    function c_(e) {
      return +e != e && (e = 0), p3.alloc(+e);
    }
    p3.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== p3.prototype;
    };
    p3.compare = function(t, r) {
      if (Be(t, Uint8Array) && (t = p3.from(t, t.offset, t.byteLength)), Be(r, Uint8Array) && (r = p3.from(r, r.offset, r.byteLength)), !p3.isBuffer(t) || !p3.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, a3 = Math.min(n, i);o2 < a3; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    p3.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    p3.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return p3.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = p3.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let a3 = t[n];
        if (Be(a3, Uint8Array))
          o2 + a3.length > i.length ? (p3.isBuffer(a3) || (a3 = p3.from(a3)), a3.copy(i, o2)) : Uint8Array.prototype.set.call(i, a3, o2);
        else if (p3.isBuffer(a3))
          a3.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += a3.length;
      }
      return i;
    };
    function bl(e, t) {
      if (p3.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || Be(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return xo(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Il(e).length;
          default:
            if (i)
              return n ? -1 : xo(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    p3.byteLength = bl;
    function d_(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return m_(this, t, r);
          case "utf8":
          case "utf-8":
            return El(this, t, r);
          case "ascii":
            return E_(this, t, r);
          case "latin1":
          case "binary":
            return v_(this, t, r);
          case "base64":
            return b_(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return S_(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    p3.prototype._isBuffer = true;
    function St(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    p3.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        St(this, r, r + 1);
      return this;
    };
    p3.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        St(this, r, r + 3), St(this, r + 1, r + 2);
      return this;
    };
    p3.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        St(this, r, r + 7), St(this, r + 1, r + 6), St(this, r + 2, r + 5), St(this, r + 3, r + 4);
      return this;
    };
    p3.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? El(this, 0, t) : d_.apply(this, arguments);
    };
    p3.prototype.toLocaleString = p3.prototype.toString;
    p3.prototype.equals = function(t) {
      if (!p3.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : p3.compare(this, t) === 0;
    };
    p3.prototype.inspect = function() {
      let t = "", r = or.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    dl && (p3.prototype[dl] = p3.prototype.inspect);
    p3.prototype.compare = function(t, r, n, i, o2) {
      if (Be(t, Uint8Array) && (t = p3.from(t, t.offset, t.byteLength)), !p3.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let a3 = o2 - i, f3 = n - r, u3 = Math.min(a3, f3), l3 = this.slice(i, o2), s2 = t.slice(r, n);
      for (let c2 = 0;c2 < u3; ++c2)
        if (l3[c2] !== s2[c2]) {
          a3 = l3[c2], f3 = s2[c2];
          break;
        }
      return a3 < f3 ? -1 : f3 < a3 ? 1 : 0;
    };
    function wl(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Oo(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = p3.from(t, n)), p3.isBuffer(t))
        return t.length === 0 ? -1 : hl(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : hl(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function hl(e, t, r, n, i) {
      let o2 = 1, a3 = e.length, f3 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, a3 /= 2, f3 /= 2, r /= 2;
      }
      function u3(s2, c2) {
        return o2 === 1 ? s2[c2] : s2.readUInt16BE(c2 * o2);
      }
      let l3;
      if (i) {
        let s2 = -1;
        for (l3 = r;l3 < a3; l3++)
          if (u3(e, l3) === u3(t, s2 === -1 ? 0 : l3 - s2)) {
            if (s2 === -1 && (s2 = l3), l3 - s2 + 1 === f3)
              return s2 * o2;
          } else
            s2 !== -1 && (l3 -= l3 - s2), s2 = -1;
      } else
        for (r + f3 > a3 && (r = a3 - f3), l3 = r;l3 >= 0; l3--) {
          let s2 = true;
          for (let c2 = 0;c2 < f3; c2++)
            if (u3(e, l3 + c2) !== u3(t, c2)) {
              s2 = false;
              break;
            }
          if (s2)
            return l3;
        }
      return -1;
    }
    p3.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    p3.prototype.indexOf = function(t, r, n) {
      return wl(this, t, r, n, true);
    };
    p3.prototype.lastIndexOf = function(t, r, n) {
      return wl(this, t, r, n, false);
    };
    function h_(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let a3;
      for (a3 = 0;a3 < n; ++a3) {
        let f3 = parseInt(t.substr(a3 * 2, 2), 16);
        if (Oo(f3))
          return a3;
        e[r + a3] = f3;
      }
      return a3;
    }
    function p_(e, t, r, n) {
      return jn(xo(t, e.length - r), e, r, n);
    }
    function y_(e, t, r, n) {
      return jn(I_(t), e, r, n);
    }
    function __(e, t, r, n) {
      return jn(Il(t), e, r, n);
    }
    function g_(e, t, r, n) {
      return jn(T_(t, e.length - r), e, r, n);
    }
    p3.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a3 = false;
      for (;; )
        switch (i) {
          case "hex":
            return h_(this, t, r, n);
          case "utf8":
          case "utf-8":
            return p_(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return y_(this, t, r, n);
          case "base64":
            return __(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return g_(this, t, r, n);
          default:
            if (a3)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a3 = true;
        }
    };
    p3.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function b_(e, t, r) {
      return t === 0 && r === e.length ? mo.fromByteArray(e) : mo.fromByteArray(e.slice(t, r));
    }
    function El(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], a3 = null, f3 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + f3 <= r) {
          let u3, l3, s2, c2;
          switch (f3) {
            case 1:
              o2 < 128 && (a3 = o2);
              break;
            case 2:
              u3 = e[i + 1], (u3 & 192) === 128 && (c2 = (o2 & 31) << 6 | u3 & 63, c2 > 127 && (a3 = c2));
              break;
            case 3:
              u3 = e[i + 1], l3 = e[i + 2], (u3 & 192) === 128 && (l3 & 192) === 128 && (c2 = (o2 & 15) << 12 | (u3 & 63) << 6 | l3 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (a3 = c2));
              break;
            case 4:
              u3 = e[i + 1], l3 = e[i + 2], s2 = e[i + 3], (u3 & 192) === 128 && (l3 & 192) === 128 && (s2 & 192) === 128 && (c2 = (o2 & 15) << 18 | (u3 & 63) << 12 | (l3 & 63) << 6 | s2 & 63, c2 > 65535 && c2 < 1114112 && (a3 = c2));
          }
        }
        a3 === null ? (a3 = 65533, f3 = 1) : a3 > 65535 && (a3 -= 65536, n.push(a3 >>> 10 & 1023 | 55296), a3 = 56320 | a3 & 1023), n.push(a3), i += f3;
      }
      return w_(n);
    }
    var pl = 4096;
    function w_(e) {
      let t = e.length;
      if (t <= pl)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += pl));
      return r;
    }
    function E_(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function v_(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function m_(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += O_[e[o2]];
      return i;
    }
    function S_(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    p3.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, p3.prototype), i;
    };
    function J2(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    p3.prototype.readUintLE = p3.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || J2(t, r, this.length);
      let i = this[t], o2 = 1, a3 = 0;
      for (;++a3 < r && (o2 *= 256); )
        i += this[t + a3] * o2;
      return i;
    };
    p3.prototype.readUintBE = p3.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || J2(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    p3.prototype.readUint8 = p3.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || J2(t, 1, this.length), this[t];
    };
    p3.prototype.readUint16LE = p3.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || J2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    p3.prototype.readUint16BE = p3.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || J2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    p3.prototype.readUint32LE = p3.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || J2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    p3.prototype.readUint32BE = p3.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || J2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    p3.prototype.readBigUInt64LE = nt3(function(t) {
      t = t >>> 0, ir(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && jr(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    p3.prototype.readBigUInt64BE = nt3(function(t) {
      t = t >>> 0, ir(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && jr(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    p3.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || J2(t, r, this.length);
      let i = this[t], o2 = 1, a3 = 0;
      for (;++a3 < r && (o2 *= 256); )
        i += this[t + a3] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    p3.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || J2(t, r, this.length);
      let i = r, o2 = 1, a3 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        a3 += this[t + --i] * o2;
      return o2 *= 128, a3 >= o2 && (a3 -= Math.pow(2, 8 * r)), a3;
    };
    p3.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || J2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    p3.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || J2(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    p3.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || J2(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    p3.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || J2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    p3.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || J2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    p3.prototype.readBigInt64LE = nt3(function(t) {
      t = t >>> 0, ir(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && jr(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    p3.prototype.readBigInt64BE = nt3(function(t) {
      t = t >>> 0, ir(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && jr(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    p3.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || J2(t, 4, this.length), nr.read(this, t, true, 23, 4);
    };
    p3.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || J2(t, 4, this.length), nr.read(this, t, false, 23, 4);
    };
    p3.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || J2(t, 8, this.length), nr.read(this, t, true, 52, 8);
    };
    p3.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || J2(t, 8, this.length), nr.read(this, t, false, 52, 8);
    };
    function fe(e, t, r, n, i, o2) {
      if (!p3.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    p3.prototype.writeUintLE = p3.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let f3 = Math.pow(2, 8 * n) - 1;
        fe(this, t, r, n, f3, 0);
      }
      let o2 = 1, a3 = 0;
      for (this[r] = t & 255;++a3 < n && (o2 *= 256); )
        this[r + a3] = t / o2 & 255;
      return r + n;
    };
    p3.prototype.writeUintBE = p3.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let f3 = Math.pow(2, 8 * n) - 1;
        fe(this, t, r, n, f3, 0);
      }
      let o2 = n - 1, a3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a3 *= 256); )
        this[r + o2] = t / a3 & 255;
      return r + n;
    };
    p3.prototype.writeUint8 = p3.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    p3.prototype.writeUint16LE = p3.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    p3.prototype.writeUint16BE = p3.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    p3.prototype.writeUint32LE = p3.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    p3.prototype.writeUint32BE = p3.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function vl(e, t, r, n, i) {
      Rl(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let a3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, r;
    }
    function ml(e, t, r, n, i) {
      Rl(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let a3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a3, a3 = a3 >> 8, e[r + 2] = a3, a3 = a3 >> 8, e[r + 1] = a3, a3 = a3 >> 8, e[r] = a3, r + 8;
    }
    p3.prototype.writeBigUInt64LE = nt3(function(t, r = 0) {
      return vl(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    p3.prototype.writeBigUInt64BE = nt3(function(t, r = 0) {
      return ml(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    p3.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n - 1);
        fe(this, t, r, n, u3 - 1, -u3);
      }
      let o2 = 0, a3 = 1, f3 = 0;
      for (this[r] = t & 255;++o2 < n && (a3 *= 256); )
        t < 0 && f3 === 0 && this[r + o2 - 1] !== 0 && (f3 = 1), this[r + o2] = (t / a3 >> 0) - f3 & 255;
      return r + n;
    };
    p3.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n - 1);
        fe(this, t, r, n, u3 - 1, -u3);
      }
      let o2 = n - 1, a3 = 1, f3 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a3 *= 256); )
        t < 0 && f3 === 0 && this[r + o2 + 1] !== 0 && (f3 = 1), this[r + o2] = (t / a3 >> 0) - f3 & 255;
      return r + n;
    };
    p3.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    p3.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    p3.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    p3.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    p3.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || fe(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    p3.prototype.writeBigInt64LE = nt3(function(t, r = 0) {
      return vl(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    p3.prototype.writeBigInt64BE = nt3(function(t, r = 0) {
      return ml(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Sl(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function Al(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Sl(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), nr.write(e, t, r, n, 23, 4), r + 4;
    }
    p3.prototype.writeFloatLE = function(t, r, n) {
      return Al(this, t, r, true, n);
    };
    p3.prototype.writeFloatBE = function(t, r, n) {
      return Al(this, t, r, false, n);
    };
    function xl(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Sl(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), nr.write(e, t, r, n, 52, 8), r + 8;
    }
    p3.prototype.writeDoubleLE = function(t, r, n) {
      return xl(this, t, r, true, n);
    };
    p3.prototype.writeDoubleBE = function(t, r, n) {
      return xl(this, t, r, false, n);
    };
    p3.prototype.copy = function(t, r, n, i) {
      if (!p3.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    p3.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !p3.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a3 = t.charCodeAt(0);
          (i === "utf8" && a3 < 128 || i === "latin1") && (t = a3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let a3 = p3.isBuffer(t) ? t : p3.from(t, i), f3 = a3.length;
        if (f3 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = a3[o2 % f3];
      }
      return this;
    };
    var rr2 = {};
    function To(e, t, r) {
      rr2[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    To("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    To("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    To("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = yl(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = yl(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function yl(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function A_(e, t, r) {
      ir(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && jr(t, e.length - (r + 1));
    }
    function Rl(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let a3 = typeof t == "bigint" ? "n" : "", f3;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? f3 = `>= 0${a3} and < 2${a3} ** ${(o2 + 1) * 8}${a3}` : f3 = `>= -(2${a3} ** ${(o2 + 1) * 8 - 1}${a3}) and < 2 ** ${(o2 + 1) * 8 - 1}${a3}` : f3 = `>= ${t}${a3} and <= ${r}${a3}`, new rr2.ERR_OUT_OF_RANGE("value", f3, e);
      }
      A_(n, i, o2);
    }
    function ir(e, t) {
      if (typeof e != "number")
        throw new rr2.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function jr(e, t, r) {
      throw Math.floor(e) !== e ? (ir(e, r), new rr2.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new rr2.ERR_BUFFER_OUT_OF_BOUNDS : new rr2.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var x_ = /[^+/0-9A-Za-z-_]/g;
    function R_(e) {
      if (e = e.split("=")[0], e = e.trim().replace(x_, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function xo(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let a3 = 0;a3 < n; ++a3) {
        if (r = e.charCodeAt(a3), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (a3 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function I_(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function T_(e, t) {
      let r, n, i, o2 = [];
      for (let a3 = 0;a3 < e.length && !((t -= 2) < 0); ++a3)
        r = e.charCodeAt(a3), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function Il(e) {
      return mo.toByteArray(R_(e));
    }
    function jn(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function Be(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Oo(e) {
      return e !== e;
    }
    var O_ = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function nt3(e) {
      return typeof BigInt > "u" ? N_ : e;
    }
    function N_() {
      throw new Error("BigInt not supported");
    }
  });
  V4 = g4((RA, Tl) => {
    Tl.exports = { ArrayIsArray(e) {
      return Array.isArray(e);
    }, ArrayPrototypeIncludes(e, t) {
      return e.includes(t);
    }, ArrayPrototypeIndexOf(e, t) {
      return e.indexOf(t);
    }, ArrayPrototypeJoin(e, t) {
      return e.join(t);
    }, ArrayPrototypeMap(e, t) {
      return e.map(t);
    }, ArrayPrototypePop(e, t) {
      return e.pop(t);
    }, ArrayPrototypePush(e, t) {
      return e.push(t);
    }, ArrayPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, Error, FunctionPrototypeCall(e, t, ...r) {
      return e.call(t, ...r);
    }, FunctionPrototypeSymbolHasInstance(e, t) {
      return Function.prototype[Symbol.hasInstance].call(e, t);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(e, t) {
      return Object.defineProperties(e, t);
    }, ObjectDefineProperty(e, t, r) {
      return Object.defineProperty(e, t, r);
    }, ObjectGetOwnPropertyDescriptor(e, t) {
      return Object.getOwnPropertyDescriptor(e, t);
    }, ObjectKeys(e) {
      return Object.keys(e);
    }, ObjectSetPrototypeOf(e, t) {
      return Object.setPrototypeOf(e, t);
    }, Promise, PromisePrototypeCatch(e, t) {
      return e.catch(t);
    }, PromisePrototypeThen(e, t, r) {
      return e.then(t, r);
    }, PromiseReject(e) {
      return Promise.reject(e);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(e, t) {
      return e.test(t);
    }, SafeSet: Set, String, StringPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, StringPrototypeToLowerCase(e) {
      return e.toLowerCase();
    }, StringPrototypeToUpperCase(e) {
      return e.toUpperCase();
    }, StringPrototypeTrim(e) {
      return e.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(e, t, r) {
      return e.set(t, r);
    }, Uint8Array };
  });
  Pe2 = g4((IA, ko) => {
    var k_ = xe(), F_ = Object.getPrototypeOf(async function() {
    }).constructor, Ol = globalThis.Blob || k_.Blob, L_ = typeof Ol < "u" ? function(t) {
      return t instanceof Ol;
    } : function(t) {
      return false;
    }, No = class extends Error {
      constructor(t) {
        if (!Array.isArray(t))
          throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
        let r = "";
        for (let n = 0;n < t.length; n++)
          r += `    ${t[n].stack}
`;
        super(r), this.name = "AggregateError", this.errors = t;
      }
    };
    ko.exports = { AggregateError: No, kEmptyObject: Object.freeze({}), once(e) {
      let t = false;
      return function(...r) {
        t || (t = true, e.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let e, t;
      return { promise: new Promise((n, i) => {
        e = n, t = i;
      }), resolve: e, reject: t };
    }, promisify(e) {
      return new Promise((t, r) => {
        e((n, ...i) => n ? r(n) : t(...i));
      });
    }, debuglog() {
      return function() {
      };
    }, format(e, ...t) {
      return e.replace(/%([sdifj])/g, function(...[r, n]) {
        let i = t.shift();
        return n === "f" ? i.toFixed(6) : n === "j" ? JSON.stringify(i) : n === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
      });
    }, inspect(e) {
      switch (typeof e) {
        case "string":
          if (e.includes("'"))
            if (e.includes('"')) {
              if (!e.includes("`") && !e.includes("${"))
                return `\`${e}\``;
            } else
              return `"${e}"`;
          return `'${e}'`;
        case "number":
          return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
        case "bigint":
          return `${String(e)}n`;
        case "boolean":
        case "undefined":
          return String(e);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(e) {
      return e instanceof F_;
    }, isArrayBufferView(e) {
      return ArrayBuffer.isView(e);
    } }, isBlob: L_ };
    ko.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  qn = g4((TA, Un) => {
    var { AbortController: Nl, AbortSignal: D_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Un.exports = Nl;
    Un.exports.AbortSignal = D_;
    Un.exports.default = Nl;
  });
  ne = g4((OA, Ll) => {
    var { format: B_, inspect: Cn, AggregateError: P_ } = Pe2(), M_ = globalThis.AggregateError || P_, j_ = Symbol("kIsNodeError"), U_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], q_ = /^([A-Z][a-z0-9]*)+$/, C_ = "__node_internal_", zn = {};
    function At2(e, t) {
      if (!e)
        throw new zn.ERR_INTERNAL_ASSERTION(t);
    }
    function kl(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function z_(e, t, r) {
      if (typeof t == "function")
        return At2(t.length <= r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`), t(...r);
      let n = (t.match(/%[dfijoOs]/g) || []).length;
      return At2(n === r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`), r.length === 0 ? t : B_(t, ...r);
    }
    function Q3(e, t, r) {
      r || (r = Error);

      class n extends r {
        constructor(...o2) {
          super(z_(e, t, o2));
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      }
      Object.defineProperties(n.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${e}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), n.prototype.code = e, n.prototype[j_] = true, zn[e] = n;
    }
    function Fl(e) {
      let t = C_ + e.name;
      return Object.defineProperty(e, "name", { value: t }), e;
    }
    function W_(e, t) {
      if (e && t && e !== t) {
        if (Array.isArray(t.errors))
          return t.errors.push(e), t;
        let r = new M_([t, e], t.message);
        return r.code = t.code, r;
      }
      return e || t;
    }
    var Fo = class extends Error {
      constructor(t = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new zn.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    Q3("ERR_ASSERTION", "%s", Error);
    Q3("ERR_INVALID_ARG_TYPE", (e, t, r) => {
      At2(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
      let n = "The ";
      e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
      let i = [], o2 = [], a3 = [];
      for (let u3 of t)
        At2(typeof u3 == "string", "All expected entries have to be of type string"), U_.includes(u3) ? i.push(u3.toLowerCase()) : q_.test(u3) ? o2.push(u3) : (At2(u3 !== "object", 'The value "object" should be written as "Object"'), a3.push(u3));
      if (o2.length > 0) {
        let u3 = i.indexOf("object");
        u3 !== -1 && (i.splice(i, u3, 1), o2.push("Object"));
      }
      if (i.length > 0) {
        switch (i.length) {
          case 1:
            n += `of type ${i[0]}`;
            break;
          case 2:
            n += `one of type ${i[0]} or ${i[1]}`;
            break;
          default: {
            let u3 = i.pop();
            n += `one of type ${i.join(", ")}, or ${u3}`;
          }
        }
        (o2.length > 0 || a3.length > 0) && (n += " or ");
      }
      if (o2.length > 0) {
        switch (o2.length) {
          case 1:
            n += `an instance of ${o2[0]}`;
            break;
          case 2:
            n += `an instance of ${o2[0]} or ${o2[1]}`;
            break;
          default: {
            let u3 = o2.pop();
            n += `an instance of ${o2.join(", ")}, or ${u3}`;
          }
        }
        a3.length > 0 && (n += " or ");
      }
      switch (a3.length) {
        case 0:
          break;
        case 1:
          a3[0].toLowerCase() !== a3[0] && (n += "an "), n += `${a3[0]}`;
          break;
        case 2:
          n += `one of ${a3[0]} or ${a3[1]}`;
          break;
        default: {
          let u3 = a3.pop();
          n += `one of ${a3.join(", ")}, or ${u3}`;
        }
      }
      if (r == null)
        n += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        n += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var f3;
        (f3 = r.constructor) !== null && f3 !== undefined && f3.name ? n += `. Received an instance of ${r.constructor.name}` : n += `. Received ${Cn(r, { depth: -1 })}`;
      } else {
        let u3 = Cn(r, { colors: false });
        u3.length > 25 && (u3 = `${u3.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u3})`;
      }
      return n;
    }, TypeError);
    Q3("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
      let n = Cn(t);
      return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
    }, TypeError);
    Q3("ERR_INVALID_RETURN_VALUE", (e, t, r) => {
      var n;
      let i = r != null && (n = r.constructor) !== null && n !== undefined && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    Q3("ERR_MISSING_ARGS", (...e) => {
      At2(e.length > 0, "At least one arg needs to be specified");
      let t, r = e.length;
      switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
        case 1:
          t += `The ${e[0]} argument`;
          break;
        case 2:
          t += `The ${e[0]} and ${e[1]} arguments`;
          break;
        default:
          {
            let n = e.pop();
            t += `The ${e.join(", ")}, and ${n} arguments`;
          }
          break;
      }
      return `${t} must be specified`;
    }, TypeError);
    Q3("ERR_OUT_OF_RANGE", (e, t, r) => {
      At2(t, 'Missing "range" argument');
      let n;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = kl(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = kl(n)), n += "n") : n = Cn(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
    }, RangeError);
    Q3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    Q3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    Q3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    Q3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    Q3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    Q3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    Q3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    Q3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    Q3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    Q3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    Q3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    Ll.exports = { AbortError: Fo, aggregateTwoErrors: Fl(W_), hideStackFrames: Fl, codes: zn };
  });
  Ur3 = g4((NA, Cl) => {
    var { ArrayIsArray: Pl, ArrayPrototypeIncludes: Ml, ArrayPrototypeJoin: jl, ArrayPrototypeMap: Z_, NumberIsInteger: Do, NumberIsNaN: $_, NumberMAX_SAFE_INTEGER: G_, NumberMIN_SAFE_INTEGER: H_, NumberParseInt: V_, ObjectPrototypeHasOwnProperty: Y_, RegExpPrototypeExec: K_, String: X_, StringPrototypeToUpperCase: J_, StringPrototypeTrim: Q_ } = V4(), { hideStackFrames: Re, codes: { ERR_SOCKET_BAD_PORT: e0, ERR_INVALID_ARG_TYPE: le, ERR_INVALID_ARG_VALUE: Wn, ERR_OUT_OF_RANGE: xt, ERR_UNKNOWN_SIGNAL: Dl } } = ne(), { normalizeEncoding: t0 } = Pe2(), { isAsyncFunction: r0, isArrayBufferView: n0 } = Pe2().types, Bl = {};
    function i0(e) {
      return e === (e | 0);
    }
    function o0(e) {
      return e === e >>> 0;
    }
    var a0 = /^[0-7]+$/, f0 = "must be a 32-bit unsigned integer or an octal string";
    function l0(e, t, r) {
      if (typeof e > "u" && (e = r), typeof e == "string") {
        if (K_(a0, e) === null)
          throw new Wn(t, e, f0);
        e = V_(e, 8);
      }
      return Ul(e, t), e;
    }
    var u0 = Re((e, t, r = H_, n = G_) => {
      if (typeof e != "number")
        throw new le(t, "number", e);
      if (!Do(e))
        throw new xt(t, "an integer", e);
      if (e < r || e > n)
        throw new xt(t, `>= ${r} && <= ${n}`, e);
    }), s0 = Re((e, t, r = -2147483648, n = 2147483647) => {
      if (typeof e != "number")
        throw new le(t, "number", e);
      if (!Do(e))
        throw new xt(t, "an integer", e);
      if (e < r || e > n)
        throw new xt(t, `>= ${r} && <= ${n}`, e);
    }), Ul = Re((e, t, r = false) => {
      if (typeof e != "number")
        throw new le(t, "number", e);
      if (!Do(e))
        throw new xt(t, "an integer", e);
      let n = r ? 1 : 0, i = 4294967295;
      if (e < n || e > i)
        throw new xt(t, `>= ${n} && <= ${i}`, e);
    });
    function ql(e, t) {
      if (typeof e != "string")
        throw new le(t, "string", e);
    }
    function c0(e, t, r = undefined, n) {
      if (typeof e != "number")
        throw new le(t, "number", e);
      if (r != null && e < r || n != null && e > n || (r != null || n != null) && $_(e))
        throw new xt(t, `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`, e);
    }
    var d0 = Re((e, t, r) => {
      if (!Ml(r, e)) {
        let n = jl(Z_(r, (o2) => typeof o2 == "string" ? `'${o2}'` : X_(o2)), ", "), i = "must be one of: " + n;
        throw new Wn(t, e, i);
      }
    });
    function h0(e, t) {
      if (typeof e != "boolean")
        throw new le(t, "boolean", e);
    }
    function Lo(e, t, r) {
      return e == null || !Y_(e, t) ? r : e[t];
    }
    var p0 = Re((e, t, r = null) => {
      let n = Lo(r, "allowArray", false), i = Lo(r, "allowFunction", false);
      if (!Lo(r, "nullable", false) && e === null || !n && Pl(e) || typeof e != "object" && (!i || typeof e != "function"))
        throw new le(t, "Object", e);
    }), y0 = Re((e, t, r = 0) => {
      if (!Pl(e))
        throw new le(t, "Array", e);
      if (e.length < r) {
        let n = `must be longer than ${r}`;
        throw new Wn(t, e, n);
      }
    });
    function _0(e, t = "signal") {
      if (ql(e, t), Bl[e] === undefined)
        throw Bl[J_(e)] !== undefined ? new Dl(e + " (signals must use all capital letters)") : new Dl(e);
    }
    var g0 = Re((e, t = "buffer") => {
      if (!n0(e))
        throw new le(t, ["Buffer", "TypedArray", "DataView"], e);
    });
    function b0(e, t) {
      let r = t0(t), n = e.length;
      if (r === "hex" && n % 2 !== 0)
        throw new Wn("encoding", t, `is invalid for data of length ${n}`);
    }
    function w0(e, t = "Port", r = true) {
      if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Q_(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
        throw new e0(t, e, r);
      return e | 0;
    }
    var E0 = Re((e, t) => {
      if (e !== undefined && (e === null || typeof e != "object" || !("aborted" in e)))
        throw new le(t, "AbortSignal", e);
    }), v0 = Re((e, t) => {
      if (typeof e != "function")
        throw new le(t, "Function", e);
    }), m0 = Re((e, t) => {
      if (typeof e != "function" || r0(e))
        throw new le(t, "Function", e);
    }), S0 = Re((e, t) => {
      if (e !== undefined)
        throw new le(t, "undefined", e);
    });
    function A0(e, t, r) {
      if (!Ml(r, e))
        throw new le(t, `('${jl(r, "|")}')`, e);
    }
    Cl.exports = { isInt32: i0, isUint32: o0, parseFileMode: l0, validateArray: y0, validateBoolean: h0, validateBuffer: g0, validateEncoding: b0, validateFunction: v0, validateInt32: s0, validateInteger: u0, validateNumber: c0, validateObject: p0, validateOneOf: d0, validatePlainFunction: m0, validatePort: w0, validateSignalName: _0, validateString: ql, validateUint32: Ul, validateUndefined: S0, validateUnion: A0, validateAbortSignal: E0 };
  });
  Mo = g4((kA, $l) => {
    var $3 = $l.exports = {}, Me, je;
    function Bo() {
      throw new Error("setTimeout has not been defined");
    }
    function Po() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Me = setTimeout : Me = Bo;
      } catch {
        Me = Bo;
      }
      try {
        typeof clearTimeout == "function" ? je = clearTimeout : je = Po;
      } catch {
        je = Po;
      }
    })();
    function zl(e) {
      if (Me === setTimeout)
        return setTimeout(e, 0);
      if ((Me === Bo || !Me) && setTimeout)
        return Me = setTimeout, setTimeout(e, 0);
      try {
        return Me(e, 0);
      } catch {
        try {
          return Me.call(null, e, 0);
        } catch {
          return Me.call(this, e, 0);
        }
      }
    }
    function x0(e) {
      if (je === clearTimeout)
        return clearTimeout(e);
      if ((je === Po || !je) && clearTimeout)
        return je = clearTimeout, clearTimeout(e);
      try {
        return je(e);
      } catch {
        try {
          return je.call(null, e);
        } catch {
          return je.call(this, e);
        }
      }
    }
    var Ke = [], ar = false, Rt, Zn = -1;
    function R0() {
      !ar || !Rt || (ar = false, Rt.length ? Ke = Rt.concat(Ke) : Zn = -1, Ke.length && Wl());
    }
    function Wl() {
      if (!ar) {
        var e = zl(R0);
        ar = true;
        for (var t = Ke.length;t; ) {
          for (Rt = Ke, Ke = [];++Zn < t; )
            Rt && Rt[Zn].run();
          Zn = -1, t = Ke.length;
        }
        Rt = null, ar = false, x0(e);
      }
    }
    $3.nextTick = function(e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          t[r - 1] = arguments[r];
      Ke.push(new Zl(e, t)), Ke.length === 1 && !ar && zl(Wl);
    };
    function Zl(e, t) {
      this.fun = e, this.array = t;
    }
    Zl.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    $3.title = "browser";
    $3.browser = true;
    $3.env = {};
    $3.argv = [];
    $3.version = "";
    $3.versions = {};
    function Xe() {
    }
    $3.on = Xe;
    $3.addListener = Xe;
    $3.once = Xe;
    $3.off = Xe;
    $3.removeListener = Xe;
    $3.removeAllListeners = Xe;
    $3.emit = Xe;
    $3.prependListener = Xe;
    $3.prependOnceListener = Xe;
    $3.listeners = function(e) {
      return [];
    };
    $3.binding = function(e) {
      throw new Error("process.binding is not supported");
    };
    $3.cwd = function() {
      return "/";
    };
    $3.chdir = function(e) {
      throw new Error("process.chdir is not supported");
    };
    $3.umask = function() {
      return 0;
    };
  });
  ye = {};
  Bn(ye, { default: () => I0 });
  it = wo(() => {
    X3(ye, vt(Mo()));
    I0 = vt(Mo());
  });
  ot2 = g4((LA, nu) => {
    var { Symbol: $n, SymbolAsyncIterator: Gl, SymbolIterator: Hl } = V4(), Vl = $n("kDestroyed"), Yl = $n("kIsErrored"), jo = $n("kIsReadable"), Kl = $n("kIsDisturbed");
    function Gn(e, t = false) {
      var r;
      return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!e._writableState || e._readableState));
    }
    function Hn(e) {
      var t;
      return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === undefined ? undefined : t.writable) !== false));
    }
    function T0(e) {
      return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function It(e) {
      return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function O0(e, t) {
      return e == null ? false : t === true ? typeof e[Gl] == "function" : t === false ? typeof e[Hl] == "function" : typeof e[Gl] == "function" || typeof e[Hl] == "function";
    }
    function Vn(e) {
      if (!It(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !!(e.destroyed || e[Vl] || n != null && n.destroyed);
    }
    function Xl(e) {
      if (!Hn(e))
        return null;
      if (e.writableEnded === true)
        return true;
      let t = e._writableState;
      return t != null && t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function N0(e, t) {
      if (!Hn(e))
        return null;
      if (e.writableFinished === true)
        return true;
      let r = e._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || t === false && r.ended === true && r.length === 0);
    }
    function k0(e) {
      if (!Gn(e))
        return null;
      if (e.readableEnded === true)
        return true;
      let t = e._readableState;
      return !t || t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Jl(e, t) {
      if (!Gn(e))
        return null;
      let r = e._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || t === false && r.ended === true && r.length === 0);
    }
    function Ql(e) {
      return e && e[jo] != null ? e[jo] : typeof e?.readable != "boolean" ? null : Vn(e) ? false : Gn(e) && e.readable && !Jl(e);
    }
    function eu(e) {
      return typeof e?.writable != "boolean" ? null : Vn(e) ? false : Hn(e) && e.writable && !Xl(e);
    }
    function F0(e, t) {
      return It(e) ? Vn(e) ? true : !(t?.readable !== false && Ql(e) || t?.writable !== false && eu(e)) : null;
    }
    function L0(e) {
      var t, r;
      return It(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function D0(e) {
      var t, r;
      return It(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function B0(e) {
      if (!It(e))
        return null;
      if (typeof e.closed == "boolean")
        return e.closed;
      let { _writableState: t, _readableState: r } = e;
      return typeof t?.closed == "boolean" || typeof r?.closed == "boolean" ? t?.closed || r?.closed : typeof e._closed == "boolean" && tu(e) ? e._closed : null;
    }
    function tu(e) {
      return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function ru(e) {
      return typeof e._sent100 == "boolean" && tu(e);
    }
    function P0(e) {
      var t;
      return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === undefined ? undefined : t.upgradeOrConnect) === undefined;
    }
    function M0(e) {
      if (!It(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !n && ru(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === false);
    }
    function j0(e) {
      var t;
      return !!(e && ((t = e[Kl]) !== null && t !== undefined ? t : e.readableDidRead || e.readableAborted));
    }
    function U0(e) {
      var t, r, n, i, o2, a3, f3, u3, l3, s2;
      return !!(e && ((t = (r = (n = (i = (o2 = (a3 = e[Yl]) !== null && a3 !== undefined ? a3 : e.readableErrored) !== null && o2 !== undefined ? o2 : e.writableErrored) !== null && i !== undefined ? i : (f3 = e._readableState) === null || f3 === undefined ? undefined : f3.errorEmitted) !== null && n !== undefined ? n : (u3 = e._writableState) === null || u3 === undefined ? undefined : u3.errorEmitted) !== null && r !== undefined ? r : (l3 = e._readableState) === null || l3 === undefined ? undefined : l3.errored) !== null && t !== undefined ? t : (s2 = e._writableState) === null || s2 === undefined ? undefined : s2.errored));
    }
    nu.exports = { kDestroyed: Vl, isDisturbed: j0, kIsDisturbed: Kl, isErrored: U0, kIsErrored: Yl, isReadable: Ql, kIsReadable: jo, isClosed: B0, isDestroyed: Vn, isDuplexNodeStream: T0, isFinished: F0, isIterable: O0, isReadableNodeStream: Gn, isReadableEnded: k0, isReadableFinished: Jl, isReadableErrored: D0, isNodeStream: It, isWritable: eu, isWritableNodeStream: Hn, isWritableEnded: Xl, isWritableFinished: N0, isWritableErrored: L0, isServerRequest: P0, isServerResponse: ru, willEmitClose: M0 };
  });
  at2 = g4((DA, qo) => {
    var fr = (it(), se(ye)), { AbortError: q0, codes: C0 } = ne(), { ERR_INVALID_ARG_TYPE: z0, ERR_STREAM_PREMATURE_CLOSE: iu } = C0, { kEmptyObject: ou, once: au } = Pe2(), { validateAbortSignal: W0, validateFunction: Z0, validateObject: $0 } = Ur3(), { Promise: G0 } = V4(), { isClosed: H0, isReadable: fu, isReadableNodeStream: Uo, isReadableFinished: lu, isReadableErrored: V0, isWritable: uu, isWritableNodeStream: su, isWritableFinished: cu, isWritableErrored: Y0, isNodeStream: K0, willEmitClose: X0 } = ot2();
    function J0(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    var Q0 = () => {
    };
    function du(e, t, r) {
      var n, i;
      arguments.length === 2 ? (r = t, t = ou) : t == null ? t = ou : $0(t, "options"), Z0(r, "callback"), W0(t.signal, "options.signal"), r = au(r);
      let o2 = (n = t.readable) !== null && n !== undefined ? n : Uo(e), a3 = (i = t.writable) !== null && i !== undefined ? i : su(e);
      if (!K0(e))
        throw new z0("stream", "Stream", e);
      let { _writableState: f3, _readableState: u3 } = e, l3 = () => {
        e.writable || h5();
      }, s2 = X0(e) && Uo(e) === o2 && su(e) === a3, c2 = cu(e, false), h5 = () => {
        c2 = true, e.destroyed && (s2 = false), !(s2 && (!e.readable || o2)) && (!o2 || d4) && r.call(e);
      }, d4 = lu(e, false), y5 = () => {
        d4 = true, e.destroyed && (s2 = false), !(s2 && (!e.writable || a3)) && (!a3 || c2) && r.call(e);
      }, b4 = (A4) => {
        r.call(e, A4);
      }, R3 = H0(e), _4 = () => {
        R3 = true;
        let A4 = Y0(e) || V0(e);
        if (A4 && typeof A4 != "boolean")
          return r.call(e, A4);
        if (o2 && !d4 && Uo(e, true) && !lu(e, false))
          return r.call(e, new iu);
        if (a3 && !c2 && !cu(e, false))
          return r.call(e, new iu);
        r.call(e);
      }, E5 = () => {
        e.req.on("finish", h5);
      };
      J0(e) ? (e.on("complete", h5), s2 || e.on("abort", _4), e.req ? E5() : e.on("request", E5)) : a3 && !f3 && (e.on("end", l3), e.on("close", l3)), !s2 && typeof e.aborted == "boolean" && e.on("aborted", _4), e.on("end", y5), e.on("finish", h5), t.error !== false && e.on("error", b4), e.on("close", _4), R3 ? fr.nextTick(_4) : f3 != null && f3.errorEmitted || u3 != null && u3.errorEmitted ? s2 || fr.nextTick(_4) : (!o2 && (!s2 || fu(e)) && (c2 || uu(e) === false) || !a3 && (!s2 || uu(e)) && (d4 || fu(e) === false) || u3 && e.req && e.aborted) && fr.nextTick(_4);
      let m3 = () => {
        r = Q0, e.removeListener("aborted", _4), e.removeListener("complete", h5), e.removeListener("abort", _4), e.removeListener("request", E5), e.req && e.req.removeListener("finish", h5), e.removeListener("end", l3), e.removeListener("close", l3), e.removeListener("finish", h5), e.removeListener("end", y5), e.removeListener("error", b4), e.removeListener("close", _4);
      };
      if (t.signal && !R3) {
        let A4 = () => {
          let v4 = r;
          m3(), v4.call(e, new q0(undefined, { cause: t.signal.reason }));
        };
        if (t.signal.aborted)
          fr.nextTick(A4);
        else {
          let v4 = r;
          r = au((...T3) => {
            t.signal.removeEventListener("abort", A4), v4.apply(e, T3);
          }), t.signal.addEventListener("abort", A4);
        }
      }
      return m3;
    }
    function eg(e, t) {
      return new G0((r, n) => {
        du(e, t, (i) => {
          i ? n(i) : r();
        });
      });
    }
    qo.exports = du;
    qo.exports.finished = eg;
  });
  Eu = g4((BA, Wo) => {
    var _u = globalThis.AbortController || qn().AbortController, { codes: { ERR_INVALID_ARG_TYPE: qr, ERR_MISSING_ARGS: tg, ERR_OUT_OF_RANGE: rg }, AbortError: Ue } = ne(), { validateAbortSignal: lr, validateInteger: ng, validateObject: ur } = Ur3(), ig = V4().Symbol("kWeak"), { finished: og } = at2(), { ArrayPrototypePush: ag, MathFloor: fg, Number: lg, NumberIsNaN: ug, Promise: hu, PromiseReject: pu, PromisePrototypeThen: sg, Symbol: gu } = V4(), Yn = gu("kEmpty"), yu = gu("kEof");
    function Kn(e, t) {
      if (typeof e != "function")
        throw new qr("fn", ["Function", "AsyncFunction"], e);
      t != null && ur(t, "options"), t?.signal != null && lr(t.signal, "options.signal");
      let r = 1;
      return t?.concurrency != null && (r = fg(t.concurrency)), ng(r, "concurrency", 1), async function* () {
        var i, o2;
        let a3 = new _u, f3 = this, u3 = [], l3 = a3.signal, s2 = { signal: l3 }, c2 = () => a3.abort();
        t != null && (i = t.signal) !== null && i !== undefined && i.aborted && c2(), t == null || (o2 = t.signal) === null || o2 === undefined || o2.addEventListener("abort", c2);
        let h5, d4, y5 = false;
        function b4() {
          y5 = true;
        }
        async function R3() {
          try {
            for await (let m3 of f3) {
              var _4;
              if (y5)
                return;
              if (l3.aborted)
                throw new Ue;
              try {
                m3 = e(m3, s2);
              } catch (A4) {
                m3 = pu(A4);
              }
              m3 !== Yn && (typeof ((_4 = m3) === null || _4 === undefined ? undefined : _4.catch) == "function" && m3.catch(b4), u3.push(m3), h5 && (h5(), h5 = null), !y5 && u3.length && u3.length >= r && await new hu((A4) => {
                d4 = A4;
              }));
            }
            u3.push(yu);
          } catch (m3) {
            let A4 = pu(m3);
            sg(A4, undefined, b4), u3.push(A4);
          } finally {
            var E5;
            y5 = true, h5 && (h5(), h5 = null), t == null || (E5 = t.signal) === null || E5 === undefined || E5.removeEventListener("abort", c2);
          }
        }
        R3();
        try {
          for (;; ) {
            for (;u3.length > 0; ) {
              let _4 = await u3[0];
              if (_4 === yu)
                return;
              if (l3.aborted)
                throw new Ue;
              _4 !== Yn && (yield _4), u3.shift(), d4 && (d4(), d4 = null);
            }
            await new hu((_4) => {
              h5 = _4;
            });
          }
        } finally {
          a3.abort(), y5 = true, d4 && (d4(), d4 = null);
        }
      }.call(this);
    }
    function cg(e = undefined) {
      return e != null && ur(e, "options"), e?.signal != null && lr(e.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let i of this) {
          var n;
          if (e != null && (n = e.signal) !== null && n !== undefined && n.aborted)
            throw new Ue({ cause: e.signal.reason });
          yield [r++, i];
        }
      }.call(this);
    }
    async function bu(e, t = undefined) {
      for await (let r of zo.call(this, e, t))
        return true;
      return false;
    }
    async function dg(e, t = undefined) {
      if (typeof e != "function")
        throw new qr("fn", ["Function", "AsyncFunction"], e);
      return !await bu.call(this, async (...r) => !await e(...r), t);
    }
    async function hg(e, t) {
      for await (let r of zo.call(this, e, t))
        return r;
    }
    async function pg(e, t) {
      if (typeof e != "function")
        throw new qr("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i), Yn;
      }
      for await (let n of Kn.call(this, r, t))
        ;
    }
    function zo(e, t) {
      if (typeof e != "function")
        throw new qr("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i) ? n : Yn;
      }
      return Kn.call(this, r, t);
    }
    var Co = class extends tg {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function yg(e, t, r) {
      var n;
      if (typeof e != "function")
        throw new qr("reducer", ["Function", "AsyncFunction"], e);
      r != null && ur(r, "options"), r?.signal != null && lr(r.signal, "options.signal");
      let i = arguments.length > 1;
      if (r != null && (n = r.signal) !== null && n !== undefined && n.aborted) {
        let l3 = new Ue(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await og(this.destroy(l3)), l3;
      }
      let o2 = new _u, a3 = o2.signal;
      if (r != null && r.signal) {
        let l3 = { once: true, [ig]: this };
        r.signal.addEventListener("abort", () => o2.abort(), l3);
      }
      let f3 = false;
      try {
        for await (let l3 of this) {
          var u3;
          if (f3 = true, r != null && (u3 = r.signal) !== null && u3 !== undefined && u3.aborted)
            throw new Ue;
          i ? t = await e(t, l3, { signal: a3 }) : (t = l3, i = true);
        }
        if (!f3 && !i)
          throw new Co;
      } finally {
        o2.abort();
      }
      return t;
    }
    async function _g(e) {
      e != null && ur(e, "options"), e?.signal != null && lr(e.signal, "options.signal");
      let t = [];
      for await (let n of this) {
        var r;
        if (e != null && (r = e.signal) !== null && r !== undefined && r.aborted)
          throw new Ue(undefined, { cause: e.signal.reason });
        ag(t, n);
      }
      return t;
    }
    function gg(e, t) {
      let r = Kn.call(this, e, t);
      return async function* () {
        for await (let i of r)
          yield* i;
      }.call(this);
    }
    function wu(e) {
      if (e = lg(e), ug(e))
        return 0;
      if (e < 0)
        throw new rg("number", ">= 0", e);
      return e;
    }
    function bg(e, t = undefined) {
      return t != null && ur(t, "options"), t?.signal != null && lr(t.signal, "options.signal"), e = wu(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new Ue;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new Ue;
          e-- <= 0 && (yield o2);
        }
      }.call(this);
    }
    function wg(e, t = undefined) {
      return t != null && ur(t, "options"), t?.signal != null && lr(t.signal, "options.signal"), e = wu(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new Ue;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new Ue;
          if (e-- > 0)
            yield o2;
          else
            return;
        }
      }.call(this);
    }
    Wo.exports.streamReturningOperators = { asIndexedPairs: cg, drop: bg, filter: zo, flatMap: gg, map: Kn, take: wg };
    Wo.exports.promiseReturningOperators = { every: dg, forEach: pg, reduce: yg, toArray: _g, some: bu, find: hg };
  });
  Tt = g4((PA, Tu) => {
    var ft2 = (it(), se(ye)), { aggregateTwoErrors: Eg, codes: { ERR_MULTIPLE_CALLBACK: vg }, AbortError: mg } = ne(), { Symbol: Su } = V4(), { kDestroyed: Sg, isDestroyed: Ag, isFinished: xg, isServerRequest: Rg } = ot2(), Au = Su("kDestroy"), Zo = Su("kConstruct");
    function xu(e, t, r) {
      e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
    }
    function Ig(e, t) {
      let r = this._readableState, n = this._writableState, i = n || r;
      return n && n.destroyed || r && r.destroyed ? (typeof t == "function" && t(), this) : (xu(e, n, r), n && (n.destroyed = true), r && (r.destroyed = true), i.constructed ? vu(this, e, t) : this.once(Au, function(o2) {
        vu(this, Eg(o2, e), t);
      }), this);
    }
    function vu(e, t, r) {
      let n = false;
      function i(o2) {
        if (n)
          return;
        n = true;
        let { _readableState: a3, _writableState: f3 } = e;
        xu(o2, f3, a3), f3 && (f3.closed = true), a3 && (a3.closed = true), typeof r == "function" && r(o2), o2 ? ft2.nextTick(Tg, e, o2) : ft2.nextTick(Ru, e);
      }
      try {
        e._destroy(t || null, i);
      } catch (o2) {
        i(o2);
      }
    }
    function Tg(e, t) {
      $o(e, t), Ru(e);
    }
    function Ru(e) {
      let { _readableState: t, _writableState: r } = e;
      r && (r.closeEmitted = true), t && (t.closeEmitted = true), (r && r.emitClose || t && t.emitClose) && e.emit("close");
    }
    function $o(e, t) {
      let { _readableState: r, _writableState: n } = e;
      n && n.errorEmitted || r && r.errorEmitted || (n && (n.errorEmitted = true), r && (r.errorEmitted = true), e.emit("error", t));
    }
    function Og() {
      let e = this._readableState, t = this._writableState;
      e && (e.constructed = true, e.closed = false, e.closeEmitted = false, e.destroyed = false, e.errored = null, e.errorEmitted = false, e.reading = false, e.ended = e.readable === false, e.endEmitted = e.readable === false), t && (t.constructed = true, t.destroyed = false, t.closed = false, t.closeEmitted = false, t.errored = null, t.errorEmitted = false, t.finalCalled = false, t.prefinished = false, t.ended = t.writable === false, t.ending = t.writable === false, t.finished = t.writable === false);
    }
    function Go(e, t, r) {
      let { _readableState: n, _writableState: i } = e;
      if (i && i.destroyed || n && n.destroyed)
        return this;
      n && n.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), n && !n.errored && (n.errored = t), r ? ft2.nextTick($o, e, t) : $o(e, t));
    }
    function Ng(e, t) {
      if (typeof e._construct != "function")
        return;
      let { _readableState: r, _writableState: n } = e;
      r && (r.constructed = false), n && (n.constructed = false), e.once(Zo, t), !(e.listenerCount(Zo) > 1) && ft2.nextTick(kg, e);
    }
    function kg(e) {
      let t = false;
      function r(n) {
        if (t) {
          Go(e, n ?? new vg);
          return;
        }
        t = true;
        let { _readableState: i, _writableState: o2 } = e, a3 = o2 || i;
        i && (i.constructed = true), o2 && (o2.constructed = true), a3.destroyed ? e.emit(Au, n) : n ? Go(e, n, true) : ft2.nextTick(Fg, e);
      }
      try {
        e._construct(r);
      } catch (n) {
        r(n);
      }
    }
    function Fg(e) {
      e.emit(Zo);
    }
    function mu(e) {
      return e && e.setHeader && typeof e.abort == "function";
    }
    function Iu(e) {
      e.emit("close");
    }
    function Lg(e, t) {
      e.emit("error", t), ft2.nextTick(Iu, e);
    }
    function Dg(e, t) {
      !e || Ag(e) || (!t && !xg(e) && (t = new mg), Rg(e) ? (e.socket = null, e.destroy(t)) : mu(e) ? e.abort() : mu(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? ft2.nextTick(Lg, e, t) : ft2.nextTick(Iu, e), e.destroyed || (e[Sg] = true));
    }
    Tu.exports = { construct: Ng, destroyer: Dg, destroy: Ig, undestroy: Og, errorOrDestroy: Go };
  });
  Qn = g4((MA, Ho) => {
    var sr = typeof Reflect == "object" ? Reflect : null, Ou = sr && typeof sr.apply == "function" ? sr.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, Xn;
    sr && typeof sr.ownKeys == "function" ? Xn = sr.ownKeys : Object.getOwnPropertySymbols ? Xn = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : Xn = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function Bg(e) {
      console && console.warn && console.warn(e);
    }
    var ku = Number.isNaN || function(t) {
      return t !== t;
    };
    function U3() {
      U3.init.call(this);
    }
    Ho.exports = U3;
    Ho.exports.once = Ug;
    U3.EventEmitter = U3;
    U3.prototype._events = undefined;
    U3.prototype._eventsCount = 0;
    U3.prototype._maxListeners = undefined;
    var Nu = 10;
    function Jn(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(U3, "defaultMaxListeners", { enumerable: true, get: function() {
      return Nu;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || ku(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Nu = e;
    } });
    U3.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    U3.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || ku(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Fu(e) {
      return e._maxListeners === undefined ? U3.defaultMaxListeners : e._maxListeners;
    }
    U3.prototype.getMaxListeners = function() {
      return Fu(this);
    };
    U3.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a3;
        if (r.length > 0 && (a3 = r[0]), a3 instanceof Error)
          throw a3;
        var f3 = new Error("Unhandled error." + (a3 ? " (" + a3.message + ")" : ""));
        throw f3.context = a3, f3;
      }
      var u3 = o2[t];
      if (u3 === undefined)
        return false;
      if (typeof u3 == "function")
        Ou(u3, this, r);
      else
        for (var l3 = u3.length, s2 = Mu(u3, l3), n = 0;n < l3; ++n)
          Ou(s2[n], this, r);
      return true;
    };
    function Lu(e, t, r, n) {
      var i, o2, a3;
      if (Jn(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), a3 = o2[t]), a3 === undefined)
        a3 = o2[t] = r, ++e._eventsCount;
      else if (typeof a3 == "function" ? a3 = o2[t] = n ? [r, a3] : [a3, r] : n ? a3.unshift(r) : a3.push(r), i = Fu(e), i > 0 && a3.length > i && !a3.warned) {
        a3.warned = true;
        var f3 = new Error("Possible EventEmitter memory leak detected. " + a3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        f3.name = "MaxListenersExceededWarning", f3.emitter = e, f3.type = t, f3.count = a3.length, Bg(f3);
      }
      return e;
    }
    U3.prototype.addListener = function(t, r) {
      return Lu(this, t, r, false);
    };
    U3.prototype.on = U3.prototype.addListener;
    U3.prototype.prependListener = function(t, r) {
      return Lu(this, t, r, true);
    };
    function Pg() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Du(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = Pg.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    U3.prototype.once = function(t, r) {
      return Jn(r), this.on(t, Du(this, t, r)), this;
    };
    U3.prototype.prependOnceListener = function(t, r) {
      return Jn(r), this.prependListener(t, Du(this, t, r)), this;
    };
    U3.prototype.removeListener = function(t, r) {
      var n, i, o2, a3, f3;
      if (Jn(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, a3 = n.length - 1;a3 >= 0; a3--)
          if (n[a3] === r || n[a3].listener === r) {
            f3 = n[a3].listener, o2 = a3;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : Mg(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, f3 || r);
      }
      return this;
    };
    U3.prototype.off = U3.prototype.removeListener;
    U3.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), a3;
        for (i = 0;i < o2.length; ++i)
          a3 = o2[i], a3 !== "removeListener" && this.removeAllListeners(a3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Bu(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? jg(i) : Mu(i, i.length);
    }
    U3.prototype.listeners = function(t) {
      return Bu(this, t, true);
    };
    U3.prototype.rawListeners = function(t) {
      return Bu(this, t, false);
    };
    U3.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Pu.call(e, t);
    };
    U3.prototype.listenerCount = Pu;
    function Pu(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    U3.prototype.eventNames = function() {
      return this._eventsCount > 0 ? Xn(this._events) : [];
    };
    function Mu(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function Mg(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function jg(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function Ug(e, t) {
      return new Promise(function(r, n) {
        function i(a3) {
          e.removeListener(t, o2), n(a3);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        ju(e, t, o2, { once: true }), t !== "error" && qg(e, i, { once: true });
      });
    }
    function qg(e, t, r) {
      typeof e.on == "function" && ju(e, "error", t, r);
    }
    function ju(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  ri = g4((jA, qu) => {
    var { ArrayIsArray: Cg, ObjectSetPrototypeOf: Uu } = V4(), { EventEmitter: ei } = Qn();
    function ti(e) {
      ei.call(this, e);
    }
    Uu(ti.prototype, ei.prototype);
    Uu(ti, ei);
    ti.prototype.pipe = function(e, t) {
      let r = this;
      function n(s2) {
        e.writable && e.write(s2) === false && r.pause && r.pause();
      }
      r.on("data", n);
      function i() {
        r.readable && r.resume && r.resume();
      }
      e.on("drain", i), !e._isStdio && (!t || t.end !== false) && (r.on("end", a3), r.on("close", f3));
      let o2 = false;
      function a3() {
        o2 || (o2 = true, e.end());
      }
      function f3() {
        o2 || (o2 = true, typeof e.destroy == "function" && e.destroy());
      }
      function u3(s2) {
        l3(), ei.listenerCount(this, "error") === 0 && this.emit("error", s2);
      }
      Vo(r, "error", u3), Vo(e, "error", u3);
      function l3() {
        r.removeListener("data", n), e.removeListener("drain", i), r.removeListener("end", a3), r.removeListener("close", f3), r.removeListener("error", u3), e.removeListener("error", u3), r.removeListener("end", l3), r.removeListener("close", l3), e.removeListener("close", l3);
      }
      return r.on("end", l3), r.on("close", l3), e.on("close", l3), e.emit("pipe", r), e;
    };
    function Vo(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Cg(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    qu.exports = { Stream: ti, prependListener: Vo };
  });
  ii = g4((UA, ni) => {
    var { AbortError: zg, codes: Wg } = ne(), Zg = at2(), { ERR_INVALID_ARG_TYPE: Cu } = Wg, $g = (e, t) => {
      if (typeof e != "object" || !("aborted" in e))
        throw new Cu(t, "AbortSignal", e);
    };
    function Gg(e) {
      return !!(e && typeof e.pipe == "function");
    }
    ni.exports.addAbortSignal = function(t, r) {
      if ($g(t, "signal"), !Gg(r))
        throw new Cu("stream", "stream.Stream", r);
      return ni.exports.addAbortSignalNoValidate(t, r);
    };
    ni.exports.addAbortSignalNoValidate = function(e, t) {
      if (typeof e != "object" || !("aborted" in e))
        return t;
      let r = () => {
        t.destroy(new zg(undefined, { cause: e.reason }));
      };
      return e.aborted ? r() : (e.addEventListener("abort", r), Zg(t, () => e.removeEventListener("abort", r))), t;
    };
  });
  Zu = g4((CA, Wu) => {
    var { StringPrototypeSlice: zu, SymbolIterator: Hg, TypedArrayPrototypeSet: oi, Uint8Array: Vg } = V4(), { Buffer: Yo } = xe(), { inspect: Yg } = Pe2();
    Wu.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(t) {
        let r = { data: t, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(t) {
        let r = { data: t, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let t = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(t) {
        if (this.length === 0)
          return "";
        let r = this.head, n = "" + r.data;
        for (;(r = r.next) !== null; )
          n += t + r.data;
        return n;
      }
      concat(t) {
        if (this.length === 0)
          return Yo.alloc(0);
        let r = Yo.allocUnsafe(t >>> 0), n = this.head, i = 0;
        for (;n; )
          oi(r, n.data, i), i += n.data.length, n = n.next;
        return r;
      }
      consume(t, r) {
        let n = this.head.data;
        if (t < n.length) {
          let i = n.slice(0, t);
          return this.head.data = n.slice(t), i;
        }
        return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
      }
      first() {
        return this.head.data;
      }
      *[Hg]() {
        for (let t = this.head;t; t = t.next)
          yield t.data;
      }
      _getString(t) {
        let r = "", n = this.head, i = 0;
        do {
          let o2 = n.data;
          if (t > o2.length)
            r += o2, t -= o2.length;
          else {
            t === o2.length ? (r += o2, ++i, n.next ? this.head = n.next : this.head = this.tail = null) : (r += zu(o2, 0, t), this.head = n, n.data = zu(o2, t));
            break;
          }
          ++i;
        } while ((n = n.next) !== null);
        return this.length -= i, r;
      }
      _getBuffer(t) {
        let r = Yo.allocUnsafe(t), n = t, i = this.head, o2 = 0;
        do {
          let a3 = i.data;
          if (t > a3.length)
            oi(r, a3, n - t), t -= a3.length;
          else {
            t === a3.length ? (oi(r, a3, n - t), ++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (oi(r, new Vg(a3.buffer, a3.byteOffset, t), n - t), this.head = i, i.data = a3.slice(t));
            break;
          }
          ++o2;
        } while ((i = i.next) !== null);
        return this.length -= o2, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](t, r) {
        return Yg(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  ai = g4((zA, Gu) => {
    var { MathFloor: Kg, NumberIsInteger: Xg } = V4(), { ERR_INVALID_ARG_VALUE: Jg } = ne().codes;
    function Qg(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function $u(e) {
      return e ? 16 : 16 * 1024;
    }
    function eb(e, t, r, n) {
      let i = Qg(t, n, r);
      if (i != null) {
        if (!Xg(i) || i < 0) {
          let o2 = n ? `options.${r}` : "options.highWaterMark";
          throw new Jg(o2, i);
        }
        return Kg(i);
      }
      return $u(e.objectMode);
    }
    Gu.exports = { getHighWaterMark: eb, getDefaultHighWaterMark: $u };
  });
  Yu = g4((Ko, Vu) => {
    var fi = xe(), qe2 = fi.Buffer;
    function Hu(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    qe2.from && qe2.alloc && qe2.allocUnsafe && qe2.allocUnsafeSlow ? Vu.exports = fi : (Hu(fi, Ko), Ko.Buffer = Ot);
    function Ot(e, t, r) {
      return qe2(e, t, r);
    }
    Ot.prototype = Object.create(qe2.prototype);
    Hu(qe2, Ot);
    Ot.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return qe2(e, t, r);
    };
    Ot.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = qe2(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    Ot.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return qe2(e);
    };
    Ot.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return fi.SlowBuffer(e);
    };
  });
  Ju = g4((Xu) => {
    var Jo = Yu().Buffer, Ku = Jo.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function tb(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function rb(e) {
      var t = tb(e);
      if (typeof t != "string" && (Jo.isEncoding === Ku || !Ku(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    Xu.StringDecoder = Cr;
    function Cr(e) {
      this.encoding = rb(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = lb, this.end = ub, t = 4;
          break;
        case "utf8":
          this.fillLast = ob, t = 4;
          break;
        case "base64":
          this.text = sb, this.end = cb, t = 3;
          break;
        default:
          this.write = db, this.end = hb;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Jo.allocUnsafe(t);
    }
    Cr.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Cr.prototype.end = fb;
    Cr.prototype.text = ab;
    Cr.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function Xo(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function nb(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = Xo(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = Xo(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = Xo(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ib(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function ob(e) {
      var t = this.lastTotal - this.lastNeed, r = ib(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function ab(e, t) {
      var r = nb(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function fb(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function lb(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function ub(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function sb(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function cb(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function db(e) {
      return e.toString(this.encoding);
    }
    function hb(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Qo = g4((ZA, rs) => {
    var Qu = (it(), se(ye)), { PromisePrototypeThen: pb, SymbolAsyncIterator: es, SymbolIterator: ts } = V4(), { Buffer: yb } = xe(), { ERR_INVALID_ARG_TYPE: _b, ERR_STREAM_NULL_VALUES: gb } = ne().codes;
    function bb(e, t, r) {
      let n;
      if (typeof t == "string" || t instanceof yb)
        return new e({ objectMode: true, ...r, read() {
          this.push(t), this.push(null);
        } });
      let i;
      if (t && t[es])
        i = true, n = t[es]();
      else if (t && t[ts])
        i = false, n = t[ts]();
      else
        throw new _b("iterable", ["Iterable"], t);
      let o2 = new e({ objectMode: true, highWaterMark: 1, ...r }), a3 = false;
      o2._read = function() {
        a3 || (a3 = true, u3());
      }, o2._destroy = function(l3, s2) {
        pb(f3(l3), () => Qu.nextTick(s2, l3), (c2) => Qu.nextTick(s2, c2 || l3));
      };
      async function f3(l3) {
        let s2 = l3 != null, c2 = typeof n.throw == "function";
        if (s2 && c2) {
          let { value: h5, done: d4 } = await n.throw(l3);
          if (await h5, d4)
            return;
        }
        if (typeof n.return == "function") {
          let { value: h5 } = await n.return();
          await h5;
        }
      }
      async function u3() {
        for (;; ) {
          try {
            let { value: l3, done: s2 } = i ? await n.next() : n.next();
            if (s2)
              o2.push(null);
            else {
              let c2 = l3 && typeof l3.then == "function" ? await l3 : l3;
              if (c2 === null)
                throw a3 = false, new gb;
              if (o2.push(c2))
                continue;
              a3 = false;
            }
          } catch (l3) {
            o2.destroy(l3);
          }
          break;
        }
      }
      return o2;
    }
    rs.exports = bb;
  });
  zr = g4(($A, ys) => {
    var Ie = (it(), se(ye)), { ArrayPrototypeIndexOf: wb, NumberIsInteger: Eb, NumberIsNaN: vb, NumberParseInt: mb, ObjectDefineProperties: os, ObjectKeys: Sb, ObjectSetPrototypeOf: as, Promise: Ab, SafeSet: xb, SymbolAsyncIterator: Rb, Symbol: Ib } = V4();
    ys.exports = F2;
    F2.ReadableState = oa;
    var { EventEmitter: Tb } = Qn(), { Stream: lt3, prependListener: Ob } = ri(), { Buffer: ea } = xe(), { addAbortSignal: Nb } = ii(), kb = at2(), B3 = Pe2().debuglog("stream", (e) => {
      B3 = e;
    }), Fb = Zu(), dr2 = Tt(), { getHighWaterMark: Lb, getDefaultHighWaterMark: Db } = ai(), { aggregateTwoErrors: ns, codes: { ERR_INVALID_ARG_TYPE: Bb, ERR_METHOD_NOT_IMPLEMENTED: Pb, ERR_OUT_OF_RANGE: Mb, ERR_STREAM_PUSH_AFTER_EOF: jb, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: Ub } } = ne(), { validateObject: qb } = Ur3(), Nt = Ib("kPaused"), { StringDecoder: fs } = Ju(), Cb = Qo();
    as(F2.prototype, lt3.prototype);
    as(F2, lt3);
    var ta = () => {
    }, { errorOrDestroy: cr } = dr2;
    function oa(e, t, r) {
      typeof r != "boolean" && (r = t instanceof Ce()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? Lb(this, e, "readableHighWaterMark", r) : Db(false), this.buffer = new Fb, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[Nt] = null, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new fs(e.encoding), this.encoding = e.encoding);
    }
    function F2(e) {
      if (!(this instanceof F2))
        return new F2(e);
      let t = this instanceof Ce();
      this._readableState = new oa(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && Nb(e.signal, this)), lt3.call(this, e), dr2.construct(this, () => {
        this._readableState.needReadable && li(this, this._readableState);
      });
    }
    F2.prototype.destroy = dr2.destroy;
    F2.prototype._undestroy = dr2.undestroy;
    F2.prototype._destroy = function(e, t) {
      t(e);
    };
    F2.prototype[Tb.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    F2.prototype.push = function(e, t) {
      return ls(this, e, t, false);
    };
    F2.prototype.unshift = function(e, t) {
      return ls(this, e, t, true);
    };
    function ls(e, t, r, n) {
      B3("readableAddChunk", t);
      let i = e._readableState, o2;
      if (i.objectMode || (typeof t == "string" ? (r = r || i.defaultEncoding, i.encoding !== r && (n && i.encoding ? t = ea.from(t, r).toString(i.encoding) : (t = ea.from(t, r), r = ""))) : t instanceof ea ? r = "" : lt3._isUint8Array(t) ? (t = lt3._uint8ArrayToBuffer(t), r = "") : t != null && (o2 = new Bb("chunk", ["string", "Buffer", "Uint8Array"], t))), o2)
        cr(e, o2);
      else if (t === null)
        i.reading = false, Zb(e, i);
      else if (i.objectMode || t && t.length > 0)
        if (n)
          if (i.endEmitted)
            cr(e, new Ub);
          else {
            if (i.destroyed || i.errored)
              return false;
            ra(e, i, t, true);
          }
        else if (i.ended)
          cr(e, new jb);
        else {
          if (i.destroyed || i.errored)
            return false;
          i.reading = false, i.decoder && !r ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? ra(e, i, t, false) : li(e, i)) : ra(e, i, t, false);
        }
      else
        n || (i.reading = false, li(e, i));
      return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function ra(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = true, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ui(e)), li(e, t);
    }
    F2.prototype.isPaused = function() {
      let e = this._readableState;
      return e[Nt] === true || e.flowing === false;
    };
    F2.prototype.setEncoding = function(e) {
      let t = new fs(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, n = "";
      for (let i of r)
        n += t.write(i);
      return r.clear(), n !== "" && r.push(n), this._readableState.length = n.length, this;
    };
    var zb = 1073741824;
    function Wb(e) {
      if (e > zb)
        throw new Mb("size", "<= 1GiB", e);
      return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function is(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : vb(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    F2.prototype.read = function(e) {
      B3("read", e), e === undefined ? e = NaN : Eb(e) || (e = mb(e, 10));
      let t = this._readableState, r = e;
      if (e > t.highWaterMark && (t.highWaterMark = Wb(e)), e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return B3("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? na(this) : ui(this), null;
      if (e = is(e, t), e === 0 && t.ended)
        return t.length === 0 && na(this), null;
      let n = t.needReadable;
      if (B3("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, B3("length less than watermark", n)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
        n = false, B3("reading, ended or constructing", n);
      else if (n) {
        B3("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true);
        try {
          this._read(t.highWaterMark);
        } catch (o2) {
          cr(this, o2);
        }
        t.sync = false, t.reading || (e = is(r, t));
      }
      let i;
      return e > 0 ? i = hs(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && na(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = true, this.emit("data", i)), i;
    };
    function Zb(e, t) {
      if (B3("onEofChunk"), !t.ended) {
        if (t.decoder) {
          let r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ui(e) : (t.needReadable = false, t.emittedReadable = true, us(e));
      }
    }
    function ui(e) {
      let t = e._readableState;
      B3("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (B3("emitReadable", t.flowing), t.emittedReadable = true, Ie.nextTick(us, e));
    }
    function us(e) {
      let t = e._readableState;
      B3("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, cs(e);
    }
    function li(e, t) {
      !t.readingMore && t.constructed && (t.readingMore = true, Ie.nextTick($b, e, t));
    }
    function $b(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        let r = t.length;
        if (B3("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    F2.prototype._read = function(e) {
      throw new Pb("_read()");
    };
    F2.prototype.pipe = function(e, t) {
      let r = this, n = this._readableState;
      n.pipes.length === 1 && (n.multiAwaitDrain || (n.multiAwaitDrain = true, n.awaitDrainWriters = new xb(n.awaitDrainWriters ? [n.awaitDrainWriters] : []))), n.pipes.push(e), B3("pipe count=%d opts=%j", n.pipes.length, t);
      let o2 = (!t || t.end !== false) && e !== Ie.stdout && e !== Ie.stderr ? f3 : R3;
      n.endEmitted ? Ie.nextTick(o2) : r.once("end", o2), e.on("unpipe", a3);
      function a3(_4, E5) {
        B3("onunpipe"), _4 === r && E5 && E5.hasUnpiped === false && (E5.hasUnpiped = true, s2());
      }
      function f3() {
        B3("onend"), e.end();
      }
      let u3, l3 = false;
      function s2() {
        B3("cleanup"), e.removeListener("close", y5), e.removeListener("finish", b4), u3 && e.removeListener("drain", u3), e.removeListener("error", d4), e.removeListener("unpipe", a3), r.removeListener("end", f3), r.removeListener("end", R3), r.removeListener("data", h5), l3 = true, u3 && n.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && u3();
      }
      function c2() {
        l3 || (n.pipes.length === 1 && n.pipes[0] === e ? (B3("false write response, pause", 0), n.awaitDrainWriters = e, n.multiAwaitDrain = false) : n.pipes.length > 1 && n.pipes.includes(e) && (B3("false write response, pause", n.awaitDrainWriters.size), n.awaitDrainWriters.add(e)), r.pause()), u3 || (u3 = Gb(r, e), e.on("drain", u3));
      }
      r.on("data", h5);
      function h5(_4) {
        B3("ondata");
        let E5 = e.write(_4);
        B3("dest.write", E5), E5 === false && c2();
      }
      function d4(_4) {
        if (B3("onerror", _4), R3(), e.removeListener("error", d4), e.listenerCount("error") === 0) {
          let E5 = e._writableState || e._readableState;
          E5 && !E5.errorEmitted ? cr(e, _4) : e.emit("error", _4);
        }
      }
      Ob(e, "error", d4);
      function y5() {
        e.removeListener("finish", b4), R3();
      }
      e.once("close", y5);
      function b4() {
        B3("onfinish"), e.removeListener("close", y5), R3();
      }
      e.once("finish", b4);
      function R3() {
        B3("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), e.writableNeedDrain === true ? n.flowing && c2() : n.flowing || (B3("pipe resume"), r.resume()), e;
    };
    function Gb(e, t) {
      return function() {
        let n = e._readableState;
        n.awaitDrainWriters === t ? (B3("pipeOnDrain", 1), n.awaitDrainWriters = null) : n.multiAwaitDrain && (B3("pipeOnDrain", n.awaitDrainWriters.size), n.awaitDrainWriters.delete(t)), (!n.awaitDrainWriters || n.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
      };
    }
    F2.prototype.unpipe = function(e) {
      let t = this._readableState, r = { hasUnpiped: false };
      if (t.pipes.length === 0)
        return this;
      if (!e) {
        let i = t.pipes;
        t.pipes = [], this.pause();
        for (let o2 = 0;o2 < i.length; o2++)
          i[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let n = wb(t.pipes, e);
      return n === -1 ? this : (t.pipes.splice(n, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, r), this);
    };
    F2.prototype.on = function(e, t) {
      let r = lt3.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, B3("on readable", n.length, n.reading), n.length ? ui(this) : n.reading || Ie.nextTick(Hb, this)), r;
    };
    F2.prototype.addListener = F2.prototype.on;
    F2.prototype.removeListener = function(e, t) {
      let r = lt3.prototype.removeListener.call(this, e, t);
      return e === "readable" && Ie.nextTick(ss, this), r;
    };
    F2.prototype.off = F2.prototype.removeListener;
    F2.prototype.removeAllListeners = function(e) {
      let t = lt3.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && Ie.nextTick(ss, this), t;
    };
    function ss(e) {
      let t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[Nt] === false ? t.flowing = true : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function Hb(e) {
      B3("readable nexttick read 0"), e.read(0);
    }
    F2.prototype.resume = function() {
      let e = this._readableState;
      return e.flowing || (B3("resume"), e.flowing = !e.readableListening, Vb(this, e)), e[Nt] = false, this;
    };
    function Vb(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, Ie.nextTick(Yb, e, t));
    }
    function Yb(e, t) {
      B3("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), cs(e), t.flowing && !t.reading && e.read(0);
    }
    F2.prototype.pause = function() {
      return B3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (B3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[Nt] = true, this;
    };
    function cs(e) {
      let t = e._readableState;
      for (B3("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    F2.prototype.wrap = function(e) {
      let t = false;
      e.on("data", (n) => {
        !this.push(n) && e.pause && (t = true, e.pause());
      }), e.on("end", () => {
        this.push(null);
      }), e.on("error", (n) => {
        cr(this, n);
      }), e.on("close", () => {
        this.destroy();
      }), e.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        t && e.resume && (t = false, e.resume());
      };
      let r = Sb(e);
      for (let n = 1;n < r.length; n++) {
        let i = r[n];
        this[i] === undefined && typeof e[i] == "function" && (this[i] = e[i].bind(e));
      }
      return this;
    };
    F2.prototype[Rb] = function() {
      return ds(this);
    };
    F2.prototype.iterator = function(e) {
      return e !== undefined && qb(e, "options"), ds(this, e);
    };
    function ds(e, t) {
      typeof e.read != "function" && (e = F2.wrap(e, { objectMode: true }));
      let r = Kb(e, t);
      return r.stream = e, r;
    }
    async function* Kb(e, t) {
      let r = ta;
      function n(a3) {
        this === e ? (r(), r = ta) : r = a3;
      }
      e.on("readable", n);
      let i, o2 = kb(e, { writable: false }, (a3) => {
        i = a3 ? ns(i, a3) : null, r(), r = ta;
      });
      try {
        for (;; ) {
          let a3 = e.destroyed ? null : e.read();
          if (a3 !== null)
            yield a3;
          else {
            if (i)
              throw i;
            if (i === null)
              return;
            await new Ab(n);
          }
        }
      } catch (a3) {
        throw i = ns(i, a3), i;
      } finally {
        (i || t?.destroyOnReturn !== false) && (i === undefined || e._readableState.autoDestroy) ? dr2.destroyer(e, null) : (e.off("readable", n), o2());
      }
    }
    os(F2.prototype, { readable: { __proto__: null, get() {
      let e = this._readableState;
      return !!e && e.readable !== false && !e.destroyed && !e.errorEmitted && !e.endEmitted;
    }, set(e) {
      this._readableState && (this._readableState.readable = !!e);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    os(oa.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[Nt] !== false;
    }, set(e) {
      this[Nt] = !!e;
    } } });
    F2._fromList = hs;
    function hs(e, t) {
      if (t.length === 0)
        return null;
      let r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function na(e) {
      let t = e._readableState;
      B3("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, Ie.nextTick(Xb, t, e));
    }
    function Xb(e, t) {
      if (B3("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
        if (e.endEmitted = true, t.emit("end"), t.writable && t.allowHalfOpen === false)
          Ie.nextTick(Jb, t);
        else if (e.autoDestroy) {
          let r = t._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && t.destroy();
        }
      }
    }
    function Jb(e) {
      e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    F2.from = function(e, t) {
      return Cb(F2, e, t);
    };
    var ia;
    function ps() {
      return ia === undefined && (ia = {}), ia;
    }
    F2.fromWeb = function(e, t) {
      return ps().newStreamReadableFromReadableStream(e, t);
    };
    F2.toWeb = function(e, t) {
      return ps().newReadableStreamFromStreamReadable(e, t);
    };
    F2.wrap = function(e, t) {
      var r, n;
      return new F2({ objectMode: (r = (n = e.readableObjectMode) !== null && n !== undefined ? n : e.objectMode) !== null && r !== undefined ? r : true, ...t, destroy(i, o2) {
        dr2.destroyer(e, i), o2(i);
      } }).wrap(e);
    };
  });
  da = g4((GA, Is) => {
    var kt = (it(), se(ye)), { ArrayPrototypeSlice: bs, Error: Qb, FunctionPrototypeSymbolHasInstance: ws, ObjectDefineProperty: Es, ObjectDefineProperties: ew, ObjectSetPrototypeOf: vs, StringPrototypeToLowerCase: tw, Symbol: rw, SymbolHasInstance: nw } = V4();
    Is.exports = W;
    W.WritableState = $r;
    var { EventEmitter: iw } = Qn(), Wr = ri().Stream, { Buffer: si } = xe(), hi = Tt(), { addAbortSignal: ow } = ii(), { getHighWaterMark: aw, getDefaultHighWaterMark: fw } = ai(), { ERR_INVALID_ARG_TYPE: lw, ERR_METHOD_NOT_IMPLEMENTED: uw, ERR_MULTIPLE_CALLBACK: ms, ERR_STREAM_CANNOT_PIPE: sw, ERR_STREAM_DESTROYED: Zr2, ERR_STREAM_ALREADY_FINISHED: cw, ERR_STREAM_NULL_VALUES: dw, ERR_STREAM_WRITE_AFTER_END: hw, ERR_UNKNOWN_ENCODING: Ss } = ne().codes, { errorOrDestroy: hr } = hi;
    vs(W.prototype, Wr.prototype);
    vs(W, Wr);
    function la() {
    }
    var pr = rw("kOnFinished");
    function $r(e, t, r) {
      typeof r != "boolean" && (r = t instanceof Ce()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? aw(this, e, "writableHighWaterMark", r) : fw(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let n = !!(e && e.decodeStrings === false);
      this.decodeStrings = !n, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yw.bind(undefined, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, di(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[pr] = [];
    }
    function di(e) {
      e.buffered = [], e.bufferedIndex = 0, e.allBuffers = true, e.allNoop = true;
    }
    $r.prototype.getBuffer = function() {
      return bs(this.buffered, this.bufferedIndex);
    };
    Es($r.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function W(e) {
      let t = this instanceof Ce();
      if (!t && !ws(W, this))
        return new W(e);
      this._writableState = new $r(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && ow(e.signal, this)), Wr.call(this, e), hi.construct(this, () => {
        let r = this._writableState;
        r.writing || sa(this, r), ca(this, r);
      });
    }
    Es(W, nw, { __proto__: null, value: function(e) {
      return ws(this, e) ? true : this !== W ? false : e && e._writableState instanceof $r;
    } });
    W.prototype.pipe = function() {
      hr(this, new sw);
    };
    function As(e, t, r, n) {
      let i = e._writableState;
      if (typeof r == "function")
        n = r, r = i.defaultEncoding;
      else {
        if (!r)
          r = i.defaultEncoding;
        else if (r !== "buffer" && !si.isEncoding(r))
          throw new Ss(r);
        typeof n != "function" && (n = la);
      }
      if (t === null)
        throw new dw;
      if (!i.objectMode)
        if (typeof t == "string")
          i.decodeStrings !== false && (t = si.from(t, r), r = "buffer");
        else if (t instanceof si)
          r = "buffer";
        else if (Wr._isUint8Array(t))
          t = Wr._uint8ArrayToBuffer(t), r = "buffer";
        else
          throw new lw("chunk", ["string", "Buffer", "Uint8Array"], t);
      let o2;
      return i.ending ? o2 = new hw : i.destroyed && (o2 = new Zr2("write")), o2 ? (kt.nextTick(n, o2), hr(e, o2, true), o2) : (i.pendingcb++, pw(e, i, t, r, n));
    }
    W.prototype.write = function(e, t, r) {
      return As(this, e, t, r) === true;
    };
    W.prototype.cork = function() {
      this._writableState.corked++;
    };
    W.prototype.uncork = function() {
      let e = this._writableState;
      e.corked && (e.corked--, e.writing || sa(this, e));
    };
    W.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = tw(t)), !si.isEncoding(t))
        throw new Ss(t);
      return this._writableState.defaultEncoding = t, this;
    };
    function pw(e, t, r, n, i) {
      let o2 = t.objectMode ? 1 : r.length;
      t.length += o2;
      let a3 = t.length < t.highWaterMark;
      return a3 || (t.needDrain = true), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({ chunk: r, encoding: n, callback: i }), t.allBuffers && n !== "buffer" && (t.allBuffers = false), t.allNoop && i !== la && (t.allNoop = false)) : (t.writelen = o2, t.writecb = i, t.writing = true, t.sync = true, e._write(r, n, t.onwrite), t.sync = false), a3 && !t.errored && !t.destroyed;
    }
    function _s(e, t, r, n, i, o2, a3) {
      t.writelen = n, t.writecb = a3, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new Zr2("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function gs(e, t, r, n) {
      --t.pendingcb, n(r), ua(t), hr(e, r);
    }
    function yw(e, t) {
      let r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function") {
        hr(e, new ms);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, t ? (t.stack, r.errored || (r.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), n ? kt.nextTick(gs, e, r, t, i) : gs(e, r, t, i)) : (r.buffered.length > r.bufferedIndex && sa(e, r), n ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === i ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: i, stream: e, state: r }, kt.nextTick(_w, r.afterWriteTickInfo)) : xs(e, r, 1, i));
    }
    function _w({ stream: e, state: t, count: r, cb: n }) {
      return t.afterWriteTickInfo = null, xs(e, t, r, n);
    }
    function xs(e, t, r, n) {
      for (!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));r-- > 0; )
        t.pendingcb--, n();
      t.destroyed && ua(t), ca(e, t);
    }
    function ua(e) {
      if (e.writing)
        return;
      for (let i = e.bufferedIndex;i < e.buffered.length; ++i) {
        var t;
        let { chunk: o2, callback: a3 } = e.buffered[i], f3 = e.objectMode ? 1 : o2.length;
        e.length -= f3, a3((t = e.errored) !== null && t !== undefined ? t : new Zr2("write"));
      }
      let r = e[pr].splice(0);
      for (let i = 0;i < r.length; i++) {
        var n;
        r[i]((n = e.errored) !== null && n !== undefined ? n : new Zr2("end"));
      }
      di(e);
    }
    function sa(e, t) {
      if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
        return;
      let { buffered: r, bufferedIndex: n, objectMode: i } = t, o2 = r.length - n;
      if (!o2)
        return;
      let a3 = n;
      if (t.bufferProcessing = true, o2 > 1 && e._writev) {
        t.pendingcb -= o2 - 1;
        let f3 = t.allNoop ? la : (l3) => {
          for (let s2 = a3;s2 < r.length; ++s2)
            r[s2].callback(l3);
        }, u3 = t.allNoop && a3 === 0 ? r : bs(r, a3);
        u3.allBuffers = t.allBuffers, _s(e, t, true, t.length, u3, "", f3), di(t);
      } else {
        do {
          let { chunk: f3, encoding: u3, callback: l3 } = r[a3];
          r[a3++] = null;
          let s2 = i ? 1 : f3.length;
          _s(e, t, false, s2, f3, u3, l3);
        } while (a3 < r.length && !t.writing);
        a3 === r.length ? di(t) : a3 > 256 ? (r.splice(0, a3), t.bufferedIndex = 0) : t.bufferedIndex = a3;
      }
      t.bufferProcessing = false;
    }
    W.prototype._write = function(e, t, r) {
      if (this._writev)
        this._writev([{ chunk: e, encoding: t }], r);
      else
        throw new uw("_write()");
    };
    W.prototype._writev = null;
    W.prototype.end = function(e, t, r) {
      let n = this._writableState;
      typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null);
      let i;
      if (e != null) {
        let o2 = As(this, e, t);
        o2 instanceof Qb && (i = o2);
      }
      return n.corked && (n.corked = 1, this.uncork()), i || (!n.errored && !n.ending ? (n.ending = true, ca(this, n, true), n.ended = true) : n.finished ? i = new cw("end") : n.destroyed && (i = new Zr2("end"))), typeof r == "function" && (i || n.finished ? kt.nextTick(r, i) : n[pr].push(r)), this;
    };
    function ci(e) {
      return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function gw(e, t) {
      let r = false;
      function n(i) {
        if (r) {
          hr(e, i ?? ms());
          return;
        }
        if (r = true, t.pendingcb--, i) {
          let o2 = t[pr].splice(0);
          for (let a3 = 0;a3 < o2.length; a3++)
            o2[a3](i);
          hr(e, i, t.sync);
        } else
          ci(t) && (t.prefinished = true, e.emit("prefinish"), t.pendingcb++, kt.nextTick(fa, e, t));
      }
      t.sync = true, t.pendingcb++;
      try {
        e._final(n);
      } catch (i) {
        n(i);
      }
      t.sync = false;
    }
    function bw(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = true, gw(e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function ca(e, t, r) {
      ci(t) && (bw(e, t), t.pendingcb === 0 && (r ? (t.pendingcb++, kt.nextTick((n, i) => {
        ci(i) ? fa(n, i) : i.pendingcb--;
      }, e, t)) : ci(t) && (t.pendingcb++, fa(e, t))));
    }
    function fa(e, t) {
      t.pendingcb--, t.finished = true;
      let r = t[pr].splice(0);
      for (let n = 0;n < r.length; n++)
        r[n]();
      if (e.emit("finish"), t.autoDestroy) {
        let n = e._readableState;
        (!n || n.autoDestroy && (n.endEmitted || n.readable === false)) && e.destroy();
      }
    }
    ew(W.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(e) {
      this._writableState && (this._writableState.destroyed = e);
    } }, writable: { __proto__: null, get() {
      let e = this._writableState;
      return !!e && e.writable !== false && !e.destroyed && !e.errored && !e.ending && !e.ended;
    }, set(e) {
      this._writableState && (this._writableState.writable = !!e);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let e = this._writableState;
      return e ? !e.destroyed && !e.ending && e.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var ww = hi.destroy;
    W.prototype.destroy = function(e, t) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[pr].length) && kt.nextTick(ua, r), ww.call(this, e, t), this;
    };
    W.prototype._undestroy = hi.undestroy;
    W.prototype._destroy = function(e, t) {
      t(e);
    };
    W.prototype[iw.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    var aa;
    function Rs() {
      return aa === undefined && (aa = {}), aa;
    }
    W.fromWeb = function(e, t) {
      return Rs().newStreamWritableFromWritableStream(e, t);
    };
    W.toWeb = function(e) {
      return Rs().newWritableStreamFromStreamWritable(e);
    };
  });
  Us = g4((HA, js) => {
    var ha = (it(), se(ye)), Ew = xe(), { isReadable: vw, isWritable: mw, isIterable: Ts, isNodeStream: Sw, isReadableNodeStream: Os, isWritableNodeStream: Ns, isDuplexNodeStream: Aw } = ot2(), ks = at2(), { AbortError: Ms, codes: { ERR_INVALID_ARG_TYPE: xw, ERR_INVALID_RETURN_VALUE: Fs } } = ne(), { destroyer: yr } = Tt(), Rw = Ce(), Iw = zr(), { createDeferredPromise: Ls } = Pe2(), Ds = Qo(), Bs = globalThis.Blob || Ew.Blob, Tw = typeof Bs < "u" ? function(t) {
      return t instanceof Bs;
    } : function(t) {
      return false;
    }, Ow = globalThis.AbortController || qn().AbortController, { FunctionPrototypeCall: Ps } = V4(), Ft = class extends Rw {
      constructor(t) {
        super(t), t?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    js.exports = function e(t, r) {
      if (Aw(t))
        return t;
      if (Os(t))
        return pi({ readable: t });
      if (Ns(t))
        return pi({ writable: t });
      if (Sw(t))
        return pi({ writable: false, readable: false });
      if (typeof t == "function") {
        let { value: i, write: o2, final: a3, destroy: f3 } = Nw(t);
        if (Ts(i))
          return Ds(Ft, i, { objectMode: true, write: o2, final: a3, destroy: f3 });
        let u3 = i?.then;
        if (typeof u3 == "function") {
          let l3, s2 = Ps(u3, i, (c2) => {
            if (c2 != null)
              throw new Fs("nully", "body", c2);
          }, (c2) => {
            yr(l3, c2);
          });
          return l3 = new Ft({ objectMode: true, readable: false, write: o2, final(c2) {
            a3(async () => {
              try {
                await s2, ha.nextTick(c2, null);
              } catch (h5) {
                ha.nextTick(c2, h5);
              }
            });
          }, destroy: f3 });
        }
        throw new Fs("Iterable, AsyncIterable or AsyncFunction", r, i);
      }
      if (Tw(t))
        return e(t.arrayBuffer());
      if (Ts(t))
        return Ds(Ft, t, { objectMode: true, writable: false });
      if (typeof t?.writable == "object" || typeof t?.readable == "object") {
        let i = t != null && t.readable ? Os(t?.readable) ? t?.readable : e(t.readable) : undefined, o2 = t != null && t.writable ? Ns(t?.writable) ? t?.writable : e(t.writable) : undefined;
        return pi({ readable: i, writable: o2 });
      }
      let n = t?.then;
      if (typeof n == "function") {
        let i;
        return Ps(n, t, (o2) => {
          o2 != null && i.push(o2), i.push(null);
        }, (o2) => {
          yr(i, o2);
        }), i = new Ft({ objectMode: true, writable: false, read() {
        } });
      }
      throw new xw(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t);
    };
    function Nw(e) {
      let { promise: t, resolve: r } = Ls(), n = new Ow, i = n.signal;
      return { value: e(async function* () {
        for (;; ) {
          let a3 = t;
          t = null;
          let { chunk: f3, done: u3, cb: l3 } = await a3;
          if (ha.nextTick(l3), u3)
            return;
          if (i.aborted)
            throw new Ms(undefined, { cause: i.reason });
          ({ promise: t, resolve: r } = Ls()), yield f3;
        }
      }(), { signal: i }), write(a3, f3, u3) {
        let l3 = r;
        r = null, l3({ chunk: a3, done: false, cb: u3 });
      }, final(a3) {
        let f3 = r;
        r = null, f3({ done: true, cb: a3 });
      }, destroy(a3, f3) {
        n.abort(), f3(a3);
      } };
    }
    function pi(e) {
      let t = e.readable && typeof e.readable.read != "function" ? Iw.wrap(e.readable) : e.readable, r = e.writable, n = !!vw(t), i = !!mw(r), o2, a3, f3, u3, l3;
      function s2(c2) {
        let h5 = u3;
        u3 = null, h5 ? h5(c2) : c2 ? l3.destroy(c2) : !n && !i && l3.destroy();
      }
      return l3 = new Ft({ readableObjectMode: !!(t != null && t.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: n, writable: i }), i && (ks(r, (c2) => {
        i = false, c2 && yr(t, c2), s2(c2);
      }), l3._write = function(c2, h5, d4) {
        r.write(c2, h5) ? d4() : o2 = d4;
      }, l3._final = function(c2) {
        r.end(), a3 = c2;
      }, r.on("drain", function() {
        if (o2) {
          let c2 = o2;
          o2 = null, c2();
        }
      }), r.on("finish", function() {
        if (a3) {
          let c2 = a3;
          a3 = null, c2();
        }
      })), n && (ks(t, (c2) => {
        n = false, c2 && yr(t, c2), s2(c2);
      }), t.on("readable", function() {
        if (f3) {
          let c2 = f3;
          f3 = null, c2();
        }
      }), t.on("end", function() {
        l3.push(null);
      }), l3._read = function() {
        for (;; ) {
          let c2 = t.read();
          if (c2 === null) {
            f3 = l3._read;
            return;
          }
          if (!l3.push(c2))
            return;
        }
      }), l3._destroy = function(c2, h5) {
        !c2 && u3 !== null && (c2 = new Ms), f3 = null, o2 = null, a3 = null, u3 === null ? h5(c2) : (u3 = h5, yr(r, c2), yr(t, c2));
      }, l3;
    }
  });
  Ce = g4((VA, zs) => {
    var { ObjectDefineProperties: kw, ObjectGetOwnPropertyDescriptor: Je, ObjectKeys: Fw, ObjectSetPrototypeOf: qs } = V4();
    zs.exports = Te;
    var _a = zr(), _e = da();
    qs(Te.prototype, _a.prototype);
    qs(Te, _a);
    {
      let e = Fw(_e.prototype);
      for (let t = 0;t < e.length; t++) {
        let r = e[t];
        Te.prototype[r] || (Te.prototype[r] = _e.prototype[r]);
      }
    }
    function Te(e) {
      if (!(this instanceof Te))
        return new Te(e);
      _a.call(this, e), _e.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== false, e.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    kw(Te.prototype, { writable: { __proto__: null, ...Je(_e.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...Je(_e.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...Je(_e.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...Je(_e.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...Je(_e.prototype, "writableLength") }, writableFinished: { __proto__: null, ...Je(_e.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...Je(_e.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...Je(_e.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...Je(_e.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(e) {
      this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } } });
    var pa;
    function Cs() {
      return pa === undefined && (pa = {}), pa;
    }
    Te.fromWeb = function(e, t) {
      return Cs().newStreamDuplexFromReadableWritablePair(e, t);
    };
    Te.toWeb = function(e) {
      return Cs().newReadableWritablePairFromDuplex(e);
    };
    var ya;
    Te.from = function(e) {
      return ya || (ya = Us()), ya(e, "body");
    };
  });
  wa = g4((YA, Zs) => {
    var { ObjectSetPrototypeOf: Ws, Symbol: Lw } = V4();
    Zs.exports = Qe;
    var { ERR_METHOD_NOT_IMPLEMENTED: Dw } = ne().codes, ba = Ce(), { getHighWaterMark: Bw } = ai();
    Ws(Qe.prototype, ba.prototype);
    Ws(Qe, ba);
    var Gr = Lw("kCallback");
    function Qe(e) {
      if (!(this instanceof Qe))
        return new Qe(e);
      let t = e ? Bw(this, e, "readableHighWaterMark", true) : null;
      t === 0 && (e = { ...e, highWaterMark: null, readableHighWaterMark: t, writableHighWaterMark: e.writableHighWaterMark || 0 }), ba.call(this, e), this._readableState.sync = false, this[Gr] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Pw);
    }
    function ga(e) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
        if (t) {
          e ? e(t) : this.destroy(t);
          return;
        }
        r != null && this.push(r), this.push(null), e && e();
      }) : (this.push(null), e && e());
    }
    function Pw() {
      this._final !== ga && ga.call(this);
    }
    Qe.prototype._final = ga;
    Qe.prototype._transform = function(e, t, r) {
      throw new Dw("_transform()");
    };
    Qe.prototype._write = function(e, t, r) {
      let n = this._readableState, i = this._writableState, o2 = n.length;
      this._transform(e, t, (a3, f3) => {
        if (a3) {
          r(a3);
          return;
        }
        f3 != null && this.push(f3), i.ended || o2 === n.length || n.length < n.highWaterMark ? r() : this[Gr] = r;
      });
    };
    Qe.prototype._read = function() {
      if (this[Gr]) {
        let e = this[Gr];
        this[Gr] = null, e();
      }
    };
  });
  va = g4((KA, Gs) => {
    var { ObjectSetPrototypeOf: $s } = V4();
    Gs.exports = _r;
    var Ea = wa();
    $s(_r.prototype, Ea.prototype);
    $s(_r, Ea);
    function _r(e) {
      if (!(this instanceof _r))
        return new _r(e);
      Ea.call(this, e);
    }
    _r.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  gi = g4((XA, Qs) => {
    var yi = (it(), se(ye)), { ArrayIsArray: Mw, Promise: jw, SymbolAsyncIterator: Uw } = V4(), _i = at2(), { once: qw } = Pe2(), Cw = Tt(), Hs = Ce(), { aggregateTwoErrors: zw, codes: { ERR_INVALID_ARG_TYPE: Xs, ERR_INVALID_RETURN_VALUE: ma, ERR_MISSING_ARGS: Ww, ERR_STREAM_DESTROYED: Zw, ERR_STREAM_PREMATURE_CLOSE: $w }, AbortError: Gw } = ne(), { validateFunction: Hw, validateAbortSignal: Vw } = Ur3(), { isIterable: gr3, isReadable: Sa, isReadableNodeStream: Ra, isNodeStream: Vs } = ot2(), Yw = globalThis.AbortController || qn().AbortController, Aa, xa;
    function Ys(e, t, r) {
      let n = false;
      e.on("close", () => {
        n = true;
      });
      let i = _i(e, { readable: t, writable: r }, (o2) => {
        n = !o2;
      });
      return { destroy: (o2) => {
        n || (n = true, Cw.destroyer(e, o2 || new Zw("pipe")));
      }, cleanup: i };
    }
    function Kw(e) {
      return Hw(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function Xw(e) {
      if (gr3(e))
        return e;
      if (Ra(e))
        return Jw(e);
      throw new Xs("val", ["Readable", "Iterable", "AsyncIterable"], e);
    }
    async function* Jw(e) {
      xa || (xa = zr()), yield* xa.prototype[Uw].call(e);
    }
    async function Ks(e, t, r, { end: n }) {
      let i, o2 = null, a3 = (l3) => {
        if (l3 && (i = l3), o2) {
          let s2 = o2;
          o2 = null, s2();
        }
      }, f3 = () => new jw((l3, s2) => {
        i ? s2(i) : o2 = () => {
          i ? s2(i) : l3();
        };
      });
      t.on("drain", a3);
      let u3 = _i(t, { readable: false }, a3);
      try {
        t.writableNeedDrain && await f3();
        for await (let l3 of e)
          t.write(l3) || await f3();
        n && t.end(), await f3(), r();
      } catch (l3) {
        r(i !== l3 ? zw(i, l3) : l3);
      } finally {
        u3(), t.off("drain", a3);
      }
    }
    function Qw(...e) {
      return Js(e, qw(Kw(e)));
    }
    function Js(e, t, r) {
      if (e.length === 1 && Mw(e[0]) && (e = e[0]), e.length < 2)
        throw new Ww("streams");
      let n = new Yw, i = n.signal, o2 = r?.signal, a3 = [];
      Vw(o2, "options.signal");
      function f3() {
        d4(new Gw);
      }
      o2?.addEventListener("abort", f3);
      let u3, l3, s2 = [], c2 = 0;
      function h5(_4) {
        d4(_4, --c2 === 0);
      }
      function d4(_4, E5) {
        if (_4 && (!u3 || u3.code === "ERR_STREAM_PREMATURE_CLOSE") && (u3 = _4), !(!u3 && !E5)) {
          for (;s2.length; )
            s2.shift()(u3);
          o2?.removeEventListener("abort", f3), n.abort(), E5 && (u3 || a3.forEach((m3) => m3()), yi.nextTick(t, u3, l3));
        }
      }
      let y5;
      for (let _4 = 0;_4 < e.length; _4++) {
        let E5 = e[_4], m3 = _4 < e.length - 1, A4 = _4 > 0, v4 = m3 || r?.end !== false, T3 = _4 === e.length - 1;
        if (Vs(E5)) {
          let I4 = function(S3) {
            S3 && S3.name !== "AbortError" && S3.code !== "ERR_STREAM_PREMATURE_CLOSE" && h5(S3);
          };
          var R3 = I4;
          if (v4) {
            let { destroy: S3, cleanup: k3 } = Ys(E5, m3, A4);
            s2.push(S3), Sa(E5) && T3 && a3.push(k3);
          }
          E5.on("error", I4), Sa(E5) && T3 && a3.push(() => {
            E5.removeListener("error", I4);
          });
        }
        if (_4 === 0)
          if (typeof E5 == "function") {
            if (y5 = E5({ signal: i }), !gr3(y5))
              throw new ma("Iterable, AsyncIterable or Stream", "source", y5);
          } else
            gr3(E5) || Ra(E5) ? y5 = E5 : y5 = Hs.from(E5);
        else if (typeof E5 == "function")
          if (y5 = Xw(y5), y5 = E5(y5, { signal: i }), m3) {
            if (!gr3(y5, true))
              throw new ma("AsyncIterable", `transform[${_4 - 1}]`, y5);
          } else {
            var b4;
            Aa || (Aa = va());
            let I4 = new Aa({ objectMode: true }), S3 = (b4 = y5) === null || b4 === undefined ? undefined : b4.then;
            if (typeof S3 == "function")
              c2++, S3.call(y5, (O4) => {
                l3 = O4, O4 != null && I4.write(O4), v4 && I4.end(), yi.nextTick(h5);
              }, (O4) => {
                I4.destroy(O4), yi.nextTick(h5, O4);
              });
            else if (gr3(y5, true))
              c2++, Ks(y5, I4, h5, { end: v4 });
            else
              throw new ma("AsyncIterable or Promise", "destination", y5);
            y5 = I4;
            let { destroy: k3, cleanup: z } = Ys(y5, false, true);
            s2.push(k3), T3 && a3.push(z);
          }
        else if (Vs(E5)) {
          if (Ra(y5)) {
            c2 += 2;
            let I4 = eE(y5, E5, h5, { end: v4 });
            Sa(E5) && T3 && a3.push(I4);
          } else if (gr3(y5))
            c2++, Ks(y5, E5, h5, { end: v4 });
          else
            throw new Xs("val", ["Readable", "Iterable", "AsyncIterable"], y5);
          y5 = E5;
        } else
          y5 = Hs.from(E5);
      }
      return (i != null && i.aborted || o2 != null && o2.aborted) && yi.nextTick(f3), y5;
    }
    function eE(e, t, r, { end: n }) {
      let i = false;
      return t.on("close", () => {
        i || r(new $w);
      }), e.pipe(t, { end: n }), n ? e.once("end", () => {
        i = true, t.end();
      }) : r(), _i(e, { readable: true, writable: false }, (o2) => {
        let a3 = e._readableState;
        o2 && o2.code === "ERR_STREAM_PREMATURE_CLOSE" && a3 && a3.ended && !a3.errored && !a3.errorEmitted ? e.once("end", r).once("error", r) : r(o2);
      }), _i(t, { readable: false, writable: true }, r);
    }
    Qs.exports = { pipelineImpl: Js, pipeline: Qw };
  });
  ic = g4((JA, nc) => {
    var { pipeline: tE } = gi(), bi = Ce(), { destroyer: rE } = Tt(), { isNodeStream: nE, isReadable: ec, isWritable: tc } = ot2(), { AbortError: iE, codes: { ERR_INVALID_ARG_VALUE: rc, ERR_MISSING_ARGS: oE } } = ne();
    nc.exports = function(...t) {
      if (t.length === 0)
        throw new oE("streams");
      if (t.length === 1)
        return bi.from(t[0]);
      let r = [...t];
      if (typeof t[0] == "function" && (t[0] = bi.from(t[0])), typeof t[t.length - 1] == "function") {
        let d4 = t.length - 1;
        t[d4] = bi.from(t[d4]);
      }
      for (let d4 = 0;d4 < t.length; ++d4)
        if (!!nE(t[d4])) {
          if (d4 < t.length - 1 && !ec(t[d4]))
            throw new rc(`streams[${d4}]`, r[d4], "must be readable");
          if (d4 > 0 && !tc(t[d4]))
            throw new rc(`streams[${d4}]`, r[d4], "must be writable");
        }
      let n, i, o2, a3, f3;
      function u3(d4) {
        let y5 = a3;
        a3 = null, y5 ? y5(d4) : d4 ? f3.destroy(d4) : !h5 && !c2 && f3.destroy();
      }
      let l3 = t[0], s2 = tE(t, u3), c2 = !!tc(l3), h5 = !!ec(s2);
      return f3 = new bi({ writableObjectMode: !!(l3 != null && l3.writableObjectMode), readableObjectMode: !!(s2 != null && s2.writableObjectMode), writable: c2, readable: h5 }), c2 && (f3._write = function(d4, y5, b4) {
        l3.write(d4, y5) ? b4() : n = b4;
      }, f3._final = function(d4) {
        l3.end(), i = d4;
      }, l3.on("drain", function() {
        if (n) {
          let d4 = n;
          n = null, d4();
        }
      }), s2.on("finish", function() {
        if (i) {
          let d4 = i;
          i = null, d4();
        }
      })), h5 && (s2.on("readable", function() {
        if (o2) {
          let d4 = o2;
          o2 = null, d4();
        }
      }), s2.on("end", function() {
        f3.push(null);
      }), f3._read = function() {
        for (;; ) {
          let d4 = s2.read();
          if (d4 === null) {
            o2 = f3._read;
            return;
          }
          if (!f3.push(d4))
            return;
        }
      }), f3._destroy = function(d4, y5) {
        !d4 && a3 !== null && (d4 = new iE), o2 = null, n = null, i = null, a3 === null ? y5(d4) : (a3 = y5, rE(s2, d4));
      }, f3;
    };
  });
  Ia = g4((QA, oc) => {
    var { ArrayPrototypePop: aE, Promise: fE } = V4(), { isIterable: lE, isNodeStream: uE } = ot2(), { pipelineImpl: sE } = gi(), { finished: cE } = at2();
    function dE(...e) {
      return new fE((t, r) => {
        let n, i, o2 = e[e.length - 1];
        if (o2 && typeof o2 == "object" && !uE(o2) && !lE(o2)) {
          let a3 = aE(e);
          n = a3.signal, i = a3.end;
        }
        sE(e, (a3, f3) => {
          a3 ? r(a3) : t(f3);
        }, { signal: n, end: i });
      });
    }
    oc.exports = { finished: cE, pipeline: dE };
  });
  yc = g4((ex, pc) => {
    var { Buffer: hE } = xe(), { ObjectDefineProperty: et, ObjectKeys: lc, ReflectApply: uc } = V4(), { promisify: { custom: sc } } = Pe2(), { streamReturningOperators: ac, promiseReturningOperators: fc } = Eu(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: cc } } = ne(), pE = ic(), { pipeline: dc } = gi(), { destroyer: yE } = Tt(), hc = at2(), Ta = Ia(), Oa = ot2(), G2 = pc.exports = ri().Stream;
    G2.isDisturbed = Oa.isDisturbed;
    G2.isErrored = Oa.isErrored;
    G2.isReadable = Oa.isReadable;
    G2.Readable = zr();
    for (let e of lc(ac)) {
      let r = function(...n) {
        if (new.target)
          throw cc();
        return G2.Readable.from(uc(t, this, n));
      };
      gE = r;
      let t = ac[e];
      et(r, "name", { __proto__: null, value: t.name }), et(r, "length", { __proto__: null, value: t.length }), et(G2.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var gE;
    for (let e of lc(fc)) {
      let r = function(...i) {
        if (new.target)
          throw cc();
        return uc(t, this, i);
      };
      gE = r;
      let t = fc[e];
      et(r, "name", { __proto__: null, value: t.name }), et(r, "length", { __proto__: null, value: t.length }), et(G2.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var gE;
    G2.Writable = da();
    G2.Duplex = Ce();
    G2.Transform = wa();
    G2.PassThrough = va();
    G2.pipeline = dc;
    var { addAbortSignal: _E } = ii();
    G2.addAbortSignal = _E;
    G2.finished = hc;
    G2.destroy = yE;
    G2.compose = pE;
    et(G2, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return Ta;
    } });
    et(dc, sc, { __proto__: null, enumerable: true, get() {
      return Ta.pipeline;
    } });
    et(hc, sc, { __proto__: null, enumerable: true, get() {
      return Ta.finished;
    } });
    G2.Stream = G2;
    G2._isUint8Array = function(t) {
      return t instanceof Uint8Array;
    };
    G2._uint8ArrayToBuffer = function(t) {
      return hE.from(t.buffer, t.byteOffset, t.byteLength);
    };
  });
  Na = g4((tx, H3) => {
    var Y3 = yc(), bE = Ia(), wE = Y3.Readable.destroy;
    H3.exports = Y3.Readable;
    H3.exports._uint8ArrayToBuffer = Y3._uint8ArrayToBuffer;
    H3.exports._isUint8Array = Y3._isUint8Array;
    H3.exports.isDisturbed = Y3.isDisturbed;
    H3.exports.isErrored = Y3.isErrored;
    H3.exports.isReadable = Y3.isReadable;
    H3.exports.Readable = Y3.Readable;
    H3.exports.Writable = Y3.Writable;
    H3.exports.Duplex = Y3.Duplex;
    H3.exports.Transform = Y3.Transform;
    H3.exports.PassThrough = Y3.PassThrough;
    H3.exports.addAbortSignal = Y3.addAbortSignal;
    H3.exports.finished = Y3.finished;
    H3.exports.destroy = Y3.destroy;
    H3.exports.destroy = wE;
    H3.exports.pipeline = Y3.pipeline;
    H3.exports.compose = Y3.compose;
    Object.defineProperty(Y3, "promises", { configurable: true, enumerable: true, get() {
      return bE;
    } });
    H3.exports.Stream = Y3.Stream;
    H3.exports.default = H3.exports;
  });
  br2 = {};
  Bn(br2, { default: () => EE });
  _c = wo(() => {
    X3(br2, vt(Na()));
    EE = vt(Na());
  });
  ka = g4((nx, gc) => {
    gc.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var t = {}, r = Symbol("test"), n = Object(r);
      if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var i = 42;
      t[r] = i;
      for (r in t)
        return false;
      if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
        return false;
      var o2 = Object.getOwnPropertySymbols(t);
      if (o2.length !== 1 || o2[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a3 = Object.getOwnPropertyDescriptor(t, r);
        if (a3.value !== i || a3.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  Hr = g4((ix, bc) => {
    var vE = ka();
    bc.exports = function() {
      return vE() && !!Symbol.toStringTag;
    };
  });
  vc = g4((ox, Ec) => {
    var wc = typeof Symbol < "u" && Symbol, mE = ka();
    Ec.exports = function() {
      return typeof wc != "function" || typeof Symbol != "function" || typeof wc("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : mE();
    };
  });
  Sc = g4((ax, mc) => {
    var SE = "Function.prototype.bind called on incompatible ", Fa = Array.prototype.slice, AE = Object.prototype.toString, xE = "[object Function]";
    mc.exports = function(t) {
      var r = this;
      if (typeof r != "function" || AE.call(r) !== xE)
        throw new TypeError(SE + r);
      for (var n = Fa.call(arguments, 1), i, o2 = function() {
        if (this instanceof i) {
          var s2 = r.apply(this, n.concat(Fa.call(arguments)));
          return Object(s2) === s2 ? s2 : this;
        } else
          return r.apply(t, n.concat(Fa.call(arguments)));
      }, a3 = Math.max(0, r.length - n.length), f3 = [], u3 = 0;u3 < a3; u3++)
        f3.push("$" + u3);
      if (i = Function("binder", "return function (" + f3.join(",") + "){ return binder.apply(this,arguments); }")(o2), r.prototype) {
        var l3 = function() {
        };
        l3.prototype = r.prototype, i.prototype = new l3, l3.prototype = null;
      }
      return i;
    };
  });
  wi = g4((fx, Ac) => {
    var RE = Sc();
    Ac.exports = Function.prototype.bind || RE;
  });
  Rc = g4((lx, xc) => {
    var IE = wi();
    xc.exports = IE.call(Function.call, Object.prototype.hasOwnProperty);
  });
  Yr = g4((ux, kc) => {
    var P4, mr2 = SyntaxError, Nc = Function, vr = TypeError, La = function(e) {
      try {
        return Nc('"use strict"; return (' + e + ").constructor;")();
      } catch {
      }
    }, Lt = Object.getOwnPropertyDescriptor;
    if (Lt)
      try {
        Lt({}, "");
      } catch {
        Lt = null;
      }
    var Da = function() {
      throw new vr;
    }, TE = Lt ? function() {
      try {
        return arguments.callee, Da;
      } catch {
        try {
          return Lt(arguments, "callee").get;
        } catch {
          return Da;
        }
      }
    }() : Da, wr = vc()(), ze = Object.getPrototypeOf || function(e) {
      return e.__proto__;
    }, Er2 = {}, OE = typeof Uint8Array > "u" ? P4 : ze(Uint8Array), Dt = { "%AggregateError%": typeof AggregateError > "u" ? P4 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? P4 : ArrayBuffer, "%ArrayIteratorPrototype%": wr ? ze([][Symbol.iterator]()) : P4, "%AsyncFromSyncIteratorPrototype%": P4, "%AsyncFunction%": Er2, "%AsyncGenerator%": Er2, "%AsyncGeneratorFunction%": Er2, "%AsyncIteratorPrototype%": Er2, "%Atomics%": typeof Atomics > "u" ? P4 : Atomics, "%BigInt%": typeof BigInt > "u" ? P4 : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? P4 : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? P4 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? P4 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? P4 : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? P4 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? P4 : FinalizationRegistry, "%Function%": Nc, "%GeneratorFunction%": Er2, "%Int8Array%": typeof Int8Array > "u" ? P4 : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? P4 : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? P4 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": wr ? ze(ze([][Symbol.iterator]())) : P4, "%JSON%": typeof JSON == "object" ? JSON : P4, "%Map%": typeof Map > "u" ? P4 : Map, "%MapIteratorPrototype%": typeof Map > "u" || !wr ? P4 : ze(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? P4 : Promise, "%Proxy%": typeof Proxy > "u" ? P4 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? P4 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? P4 : Set, "%SetIteratorPrototype%": typeof Set > "u" || !wr ? P4 : ze(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? P4 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": wr ? ze(""[Symbol.iterator]()) : P4, "%Symbol%": wr ? Symbol : P4, "%SyntaxError%": mr2, "%ThrowTypeError%": TE, "%TypedArray%": OE, "%TypeError%": vr, "%Uint8Array%": typeof Uint8Array > "u" ? P4 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? P4 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? P4 : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? P4 : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? P4 : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? P4 : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? P4 : WeakSet };
    try {
      null.error;
    } catch (e) {
      Ic = ze(ze(e)), Dt["%Error.prototype%"] = Ic;
    }
    var Ic, NE = function e(t) {
      var r;
      if (t === "%AsyncFunction%")
        r = La("async function () {}");
      else if (t === "%GeneratorFunction%")
        r = La("function* () {}");
      else if (t === "%AsyncGeneratorFunction%")
        r = La("async function* () {}");
      else if (t === "%AsyncGenerator%") {
        var n = e("%AsyncGeneratorFunction%");
        n && (r = n.prototype);
      } else if (t === "%AsyncIteratorPrototype%") {
        var i = e("%AsyncGenerator%");
        i && (r = ze(i.prototype));
      }
      return Dt[t] = r, r;
    }, Tc = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Vr = wi(), Ei = Rc(), kE = Vr.call(Function.call, Array.prototype.concat), FE = Vr.call(Function.apply, Array.prototype.splice), Oc = Vr.call(Function.call, String.prototype.replace), vi = Vr.call(Function.call, String.prototype.slice), LE = Vr.call(Function.call, RegExp.prototype.exec), DE = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, BE = /\\(\\)?/g, PE = function(t) {
      var r = vi(t, 0, 1), n = vi(t, -1);
      if (r === "%" && n !== "%")
        throw new mr2("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && r !== "%")
        throw new mr2("invalid intrinsic syntax, expected opening `%`");
      var i = [];
      return Oc(t, DE, function(o2, a3, f3, u3) {
        i[i.length] = f3 ? Oc(u3, BE, "$1") : a3 || o2;
      }), i;
    }, ME = function(t, r) {
      var n = t, i;
      if (Ei(Tc, n) && (i = Tc[n], n = "%" + i[0] + "%"), Ei(Dt, n)) {
        var o2 = Dt[n];
        if (o2 === Er2 && (o2 = NE(n)), typeof o2 > "u" && !r)
          throw new vr("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return { alias: i, name: n, value: o2 };
      }
      throw new mr2("intrinsic " + t + " does not exist!");
    };
    kc.exports = function(t, r) {
      if (typeof t != "string" || t.length === 0)
        throw new vr("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof r != "boolean")
        throw new vr('"allowMissing" argument must be a boolean');
      if (LE(/^%?[^%]*%?$/, t) === null)
        throw new mr2("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var n = PE(t), i = n.length > 0 ? n[0] : "", o2 = ME("%" + i + "%", r), a3 = o2.name, f3 = o2.value, u3 = false, l3 = o2.alias;
      l3 && (i = l3[0], FE(n, kE([0, 1], l3)));
      for (var s2 = 1, c2 = true;s2 < n.length; s2 += 1) {
        var h5 = n[s2], d4 = vi(h5, 0, 1), y5 = vi(h5, -1);
        if ((d4 === '"' || d4 === "'" || d4 === "`" || y5 === '"' || y5 === "'" || y5 === "`") && d4 !== y5)
          throw new mr2("property names with quotes must have matching quotes");
        if ((h5 === "constructor" || !c2) && (u3 = true), i += "." + h5, a3 = "%" + i + "%", Ei(Dt, a3))
          f3 = Dt[a3];
        else if (f3 != null) {
          if (!(h5 in f3)) {
            if (!r)
              throw new vr("base intrinsic for " + t + " exists, but the property is not available.");
            return;
          }
          if (Lt && s2 + 1 >= n.length) {
            var b4 = Lt(f3, h5);
            c2 = !!b4, c2 && "get" in b4 && !("originalValue" in b4.get) ? f3 = b4.get : f3 = f3[h5];
          } else
            c2 = Ei(f3, h5), f3 = f3[h5];
          c2 && !u3 && (Dt[a3] = f3);
        }
      }
      return f3;
    };
  });
  Si = g4((sx, mi) => {
    var Ba = wi(), Sr = Yr(), Dc = Sr("%Function.prototype.apply%"), Bc = Sr("%Function.prototype.call%"), Pc = Sr("%Reflect.apply%", true) || Ba.call(Bc, Dc), Fc = Sr("%Object.getOwnPropertyDescriptor%", true), Bt = Sr("%Object.defineProperty%", true), jE = Sr("%Math.max%");
    if (Bt)
      try {
        Bt({}, "a", { value: 1 });
      } catch {
        Bt = null;
      }
    mi.exports = function(t) {
      var r = Pc(Ba, Bc, arguments);
      if (Fc && Bt) {
        var n = Fc(r, "length");
        n.configurable && Bt(r, "length", { value: 1 + jE(0, t.length - (arguments.length - 1)) });
      }
      return r;
    };
    var Lc = function() {
      return Pc(Ba, Dc, arguments);
    };
    Bt ? Bt(mi.exports, "apply", { value: Lc }) : mi.exports.apply = Lc;
  });
  Ai = g4((cx, Uc) => {
    var Mc = Yr(), jc = Si(), UE = jc(Mc("String.prototype.indexOf"));
    Uc.exports = function(t, r) {
      var n = Mc(t, !!r);
      return typeof n == "function" && UE(t, ".prototype.") > -1 ? jc(n) : n;
    };
  });
  zc = g4((dx, Cc) => {
    var qE = Hr()(), CE = Ai(), Pa = CE("Object.prototype.toString"), xi = function(t) {
      return qE && t && typeof t == "object" && Symbol.toStringTag in t ? false : Pa(t) === "[object Arguments]";
    }, qc = function(t) {
      return xi(t) ? true : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Pa(t) !== "[object Array]" && Pa(t.callee) === "[object Function]";
    }, zE = function() {
      return xi(arguments);
    }();
    xi.isLegacyArguments = qc;
    Cc.exports = zE ? xi : qc;
  });
  $c = g4((hx, Zc) => {
    var WE = Object.prototype.toString, ZE = Function.prototype.toString, $E = /^\s*(?:function)?\*/, Wc = Hr()(), Ma = Object.getPrototypeOf, GE = function() {
      if (!Wc)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {
      }
    }, ja;
    Zc.exports = function(t) {
      if (typeof t != "function")
        return false;
      if ($E.test(ZE.call(t)))
        return true;
      if (!Wc) {
        var r = WE.call(t);
        return r === "[object GeneratorFunction]";
      }
      if (!Ma)
        return false;
      if (typeof ja > "u") {
        var n = GE();
        ja = n ? Ma(n) : false;
      }
      return Ma(t) === ja;
    };
  });
  Yc = g4((px, Vc) => {
    var Hc = Function.prototype.toString, Ar2 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, qa, Ri;
    if (typeof Ar2 == "function" && typeof Object.defineProperty == "function")
      try {
        qa = Object.defineProperty({}, "length", { get: function() {
          throw Ri;
        } }), Ri = {}, Ar2(function() {
          throw 42;
        }, null, qa);
      } catch (e) {
        e !== Ri && (Ar2 = null);
      }
    else
      Ar2 = null;
    var HE = /^\s*class\b/, Ca = function(t) {
      try {
        var r = Hc.call(t);
        return HE.test(r);
      } catch {
        return false;
      }
    }, Ua = function(t) {
      try {
        return Ca(t) ? false : (Hc.call(t), true);
      } catch {
        return false;
      }
    }, Ii = Object.prototype.toString, VE = "[object Object]", YE = "[object Function]", KE = "[object GeneratorFunction]", XE = "[object HTMLAllCollection]", JE = "[object HTML document.all class]", QE = "[object HTMLCollection]", ev = typeof Symbol == "function" && !!Symbol.toStringTag, tv = !(0 in [,]), za = function() {
      return false;
    };
    typeof document == "object" && (Gc = document.all, Ii.call(Gc) === Ii.call(document.all) && (za = function(t) {
      if ((tv || !t) && (typeof t > "u" || typeof t == "object"))
        try {
          var r = Ii.call(t);
          return (r === XE || r === JE || r === QE || r === VE) && t("") == null;
        } catch {
        }
      return false;
    }));
    var Gc;
    Vc.exports = Ar2 ? function(t) {
      if (za(t))
        return true;
      if (!t || typeof t != "function" && typeof t != "object")
        return false;
      try {
        Ar2(t, null, qa);
      } catch (r) {
        if (r !== Ri)
          return false;
      }
      return !Ca(t) && Ua(t);
    } : function(t) {
      if (za(t))
        return true;
      if (!t || typeof t != "function" && typeof t != "object")
        return false;
      if (ev)
        return Ua(t);
      if (Ca(t))
        return false;
      var r = Ii.call(t);
      return r !== YE && r !== KE && !/^\[object HTML/.test(r) ? false : Ua(t);
    };
  });
  Wa = g4((yx, Xc) => {
    var rv = Yc(), nv = Object.prototype.toString, Kc = Object.prototype.hasOwnProperty, iv = function(t, r, n) {
      for (var i = 0, o2 = t.length;i < o2; i++)
        Kc.call(t, i) && (n == null ? r(t[i], i, t) : r.call(n, t[i], i, t));
    }, ov = function(t, r, n) {
      for (var i = 0, o2 = t.length;i < o2; i++)
        n == null ? r(t.charAt(i), i, t) : r.call(n, t.charAt(i), i, t);
    }, av = function(t, r, n) {
      for (var i in t)
        Kc.call(t, i) && (n == null ? r(t[i], i, t) : r.call(n, t[i], i, t));
    }, fv = function(t, r, n) {
      if (!rv(r))
        throw new TypeError("iterator must be a function");
      var i;
      arguments.length >= 3 && (i = n), nv.call(t) === "[object Array]" ? iv(t, r, i) : typeof t == "string" ? ov(t, r, i) : av(t, r, i);
    };
    Xc.exports = fv;
  });
  $a = g4((_x, Jc) => {
    var Za = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], lv = typeof globalThis > "u" ? global : globalThis;
    Jc.exports = function() {
      for (var t = [], r = 0;r < Za.length; r++)
        typeof lv[Za[r]] == "function" && (t[t.length] = Za[r]);
      return t;
    };
  });
  Ga = g4((gx, Qc) => {
    var uv = Yr(), Ti = uv("%Object.getOwnPropertyDescriptor%", true);
    if (Ti)
      try {
        Ti([], "length");
      } catch {
        Ti = null;
      }
    Qc.exports = Ti;
  });
  Ya = g4((bx, id) => {
    var ed = Wa(), sv = $a(), Va = Ai(), cv = Va("Object.prototype.toString"), td = Hr()(), Oi = Ga(), dv = typeof globalThis > "u" ? global : globalThis, rd = sv(), hv = Va("Array.prototype.indexOf", true) || function(t, r) {
      for (var n = 0;n < t.length; n += 1)
        if (t[n] === r)
          return n;
      return -1;
    }, pv = Va("String.prototype.slice"), nd = {}, Ha = Object.getPrototypeOf;
    td && Oi && Ha && ed(rd, function(e) {
      var t = new dv[e];
      if (Symbol.toStringTag in t) {
        var r = Ha(t), n = Oi(r, Symbol.toStringTag);
        if (!n) {
          var i = Ha(r);
          n = Oi(i, Symbol.toStringTag);
        }
        nd[e] = n.get;
      }
    });
    var yv = function(t) {
      var r = false;
      return ed(nd, function(n, i) {
        if (!r)
          try {
            r = n.call(t) === i;
          } catch {
          }
      }), r;
    };
    id.exports = function(t) {
      if (!t || typeof t != "object")
        return false;
      if (!td || !(Symbol.toStringTag in t)) {
        var r = pv(cv(t), 8, -1);
        return hv(rd, r) > -1;
      }
      return Oi ? yv(t) : false;
    };
  });
  cd = g4((wx, sd) => {
    var ad = Wa(), _v = $a(), fd = Ai(), Ka = Ga(), gv = fd("Object.prototype.toString"), ld = Hr()(), od = typeof globalThis > "u" ? global : globalThis, bv = _v(), wv = fd("String.prototype.slice"), ud = {}, Xa = Object.getPrototypeOf;
    ld && Ka && Xa && ad(bv, function(e) {
      if (typeof od[e] == "function") {
        var t = new od[e];
        if (Symbol.toStringTag in t) {
          var r = Xa(t), n = Ka(r, Symbol.toStringTag);
          if (!n) {
            var i = Xa(r);
            n = Ka(i, Symbol.toStringTag);
          }
          ud[e] = n.get;
        }
      }
    });
    var Ev = function(t) {
      var r = false;
      return ad(ud, function(n, i) {
        if (!r)
          try {
            var o2 = n.call(t);
            o2 === i && (r = o2);
          } catch {
          }
      }), r;
    }, vv = Ya();
    sd.exports = function(t) {
      return vv(t) ? !ld || !(Symbol.toStringTag in t) ? wv(gv(t), 8, -1) : Ev(t) : false;
    };
  });
  xd = g4((L4) => {
    var mv = zc(), Sv = $c(), Oe = cd(), dd = Ya();
    function xr(e) {
      return e.call.bind(e);
    }
    var hd = typeof BigInt < "u", pd = typeof Symbol < "u", ge = xr(Object.prototype.toString), Av = xr(Number.prototype.valueOf), xv = xr(String.prototype.valueOf), Rv = xr(Boolean.prototype.valueOf);
    hd && (yd = xr(BigInt.prototype.valueOf));
    var yd;
    pd && (_d = xr(Symbol.prototype.valueOf));
    var _d;
    function Xr(e, t) {
      if (typeof e != "object")
        return false;
      try {
        return t(e), true;
      } catch {
        return false;
      }
    }
    L4.isArgumentsObject = mv;
    L4.isGeneratorFunction = Sv;
    L4.isTypedArray = dd;
    function Iv(e) {
      return typeof Promise < "u" && e instanceof Promise || e !== null && typeof e == "object" && typeof e.then == "function" && typeof e.catch == "function";
    }
    L4.isPromise = Iv;
    function Tv(e) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(e) : dd(e) || bd(e);
    }
    L4.isArrayBufferView = Tv;
    function Ov(e) {
      return Oe(e) === "Uint8Array";
    }
    L4.isUint8Array = Ov;
    function Nv(e) {
      return Oe(e) === "Uint8ClampedArray";
    }
    L4.isUint8ClampedArray = Nv;
    function kv(e) {
      return Oe(e) === "Uint16Array";
    }
    L4.isUint16Array = kv;
    function Fv(e) {
      return Oe(e) === "Uint32Array";
    }
    L4.isUint32Array = Fv;
    function Lv(e) {
      return Oe(e) === "Int8Array";
    }
    L4.isInt8Array = Lv;
    function Dv(e) {
      return Oe(e) === "Int16Array";
    }
    L4.isInt16Array = Dv;
    function Bv(e) {
      return Oe(e) === "Int32Array";
    }
    L4.isInt32Array = Bv;
    function Pv(e) {
      return Oe(e) === "Float32Array";
    }
    L4.isFloat32Array = Pv;
    function Mv(e) {
      return Oe(e) === "Float64Array";
    }
    L4.isFloat64Array = Mv;
    function jv(e) {
      return Oe(e) === "BigInt64Array";
    }
    L4.isBigInt64Array = jv;
    function Uv(e) {
      return Oe(e) === "BigUint64Array";
    }
    L4.isBigUint64Array = Uv;
    function Ni(e) {
      return ge(e) === "[object Map]";
    }
    Ni.working = typeof Map < "u" && Ni(new Map);
    function qv(e) {
      return typeof Map > "u" ? false : Ni.working ? Ni(e) : e instanceof Map;
    }
    L4.isMap = qv;
    function ki(e) {
      return ge(e) === "[object Set]";
    }
    ki.working = typeof Set < "u" && ki(new Set);
    function Cv(e) {
      return typeof Set > "u" ? false : ki.working ? ki(e) : e instanceof Set;
    }
    L4.isSet = Cv;
    function Fi(e) {
      return ge(e) === "[object WeakMap]";
    }
    Fi.working = typeof WeakMap < "u" && Fi(new WeakMap);
    function zv(e) {
      return typeof WeakMap > "u" ? false : Fi.working ? Fi(e) : e instanceof WeakMap;
    }
    L4.isWeakMap = zv;
    function Qa(e) {
      return ge(e) === "[object WeakSet]";
    }
    Qa.working = typeof WeakSet < "u" && Qa(new WeakSet);
    function Wv(e) {
      return Qa(e);
    }
    L4.isWeakSet = Wv;
    function Li(e) {
      return ge(e) === "[object ArrayBuffer]";
    }
    Li.working = typeof ArrayBuffer < "u" && Li(new ArrayBuffer);
    function gd(e) {
      return typeof ArrayBuffer > "u" ? false : Li.working ? Li(e) : e instanceof ArrayBuffer;
    }
    L4.isArrayBuffer = gd;
    function Di(e) {
      return ge(e) === "[object DataView]";
    }
    Di.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Di(new DataView(new ArrayBuffer(1), 0, 1));
    function bd(e) {
      return typeof DataView > "u" ? false : Di.working ? Di(e) : e instanceof DataView;
    }
    L4.isDataView = bd;
    var Ja = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
    function Kr2(e) {
      return ge(e) === "[object SharedArrayBuffer]";
    }
    function wd(e) {
      return typeof Ja > "u" ? false : (typeof Kr2.working > "u" && (Kr2.working = Kr2(new Ja)), Kr2.working ? Kr2(e) : e instanceof Ja);
    }
    L4.isSharedArrayBuffer = wd;
    function Zv(e) {
      return ge(e) === "[object AsyncFunction]";
    }
    L4.isAsyncFunction = Zv;
    function $v(e) {
      return ge(e) === "[object Map Iterator]";
    }
    L4.isMapIterator = $v;
    function Gv(e) {
      return ge(e) === "[object Set Iterator]";
    }
    L4.isSetIterator = Gv;
    function Hv(e) {
      return ge(e) === "[object Generator]";
    }
    L4.isGeneratorObject = Hv;
    function Vv(e) {
      return ge(e) === "[object WebAssembly.Module]";
    }
    L4.isWebAssemblyCompiledModule = Vv;
    function Ed(e) {
      return Xr(e, Av);
    }
    L4.isNumberObject = Ed;
    function vd(e) {
      return Xr(e, xv);
    }
    L4.isStringObject = vd;
    function md(e) {
      return Xr(e, Rv);
    }
    L4.isBooleanObject = md;
    function Sd(e) {
      return hd && Xr(e, yd);
    }
    L4.isBigIntObject = Sd;
    function Ad(e) {
      return pd && Xr(e, _d);
    }
    L4.isSymbolObject = Ad;
    function Yv(e) {
      return Ed(e) || vd(e) || md(e) || Sd(e) || Ad(e);
    }
    L4.isBoxedPrimitive = Yv;
    function Kv(e) {
      return typeof Uint8Array < "u" && (gd(e) || wd(e));
    }
    L4.isAnyArrayBuffer = Kv;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e) {
      Object.defineProperty(L4, e, { enumerable: false, value: function() {
        throw new Error(e + " is not supported in userland");
      } });
    });
  });
  Id = g4((vx, Rd) => {
    Rd.exports = function(t) {
      return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
    };
  });
  Td = g4((mx, ef) => {
    typeof Object.create == "function" ? ef.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : ef.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {
        };
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  ff = g4((D3) => {
    var Od = Object.getOwnPropertyDescriptors || function(t) {
      for (var r = Object.keys(t), n = {}, i = 0;i < r.length; i++)
        n[r[i]] = Object.getOwnPropertyDescriptor(t, r[i]);
      return n;
    }, Xv = /%[sdj%]/g;
    D3.format = function(e) {
      if (!Ci(e)) {
        for (var t = [], r = 0;r < arguments.length; r++)
          t.push(ut2(arguments[r]));
        return t.join(" ");
      }
      for (var r = 1, n = arguments, i = n.length, o2 = String(e).replace(Xv, function(f3) {
        if (f3 === "%%")
          return "%";
        if (r >= i)
          return f3;
        switch (f3) {
          case "%s":
            return String(n[r++]);
          case "%d":
            return Number(n[r++]);
          case "%j":
            try {
              return JSON.stringify(n[r++]);
            } catch {
              return "[Circular]";
            }
          default:
            return f3;
        }
      }), a3 = n[r];r < i; a3 = n[++r])
        qi(a3) || !Rr2(a3) ? o2 += " " + a3 : o2 += " " + ut2(a3);
      return o2;
    };
    D3.deprecate = function(e, t) {
      if (typeof process < "u" && process.noDeprecation === true)
        return e;
      if (typeof process > "u")
        return function() {
          return D3.deprecate(e, t).apply(this, arguments);
        };
      var r = false;
      function n() {
        if (!r) {
          if (process.throwDeprecation)
            throw new Error(t);
          process.traceDeprecation ? console.trace(t) : console.error(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    };
    var Bi = {}, Nd = /^$/;
    process.env.NODE_DEBUG && (Pi = process.env.NODE_DEBUG, Pi = Pi.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Nd = new RegExp("^" + Pi + "$", "i"));
    var Pi;
    D3.debuglog = function(e) {
      if (e = e.toUpperCase(), !Bi[e])
        if (Nd.test(e)) {
          var t = process.pid;
          Bi[e] = function() {
            var r = D3.format.apply(D3, arguments);
            console.error("%s %d: %s", e, t, r);
          };
        } else
          Bi[e] = function() {
          };
      return Bi[e];
    };
    function ut2(e, t) {
      var r = { seen: [], stylize: Qv };
      return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), of(t) ? r.showHidden = t : t && D3._extend(r, t), Mt(r.showHidden) && (r.showHidden = false), Mt(r.depth) && (r.depth = 2), Mt(r.colors) && (r.colors = false), Mt(r.customInspect) && (r.customInspect = true), r.colors && (r.stylize = Jv), ji(r, e, r.depth);
    }
    D3.inspect = ut2;
    ut2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    ut2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function Jv(e, t) {
      var r = ut2.styles[t];
      return r ? "\x1B[" + ut2.colors[r][0] + "m" + e + "\x1B[" + ut2.colors[r][1] + "m" : e;
    }
    function Qv(e, t) {
      return e;
    }
    function em(e) {
      var t = {};
      return e.forEach(function(r, n) {
        t[r] = true;
      }), t;
    }
    function ji(e, t, r) {
      if (e.customInspect && t && Mi(t.inspect) && t.inspect !== D3.inspect && !(t.constructor && t.constructor.prototype === t)) {
        var n = t.inspect(r, e);
        return Ci(n) || (n = ji(e, n, r)), n;
      }
      var i = tm(e, t);
      if (i)
        return i;
      var o2 = Object.keys(t), a3 = em(o2);
      if (e.showHidden && (o2 = Object.getOwnPropertyNames(t)), Qr(t) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0))
        return tf(t);
      if (o2.length === 0) {
        if (Mi(t)) {
          var f3 = t.name ? ": " + t.name : "";
          return e.stylize("[Function" + f3 + "]", "special");
        }
        if (Jr(t))
          return e.stylize(RegExp.prototype.toString.call(t), "regexp");
        if (Ui(t))
          return e.stylize(Date.prototype.toString.call(t), "date");
        if (Qr(t))
          return tf(t);
      }
      var u3 = "", l3 = false, s2 = ["{", "}"];
      if (kd(t) && (l3 = true, s2 = ["[", "]"]), Mi(t)) {
        var c2 = t.name ? ": " + t.name : "";
        u3 = " [Function" + c2 + "]";
      }
      if (Jr(t) && (u3 = " " + RegExp.prototype.toString.call(t)), Ui(t) && (u3 = " " + Date.prototype.toUTCString.call(t)), Qr(t) && (u3 = " " + tf(t)), o2.length === 0 && (!l3 || t.length == 0))
        return s2[0] + u3 + s2[1];
      if (r < 0)
        return Jr(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special");
      e.seen.push(t);
      var h5;
      return l3 ? h5 = rm(e, t, r, a3, o2) : h5 = o2.map(function(d4) {
        return nf(e, t, r, a3, d4, l3);
      }), e.seen.pop(), nm(h5, u3, s2);
    }
    function tm(e, t) {
      if (Mt(t))
        return e.stylize("undefined", "undefined");
      if (Ci(t)) {
        var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e.stylize(r, "string");
      }
      if (Fd(t))
        return e.stylize("" + t, "number");
      if (of(t))
        return e.stylize("" + t, "boolean");
      if (qi(t))
        return e.stylize("null", "null");
    }
    function tf(e) {
      return "[" + Error.prototype.toString.call(e) + "]";
    }
    function rm(e, t, r, n, i) {
      for (var o2 = [], a3 = 0, f3 = t.length;a3 < f3; ++a3)
        Ld(t, String(a3)) ? o2.push(nf(e, t, r, n, String(a3), true)) : o2.push("");
      return i.forEach(function(u3) {
        u3.match(/^\d+$/) || o2.push(nf(e, t, r, n, u3, true));
      }), o2;
    }
    function nf(e, t, r, n, i, o2) {
      var a3, f3, u3;
      if (u3 = Object.getOwnPropertyDescriptor(t, i) || { value: t[i] }, u3.get ? u3.set ? f3 = e.stylize("[Getter/Setter]", "special") : f3 = e.stylize("[Getter]", "special") : u3.set && (f3 = e.stylize("[Setter]", "special")), Ld(n, i) || (a3 = "[" + i + "]"), f3 || (e.seen.indexOf(u3.value) < 0 ? (qi(r) ? f3 = ji(e, u3.value, null) : f3 = ji(e, u3.value, r - 1), f3.indexOf(`
`) > -1 && (o2 ? f3 = f3.split(`
`).map(function(l3) {
        return "  " + l3;
      }).join(`
`).slice(2) : f3 = `
` + f3.split(`
`).map(function(l3) {
        return "   " + l3;
      }).join(`
`))) : f3 = e.stylize("[Circular]", "special")), Mt(a3)) {
        if (o2 && i.match(/^\d+$/))
          return f3;
        a3 = JSON.stringify("" + i), a3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a3 = a3.slice(1, -1), a3 = e.stylize(a3, "name")) : (a3 = a3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a3 = e.stylize(a3, "string"));
      }
      return a3 + ": " + f3;
    }
    function nm(e, t, r) {
      var n = 0, i = e.reduce(function(o2, a3) {
        return n++, a3.indexOf(`
`) >= 0 && n++, o2 + a3.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return i > 60 ? r[0] + (t === "" ? "" : t + `
 `) + " " + e.join(`,
  `) + " " + r[1] : r[0] + t + " " + e.join(", ") + " " + r[1];
    }
    D3.types = xd();
    function kd(e) {
      return Array.isArray(e);
    }
    D3.isArray = kd;
    function of(e) {
      return typeof e == "boolean";
    }
    D3.isBoolean = of;
    function qi(e) {
      return e === null;
    }
    D3.isNull = qi;
    function im(e) {
      return e == null;
    }
    D3.isNullOrUndefined = im;
    function Fd(e) {
      return typeof e == "number";
    }
    D3.isNumber = Fd;
    function Ci(e) {
      return typeof e == "string";
    }
    D3.isString = Ci;
    function om(e) {
      return typeof e == "symbol";
    }
    D3.isSymbol = om;
    function Mt(e) {
      return e === undefined;
    }
    D3.isUndefined = Mt;
    function Jr(e) {
      return Rr2(e) && af(e) === "[object RegExp]";
    }
    D3.isRegExp = Jr;
    D3.types.isRegExp = Jr;
    function Rr2(e) {
      return typeof e == "object" && e !== null;
    }
    D3.isObject = Rr2;
    function Ui(e) {
      return Rr2(e) && af(e) === "[object Date]";
    }
    D3.isDate = Ui;
    D3.types.isDate = Ui;
    function Qr(e) {
      return Rr2(e) && (af(e) === "[object Error]" || e instanceof Error);
    }
    D3.isError = Qr;
    D3.types.isNativeError = Qr;
    function Mi(e) {
      return typeof e == "function";
    }
    D3.isFunction = Mi;
    function am(e) {
      return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || typeof e > "u";
    }
    D3.isPrimitive = am;
    D3.isBuffer = Id();
    function af(e) {
      return Object.prototype.toString.call(e);
    }
    function rf(e) {
      return e < 10 ? "0" + e.toString(10) : e.toString(10);
    }
    var fm = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function lm() {
      var e = new Date, t = [rf(e.getHours()), rf(e.getMinutes()), rf(e.getSeconds())].join(":");
      return [e.getDate(), fm[e.getMonth()], t].join(" ");
    }
    D3.log = function() {
      console.log("%s - %s", lm(), D3.format.apply(D3, arguments));
    };
    D3.inherits = Td();
    D3._extend = function(e, t) {
      if (!t || !Rr2(t))
        return e;
      for (var r = Object.keys(t), n = r.length;n--; )
        e[r[n]] = t[r[n]];
      return e;
    };
    function Ld(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }
    var Pt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
    D3.promisify = function(t) {
      if (typeof t != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Pt && t[Pt]) {
        var r = t[Pt];
        if (typeof r != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(r, Pt, { value: r, enumerable: false, writable: false, configurable: true }), r;
      }
      function r() {
        for (var n, i, o2 = new Promise(function(u3, l3) {
          n = u3, i = l3;
        }), a3 = [], f3 = 0;f3 < arguments.length; f3++)
          a3.push(arguments[f3]);
        a3.push(function(u3, l3) {
          u3 ? i(u3) : n(l3);
        });
        try {
          t.apply(this, a3);
        } catch (u3) {
          i(u3);
        }
        return o2;
      }
      return Object.setPrototypeOf(r, Object.getPrototypeOf(t)), Pt && Object.defineProperty(r, Pt, { value: r, enumerable: false, writable: false, configurable: true }), Object.defineProperties(r, Od(t));
    };
    D3.promisify.custom = Pt;
    function um(e, t) {
      if (!e) {
        var r = new Error("Promise was rejected with a falsy value");
        r.reason = e, e = r;
      }
      return t(e);
    }
    function sm(e) {
      if (typeof e != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function t() {
        for (var r = [], n = 0;n < arguments.length; n++)
          r.push(arguments[n]);
        var i = r.pop();
        if (typeof i != "function")
          throw new TypeError("The last argument must be of type Function");
        var o2 = this, a3 = function() {
          return i.apply(o2, arguments);
        };
        e.apply(this, r).then(function(f3) {
          process.nextTick(a3.bind(null, null, f3));
        }, function(f3) {
          process.nextTick(um.bind(null, f3, a3));
        });
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, Od(e)), t;
    }
    D3.callbackify = sm;
  });
  be = {};
  Bn(be, { TextDecoder: () => Bd, TextEncoder: () => Dd, default: () => cm });
  Ir2 = wo(() => {
    X3(be, vt(ff()));
    Dd = globalThis.TextEncoder, Bd = globalThis.TextDecoder, cm = { TextEncoder: Dd, TextDecoder: Bd };
  });
  cf = g4((xx, jd) => {
    function Tr(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Tr = function(r) {
        return typeof r;
      } : Tr = function(r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
      }, Tr(e);
    }
    function dm(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function hm(e, t) {
      return t && (Tr(t) === "object" || typeof t == "function") ? t : pm(e);
    }
    function pm(e) {
      if (e === undefined)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function uf(e) {
      return uf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r);
      }, uf(e);
    }
    function ym(e, t) {
      if (typeof t != "function" && t !== null)
        throw new TypeError("Super expression must either be null or a function");
      e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: true, configurable: true } }), t && sf(e, t);
    }
    function sf(e, t) {
      return sf = Object.setPrototypeOf || function(n, i) {
        return n.__proto__ = i, n;
      }, sf(e, t);
    }
    var Md = {}, Or, lf;
    function en(e, t, r) {
      r || (r = Error);
      function n(o2, a3, f3) {
        return typeof t == "string" ? t : t(o2, a3, f3);
      }
      var i = function(o2) {
        ym(a3, o2);
        function a3(f3, u3, l3) {
          var s2;
          return dm(this, a3), s2 = hm(this, uf(a3).call(this, n(f3, u3, l3))), s2.code = e, s2;
        }
        return a3;
      }(r);
      Md[e] = i;
    }
    function Pd(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function _m(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function gm(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function bm(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    en("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    en("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      Or === undefined && (Or = tn()), Or(typeof e == "string", "'name' must be a string");
      var n;
      typeof t == "string" && _m(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (gm(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(Pd(t, "type"));
      else {
        var o2 = bm(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o2, " ").concat(n, " ").concat(Pd(t, "type"));
      }
      return i += ". Received type ".concat(Tr(r)), i;
    }, TypeError);
    en("ERR_INVALID_ARG_VALUE", function(e, t) {
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
      lf === undefined && (lf = (Ir2(), se(be)));
      var n = lf.inspect(t);
      return n.length > 128 && (n = "".concat(n.slice(0, 128), "...")), "The argument '".concat(e, "' ").concat(r, ". Received ").concat(n);
    }, TypeError, RangeError);
    en("ERR_INVALID_RETURN_VALUE", function(e, t, r) {
      var n;
      return r && r.constructor && r.constructor.name ? n = "instance of ".concat(r.constructor.name) : n = "type ".concat(Tr(r)), "Expected ".concat(e, ' to be returned from the "').concat(t, '"') + " function but got ".concat(n, ".");
    }, TypeError);
    en("ERR_MISSING_ARGS", function() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      Or === undefined && (Or = tn()), Or(t.length > 0, "At least one arg needs to be specified");
      var n = "The ", i = t.length;
      switch (t = t.map(function(o2) {
        return '"'.concat(o2, '"');
      }), i) {
        case 1:
          n += "".concat(t[0], " argument");
          break;
        case 2:
          n += "".concat(t[0], " and ").concat(t[1], " arguments");
          break;
        default:
          n += t.slice(0, i - 1).join(", "), n += ", and ".concat(t[i - 1], " arguments");
          break;
      }
      return "".concat(n, " must be specified");
    }, TypeError);
    jd.exports.codes = Md;
  });
  Wd = g4((Rx, zd) => {
    function wm(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {}, n = Object.keys(r);
        typeof Object.getOwnPropertySymbols == "function" && (n = n.concat(Object.getOwnPropertySymbols(r).filter(function(i) {
          return Object.getOwnPropertyDescriptor(r, i).enumerable;
        }))), n.forEach(function(i) {
          Em(e, i, r[i]);
        });
      }
      return e;
    }
    function Em(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function vm(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function Ud(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function mm(e, t, r) {
      return t && Ud(e.prototype, t), r && Ud(e, r), e;
    }
    function Nr(e, t) {
      return t && (we(t) === "object" || typeof t == "function") ? t : df(e);
    }
    function df(e) {
      if (e === undefined)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function Sm(e, t) {
      if (typeof t != "function" && t !== null)
        throw new TypeError("Super expression must either be null or a function");
      e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: true, configurable: true } }), t && an(e, t);
    }
    function hf(e) {
      var t = typeof Map == "function" ? new Map : undefined;
      return hf = function(n) {
        if (n === null || !xm(n))
          return n;
        if (typeof n != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof t < "u") {
          if (t.has(n))
            return t.get(n);
          t.set(n, i);
        }
        function i() {
          return zi(n, arguments, st3(this).constructor);
        }
        return i.prototype = Object.create(n.prototype, { constructor: { value: i, enumerable: false, writable: true, configurable: true } }), an(i, n);
      }, hf(e);
    }
    function Am() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return false;
      if (typeof Proxy == "function")
        return true;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        })), true;
      } catch {
        return false;
      }
    }
    function zi(e, t, r) {
      return Am() ? zi = Reflect.construct : zi = function(i, o2, a3) {
        var f3 = [null];
        f3.push.apply(f3, o2);
        var u3 = Function.bind.apply(i, f3), l3 = new u3;
        return a3 && an(l3, a3.prototype), l3;
      }, zi.apply(null, arguments);
    }
    function xm(e) {
      return Function.toString.call(e).indexOf("[native code]") !== -1;
    }
    function an(e, t) {
      return an = Object.setPrototypeOf || function(n, i) {
        return n.__proto__ = i, n;
      }, an(e, t);
    }
    function st3(e) {
      return st3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r);
      }, st3(e);
    }
    function we(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? we = function(r) {
        return typeof r;
      } : we = function(r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
      }, we(e);
    }
    var Rm = (Ir2(), se(be)), pf = Rm.inspect, Im = cf(), Tm = Im.codes.ERR_INVALID_ARG_TYPE;
    function qd(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Om(e, t) {
      if (t = Math.floor(t), e.length == 0 || t == 0)
        return "";
      var r = e.length * t;
      for (t = Math.floor(Math.log(t) / Math.log(2));t; )
        e += e, t--;
      return e += e.substring(0, r - e.length), e;
    }
    var Ne = "", rn = "", nn = "", ee = "", jt = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" }, Nm = 10;
    function Cd(e) {
      var t = Object.keys(e), r = Object.create(Object.getPrototypeOf(e));
      return t.forEach(function(n) {
        r[n] = e[n];
      }), Object.defineProperty(r, "message", { value: e.message }), r;
    }
    function on(e) {
      return pf(e, { compact: false, customInspect: false, depth: 1000, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
    }
    function km(e, t, r) {
      var n = "", i = "", o2 = 0, a3 = "", f3 = false, u3 = on(e), l3 = u3.split(`
`), s2 = on(t).split(`
`), c2 = 0, h5 = "";
      if (r === "strictEqual" && we(e) === "object" && we(t) === "object" && e !== null && t !== null && (r = "strictEqualObject"), l3.length === 1 && s2.length === 1 && l3[0] !== s2[0]) {
        var d4 = l3[0].length + s2[0].length;
        if (d4 <= Nm) {
          if ((we(e) !== "object" || e === null) && (we(t) !== "object" || t === null) && (e !== 0 || t !== 0))
            return "".concat(jt[r], `

`) + "".concat(l3[0], " !== ").concat(s2[0], `
`);
        } else if (r !== "strictEqualObject") {
          var y5 = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (d4 < y5) {
            for (;l3[0][c2] === s2[0][c2]; )
              c2++;
            c2 > 2 && (h5 = `
  `.concat(Om(" ", c2), "^"), c2 = 0);
          }
        }
      }
      for (var b4 = l3[l3.length - 1], R3 = s2[s2.length - 1];b4 === R3 && (c2++ < 2 ? a3 = `
  `.concat(b4).concat(a3) : n = b4, l3.pop(), s2.pop(), !(l3.length === 0 || s2.length === 0)); )
        b4 = l3[l3.length - 1], R3 = s2[s2.length - 1];
      var _4 = Math.max(l3.length, s2.length);
      if (_4 === 0) {
        var E5 = u3.split(`
`);
        if (E5.length > 30)
          for (E5[26] = "".concat(Ne, "...").concat(ee);E5.length > 27; )
            E5.pop();
        return "".concat(jt.notIdentical, `

`).concat(E5.join(`
`), `
`);
      }
      c2 > 3 && (a3 = `
`.concat(Ne, "...").concat(ee).concat(a3), f3 = true), n !== "" && (a3 = `
  `.concat(n).concat(a3), n = "");
      var m3 = 0, A4 = jt[r] + `
`.concat(rn, "+ actual").concat(ee, " ").concat(nn, "- expected").concat(ee), v4 = " ".concat(Ne, "...").concat(ee, " Lines skipped");
      for (c2 = 0;c2 < _4; c2++) {
        var T3 = c2 - o2;
        if (l3.length < c2 + 1)
          T3 > 1 && c2 > 2 && (T3 > 4 ? (i += `
`.concat(Ne, "...").concat(ee), f3 = true) : T3 > 3 && (i += `
  `.concat(s2[c2 - 2]), m3++), i += `
  `.concat(s2[c2 - 1]), m3++), o2 = c2, n += `
`.concat(nn, "-").concat(ee, " ").concat(s2[c2]), m3++;
        else if (s2.length < c2 + 1)
          T3 > 1 && c2 > 2 && (T3 > 4 ? (i += `
`.concat(Ne, "...").concat(ee), f3 = true) : T3 > 3 && (i += `
  `.concat(l3[c2 - 2]), m3++), i += `
  `.concat(l3[c2 - 1]), m3++), o2 = c2, i += `
`.concat(rn, "+").concat(ee, " ").concat(l3[c2]), m3++;
        else {
          var I4 = s2[c2], S3 = l3[c2], k3 = S3 !== I4 && (!qd(S3, ",") || S3.slice(0, -1) !== I4);
          k3 && qd(I4, ",") && I4.slice(0, -1) === S3 && (k3 = false, S3 += ","), k3 ? (T3 > 1 && c2 > 2 && (T3 > 4 ? (i += `
`.concat(Ne, "...").concat(ee), f3 = true) : T3 > 3 && (i += `
  `.concat(l3[c2 - 2]), m3++), i += `
  `.concat(l3[c2 - 1]), m3++), o2 = c2, i += `
`.concat(rn, "+").concat(ee, " ").concat(S3), n += `
`.concat(nn, "-").concat(ee, " ").concat(I4), m3 += 2) : (i += n, n = "", (T3 === 1 || c2 === 0) && (i += `
  `.concat(S3), m3++));
        }
        if (m3 > 20 && c2 < _4 - 2)
          return "".concat(A4).concat(v4, `
`).concat(i, `
`).concat(Ne, "...").concat(ee).concat(n, `
`) + "".concat(Ne, "...").concat(ee);
      }
      return "".concat(A4).concat(f3 ? v4 : "", `
`).concat(i).concat(n).concat(a3).concat(h5);
    }
    var Fm = function(e) {
      Sm(t, e);
      function t(r) {
        var n;
        if (vm(this, t), we(r) !== "object" || r === null)
          throw new Tm("options", "Object", r);
        var { message: i, operator: o2, stackStartFn: a3, actual: f3, expected: u3 } = r, l3 = Error.stackTraceLimit;
        if (Error.stackTraceLimit = 0, i != null)
          n = Nr(this, st3(t).call(this, String(i)));
        else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 ? (Ne = "\x1B[34m", rn = "\x1B[32m", ee = "\x1B[39m", nn = "\x1B[31m") : (Ne = "", rn = "", ee = "", nn = "")), we(f3) === "object" && f3 !== null && we(u3) === "object" && u3 !== null && "stack" in f3 && f3 instanceof Error && "stack" in u3 && u3 instanceof Error && (f3 = Cd(f3), u3 = Cd(u3)), o2 === "deepStrictEqual" || o2 === "strictEqual")
          n = Nr(this, st3(t).call(this, km(f3, u3, o2)));
        else if (o2 === "notDeepStrictEqual" || o2 === "notStrictEqual") {
          var s2 = jt[o2], c2 = on(f3).split(`
`);
          if (o2 === "notStrictEqual" && we(f3) === "object" && f3 !== null && (s2 = jt.notStrictEqualObject), c2.length > 30)
            for (c2[26] = "".concat(Ne, "...").concat(ee);c2.length > 27; )
              c2.pop();
          c2.length === 1 ? n = Nr(this, st3(t).call(this, "".concat(s2, " ").concat(c2[0]))) : n = Nr(this, st3(t).call(this, "".concat(s2, `

`).concat(c2.join(`
`), `
`)));
        } else {
          var h5 = on(f3), d4 = "", y5 = jt[o2];
          o2 === "notDeepEqual" || o2 === "notEqual" ? (h5 = "".concat(jt[o2], `

`).concat(h5), h5.length > 1024 && (h5 = "".concat(h5.slice(0, 1021), "..."))) : (d4 = "".concat(on(u3)), h5.length > 512 && (h5 = "".concat(h5.slice(0, 509), "...")), d4.length > 512 && (d4 = "".concat(d4.slice(0, 509), "...")), o2 === "deepEqual" || o2 === "equal" ? h5 = "".concat(y5, `

`).concat(h5, `

should equal

`) : d4 = " ".concat(o2, " ").concat(d4)), n = Nr(this, st3(t).call(this, "".concat(h5).concat(d4)));
        }
        return Error.stackTraceLimit = l3, n.generatedMessage = !i, Object.defineProperty(df(n), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), n.code = "ERR_ASSERTION", n.actual = f3, n.expected = u3, n.operator = o2, Error.captureStackTrace && Error.captureStackTrace(df(n), a3), n.stack, n.name = "AssertionError", Nr(n);
      }
      return mm(t, [{ key: "toString", value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      } }, { key: pf.custom, value: function(n, i) {
        return pf(this, wm({}, i, { customInspect: false, depth: 0 }));
      } }]), t;
    }(hf(Error));
    zd.exports = Fm;
  });
  Gd = g4((Ix, $d) => {
    function Zd(e, t) {
      if (e == null)
        throw new TypeError("Cannot convert first argument to object");
      for (var r = Object(e), n = 1;n < arguments.length; n++) {
        var i = arguments[n];
        if (i != null)
          for (var o2 = Object.keys(Object(i)), a3 = 0, f3 = o2.length;a3 < f3; a3++) {
            var u3 = o2[a3], l3 = Object.getOwnPropertyDescriptor(i, u3);
            l3 !== undefined && l3.enumerable && (r[u3] = i[u3]);
          }
      }
      return r;
    }
    function Lm() {
      Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: Zd });
    }
    $d.exports = { assign: Zd, polyfill: Lm };
  });
  yf = g4((Tx, Vd) => {
    var Hd = Object.prototype.toString;
    Vd.exports = function(t) {
      var r = Hd.call(t), n = r === "[object Arguments]";
      return n || (n = r !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Hd.call(t.callee) === "[object Function]"), n;
    };
  });
  nh = g4((Ox, rh) => {
    var th;
    Object.keys || (fn = Object.prototype.hasOwnProperty, _f = Object.prototype.toString, Yd = yf(), gf = Object.prototype.propertyIsEnumerable, Kd = !gf.call({ toString: null }, "toString"), Xd = gf.call(function() {
    }, "prototype"), ln = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], Wi = function(e) {
      var t = e.constructor;
      return t && t.prototype === e;
    }, Jd = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, Qd = function() {
      if (typeof window > "u")
        return false;
      for (var e in window)
        try {
          if (!Jd["$" + e] && fn.call(window, e) && window[e] !== null && typeof window[e] == "object")
            try {
              Wi(window[e]);
            } catch {
              return true;
            }
        } catch {
          return true;
        }
      return false;
    }(), eh = function(e) {
      if (typeof window > "u" || !Qd)
        return Wi(e);
      try {
        return Wi(e);
      } catch {
        return false;
      }
    }, th = function(t) {
      var r = t !== null && typeof t == "object", n = _f.call(t) === "[object Function]", i = Yd(t), o2 = r && _f.call(t) === "[object String]", a3 = [];
      if (!r && !n && !i)
        throw new TypeError("Object.keys called on a non-object");
      var f3 = Xd && n;
      if (o2 && t.length > 0 && !fn.call(t, 0))
        for (var u3 = 0;u3 < t.length; ++u3)
          a3.push(String(u3));
      if (i && t.length > 0)
        for (var l3 = 0;l3 < t.length; ++l3)
          a3.push(String(l3));
      else
        for (var s2 in t)
          !(f3 && s2 === "prototype") && fn.call(t, s2) && a3.push(String(s2));
      if (Kd)
        for (var c2 = eh(t), h5 = 0;h5 < ln.length; ++h5)
          !(c2 && ln[h5] === "constructor") && fn.call(t, ln[h5]) && a3.push(ln[h5]);
      return a3;
    });
    var fn, _f, Yd, gf, Kd, Xd, ln, Wi, Jd, Qd, eh;
    rh.exports = th;
  });
  fh = g4((Nx, ah) => {
    var Dm = Array.prototype.slice, Bm = yf(), ih = Object.keys, Zi = ih ? function(t) {
      return ih(t);
    } : nh(), oh = Object.keys;
    Zi.shim = function() {
      if (Object.keys) {
        var t = function() {
          var r = Object.keys(arguments);
          return r && r.length === arguments.length;
        }(1, 2);
        t || (Object.keys = function(n) {
          return Bm(n) ? oh(Dm.call(n)) : oh(n);
        });
      } else
        Object.keys = Zi;
      return Object.keys || Zi;
    };
    ah.exports = Zi;
  });
  uh = g4((kx, lh) => {
    var Pm = Yr(), bf = Pm("%Object.defineProperty%", true), wf = function() {
      if (bf)
        try {
          return bf({}, "a", { value: 1 }), true;
        } catch {
          return false;
        }
      return false;
    };
    wf.hasArrayLengthDefineBug = function() {
      if (!wf())
        return null;
      try {
        return bf([], "length", { value: 1 }).length !== 1;
      } catch {
        return true;
      }
    };
    lh.exports = wf;
  });
  un = g4((Fx, hh) => {
    var Mm = fh(), jm = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", Um = Object.prototype.toString, qm = Array.prototype.concat, sh = Object.defineProperty, Cm = function(e) {
      return typeof e == "function" && Um.call(e) === "[object Function]";
    }, zm = uh()(), ch = sh && zm, Wm = function(e, t, r, n) {
      if (t in e) {
        if (n === true) {
          if (e[t] === r)
            return;
        } else if (!Cm(n) || !n())
          return;
      }
      ch ? sh(e, t, { configurable: true, enumerable: false, value: r, writable: true }) : e[t] = r;
    }, dh = function(e, t) {
      var r = arguments.length > 2 ? arguments[2] : {}, n = Mm(t);
      jm && (n = qm.call(n, Object.getOwnPropertySymbols(t)));
      for (var i = 0;i < n.length; i += 1)
        Wm(e, n[i], t[n[i]], r[n[i]]);
    };
    dh.supportsDescriptors = !!ch;
    hh.exports = dh;
  });
  Ef = g4((Lx, yh) => {
    var ph = function(e) {
      return e !== e;
    };
    yh.exports = function(t, r) {
      return t === 0 && r === 0 ? 1 / t === 1 / r : !!(t === r || ph(t) && ph(r));
    };
  });
  vf = g4((Dx, _h) => {
    var Zm = Ef();
    _h.exports = function() {
      return typeof Object.is == "function" ? Object.is : Zm;
    };
  });
  bh = g4((Bx, gh) => {
    var $m = vf(), Gm = un();
    gh.exports = function() {
      var t = $m();
      return Gm(Object, { is: t }, { is: function() {
        return Object.is !== t;
      } }), t;
    };
  });
  mf = g4((Px, vh) => {
    var Hm = un(), Vm = Si(), Ym = Ef(), wh = vf(), Km = bh(), Eh = Vm(wh(), Object);
    Hm(Eh, { getPolyfill: wh, implementation: Ym, shim: Km });
    vh.exports = Eh;
  });
  Sf = g4((Mx, mh) => {
    mh.exports = function(t) {
      return t !== t;
    };
  });
  Af = g4((jx, Sh) => {
    var Xm = Sf();
    Sh.exports = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : Xm;
    };
  });
  xh = g4((Ux, Ah) => {
    var Jm = un(), Qm = Af();
    Ah.exports = function() {
      var t = Qm();
      return Jm(Number, { isNaN: t }, { isNaN: function() {
        return Number.isNaN !== t;
      } }), t;
    };
  });
  Oh = g4((qx, Th) => {
    var eS = Si(), tS = un(), rS = Sf(), Rh = Af(), nS = xh(), Ih = eS(Rh(), Number);
    tS(Ih, { getPolyfill: Rh, implementation: rS, shim: nS });
    Th.exports = Ih;
  });
  Vh = g4((Cx, Hh) => {
    function Nh(e, t) {
      return aS(e) || oS(e, t) || iS();
    }
    function iS() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function oS(e, t) {
      var r = [], n = true, i = false, o2 = undefined;
      try {
        for (var a3 = e[Symbol.iterator](), f3;!(n = (f3 = a3.next()).done) && (r.push(f3.value), !(t && r.length === t)); n = true)
          ;
      } catch (u3) {
        i = true, o2 = u3;
      } finally {
        try {
          !n && a3.return != null && a3.return();
        } finally {
          if (i)
            throw o2;
        }
      }
      return r;
    }
    function aS(e) {
      if (Array.isArray(e))
        return e;
    }
    function ce2(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ce2 = function(r) {
        return typeof r;
      } : ce2 = function(r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
      }, ce2(e);
    }
    var fS = /a/g.flags !== undefined, Xi = function(t) {
      var r = [];
      return t.forEach(function(n) {
        return r.push(n);
      }), r;
    }, kh = function(t) {
      var r = [];
      return t.forEach(function(n, i) {
        return r.push([i, n]);
      }), r;
    }, zh = Object.is ? Object.is : mf(), Yi = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    }, xf = Number.isNaN ? Number.isNaN : Oh();
    function If(e) {
      return e.call.bind(e);
    }
    var cn = If(Object.prototype.hasOwnProperty), Ki = If(Object.prototype.propertyIsEnumerable), Fh = If(Object.prototype.toString), ie = (Ir2(), se(be)).types, lS = ie.isAnyArrayBuffer, uS = ie.isArrayBufferView, Lh = ie.isDate, $i = ie.isMap, Dh = ie.isRegExp, Gi = ie.isSet, sS = ie.isNativeError, cS = ie.isBoxedPrimitive, Bh = ie.isNumberObject, Ph = ie.isStringObject, Mh = ie.isBooleanObject, jh = ie.isBigIntObject, dS = ie.isSymbolObject, hS = ie.isFloat32Array, pS = ie.isFloat64Array;
    function yS(e) {
      if (e.length === 0 || e.length > 10)
        return true;
      for (var t = 0;t < e.length; t++) {
        var r = e.charCodeAt(t);
        if (r < 48 || r > 57)
          return true;
      }
      return e.length === 10 && e >= Math.pow(2, 32);
    }
    function Hi(e) {
      return Object.keys(e).filter(yS).concat(Yi(e).filter(Object.prototype.propertyIsEnumerable.bind(e)));
    }
    function Wh(e, t) {
      if (e === t)
        return 0;
      for (var r = e.length, n = t.length, i = 0, o2 = Math.min(r, n);i < o2; ++i)
        if (e[i] !== t[i]) {
          r = e[i], n = t[i];
          break;
        }
      return r < n ? -1 : n < r ? 1 : 0;
    }
    var Vi = undefined, _S = true, gS = false, Rf = 0, Tf = 1, Zh = 2, $h = 3;
    function bS(e, t) {
      return fS ? e.source === t.source && e.flags === t.flags : RegExp.prototype.toString.call(e) === RegExp.prototype.toString.call(t);
    }
    function wS(e, t) {
      if (e.byteLength !== t.byteLength)
        return false;
      for (var r = 0;r < e.byteLength; r++)
        if (e[r] !== t[r])
          return false;
      return true;
    }
    function ES(e, t) {
      return e.byteLength !== t.byteLength ? false : Wh(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength)) === 0;
    }
    function vS(e, t) {
      return e.byteLength === t.byteLength && Wh(new Uint8Array(e), new Uint8Array(t)) === 0;
    }
    function mS(e, t) {
      return Bh(e) ? Bh(t) && zh(Number.prototype.valueOf.call(e), Number.prototype.valueOf.call(t)) : Ph(e) ? Ph(t) && String.prototype.valueOf.call(e) === String.prototype.valueOf.call(t) : Mh(e) ? Mh(t) && Boolean.prototype.valueOf.call(e) === Boolean.prototype.valueOf.call(t) : jh(e) ? jh(t) && BigInt.prototype.valueOf.call(e) === BigInt.prototype.valueOf.call(t) : dS(t) && Symbol.prototype.valueOf.call(e) === Symbol.prototype.valueOf.call(t);
    }
    function Ee(e, t, r, n) {
      if (e === t)
        return e !== 0 ? true : r ? zh(e, t) : true;
      if (r) {
        if (ce2(e) !== "object")
          return typeof e == "number" && xf(e) && xf(t);
        if (ce2(t) !== "object" || e === null || t === null || Object.getPrototypeOf(e) !== Object.getPrototypeOf(t))
          return false;
      } else {
        if (e === null || ce2(e) !== "object")
          return t === null || ce2(t) !== "object" ? e == t : false;
        if (t === null || ce2(t) !== "object")
          return false;
      }
      var i = Fh(e), o2 = Fh(t);
      if (i !== o2)
        return false;
      if (Array.isArray(e)) {
        if (e.length !== t.length)
          return false;
        var a3 = Hi(e, Vi), f3 = Hi(t, Vi);
        return a3.length !== f3.length ? false : sn(e, t, r, n, Tf, a3);
      }
      if (i === "[object Object]" && (!$i(e) && $i(t) || !Gi(e) && Gi(t)))
        return false;
      if (Lh(e)) {
        if (!Lh(t) || Date.prototype.getTime.call(e) !== Date.prototype.getTime.call(t))
          return false;
      } else if (Dh(e)) {
        if (!Dh(t) || !bS(e, t))
          return false;
      } else if (sS(e) || e instanceof Error) {
        if (e.message !== t.message || e.name !== t.name)
          return false;
      } else if (uS(e)) {
        if (!r && (hS(e) || pS(e))) {
          if (!wS(e, t))
            return false;
        } else if (!ES(e, t))
          return false;
        var u3 = Hi(e, Vi), l3 = Hi(t, Vi);
        return u3.length !== l3.length ? false : sn(e, t, r, n, Rf, u3);
      } else {
        if (Gi(e))
          return !Gi(t) || e.size !== t.size ? false : sn(e, t, r, n, Zh);
        if ($i(e))
          return !$i(t) || e.size !== t.size ? false : sn(e, t, r, n, $h);
        if (lS(e)) {
          if (!vS(e, t))
            return false;
        } else if (cS(e) && !mS(e, t))
          return false;
      }
      return sn(e, t, r, n, Rf);
    }
    function Uh(e, t) {
      return t.filter(function(r) {
        return Ki(e, r);
      });
    }
    function sn(e, t, r, n, i, o2) {
      if (arguments.length === 5) {
        o2 = Object.keys(e);
        var a3 = Object.keys(t);
        if (o2.length !== a3.length)
          return false;
      }
      for (var f3 = 0;f3 < o2.length; f3++)
        if (!cn(t, o2[f3]))
          return false;
      if (r && arguments.length === 5) {
        var u3 = Yi(e);
        if (u3.length !== 0) {
          var l3 = 0;
          for (f3 = 0;f3 < u3.length; f3++) {
            var s2 = u3[f3];
            if (Ki(e, s2)) {
              if (!Ki(t, s2))
                return false;
              o2.push(s2), l3++;
            } else if (Ki(t, s2))
              return false;
          }
          var c2 = Yi(t);
          if (u3.length !== c2.length && Uh(t, c2).length !== l3)
            return false;
        } else {
          var h5 = Yi(t);
          if (h5.length !== 0 && Uh(t, h5).length !== 0)
            return false;
        }
      }
      if (o2.length === 0 && (i === Rf || i === Tf && e.length === 0 || e.size === 0))
        return true;
      if (n === undefined)
        n = { val1: new Map, val2: new Map, position: 0 };
      else {
        var d4 = n.val1.get(e);
        if (d4 !== undefined) {
          var y5 = n.val2.get(t);
          if (y5 !== undefined)
            return d4 === y5;
        }
        n.position++;
      }
      n.val1.set(e, n.position), n.val2.set(t, n.position);
      var b4 = IS(e, t, r, o2, n, i);
      return n.val1.delete(e), n.val2.delete(t), b4;
    }
    function qh(e, t, r, n) {
      for (var i = Xi(e), o2 = 0;o2 < i.length; o2++) {
        var a3 = i[o2];
        if (Ee(t, a3, r, n))
          return e.delete(a3), true;
      }
      return false;
    }
    function Gh(e) {
      switch (ce2(e)) {
        case "undefined":
          return null;
        case "object":
          return;
        case "symbol":
          return false;
        case "string":
          e = +e;
        case "number":
          if (xf(e))
            return false;
      }
      return true;
    }
    function SS(e, t, r) {
      var n = Gh(r);
      return n ?? (t.has(n) && !e.has(n));
    }
    function AS(e, t, r, n, i) {
      var o2 = Gh(r);
      if (o2 != null)
        return o2;
      var a3 = t.get(o2);
      return a3 === undefined && !t.has(o2) || !Ee(n, a3, false, i) ? false : !e.has(o2) && Ee(n, a3, false, i);
    }
    function xS(e, t, r, n) {
      for (var i = null, o2 = Xi(e), a3 = 0;a3 < o2.length; a3++) {
        var f3 = o2[a3];
        if (ce2(f3) === "object" && f3 !== null)
          i === null && (i = new Set), i.add(f3);
        else if (!t.has(f3)) {
          if (r || !SS(e, t, f3))
            return false;
          i === null && (i = new Set), i.add(f3);
        }
      }
      if (i !== null) {
        for (var u3 = Xi(t), l3 = 0;l3 < u3.length; l3++) {
          var s2 = u3[l3];
          if (ce2(s2) === "object" && s2 !== null) {
            if (!qh(i, s2, r, n))
              return false;
          } else if (!r && !e.has(s2) && !qh(i, s2, r, n))
            return false;
        }
        return i.size === 0;
      }
      return true;
    }
    function Ch(e, t, r, n, i, o2) {
      for (var a3 = Xi(e), f3 = 0;f3 < a3.length; f3++) {
        var u3 = a3[f3];
        if (Ee(r, u3, i, o2) && Ee(n, t.get(u3), i, o2))
          return e.delete(u3), true;
      }
      return false;
    }
    function RS(e, t, r, n) {
      for (var i = null, o2 = kh(e), a3 = 0;a3 < o2.length; a3++) {
        var f3 = Nh(o2[a3], 2), u3 = f3[0], l3 = f3[1];
        if (ce2(u3) === "object" && u3 !== null)
          i === null && (i = new Set), i.add(u3);
        else {
          var s2 = t.get(u3);
          if (s2 === undefined && !t.has(u3) || !Ee(l3, s2, r, n)) {
            if (r || !AS(e, t, u3, l3, n))
              return false;
            i === null && (i = new Set), i.add(u3);
          }
        }
      }
      if (i !== null) {
        for (var c2 = kh(t), h5 = 0;h5 < c2.length; h5++) {
          var d4 = Nh(c2[h5], 2), u3 = d4[0], y5 = d4[1];
          if (ce2(u3) === "object" && u3 !== null) {
            if (!Ch(i, e, u3, y5, r, n))
              return false;
          } else if (!r && (!e.has(u3) || !Ee(e.get(u3), y5, false, n)) && !Ch(i, e, u3, y5, false, n))
            return false;
        }
        return i.size === 0;
      }
      return true;
    }
    function IS(e, t, r, n, i, o2) {
      var a3 = 0;
      if (o2 === Zh) {
        if (!xS(e, t, r, i))
          return false;
      } else if (o2 === $h) {
        if (!RS(e, t, r, i))
          return false;
      } else if (o2 === Tf)
        for (;a3 < e.length; a3++)
          if (cn(e, a3)) {
            if (!cn(t, a3) || !Ee(e[a3], t[a3], r, i))
              return false;
          } else {
            if (cn(t, a3))
              return false;
            for (var f3 = Object.keys(e);a3 < f3.length; a3++) {
              var u3 = f3[a3];
              if (!cn(t, u3) || !Ee(e[u3], t[u3], r, i))
                return false;
            }
            return f3.length === Object.keys(t).length;
          }
      for (a3 = 0;a3 < n.length; a3++) {
        var l3 = n[a3];
        if (!Ee(e[l3], t[l3], r, i))
          return false;
      }
      return true;
    }
    function TS(e, t) {
      return Ee(e, t, gS);
    }
    function OS(e, t) {
      return Ee(e, t, _S);
    }
    Hh.exports = { isDeepEqual: TS, isDeepStrictEqual: OS };
  });
  tn = g4((zx, sp) => {
    function ct3(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ct3 = function(r) {
        return typeof r;
      } : ct3 = function(r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
      }, ct3(e);
    }
    function NS(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    var kS = cf(), hn = kS.codes, Yh = hn.ERR_AMBIGUOUS_ARGUMENT, dn = hn.ERR_INVALID_ARG_TYPE, FS = hn.ERR_INVALID_ARG_VALUE, LS = hn.ERR_INVALID_RETURN_VALUE, ht2 = hn.ERR_MISSING_ARGS, Ut = Wd(), DS = (Ir2(), se(be)), BS = DS.inspect, Qh = (Ir2(), se(be)).types, PS = Qh.isPromise, Of = Qh.isRegExp, MS = Object.assign ? Object.assign : Gd().assign, ep = Object.is ? Object.is : mf(), dt2, Ji;
    function pn() {
      var e = Vh();
      dt2 = e.isDeepEqual, Ji = e.isDeepStrictEqual;
    }
    var Kh = false, q3 = sp.exports = Nf, Qi = {};
    function ke(e) {
      throw e.message instanceof Error ? e.message : new Ut(e);
    }
    function tp(e, t, r, n, i) {
      var o2 = arguments.length, a3;
      if (o2 === 0)
        a3 = "Failed";
      else if (o2 === 1)
        r = e, e = undefined;
      else {
        if (Kh === false) {
          Kh = true;
          var f3 = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          f3("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        o2 === 2 && (n = "!=");
      }
      if (r instanceof Error)
        throw r;
      var u3 = { actual: e, expected: t, operator: n === undefined ? "fail" : n, stackStartFn: i || tp };
      r !== undefined && (u3.message = r);
      var l3 = new Ut(u3);
      throw a3 && (l3.message = a3, l3.generatedMessage = true), l3;
    }
    q3.fail = tp;
    q3.AssertionError = Ut;
    function rp(e, t, r, n) {
      if (!r) {
        var i = false;
        if (t === 0)
          i = true, n = "No value argument passed to `assert.ok()`";
        else if (n instanceof Error)
          throw n;
        var o2 = new Ut({ actual: r, expected: true, message: n, operator: "==", stackStartFn: e });
        throw o2.generatedMessage = i, o2;
      }
    }
    function Nf() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      rp.apply(undefined, [Nf, t.length].concat(t));
    }
    q3.ok = Nf;
    q3.equal = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      t != r && ke({ actual: t, expected: r, message: n, operator: "==", stackStartFn: e });
    };
    q3.notEqual = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      t == r && ke({ actual: t, expected: r, message: n, operator: "!=", stackStartFn: e });
    };
    q3.deepEqual = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      dt2 === undefined && pn(), dt2(t, r) || ke({ actual: t, expected: r, message: n, operator: "deepEqual", stackStartFn: e });
    };
    q3.notDeepEqual = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      dt2 === undefined && pn(), dt2(t, r) && ke({ actual: t, expected: r, message: n, operator: "notDeepEqual", stackStartFn: e });
    };
    q3.deepStrictEqual = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      dt2 === undefined && pn(), Ji(t, r) || ke({ actual: t, expected: r, message: n, operator: "deepStrictEqual", stackStartFn: e });
    };
    q3.notDeepStrictEqual = np;
    function np(e, t, r) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      dt2 === undefined && pn(), Ji(e, t) && ke({ actual: e, expected: t, message: r, operator: "notDeepStrictEqual", stackStartFn: np });
    }
    q3.strictEqual = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      ep(t, r) || ke({ actual: t, expected: r, message: n, operator: "strictEqual", stackStartFn: e });
    };
    q3.notStrictEqual = function e(t, r, n) {
      if (arguments.length < 2)
        throw new ht2("actual", "expected");
      ep(t, r) && ke({ actual: t, expected: r, message: n, operator: "notStrictEqual", stackStartFn: e });
    };
    var Xh = function e(t, r, n) {
      var i = this;
      NS(this, e), r.forEach(function(o2) {
        o2 in t && (n !== undefined && typeof n[o2] == "string" && Of(t[o2]) && t[o2].test(n[o2]) ? i[o2] = n[o2] : i[o2] = t[o2]);
      });
    };
    function jS(e, t, r, n, i, o2) {
      if (!(r in e) || !Ji(e[r], t[r])) {
        if (!n) {
          var a3 = new Xh(e, i), f3 = new Xh(t, i, e), u3 = new Ut({ actual: a3, expected: f3, operator: "deepStrictEqual", stackStartFn: o2 });
          throw u3.actual = e, u3.expected = t, u3.operator = o2.name, u3;
        }
        ke({ actual: e, expected: t, message: n, operator: o2.name, stackStartFn: o2 });
      }
    }
    function ip(e, t, r, n) {
      if (typeof t != "function") {
        if (Of(t))
          return t.test(e);
        if (arguments.length === 2)
          throw new dn("expected", ["Function", "RegExp"], t);
        if (ct3(e) !== "object" || e === null) {
          var i = new Ut({ actual: e, expected: t, message: r, operator: "deepStrictEqual", stackStartFn: n });
          throw i.operator = n.name, i;
        }
        var o2 = Object.keys(t);
        if (t instanceof Error)
          o2.push("name", "message");
        else if (o2.length === 0)
          throw new FS("error", t, "may not be an empty object");
        return dt2 === undefined && pn(), o2.forEach(function(a3) {
          typeof e[a3] == "string" && Of(t[a3]) && t[a3].test(e[a3]) || jS(e, t, a3, r, o2, n);
        }), true;
      }
      return t.prototype !== undefined && e instanceof t ? true : Error.isPrototypeOf(t) ? false : t.call({}, e) === true;
    }
    function op(e) {
      if (typeof e != "function")
        throw new dn("fn", "Function", e);
      try {
        e();
      } catch (t) {
        return t;
      }
      return Qi;
    }
    function Jh(e) {
      return PS(e) || e !== null && ct3(e) === "object" && typeof e.then == "function" && typeof e.catch == "function";
    }
    function ap(e) {
      return Promise.resolve().then(function() {
        var t;
        if (typeof e == "function") {
          if (t = e(), !Jh(t))
            throw new LS("instance of Promise", "promiseFn", t);
        } else if (Jh(e))
          t = e;
        else
          throw new dn("promiseFn", ["Function", "Promise"], e);
        return Promise.resolve().then(function() {
          return t;
        }).then(function() {
          return Qi;
        }).catch(function(r) {
          return r;
        });
      });
    }
    function fp(e, t, r, n) {
      if (typeof r == "string") {
        if (arguments.length === 4)
          throw new dn("error", ["Object", "Error", "Function", "RegExp"], r);
        if (ct3(t) === "object" && t !== null) {
          if (t.message === r)
            throw new Yh("error/message", 'The error message "'.concat(t.message, '" is identical to the message.'));
        } else if (t === r)
          throw new Yh("error/message", 'The error "'.concat(t, '" is identical to the message.'));
        n = r, r = undefined;
      } else if (r != null && ct3(r) !== "object" && typeof r != "function")
        throw new dn("error", ["Object", "Error", "Function", "RegExp"], r);
      if (t === Qi) {
        var i = "";
        r && r.name && (i += " (".concat(r.name, ")")), i += n ? ": ".concat(n) : ".";
        var o2 = e.name === "rejects" ? "rejection" : "exception";
        ke({ actual: undefined, expected: r, operator: e.name, message: "Missing expected ".concat(o2).concat(i), stackStartFn: e });
      }
      if (r && !ip(t, r, n, e))
        throw t;
    }
    function lp(e, t, r, n) {
      if (t !== Qi) {
        if (typeof r == "string" && (n = r, r = undefined), !r || ip(t, r)) {
          var i = n ? ": ".concat(n) : ".", o2 = e.name === "doesNotReject" ? "rejection" : "exception";
          ke({ actual: t, expected: r, operator: e.name, message: "Got unwanted ".concat(o2).concat(i, `
`) + 'Actual message: "'.concat(t && t.message, '"'), stackStartFn: e });
        }
        throw t;
      }
    }
    q3.throws = function e(t) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;i < r; i++)
        n[i - 1] = arguments[i];
      fp.apply(undefined, [e, op(t)].concat(n));
    };
    q3.rejects = function e(t) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;i < r; i++)
        n[i - 1] = arguments[i];
      return ap(t).then(function(o2) {
        return fp.apply(undefined, [e, o2].concat(n));
      });
    };
    q3.doesNotThrow = function e(t) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;i < r; i++)
        n[i - 1] = arguments[i];
      lp.apply(undefined, [e, op(t)].concat(n));
    };
    q3.doesNotReject = function e(t) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;i < r; i++)
        n[i - 1] = arguments[i];
      return ap(t).then(function(o2) {
        return lp.apply(undefined, [e, o2].concat(n));
      });
    };
    q3.ifError = function e(t) {
      if (t != null) {
        var r = "ifError got unwanted exception: ";
        ct3(t) === "object" && typeof t.message == "string" ? t.message.length === 0 && t.constructor ? r += t.constructor.name : r += t.message : r += BS(t);
        var n = new Ut({ actual: t, expected: null, operator: "ifError", message: r, stackStartFn: e }), i = t.stack;
        if (typeof i == "string") {
          var o2 = i.split(`
`);
          o2.shift();
          for (var a3 = n.stack.split(`
`), f3 = 0;f3 < o2.length; f3++) {
            var u3 = a3.indexOf(o2[f3]);
            if (u3 !== -1) {
              a3 = a3.slice(0, u3);
              break;
            }
          }
          n.stack = "".concat(a3.join(`
`), `
`).concat(o2.join(`
`));
        }
        throw n;
      }
    };
    function up() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      rp.apply(undefined, [up, t.length].concat(t));
    }
    q3.strict = MS(up, q3, { equal: q3.strictEqual, deepEqual: q3.deepStrictEqual, notEqual: q3.notStrictEqual, notDeepEqual: q3.notDeepStrictEqual });
    q3.strict.strict = q3.strict;
  });
  dp = g4((Wx, cp) => {
    function US() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    }
    cp.exports = US;
  });
  yn = g4((oe) => {
    var qS = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function CS(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }
    oe.assign = function(e) {
      for (var t = Array.prototype.slice.call(arguments, 1);t.length; ) {
        var r = t.shift();
        if (!!r) {
          if (typeof r != "object")
            throw new TypeError(r + "must be non-object");
          for (var n in r)
            CS(r, n) && (e[n] = r[n]);
        }
      }
      return e;
    };
    oe.shrinkBuf = function(e, t) {
      return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e);
    };
    var zS = { arraySet: function(e, t, r, n, i) {
      if (t.subarray && e.subarray) {
        e.set(t.subarray(r, r + n), i);
        return;
      }
      for (var o2 = 0;o2 < n; o2++)
        e[i + o2] = t[r + o2];
    }, flattenChunks: function(e) {
      var t, r, n, i, o2, a3;
      for (n = 0, t = 0, r = e.length;t < r; t++)
        n += e[t].length;
      for (a3 = new Uint8Array(n), i = 0, t = 0, r = e.length;t < r; t++)
        o2 = e[t], a3.set(o2, i), i += o2.length;
      return a3;
    } }, WS = { arraySet: function(e, t, r, n, i) {
      for (var o2 = 0;o2 < n; o2++)
        e[i + o2] = t[r + o2];
    }, flattenChunks: function(e) {
      return [].concat.apply([], e);
    } };
    oe.setTyped = function(e) {
      e ? (oe.Buf8 = Uint8Array, oe.Buf16 = Uint16Array, oe.Buf32 = Int32Array, oe.assign(oe, zS)) : (oe.Buf8 = Array, oe.Buf16 = Array, oe.Buf32 = Array, oe.assign(oe, WS));
    };
    oe.setTyped(qS);
  });
  Bp = g4((Lr) => {
    var ZS = yn(), $S = 4, hp = 0, pp = 1, GS = 2;
    function Fr3(e) {
      for (var t = e.length;--t >= 0; )
        e[t] = 0;
    }
    var HS = 0, Ep = 1, VS = 2, YS = 3, KS = 258, Mf = 29, vn = 256, gn = vn + 1 + Mf, kr = 30, jf = 19, vp = 2 * gn + 1, qt = 15, kf = 16, XS = 7, Uf = 256, mp = 16, Sp = 17, Ap = 18, Bf = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], eo = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], JS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], xp = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], QS = 512, tt2 = new Array((gn + 2) * 2);
    Fr3(tt2);
    var _n = new Array(kr * 2);
    Fr3(_n);
    var bn = new Array(QS);
    Fr3(bn);
    var wn = new Array(KS - YS + 1);
    Fr3(wn);
    var qf = new Array(Mf);
    Fr3(qf);
    var to = new Array(kr);
    Fr3(to);
    function Ff(e, t, r, n, i) {
      this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = e && e.length;
    }
    var Rp, Ip, Tp;
    function Lf(e, t) {
      this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
    }
    function Op(e) {
      return e < 256 ? bn[e] : bn[256 + (e >>> 7)];
    }
    function En(e, t) {
      e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
    }
    function ue(e, t, r) {
      e.bi_valid > kf - r ? (e.bi_buf |= t << e.bi_valid & 65535, En(e, e.bi_buf), e.bi_buf = t >> kf - e.bi_valid, e.bi_valid += r - kf) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
    }
    function We(e, t, r) {
      ue(e, r[t * 2], r[t * 2 + 1]);
    }
    function Np(e, t) {
      var r = 0;
      do
        r |= e & 1, e >>>= 1, r <<= 1;
      while (--t > 0);
      return r >>> 1;
    }
    function e1(e) {
      e.bi_valid === 16 ? (En(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
    }
    function t1(e, t) {
      var { dyn_tree: r, max_code: n } = t, i = t.stat_desc.static_tree, o2 = t.stat_desc.has_stree, a3 = t.stat_desc.extra_bits, f3 = t.stat_desc.extra_base, u3 = t.stat_desc.max_length, l3, s2, c2, h5, d4, y5, b4 = 0;
      for (h5 = 0;h5 <= qt; h5++)
        e.bl_count[h5] = 0;
      for (r[e.heap[e.heap_max] * 2 + 1] = 0, l3 = e.heap_max + 1;l3 < vp; l3++)
        s2 = e.heap[l3], h5 = r[r[s2 * 2 + 1] * 2 + 1] + 1, h5 > u3 && (h5 = u3, b4++), r[s2 * 2 + 1] = h5, !(s2 > n) && (e.bl_count[h5]++, d4 = 0, s2 >= f3 && (d4 = a3[s2 - f3]), y5 = r[s2 * 2], e.opt_len += y5 * (h5 + d4), o2 && (e.static_len += y5 * (i[s2 * 2 + 1] + d4)));
      if (b4 !== 0) {
        do {
          for (h5 = u3 - 1;e.bl_count[h5] === 0; )
            h5--;
          e.bl_count[h5]--, e.bl_count[h5 + 1] += 2, e.bl_count[u3]--, b4 -= 2;
        } while (b4 > 0);
        for (h5 = u3;h5 !== 0; h5--)
          for (s2 = e.bl_count[h5];s2 !== 0; )
            c2 = e.heap[--l3], !(c2 > n) && (r[c2 * 2 + 1] !== h5 && (e.opt_len += (h5 - r[c2 * 2 + 1]) * r[c2 * 2], r[c2 * 2 + 1] = h5), s2--);
      }
    }
    function kp(e, t, r) {
      var n = new Array(qt + 1), i = 0, o2, a3;
      for (o2 = 1;o2 <= qt; o2++)
        n[o2] = i = i + r[o2 - 1] << 1;
      for (a3 = 0;a3 <= t; a3++) {
        var f3 = e[a3 * 2 + 1];
        f3 !== 0 && (e[a3 * 2] = Np(n[f3]++, f3));
      }
    }
    function r1() {
      var e, t, r, n, i, o2 = new Array(qt + 1);
      for (r = 0, n = 0;n < Mf - 1; n++)
        for (qf[n] = r, e = 0;e < 1 << Bf[n]; e++)
          wn[r++] = n;
      for (wn[r - 1] = n, i = 0, n = 0;n < 16; n++)
        for (to[n] = i, e = 0;e < 1 << eo[n]; e++)
          bn[i++] = n;
      for (i >>= 7;n < kr; n++)
        for (to[n] = i << 7, e = 0;e < 1 << eo[n] - 7; e++)
          bn[256 + i++] = n;
      for (t = 0;t <= qt; t++)
        o2[t] = 0;
      for (e = 0;e <= 143; )
        tt2[e * 2 + 1] = 8, e++, o2[8]++;
      for (;e <= 255; )
        tt2[e * 2 + 1] = 9, e++, o2[9]++;
      for (;e <= 279; )
        tt2[e * 2 + 1] = 7, e++, o2[7]++;
      for (;e <= 287; )
        tt2[e * 2 + 1] = 8, e++, o2[8]++;
      for (kp(tt2, gn + 1, o2), e = 0;e < kr; e++)
        _n[e * 2 + 1] = 5, _n[e * 2] = Np(e, 5);
      Rp = new Ff(tt2, Bf, vn + 1, gn, qt), Ip = new Ff(_n, eo, 0, kr, qt), Tp = new Ff(new Array(0), JS, 0, jf, XS);
    }
    function Fp(e) {
      var t;
      for (t = 0;t < gn; t++)
        e.dyn_ltree[t * 2] = 0;
      for (t = 0;t < kr; t++)
        e.dyn_dtree[t * 2] = 0;
      for (t = 0;t < jf; t++)
        e.bl_tree[t * 2] = 0;
      e.dyn_ltree[Uf * 2] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
    }
    function Lp(e) {
      e.bi_valid > 8 ? En(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
    }
    function n1(e, t, r, n) {
      Lp(e), n && (En(e, r), En(e, ~r)), ZS.arraySet(e.pending_buf, e.window, t, r, e.pending), e.pending += r;
    }
    function yp(e, t, r, n) {
      var i = t * 2, o2 = r * 2;
      return e[i] < e[o2] || e[i] === e[o2] && n[t] <= n[r];
    }
    function Df(e, t, r) {
      for (var n = e.heap[r], i = r << 1;i <= e.heap_len && (i < e.heap_len && yp(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !yp(t, n, e.heap[i], e.depth)); )
        e.heap[r] = e.heap[i], r = i, i <<= 1;
      e.heap[r] = n;
    }
    function _p(e, t, r) {
      var n, i, o2 = 0, a3, f3;
      if (e.last_lit !== 0)
        do
          n = e.pending_buf[e.d_buf + o2 * 2] << 8 | e.pending_buf[e.d_buf + o2 * 2 + 1], i = e.pending_buf[e.l_buf + o2], o2++, n === 0 ? We(e, i, t) : (a3 = wn[i], We(e, a3 + vn + 1, t), f3 = Bf[a3], f3 !== 0 && (i -= qf[a3], ue(e, i, f3)), n--, a3 = Op(n), We(e, a3, r), f3 = eo[a3], f3 !== 0 && (n -= to[a3], ue(e, n, f3)));
        while (o2 < e.last_lit);
      We(e, Uf, t);
    }
    function Pf(e, t) {
      var r = t.dyn_tree, n = t.stat_desc.static_tree, i = t.stat_desc.has_stree, o2 = t.stat_desc.elems, a3, f3, u3 = -1, l3;
      for (e.heap_len = 0, e.heap_max = vp, a3 = 0;a3 < o2; a3++)
        r[a3 * 2] !== 0 ? (e.heap[++e.heap_len] = u3 = a3, e.depth[a3] = 0) : r[a3 * 2 + 1] = 0;
      for (;e.heap_len < 2; )
        l3 = e.heap[++e.heap_len] = u3 < 2 ? ++u3 : 0, r[l3 * 2] = 1, e.depth[l3] = 0, e.opt_len--, i && (e.static_len -= n[l3 * 2 + 1]);
      for (t.max_code = u3, a3 = e.heap_len >> 1;a3 >= 1; a3--)
        Df(e, r, a3);
      l3 = o2;
      do
        a3 = e.heap[1], e.heap[1] = e.heap[e.heap_len--], Df(e, r, 1), f3 = e.heap[1], e.heap[--e.heap_max] = a3, e.heap[--e.heap_max] = f3, r[l3 * 2] = r[a3 * 2] + r[f3 * 2], e.depth[l3] = (e.depth[a3] >= e.depth[f3] ? e.depth[a3] : e.depth[f3]) + 1, r[a3 * 2 + 1] = r[f3 * 2 + 1] = l3, e.heap[1] = l3++, Df(e, r, 1);
      while (e.heap_len >= 2);
      e.heap[--e.heap_max] = e.heap[1], t1(e, t), kp(r, u3, e.bl_count);
    }
    function gp(e, t, r) {
      var n, i = -1, o2, a3 = t[0 * 2 + 1], f3 = 0, u3 = 7, l3 = 4;
      for (a3 === 0 && (u3 = 138, l3 = 3), t[(r + 1) * 2 + 1] = 65535, n = 0;n <= r; n++)
        o2 = a3, a3 = t[(n + 1) * 2 + 1], !(++f3 < u3 && o2 === a3) && (f3 < l3 ? e.bl_tree[o2 * 2] += f3 : o2 !== 0 ? (o2 !== i && e.bl_tree[o2 * 2]++, e.bl_tree[mp * 2]++) : f3 <= 10 ? e.bl_tree[Sp * 2]++ : e.bl_tree[Ap * 2]++, f3 = 0, i = o2, a3 === 0 ? (u3 = 138, l3 = 3) : o2 === a3 ? (u3 = 6, l3 = 3) : (u3 = 7, l3 = 4));
    }
    function bp(e, t, r) {
      var n, i = -1, o2, a3 = t[0 * 2 + 1], f3 = 0, u3 = 7, l3 = 4;
      for (a3 === 0 && (u3 = 138, l3 = 3), n = 0;n <= r; n++)
        if (o2 = a3, a3 = t[(n + 1) * 2 + 1], !(++f3 < u3 && o2 === a3)) {
          if (f3 < l3)
            do
              We(e, o2, e.bl_tree);
            while (--f3 !== 0);
          else
            o2 !== 0 ? (o2 !== i && (We(e, o2, e.bl_tree), f3--), We(e, mp, e.bl_tree), ue(e, f3 - 3, 2)) : f3 <= 10 ? (We(e, Sp, e.bl_tree), ue(e, f3 - 3, 3)) : (We(e, Ap, e.bl_tree), ue(e, f3 - 11, 7));
          f3 = 0, i = o2, a3 === 0 ? (u3 = 138, l3 = 3) : o2 === a3 ? (u3 = 6, l3 = 3) : (u3 = 7, l3 = 4);
        }
    }
    function i1(e) {
      var t;
      for (gp(e, e.dyn_ltree, e.l_desc.max_code), gp(e, e.dyn_dtree, e.d_desc.max_code), Pf(e, e.bl_desc), t = jf - 1;t >= 3 && e.bl_tree[xp[t] * 2 + 1] === 0; t--)
        ;
      return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
    }
    function o1(e, t, r, n) {
      var i;
      for (ue(e, t - 257, 5), ue(e, r - 1, 5), ue(e, n - 4, 4), i = 0;i < n; i++)
        ue(e, e.bl_tree[xp[i] * 2 + 1], 3);
      bp(e, e.dyn_ltree, t - 1), bp(e, e.dyn_dtree, r - 1);
    }
    function a1(e) {
      var t = 4093624447, r;
      for (r = 0;r <= 31; r++, t >>>= 1)
        if (t & 1 && e.dyn_ltree[r * 2] !== 0)
          return hp;
      if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
        return pp;
      for (r = 32;r < vn; r++)
        if (e.dyn_ltree[r * 2] !== 0)
          return pp;
      return hp;
    }
    var wp = false;
    function f1(e) {
      wp || (r1(), wp = true), e.l_desc = new Lf(e.dyn_ltree, Rp), e.d_desc = new Lf(e.dyn_dtree, Ip), e.bl_desc = new Lf(e.bl_tree, Tp), e.bi_buf = 0, e.bi_valid = 0, Fp(e);
    }
    function Dp(e, t, r, n) {
      ue(e, (HS << 1) + (n ? 1 : 0), 3), n1(e, t, r, true);
    }
    function l1(e) {
      ue(e, Ep << 1, 3), We(e, Uf, tt2), e1(e);
    }
    function u1(e, t, r, n) {
      var i, o2, a3 = 0;
      e.level > 0 ? (e.strm.data_type === GS && (e.strm.data_type = a1(e)), Pf(e, e.l_desc), Pf(e, e.d_desc), a3 = i1(e), i = e.opt_len + 3 + 7 >>> 3, o2 = e.static_len + 3 + 7 >>> 3, o2 <= i && (i = o2)) : i = o2 = r + 5, r + 4 <= i && t !== -1 ? Dp(e, t, r, n) : e.strategy === $S || o2 === i ? (ue(e, (Ep << 1) + (n ? 1 : 0), 3), _p(e, tt2, _n)) : (ue(e, (VS << 1) + (n ? 1 : 0), 3), o1(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a3 + 1), _p(e, e.dyn_ltree, e.dyn_dtree)), Fp(e), n && Lp(e);
    }
    function s1(e, t, r) {
      return e.pending_buf[e.d_buf + e.last_lit * 2] = t >>> 8 & 255, e.pending_buf[e.d_buf + e.last_lit * 2 + 1] = t & 255, e.pending_buf[e.l_buf + e.last_lit] = r & 255, e.last_lit++, t === 0 ? e.dyn_ltree[r * 2]++ : (e.matches++, t--, e.dyn_ltree[(wn[r] + vn + 1) * 2]++, e.dyn_dtree[Op(t) * 2]++), e.last_lit === e.lit_bufsize - 1;
    }
    Lr._tr_init = f1;
    Lr._tr_stored_block = Dp;
    Lr._tr_flush_block = u1;
    Lr._tr_tally = s1;
    Lr._tr_align = l1;
  });
  Cf = g4((Gx, Pp) => {
    function c1(e, t, r, n) {
      for (var i = e & 65535 | 0, o2 = e >>> 16 & 65535 | 0, a3 = 0;r !== 0; ) {
        a3 = r > 2000 ? 2000 : r, r -= a3;
        do
          i = i + t[n++] | 0, o2 = o2 + i | 0;
        while (--a3);
        i %= 65521, o2 %= 65521;
      }
      return i | o2 << 16 | 0;
    }
    Pp.exports = c1;
  });
  zf = g4((Hx, Mp) => {
    function d1() {
      for (var e, t = [], r = 0;r < 256; r++) {
        e = r;
        for (var n = 0;n < 8; n++)
          e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
        t[r] = e;
      }
      return t;
    }
    var h1 = d1();
    function p1(e, t, r, n) {
      var i = h1, o2 = n + r;
      e ^= -1;
      for (var a3 = n;a3 < o2; a3++)
        e = e >>> 8 ^ i[(e ^ t[a3]) & 255];
      return e ^ -1;
    }
    Mp.exports = p1;
  });
  Up = g4((Vx, jp) => {
    jp.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  });
  Vp = g4((Ge) => {
    var ae = yn(), ve = Bp(), Wp = Cf(), pt3 = zf(), y1 = Up(), Zt = 0, _1 = 1, g1 = 3, wt = 4, qp = 5, $e = 0, Cp = 1, me = -2, b1 = -3, Wf = -5, w1 = -1, E1 = 1, ro = 2, v1 = 3, m1 = 4, S1 = 0, A1 = 2, ao = 8, x1 = 9, R1 = 15, I1 = 8, T1 = 29, O1 = 256, $f = O1 + 1 + T1, N1 = 30, k1 = 19, F1 = 2 * $f + 1, L1 = 15, M3 = 3, gt2 = 258, Fe = gt2 + M3 + 1, D1 = 32, fo = 42, Gf = 69, no = 73, io = 91, oo = 103, Ct = 113, Sn = 666, K3 = 1, An = 2, zt = 3, Pr = 4, B1 = 3;
    function bt2(e, t) {
      return e.msg = y1[t], t;
    }
    function zp(e) {
      return (e << 1) - (e > 4 ? 9 : 0);
    }
    function _t(e) {
      for (var t = e.length;--t >= 0; )
        e[t] = 0;
    }
    function yt2(e) {
      var t = e.state, r = t.pending;
      r > e.avail_out && (r = e.avail_out), r !== 0 && (ae.arraySet(e.output, t.pending_buf, t.pending_out, r, e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0));
    }
    function te(e, t) {
      ve._tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, yt2(e.strm);
    }
    function j5(e, t) {
      e.pending_buf[e.pending++] = t;
    }
    function mn(e, t) {
      e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
    }
    function P1(e, t, r, n) {
      var i = e.avail_in;
      return i > n && (i = n), i === 0 ? 0 : (e.avail_in -= i, ae.arraySet(t, e.input, e.next_in, i, r), e.state.wrap === 1 ? e.adler = Wp(e.adler, t, i, r) : e.state.wrap === 2 && (e.adler = pt3(e.adler, t, i, r)), e.next_in += i, e.total_in += i, i);
    }
    function Zp(e, t) {
      var { max_chain_length: r, strstart: n } = e, i, o2, a3 = e.prev_length, f3 = e.nice_match, u3 = e.strstart > e.w_size - Fe ? e.strstart - (e.w_size - Fe) : 0, l3 = e.window, s2 = e.w_mask, c2 = e.prev, h5 = e.strstart + gt2, d4 = l3[n + a3 - 1], y5 = l3[n + a3];
      e.prev_length >= e.good_match && (r >>= 2), f3 > e.lookahead && (f3 = e.lookahead);
      do
        if (i = t, !(l3[i + a3] !== y5 || l3[i + a3 - 1] !== d4 || l3[i] !== l3[n] || l3[++i] !== l3[n + 1])) {
          n += 2, i++;
          do
            ;
          while (l3[++n] === l3[++i] && l3[++n] === l3[++i] && l3[++n] === l3[++i] && l3[++n] === l3[++i] && l3[++n] === l3[++i] && l3[++n] === l3[++i] && l3[++n] === l3[++i] && l3[++n] === l3[++i] && n < h5);
          if (o2 = gt2 - (h5 - n), n = h5 - gt2, o2 > a3) {
            if (e.match_start = t, a3 = o2, o2 >= f3)
              break;
            d4 = l3[n + a3 - 1], y5 = l3[n + a3];
          }
        }
      while ((t = c2[t & s2]) > u3 && --r !== 0);
      return a3 <= e.lookahead ? a3 : e.lookahead;
    }
    function Wt(e) {
      var t = e.w_size, r, n, i, o2, a3;
      do {
        if (o2 = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - Fe)) {
          ae.arraySet(e.window, e.window, t, t, 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, n = e.hash_size, r = n;
          do
            i = e.head[--r], e.head[r] = i >= t ? i - t : 0;
          while (--n);
          n = t, r = n;
          do
            i = e.prev[--r], e.prev[r] = i >= t ? i - t : 0;
          while (--n);
          o2 += t;
        }
        if (e.strm.avail_in === 0)
          break;
        if (n = P1(e.strm, e.window, e.strstart + e.lookahead, o2), e.lookahead += n, e.lookahead + e.insert >= M3)
          for (a3 = e.strstart - e.insert, e.ins_h = e.window[a3], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[a3 + 1]) & e.hash_mask;e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[a3 + M3 - 1]) & e.hash_mask, e.prev[a3 & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = a3, a3++, e.insert--, !(e.lookahead + e.insert < M3)); )
            ;
      } while (e.lookahead < Fe && e.strm.avail_in !== 0);
    }
    function M1(e, t) {
      var r = 65535;
      for (r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5);; ) {
        if (e.lookahead <= 1) {
          if (Wt(e), e.lookahead === 0 && t === Zt)
            return K3;
          if (e.lookahead === 0)
            break;
        }
        e.strstart += e.lookahead, e.lookahead = 0;
        var n = e.block_start + r;
        if ((e.strstart === 0 || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, te(e, false), e.strm.avail_out === 0) || e.strstart - e.block_start >= e.w_size - Fe && (te(e, false), e.strm.avail_out === 0))
          return K3;
      }
      return e.insert = 0, t === wt ? (te(e, true), e.strm.avail_out === 0 ? zt : Pr) : (e.strstart > e.block_start && (te(e, false), e.strm.avail_out === 0), K3);
    }
    function Zf(e, t) {
      for (var r, n;; ) {
        if (e.lookahead < Fe) {
          if (Wt(e), e.lookahead < Fe && t === Zt)
            return K3;
          if (e.lookahead === 0)
            break;
        }
        if (r = 0, e.lookahead >= M3 && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + M3 - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - Fe && (e.match_length = Zp(e, r)), e.match_length >= M3)
          if (n = ve._tr_tally(e, e.strstart - e.match_start, e.match_length - M3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= M3) {
            e.match_length--;
            do
              e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + M3 - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
            while (--e.match_length !== 0);
            e.strstart++;
          } else
            e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
        else
          n = ve._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
        if (n && (te(e, false), e.strm.avail_out === 0))
          return K3;
      }
      return e.insert = e.strstart < M3 - 1 ? e.strstart : M3 - 1, t === wt ? (te(e, true), e.strm.avail_out === 0 ? zt : Pr) : e.last_lit && (te(e, false), e.strm.avail_out === 0) ? K3 : An;
    }
    function Dr(e, t) {
      for (var r, n, i;; ) {
        if (e.lookahead < Fe) {
          if (Wt(e), e.lookahead < Fe && t === Zt)
            return K3;
          if (e.lookahead === 0)
            break;
        }
        if (r = 0, e.lookahead >= M3 && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + M3 - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = M3 - 1, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - Fe && (e.match_length = Zp(e, r), e.match_length <= 5 && (e.strategy === E1 || e.match_length === M3 && e.strstart - e.match_start > 4096) && (e.match_length = M3 - 1)), e.prev_length >= M3 && e.match_length <= e.prev_length) {
          i = e.strstart + e.lookahead - M3, n = ve._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - M3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
          do
            ++e.strstart <= i && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + M3 - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
          while (--e.prev_length !== 0);
          if (e.match_available = 0, e.match_length = M3 - 1, e.strstart++, n && (te(e, false), e.strm.avail_out === 0))
            return K3;
        } else if (e.match_available) {
          if (n = ve._tr_tally(e, 0, e.window[e.strstart - 1]), n && te(e, false), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
            return K3;
        } else
          e.match_available = 1, e.strstart++, e.lookahead--;
      }
      return e.match_available && (n = ve._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < M3 - 1 ? e.strstart : M3 - 1, t === wt ? (te(e, true), e.strm.avail_out === 0 ? zt : Pr) : e.last_lit && (te(e, false), e.strm.avail_out === 0) ? K3 : An;
    }
    function j1(e, t) {
      for (var r, n, i, o2, a3 = e.window;; ) {
        if (e.lookahead <= gt2) {
          if (Wt(e), e.lookahead <= gt2 && t === Zt)
            return K3;
          if (e.lookahead === 0)
            break;
        }
        if (e.match_length = 0, e.lookahead >= M3 && e.strstart > 0 && (i = e.strstart - 1, n = a3[i], n === a3[++i] && n === a3[++i] && n === a3[++i])) {
          o2 = e.strstart + gt2;
          do
            ;
          while (n === a3[++i] && n === a3[++i] && n === a3[++i] && n === a3[++i] && n === a3[++i] && n === a3[++i] && n === a3[++i] && n === a3[++i] && i < o2);
          e.match_length = gt2 - (o2 - i), e.match_length > e.lookahead && (e.match_length = e.lookahead);
        }
        if (e.match_length >= M3 ? (r = ve._tr_tally(e, 1, e.match_length - M3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = ve._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (te(e, false), e.strm.avail_out === 0))
          return K3;
      }
      return e.insert = 0, t === wt ? (te(e, true), e.strm.avail_out === 0 ? zt : Pr) : e.last_lit && (te(e, false), e.strm.avail_out === 0) ? K3 : An;
    }
    function U1(e, t) {
      for (var r;; ) {
        if (e.lookahead === 0 && (Wt(e), e.lookahead === 0)) {
          if (t === Zt)
            return K3;
          break;
        }
        if (e.match_length = 0, r = ve._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (te(e, false), e.strm.avail_out === 0))
          return K3;
      }
      return e.insert = 0, t === wt ? (te(e, true), e.strm.avail_out === 0 ? zt : Pr) : e.last_lit && (te(e, false), e.strm.avail_out === 0) ? K3 : An;
    }
    function Ze(e, t, r, n, i) {
      this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = i;
    }
    var Br3;
    Br3 = [new Ze(0, 0, 0, 0, M1), new Ze(4, 4, 8, 4, Zf), new Ze(4, 5, 16, 8, Zf), new Ze(4, 6, 32, 32, Zf), new Ze(4, 4, 16, 16, Dr), new Ze(8, 16, 32, 32, Dr), new Ze(8, 16, 128, 128, Dr), new Ze(8, 32, 128, 256, Dr), new Ze(32, 128, 258, 1024, Dr), new Ze(32, 258, 258, 4096, Dr)];
    function q1(e) {
      e.window_size = 2 * e.w_size, _t(e.head), e.max_lazy_match = Br3[e.level].max_lazy, e.good_match = Br3[e.level].good_length, e.nice_match = Br3[e.level].nice_length, e.max_chain_length = Br3[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = M3 - 1, e.match_available = 0, e.ins_h = 0;
    }
    function C1() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ao, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new ae.Buf16(F1 * 2), this.dyn_dtree = new ae.Buf16((2 * N1 + 1) * 2), this.bl_tree = new ae.Buf16((2 * k1 + 1) * 2), _t(this.dyn_ltree), _t(this.dyn_dtree), _t(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new ae.Buf16(L1 + 1), this.heap = new ae.Buf16(2 * $f + 1), _t(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new ae.Buf16(2 * $f + 1), _t(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    function $p(e) {
      var t;
      return !e || !e.state ? bt2(e, me) : (e.total_in = e.total_out = 0, e.data_type = A1, t = e.state, t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? fo : Ct, e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = Zt, ve._tr_init(t), $e);
    }
    function Gp(e) {
      var t = $p(e);
      return t === $e && q1(e.state), t;
    }
    function z1(e, t) {
      return !e || !e.state || e.state.wrap !== 2 ? me : (e.state.gzhead = t, $e);
    }
    function Hp(e, t, r, n, i, o2) {
      if (!e)
        return me;
      var a3 = 1;
      if (t === w1 && (t = 6), n < 0 ? (a3 = 0, n = -n) : n > 15 && (a3 = 2, n -= 16), i < 1 || i > x1 || r !== ao || n < 8 || n > 15 || t < 0 || t > 9 || o2 < 0 || o2 > m1)
        return bt2(e, me);
      n === 8 && (n = 9);
      var f3 = new C1;
      return e.state = f3, f3.strm = e, f3.wrap = a3, f3.gzhead = null, f3.w_bits = n, f3.w_size = 1 << f3.w_bits, f3.w_mask = f3.w_size - 1, f3.hash_bits = i + 7, f3.hash_size = 1 << f3.hash_bits, f3.hash_mask = f3.hash_size - 1, f3.hash_shift = ~~((f3.hash_bits + M3 - 1) / M3), f3.window = new ae.Buf8(f3.w_size * 2), f3.head = new ae.Buf16(f3.hash_size), f3.prev = new ae.Buf16(f3.w_size), f3.lit_bufsize = 1 << i + 6, f3.pending_buf_size = f3.lit_bufsize * 4, f3.pending_buf = new ae.Buf8(f3.pending_buf_size), f3.d_buf = 1 * f3.lit_bufsize, f3.l_buf = (1 + 2) * f3.lit_bufsize, f3.level = t, f3.strategy = o2, f3.method = r, Gp(e);
    }
    function W1(e, t) {
      return Hp(e, t, ao, R1, I1, S1);
    }
    function Z1(e, t) {
      var r, n, i, o2;
      if (!e || !e.state || t > qp || t < 0)
        return e ? bt2(e, me) : me;
      if (n = e.state, !e.output || !e.input && e.avail_in !== 0 || n.status === Sn && t !== wt)
        return bt2(e, e.avail_out === 0 ? Wf : me);
      if (n.strm = e, r = n.last_flush, n.last_flush = t, n.status === fo)
        if (n.wrap === 2)
          e.adler = 0, j5(n, 31), j5(n, 139), j5(n, 8), n.gzhead ? (j5(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), j5(n, n.gzhead.time & 255), j5(n, n.gzhead.time >> 8 & 255), j5(n, n.gzhead.time >> 16 & 255), j5(n, n.gzhead.time >> 24 & 255), j5(n, n.level === 9 ? 2 : n.strategy >= ro || n.level < 2 ? 4 : 0), j5(n, n.gzhead.os & 255), n.gzhead.extra && n.gzhead.extra.length && (j5(n, n.gzhead.extra.length & 255), j5(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = pt3(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = Gf) : (j5(n, 0), j5(n, 0), j5(n, 0), j5(n, 0), j5(n, 0), j5(n, n.level === 9 ? 2 : n.strategy >= ro || n.level < 2 ? 4 : 0), j5(n, B1), n.status = Ct);
        else {
          var a3 = ao + (n.w_bits - 8 << 4) << 8, f3 = -1;
          n.strategy >= ro || n.level < 2 ? f3 = 0 : n.level < 6 ? f3 = 1 : n.level === 6 ? f3 = 2 : f3 = 3, a3 |= f3 << 6, n.strstart !== 0 && (a3 |= D1), a3 += 31 - a3 % 31, n.status = Ct, mn(n, a3), n.strstart !== 0 && (mn(n, e.adler >>> 16), mn(n, e.adler & 65535)), e.adler = 1;
        }
      if (n.status === Gf)
        if (n.gzhead.extra) {
          for (i = n.pending;n.gzindex < (n.gzhead.extra.length & 65535) && !(n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = pt3(e.adler, n.pending_buf, n.pending - i, i)), yt2(e), i = n.pending, n.pending === n.pending_buf_size)); )
            j5(n, n.gzhead.extra[n.gzindex] & 255), n.gzindex++;
          n.gzhead.hcrc && n.pending > i && (e.adler = pt3(e.adler, n.pending_buf, n.pending - i, i)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = no);
        } else
          n.status = no;
      if (n.status === no)
        if (n.gzhead.name) {
          i = n.pending;
          do {
            if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = pt3(e.adler, n.pending_buf, n.pending - i, i)), yt2(e), i = n.pending, n.pending === n.pending_buf_size)) {
              o2 = 1;
              break;
            }
            n.gzindex < n.gzhead.name.length ? o2 = n.gzhead.name.charCodeAt(n.gzindex++) & 255 : o2 = 0, j5(n, o2);
          } while (o2 !== 0);
          n.gzhead.hcrc && n.pending > i && (e.adler = pt3(e.adler, n.pending_buf, n.pending - i, i)), o2 === 0 && (n.gzindex = 0, n.status = io);
        } else
          n.status = io;
      if (n.status === io)
        if (n.gzhead.comment) {
          i = n.pending;
          do {
            if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = pt3(e.adler, n.pending_buf, n.pending - i, i)), yt2(e), i = n.pending, n.pending === n.pending_buf_size)) {
              o2 = 1;
              break;
            }
            n.gzindex < n.gzhead.comment.length ? o2 = n.gzhead.comment.charCodeAt(n.gzindex++) & 255 : o2 = 0, j5(n, o2);
          } while (o2 !== 0);
          n.gzhead.hcrc && n.pending > i && (e.adler = pt3(e.adler, n.pending_buf, n.pending - i, i)), o2 === 0 && (n.status = oo);
        } else
          n.status = oo;
      if (n.status === oo && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && yt2(e), n.pending + 2 <= n.pending_buf_size && (j5(n, e.adler & 255), j5(n, e.adler >> 8 & 255), e.adler = 0, n.status = Ct)) : n.status = Ct), n.pending !== 0) {
        if (yt2(e), e.avail_out === 0)
          return n.last_flush = -1, $e;
      } else if (e.avail_in === 0 && zp(t) <= zp(r) && t !== wt)
        return bt2(e, Wf);
      if (n.status === Sn && e.avail_in !== 0)
        return bt2(e, Wf);
      if (e.avail_in !== 0 || n.lookahead !== 0 || t !== Zt && n.status !== Sn) {
        var u3 = n.strategy === ro ? U1(n, t) : n.strategy === v1 ? j1(n, t) : Br3[n.level].func(n, t);
        if ((u3 === zt || u3 === Pr) && (n.status = Sn), u3 === K3 || u3 === zt)
          return e.avail_out === 0 && (n.last_flush = -1), $e;
        if (u3 === An && (t === _1 ? ve._tr_align(n) : t !== qp && (ve._tr_stored_block(n, 0, 0, false), t === g1 && (_t(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), yt2(e), e.avail_out === 0))
          return n.last_flush = -1, $e;
      }
      return t !== wt ? $e : n.wrap <= 0 ? Cp : (n.wrap === 2 ? (j5(n, e.adler & 255), j5(n, e.adler >> 8 & 255), j5(n, e.adler >> 16 & 255), j5(n, e.adler >> 24 & 255), j5(n, e.total_in & 255), j5(n, e.total_in >> 8 & 255), j5(n, e.total_in >> 16 & 255), j5(n, e.total_in >> 24 & 255)) : (mn(n, e.adler >>> 16), mn(n, e.adler & 65535)), yt2(e), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? $e : Cp);
    }
    function $1(e) {
      var t;
      return !e || !e.state ? me : (t = e.state.status, t !== fo && t !== Gf && t !== no && t !== io && t !== oo && t !== Ct && t !== Sn ? bt2(e, me) : (e.state = null, t === Ct ? bt2(e, b1) : $e));
    }
    function G1(e, t) {
      var r = t.length, n, i, o2, a3, f3, u3, l3, s2;
      if (!e || !e.state || (n = e.state, a3 = n.wrap, a3 === 2 || a3 === 1 && n.status !== fo || n.lookahead))
        return me;
      for (a3 === 1 && (e.adler = Wp(e.adler, t, r, 0)), n.wrap = 0, r >= n.w_size && (a3 === 0 && (_t(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0), s2 = new ae.Buf8(n.w_size), ae.arraySet(s2, t, r - n.w_size, n.w_size, 0), t = s2, r = n.w_size), f3 = e.avail_in, u3 = e.next_in, l3 = e.input, e.avail_in = r, e.next_in = 0, e.input = t, Wt(n);n.lookahead >= M3; ) {
        i = n.strstart, o2 = n.lookahead - (M3 - 1);
        do
          n.ins_h = (n.ins_h << n.hash_shift ^ n.window[i + M3 - 1]) & n.hash_mask, n.prev[i & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = i, i++;
        while (--o2);
        n.strstart = i, n.lookahead = M3 - 1, Wt(n);
      }
      return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = M3 - 1, n.match_available = 0, e.next_in = u3, e.input = l3, e.avail_in = f3, n.wrap = a3, $e;
    }
    Ge.deflateInit = W1;
    Ge.deflateInit2 = Hp;
    Ge.deflateReset = Gp;
    Ge.deflateResetKeep = $p;
    Ge.deflateSetHeader = z1;
    Ge.deflate = Z1;
    Ge.deflateEnd = $1;
    Ge.deflateSetDictionary = G1;
    Ge.deflateInfo = "pako deflate (from Nodeca project)";
  });
  Kp = g4((Kx, Yp) => {
    var lo = 30, H1 = 12;
    Yp.exports = function(t, r) {
      var n, i, o2, a3, f3, u3, l3, s2, c2, h5, d4, y5, b4, R3, _4, E5, m3, A4, v4, T3, I4, S3, k3, z, O4;
      n = t.state, i = t.next_in, z = t.input, o2 = i + (t.avail_in - 5), a3 = t.next_out, O4 = t.output, f3 = a3 - (r - t.avail_out), u3 = a3 + (t.avail_out - 257), l3 = n.dmax, s2 = n.wsize, c2 = n.whave, h5 = n.wnext, d4 = n.window, y5 = n.hold, b4 = n.bits, R3 = n.lencode, _4 = n.distcode, E5 = (1 << n.lenbits) - 1, m3 = (1 << n.distbits) - 1;
      e:
        do {
          b4 < 15 && (y5 += z[i++] << b4, b4 += 8, y5 += z[i++] << b4, b4 += 8), A4 = R3[y5 & E5];
          t:
            for (;; ) {
              if (v4 = A4 >>> 24, y5 >>>= v4, b4 -= v4, v4 = A4 >>> 16 & 255, v4 === 0)
                O4[a3++] = A4 & 65535;
              else if (v4 & 16) {
                T3 = A4 & 65535, v4 &= 15, v4 && (b4 < v4 && (y5 += z[i++] << b4, b4 += 8), T3 += y5 & (1 << v4) - 1, y5 >>>= v4, b4 -= v4), b4 < 15 && (y5 += z[i++] << b4, b4 += 8, y5 += z[i++] << b4, b4 += 8), A4 = _4[y5 & m3];
                r:
                  for (;; ) {
                    if (v4 = A4 >>> 24, y5 >>>= v4, b4 -= v4, v4 = A4 >>> 16 & 255, v4 & 16) {
                      if (I4 = A4 & 65535, v4 &= 15, b4 < v4 && (y5 += z[i++] << b4, b4 += 8, b4 < v4 && (y5 += z[i++] << b4, b4 += 8)), I4 += y5 & (1 << v4) - 1, I4 > l3) {
                        t.msg = "invalid distance too far back", n.mode = lo;
                        break e;
                      }
                      if (y5 >>>= v4, b4 -= v4, v4 = a3 - f3, I4 > v4) {
                        if (v4 = I4 - v4, v4 > c2 && n.sane) {
                          t.msg = "invalid distance too far back", n.mode = lo;
                          break e;
                        }
                        if (S3 = 0, k3 = d4, h5 === 0) {
                          if (S3 += s2 - v4, v4 < T3) {
                            T3 -= v4;
                            do
                              O4[a3++] = d4[S3++];
                            while (--v4);
                            S3 = a3 - I4, k3 = O4;
                          }
                        } else if (h5 < v4) {
                          if (S3 += s2 + h5 - v4, v4 -= h5, v4 < T3) {
                            T3 -= v4;
                            do
                              O4[a3++] = d4[S3++];
                            while (--v4);
                            if (S3 = 0, h5 < T3) {
                              v4 = h5, T3 -= v4;
                              do
                                O4[a3++] = d4[S3++];
                              while (--v4);
                              S3 = a3 - I4, k3 = O4;
                            }
                          }
                        } else if (S3 += h5 - v4, v4 < T3) {
                          T3 -= v4;
                          do
                            O4[a3++] = d4[S3++];
                          while (--v4);
                          S3 = a3 - I4, k3 = O4;
                        }
                        for (;T3 > 2; )
                          O4[a3++] = k3[S3++], O4[a3++] = k3[S3++], O4[a3++] = k3[S3++], T3 -= 3;
                        T3 && (O4[a3++] = k3[S3++], T3 > 1 && (O4[a3++] = k3[S3++]));
                      } else {
                        S3 = a3 - I4;
                        do
                          O4[a3++] = O4[S3++], O4[a3++] = O4[S3++], O4[a3++] = O4[S3++], T3 -= 3;
                        while (T3 > 2);
                        T3 && (O4[a3++] = O4[S3++], T3 > 1 && (O4[a3++] = O4[S3++]));
                      }
                    } else if ((v4 & 64) === 0) {
                      A4 = _4[(A4 & 65535) + (y5 & (1 << v4) - 1)];
                      continue r;
                    } else {
                      t.msg = "invalid distance code", n.mode = lo;
                      break e;
                    }
                    break;
                  }
              } else if ((v4 & 64) === 0) {
                A4 = R3[(A4 & 65535) + (y5 & (1 << v4) - 1)];
                continue t;
              } else if (v4 & 32) {
                n.mode = H1;
                break e;
              } else {
                t.msg = "invalid literal/length code", n.mode = lo;
                break e;
              }
              break;
            }
        } while (i < o2 && a3 < u3);
      T3 = b4 >> 3, i -= T3, b4 -= T3 << 3, y5 &= (1 << b4) - 1, t.next_in = i, t.next_out = a3, t.avail_in = i < o2 ? 5 + (o2 - i) : 5 - (i - o2), t.avail_out = a3 < u3 ? 257 + (u3 - a3) : 257 - (a3 - u3), n.hold = y5, n.bits = b4;
    };
  });
  ny = g4((Xx, ry) => {
    var Xp = yn(), Mr = 15, Jp = 852, Qp = 592, ey = 0, Hf = 1, ty = 2, V1 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], Y1 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], K1 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], X1 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    ry.exports = function(t, r, n, i, o2, a3, f3, u3) {
      var l3 = u3.bits, s2 = 0, c2 = 0, h5 = 0, d4 = 0, y5 = 0, b4 = 0, R3 = 0, _4 = 0, E5 = 0, m3 = 0, A4, v4, T3, I4, S3, k3 = null, z = 0, O4, Ae2 = new Xp.Buf16(Mr + 1), On = new Xp.Buf16(Mr + 1), Nn = null, al = 0, fl, kn, Fn;
      for (s2 = 0;s2 <= Mr; s2++)
        Ae2[s2] = 0;
      for (c2 = 0;c2 < i; c2++)
        Ae2[r[n + c2]]++;
      for (y5 = l3, d4 = Mr;d4 >= 1 && Ae2[d4] === 0; d4--)
        ;
      if (y5 > d4 && (y5 = d4), d4 === 0)
        return o2[a3++] = 1 << 24 | 64 << 16 | 0, o2[a3++] = 1 << 24 | 64 << 16 | 0, u3.bits = 1, 0;
      for (h5 = 1;h5 < d4 && Ae2[h5] === 0; h5++)
        ;
      for (y5 < h5 && (y5 = h5), _4 = 1, s2 = 1;s2 <= Mr; s2++)
        if (_4 <<= 1, _4 -= Ae2[s2], _4 < 0)
          return -1;
      if (_4 > 0 && (t === ey || d4 !== 1))
        return -1;
      for (On[1] = 0, s2 = 1;s2 < Mr; s2++)
        On[s2 + 1] = On[s2] + Ae2[s2];
      for (c2 = 0;c2 < i; c2++)
        r[n + c2] !== 0 && (f3[On[r[n + c2]]++] = c2);
      if (t === ey ? (k3 = Nn = f3, O4 = 19) : t === Hf ? (k3 = V1, z -= 257, Nn = Y1, al -= 257, O4 = 256) : (k3 = K1, Nn = X1, O4 = -1), m3 = 0, c2 = 0, s2 = h5, S3 = a3, b4 = y5, R3 = 0, T3 = -1, E5 = 1 << y5, I4 = E5 - 1, t === Hf && E5 > Jp || t === ty && E5 > Qp)
        return 1;
      for (;; ) {
        fl = s2 - R3, f3[c2] < O4 ? (kn = 0, Fn = f3[c2]) : f3[c2] > O4 ? (kn = Nn[al + f3[c2]], Fn = k3[z + f3[c2]]) : (kn = 32 + 64, Fn = 0), A4 = 1 << s2 - R3, v4 = 1 << b4, h5 = v4;
        do
          v4 -= A4, o2[S3 + (m3 >> R3) + v4] = fl << 24 | kn << 16 | Fn | 0;
        while (v4 !== 0);
        for (A4 = 1 << s2 - 1;m3 & A4; )
          A4 >>= 1;
        if (A4 !== 0 ? (m3 &= A4 - 1, m3 += A4) : m3 = 0, c2++, --Ae2[s2] === 0) {
          if (s2 === d4)
            break;
          s2 = r[n + f3[c2]];
        }
        if (s2 > y5 && (m3 & I4) !== T3) {
          for (R3 === 0 && (R3 = y5), S3 += h5, b4 = s2 - R3, _4 = 1 << b4;b4 + R3 < d4 && (_4 -= Ae2[b4 + R3], !(_4 <= 0)); )
            b4++, _4 <<= 1;
          if (E5 += 1 << b4, t === Hf && E5 > Jp || t === ty && E5 > Qp)
            return 1;
          T3 = m3 & I4, o2[T3] = y5 << 24 | b4 << 16 | S3 - a3 | 0;
        }
      }
      return m3 !== 0 && (o2[S3 + m3] = s2 - R3 << 24 | 64 << 16 | 0), u3.bits = y5, 0;
    };
  });
  jy = g4((Le) => {
    var de = yn(), Qf = Cf(), He = zf(), J1 = Kp(), xn = ny(), Q1 = 0, Oy = 1, Ny = 2, iy = 4, eA = 5, uo = 6, $t = 0, tA = 1, rA = 2, Se2 = -2, ky = -3, el = -4, nA = -5, oy = 8, Fy = 1, ay = 2, fy = 3, ly = 4, uy = 5, sy = 6, cy = 7, dy = 8, hy = 9, py = 10, ho = 11, rt2 = 12, Vf = 13, yy = 14, Yf = 15, _y = 16, gy = 17, by = 18, wy = 19, so2 = 20, co = 21, Ey = 22, vy = 23, my = 24, Sy = 25, Ay = 26, Kf = 27, xy = 28, Ry = 29, C3 = 30, tl = 31, iA = 32, oA = 852, aA = 592, fA = 15, lA = fA;
    function Iy(e) {
      return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
    }
    function uA() {
      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new de.Buf16(320), this.work = new de.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    function Ly(e) {
      var t;
      return !e || !e.state ? Se2 : (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = Fy, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new de.Buf32(oA), t.distcode = t.distdyn = new de.Buf32(aA), t.sane = 1, t.back = -1, $t);
    }
    function Dy(e) {
      var t;
      return !e || !e.state ? Se2 : (t = e.state, t.wsize = 0, t.whave = 0, t.wnext = 0, Ly(e));
    }
    function By(e, t) {
      var r, n;
      return !e || !e.state || (n = e.state, t < 0 ? (r = 0, t = -t) : (r = (t >> 4) + 1, t < 48 && (t &= 15)), t && (t < 8 || t > 15)) ? Se2 : (n.window !== null && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, Dy(e));
    }
    function Py(e, t) {
      var r, n;
      return e ? (n = new uA, e.state = n, n.window = null, r = By(e, t), r !== $t && (e.state = null), r) : Se2;
    }
    function sA(e) {
      return Py(e, lA);
    }
    var Ty = true, Xf, Jf;
    function cA(e) {
      if (Ty) {
        var t;
        for (Xf = new de.Buf32(512), Jf = new de.Buf32(32), t = 0;t < 144; )
          e.lens[t++] = 8;
        for (;t < 256; )
          e.lens[t++] = 9;
        for (;t < 280; )
          e.lens[t++] = 7;
        for (;t < 288; )
          e.lens[t++] = 8;
        for (xn(Oy, e.lens, 0, 288, Xf, 0, e.work, { bits: 9 }), t = 0;t < 32; )
          e.lens[t++] = 5;
        xn(Ny, e.lens, 0, 32, Jf, 0, e.work, { bits: 5 }), Ty = false;
      }
      e.lencode = Xf, e.lenbits = 9, e.distcode = Jf, e.distbits = 5;
    }
    function My(e, t, r, n) {
      var i, o2 = e.state;
      return o2.window === null && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new de.Buf8(o2.wsize)), n >= o2.wsize ? (de.arraySet(o2.window, t, r - o2.wsize, o2.wsize, 0), o2.wnext = 0, o2.whave = o2.wsize) : (i = o2.wsize - o2.wnext, i > n && (i = n), de.arraySet(o2.window, t, r - n, i, o2.wnext), n -= i, n ? (de.arraySet(o2.window, t, r - n, n, 0), o2.wnext = n, o2.whave = o2.wsize) : (o2.wnext += i, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += i))), 0;
    }
    function dA(e, t) {
      var r, n, i, o2, a3, f3, u3, l3, s2, c2, h5, d4, y5, b4, R3 = 0, _4, E5, m3, A4, v4, T3, I4, S3, k3 = new de.Buf8(4), z, O4, Ae2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!e || !e.state || !e.output || !e.input && e.avail_in !== 0)
        return Se2;
      r = e.state, r.mode === rt2 && (r.mode = Vf), a3 = e.next_out, i = e.output, u3 = e.avail_out, o2 = e.next_in, n = e.input, f3 = e.avail_in, l3 = r.hold, s2 = r.bits, c2 = f3, h5 = u3, S3 = $t;
      e:
        for (;; )
          switch (r.mode) {
            case Fy:
              if (r.wrap === 0) {
                r.mode = Vf;
                break;
              }
              for (;s2 < 16; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              if (r.wrap & 2 && l3 === 35615) {
                r.check = 0, k3[0] = l3 & 255, k3[1] = l3 >>> 8 & 255, r.check = He(r.check, k3, 2, 0), l3 = 0, s2 = 0, r.mode = ay;
                break;
              }
              if (r.flags = 0, r.head && (r.head.done = false), !(r.wrap & 1) || (((l3 & 255) << 8) + (l3 >> 8)) % 31) {
                e.msg = "incorrect header check", r.mode = C3;
                break;
              }
              if ((l3 & 15) !== oy) {
                e.msg = "unknown compression method", r.mode = C3;
                break;
              }
              if (l3 >>>= 4, s2 -= 4, I4 = (l3 & 15) + 8, r.wbits === 0)
                r.wbits = I4;
              else if (I4 > r.wbits) {
                e.msg = "invalid window size", r.mode = C3;
                break;
              }
              r.dmax = 1 << I4, e.adler = r.check = 1, r.mode = l3 & 512 ? py : rt2, l3 = 0, s2 = 0;
              break;
            case ay:
              for (;s2 < 16; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              if (r.flags = l3, (r.flags & 255) !== oy) {
                e.msg = "unknown compression method", r.mode = C3;
                break;
              }
              if (r.flags & 57344) {
                e.msg = "unknown header flags set", r.mode = C3;
                break;
              }
              r.head && (r.head.text = l3 >> 8 & 1), r.flags & 512 && (k3[0] = l3 & 255, k3[1] = l3 >>> 8 & 255, r.check = He(r.check, k3, 2, 0)), l3 = 0, s2 = 0, r.mode = fy;
            case fy:
              for (;s2 < 32; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              r.head && (r.head.time = l3), r.flags & 512 && (k3[0] = l3 & 255, k3[1] = l3 >>> 8 & 255, k3[2] = l3 >>> 16 & 255, k3[3] = l3 >>> 24 & 255, r.check = He(r.check, k3, 4, 0)), l3 = 0, s2 = 0, r.mode = ly;
            case ly:
              for (;s2 < 16; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              r.head && (r.head.xflags = l3 & 255, r.head.os = l3 >> 8), r.flags & 512 && (k3[0] = l3 & 255, k3[1] = l3 >>> 8 & 255, r.check = He(r.check, k3, 2, 0)), l3 = 0, s2 = 0, r.mode = uy;
            case uy:
              if (r.flags & 1024) {
                for (;s2 < 16; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                r.length = l3, r.head && (r.head.extra_len = l3), r.flags & 512 && (k3[0] = l3 & 255, k3[1] = l3 >>> 8 & 255, r.check = He(r.check, k3, 2, 0)), l3 = 0, s2 = 0;
              } else
                r.head && (r.head.extra = null);
              r.mode = sy;
            case sy:
              if (r.flags & 1024 && (d4 = r.length, d4 > f3 && (d4 = f3), d4 && (r.head && (I4 = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), de.arraySet(r.head.extra, n, o2, d4, I4)), r.flags & 512 && (r.check = He(r.check, n, d4, o2)), f3 -= d4, o2 += d4, r.length -= d4), r.length))
                break e;
              r.length = 0, r.mode = cy;
            case cy:
              if (r.flags & 2048) {
                if (f3 === 0)
                  break e;
                d4 = 0;
                do
                  I4 = n[o2 + d4++], r.head && I4 && r.length < 65536 && (r.head.name += String.fromCharCode(I4));
                while (I4 && d4 < f3);
                if (r.flags & 512 && (r.check = He(r.check, n, d4, o2)), f3 -= d4, o2 += d4, I4)
                  break e;
              } else
                r.head && (r.head.name = null);
              r.length = 0, r.mode = dy;
            case dy:
              if (r.flags & 4096) {
                if (f3 === 0)
                  break e;
                d4 = 0;
                do
                  I4 = n[o2 + d4++], r.head && I4 && r.length < 65536 && (r.head.comment += String.fromCharCode(I4));
                while (I4 && d4 < f3);
                if (r.flags & 512 && (r.check = He(r.check, n, d4, o2)), f3 -= d4, o2 += d4, I4)
                  break e;
              } else
                r.head && (r.head.comment = null);
              r.mode = hy;
            case hy:
              if (r.flags & 512) {
                for (;s2 < 16; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                if (l3 !== (r.check & 65535)) {
                  e.msg = "header crc mismatch", r.mode = C3;
                  break;
                }
                l3 = 0, s2 = 0;
              }
              r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = true), e.adler = r.check = 0, r.mode = rt2;
              break;
            case py:
              for (;s2 < 32; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              e.adler = r.check = Iy(l3), l3 = 0, s2 = 0, r.mode = ho;
            case ho:
              if (r.havedict === 0)
                return e.next_out = a3, e.avail_out = u3, e.next_in = o2, e.avail_in = f3, r.hold = l3, r.bits = s2, rA;
              e.adler = r.check = 1, r.mode = rt2;
            case rt2:
              if (t === eA || t === uo)
                break e;
            case Vf:
              if (r.last) {
                l3 >>>= s2 & 7, s2 -= s2 & 7, r.mode = Kf;
                break;
              }
              for (;s2 < 3; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              switch (r.last = l3 & 1, l3 >>>= 1, s2 -= 1, l3 & 3) {
                case 0:
                  r.mode = yy;
                  break;
                case 1:
                  if (cA(r), r.mode = so2, t === uo) {
                    l3 >>>= 2, s2 -= 2;
                    break e;
                  }
                  break;
                case 2:
                  r.mode = gy;
                  break;
                case 3:
                  e.msg = "invalid block type", r.mode = C3;
              }
              l3 >>>= 2, s2 -= 2;
              break;
            case yy:
              for (l3 >>>= s2 & 7, s2 -= s2 & 7;s2 < 32; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              if ((l3 & 65535) !== (l3 >>> 16 ^ 65535)) {
                e.msg = "invalid stored block lengths", r.mode = C3;
                break;
              }
              if (r.length = l3 & 65535, l3 = 0, s2 = 0, r.mode = Yf, t === uo)
                break e;
            case Yf:
              r.mode = _y;
            case _y:
              if (d4 = r.length, d4) {
                if (d4 > f3 && (d4 = f3), d4 > u3 && (d4 = u3), d4 === 0)
                  break e;
                de.arraySet(i, n, o2, d4, a3), f3 -= d4, o2 += d4, u3 -= d4, a3 += d4, r.length -= d4;
                break;
              }
              r.mode = rt2;
              break;
            case gy:
              for (;s2 < 14; ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              if (r.nlen = (l3 & 31) + 257, l3 >>>= 5, s2 -= 5, r.ndist = (l3 & 31) + 1, l3 >>>= 5, s2 -= 5, r.ncode = (l3 & 15) + 4, l3 >>>= 4, s2 -= 4, r.nlen > 286 || r.ndist > 30) {
                e.msg = "too many length or distance symbols", r.mode = C3;
                break;
              }
              r.have = 0, r.mode = by;
            case by:
              for (;r.have < r.ncode; ) {
                for (;s2 < 3; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                r.lens[Ae2[r.have++]] = l3 & 7, l3 >>>= 3, s2 -= 3;
              }
              for (;r.have < 19; )
                r.lens[Ae2[r.have++]] = 0;
              if (r.lencode = r.lendyn, r.lenbits = 7, z = { bits: r.lenbits }, S3 = xn(Q1, r.lens, 0, 19, r.lencode, 0, r.work, z), r.lenbits = z.bits, S3) {
                e.msg = "invalid code lengths set", r.mode = C3;
                break;
              }
              r.have = 0, r.mode = wy;
            case wy:
              for (;r.have < r.nlen + r.ndist; ) {
                for (;R3 = r.lencode[l3 & (1 << r.lenbits) - 1], _4 = R3 >>> 24, E5 = R3 >>> 16 & 255, m3 = R3 & 65535, !(_4 <= s2); ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                if (m3 < 16)
                  l3 >>>= _4, s2 -= _4, r.lens[r.have++] = m3;
                else {
                  if (m3 === 16) {
                    for (O4 = _4 + 2;s2 < O4; ) {
                      if (f3 === 0)
                        break e;
                      f3--, l3 += n[o2++] << s2, s2 += 8;
                    }
                    if (l3 >>>= _4, s2 -= _4, r.have === 0) {
                      e.msg = "invalid bit length repeat", r.mode = C3;
                      break;
                    }
                    I4 = r.lens[r.have - 1], d4 = 3 + (l3 & 3), l3 >>>= 2, s2 -= 2;
                  } else if (m3 === 17) {
                    for (O4 = _4 + 3;s2 < O4; ) {
                      if (f3 === 0)
                        break e;
                      f3--, l3 += n[o2++] << s2, s2 += 8;
                    }
                    l3 >>>= _4, s2 -= _4, I4 = 0, d4 = 3 + (l3 & 7), l3 >>>= 3, s2 -= 3;
                  } else {
                    for (O4 = _4 + 7;s2 < O4; ) {
                      if (f3 === 0)
                        break e;
                      f3--, l3 += n[o2++] << s2, s2 += 8;
                    }
                    l3 >>>= _4, s2 -= _4, I4 = 0, d4 = 11 + (l3 & 127), l3 >>>= 7, s2 -= 7;
                  }
                  if (r.have + d4 > r.nlen + r.ndist) {
                    e.msg = "invalid bit length repeat", r.mode = C3;
                    break;
                  }
                  for (;d4--; )
                    r.lens[r.have++] = I4;
                }
              }
              if (r.mode === C3)
                break;
              if (r.lens[256] === 0) {
                e.msg = "invalid code -- missing end-of-block", r.mode = C3;
                break;
              }
              if (r.lenbits = 9, z = { bits: r.lenbits }, S3 = xn(Oy, r.lens, 0, r.nlen, r.lencode, 0, r.work, z), r.lenbits = z.bits, S3) {
                e.msg = "invalid literal/lengths set", r.mode = C3;
                break;
              }
              if (r.distbits = 6, r.distcode = r.distdyn, z = { bits: r.distbits }, S3 = xn(Ny, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, z), r.distbits = z.bits, S3) {
                e.msg = "invalid distances set", r.mode = C3;
                break;
              }
              if (r.mode = so2, t === uo)
                break e;
            case so2:
              r.mode = co;
            case co:
              if (f3 >= 6 && u3 >= 258) {
                e.next_out = a3, e.avail_out = u3, e.next_in = o2, e.avail_in = f3, r.hold = l3, r.bits = s2, J1(e, h5), a3 = e.next_out, i = e.output, u3 = e.avail_out, o2 = e.next_in, n = e.input, f3 = e.avail_in, l3 = r.hold, s2 = r.bits, r.mode === rt2 && (r.back = -1);
                break;
              }
              for (r.back = 0;R3 = r.lencode[l3 & (1 << r.lenbits) - 1], _4 = R3 >>> 24, E5 = R3 >>> 16 & 255, m3 = R3 & 65535, !(_4 <= s2); ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              if (E5 && (E5 & 240) === 0) {
                for (A4 = _4, v4 = E5, T3 = m3;R3 = r.lencode[T3 + ((l3 & (1 << A4 + v4) - 1) >> A4)], _4 = R3 >>> 24, E5 = R3 >>> 16 & 255, m3 = R3 & 65535, !(A4 + _4 <= s2); ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                l3 >>>= A4, s2 -= A4, r.back += A4;
              }
              if (l3 >>>= _4, s2 -= _4, r.back += _4, r.length = m3, E5 === 0) {
                r.mode = Ay;
                break;
              }
              if (E5 & 32) {
                r.back = -1, r.mode = rt2;
                break;
              }
              if (E5 & 64) {
                e.msg = "invalid literal/length code", r.mode = C3;
                break;
              }
              r.extra = E5 & 15, r.mode = Ey;
            case Ey:
              if (r.extra) {
                for (O4 = r.extra;s2 < O4; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                r.length += l3 & (1 << r.extra) - 1, l3 >>>= r.extra, s2 -= r.extra, r.back += r.extra;
              }
              r.was = r.length, r.mode = vy;
            case vy:
              for (;R3 = r.distcode[l3 & (1 << r.distbits) - 1], _4 = R3 >>> 24, E5 = R3 >>> 16 & 255, m3 = R3 & 65535, !(_4 <= s2); ) {
                if (f3 === 0)
                  break e;
                f3--, l3 += n[o2++] << s2, s2 += 8;
              }
              if ((E5 & 240) === 0) {
                for (A4 = _4, v4 = E5, T3 = m3;R3 = r.distcode[T3 + ((l3 & (1 << A4 + v4) - 1) >> A4)], _4 = R3 >>> 24, E5 = R3 >>> 16 & 255, m3 = R3 & 65535, !(A4 + _4 <= s2); ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                l3 >>>= A4, s2 -= A4, r.back += A4;
              }
              if (l3 >>>= _4, s2 -= _4, r.back += _4, E5 & 64) {
                e.msg = "invalid distance code", r.mode = C3;
                break;
              }
              r.offset = m3, r.extra = E5 & 15, r.mode = my;
            case my:
              if (r.extra) {
                for (O4 = r.extra;s2 < O4; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                r.offset += l3 & (1 << r.extra) - 1, l3 >>>= r.extra, s2 -= r.extra, r.back += r.extra;
              }
              if (r.offset > r.dmax) {
                e.msg = "invalid distance too far back", r.mode = C3;
                break;
              }
              r.mode = Sy;
            case Sy:
              if (u3 === 0)
                break e;
              if (d4 = h5 - u3, r.offset > d4) {
                if (d4 = r.offset - d4, d4 > r.whave && r.sane) {
                  e.msg = "invalid distance too far back", r.mode = C3;
                  break;
                }
                d4 > r.wnext ? (d4 -= r.wnext, y5 = r.wsize - d4) : y5 = r.wnext - d4, d4 > r.length && (d4 = r.length), b4 = r.window;
              } else
                b4 = i, y5 = a3 - r.offset, d4 = r.length;
              d4 > u3 && (d4 = u3), u3 -= d4, r.length -= d4;
              do
                i[a3++] = b4[y5++];
              while (--d4);
              r.length === 0 && (r.mode = co);
              break;
            case Ay:
              if (u3 === 0)
                break e;
              i[a3++] = r.length, u3--, r.mode = co;
              break;
            case Kf:
              if (r.wrap) {
                for (;s2 < 32; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 |= n[o2++] << s2, s2 += 8;
                }
                if (h5 -= u3, e.total_out += h5, r.total += h5, h5 && (e.adler = r.check = r.flags ? He(r.check, i, h5, a3 - h5) : Qf(r.check, i, h5, a3 - h5)), h5 = u3, (r.flags ? l3 : Iy(l3)) !== r.check) {
                  e.msg = "incorrect data check", r.mode = C3;
                  break;
                }
                l3 = 0, s2 = 0;
              }
              r.mode = xy;
            case xy:
              if (r.wrap && r.flags) {
                for (;s2 < 32; ) {
                  if (f3 === 0)
                    break e;
                  f3--, l3 += n[o2++] << s2, s2 += 8;
                }
                if (l3 !== (r.total & 4294967295)) {
                  e.msg = "incorrect length check", r.mode = C3;
                  break;
                }
                l3 = 0, s2 = 0;
              }
              r.mode = Ry;
            case Ry:
              S3 = tA;
              break e;
            case C3:
              S3 = ky;
              break e;
            case tl:
              return el;
            case iA:
            default:
              return Se2;
          }
      return e.next_out = a3, e.avail_out = u3, e.next_in = o2, e.avail_in = f3, r.hold = l3, r.bits = s2, (r.wsize || h5 !== e.avail_out && r.mode < C3 && (r.mode < Kf || t !== iy)) && My(e, e.output, e.next_out, h5 - e.avail_out) ? (r.mode = tl, el) : (c2 -= e.avail_in, h5 -= e.avail_out, e.total_in += c2, e.total_out += h5, r.total += h5, r.wrap && h5 && (e.adler = r.check = r.flags ? He(r.check, i, h5, e.next_out - h5) : Qf(r.check, i, h5, e.next_out - h5)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === rt2 ? 128 : 0) + (r.mode === so2 || r.mode === Yf ? 256 : 0), (c2 === 0 && h5 === 0 || t === iy) && S3 === $t && (S3 = nA), S3);
    }
    function hA(e) {
      if (!e || !e.state)
        return Se2;
      var t = e.state;
      return t.window && (t.window = null), e.state = null, $t;
    }
    function pA(e, t) {
      var r;
      return !e || !e.state || (r = e.state, (r.wrap & 2) === 0) ? Se2 : (r.head = t, t.done = false, $t);
    }
    function yA(e, t) {
      var r = t.length, n, i, o2;
      return !e || !e.state || (n = e.state, n.wrap !== 0 && n.mode !== ho) ? Se2 : n.mode === ho && (i = 1, i = Qf(i, t, r, 0), i !== n.check) ? ky : (o2 = My(e, t, r, r), o2 ? (n.mode = tl, el) : (n.havedict = 1, $t));
    }
    Le.inflateReset = Dy;
    Le.inflateReset2 = By;
    Le.inflateResetKeep = Ly;
    Le.inflateInit = sA;
    Le.inflateInit2 = Py;
    Le.inflate = dA;
    Le.inflateEnd = hA;
    Le.inflateGetHeader = pA;
    Le.inflateSetDictionary = yA;
    Le.inflateInfo = "pako inflate (from Nodeca project)";
  });
  qy = g4((Qx, Uy) => {
    Uy.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  });
  zy = g4((w3) => {
    var he = tn(), _A = dp(), Rn = Vp(), Gt = jy(), Cy = qy();
    for (rl in Cy)
      w3[rl] = Cy[rl];
    var rl;
    w3.NONE = 0;
    w3.DEFLATE = 1;
    w3.INFLATE = 2;
    w3.GZIP = 3;
    w3.GUNZIP = 4;
    w3.DEFLATERAW = 5;
    w3.INFLATERAW = 6;
    w3.UNZIP = 7;
    var gA = 31, bA = 139;
    function re2(e) {
      if (typeof e != "number" || e < w3.DEFLATE || e > w3.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = false, this.level = 0, this.memLevel = 0, this.mode = e, this.strategy = 0, this.windowBits = 0, this.write_in_progress = false, this.pending_close = false, this.gzip_id_bytes_read = 0;
    }
    re2.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false, he(this.init_done, "close before init"), he(this.mode <= w3.UNZIP), this.mode === w3.DEFLATE || this.mode === w3.GZIP || this.mode === w3.DEFLATERAW ? Rn.deflateEnd(this.strm) : (this.mode === w3.INFLATE || this.mode === w3.GUNZIP || this.mode === w3.INFLATERAW || this.mode === w3.UNZIP) && Gt.inflateEnd(this.strm), this.mode = w3.NONE, this.dictionary = null;
    };
    re2.prototype.write = function(e, t, r, n, i, o2, a3) {
      return this._write(true, e, t, r, n, i, o2, a3);
    };
    re2.prototype.writeSync = function(e, t, r, n, i, o2, a3) {
      return this._write(false, e, t, r, n, i, o2, a3);
    };
    re2.prototype._write = function(e, t, r, n, i, o2, a3, f3) {
      if (he.equal(arguments.length, 8), he(this.init_done, "write before init"), he(this.mode !== w3.NONE, "already finalized"), he.equal(false, this.write_in_progress, "write already in progress"), he.equal(false, this.pending_close, "close is pending"), this.write_in_progress = true, he.equal(false, t === undefined, "must provide flush value"), this.write_in_progress = true, t !== w3.Z_NO_FLUSH && t !== w3.Z_PARTIAL_FLUSH && t !== w3.Z_SYNC_FLUSH && t !== w3.Z_FULL_FLUSH && t !== w3.Z_FINISH && t !== w3.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (r == null && (r = Buffer.alloc(0), i = 0, n = 0), this.strm.avail_in = i, this.strm.input = r, this.strm.next_in = n, this.strm.avail_out = f3, this.strm.output = o2, this.strm.next_out = a3, this.flush = t, !e)
        return this._process(), this._checkError() ? this._afterSync() : undefined;
      var u3 = this;
      return process.nextTick(function() {
        u3._process(), u3._after();
      }), this;
    };
    re2.prototype._afterSync = function() {
      var e = this.strm.avail_out, t = this.strm.avail_in;
      return this.write_in_progress = false, [t, e];
    };
    re2.prototype._process = function() {
      var e = null;
      switch (this.mode) {
        case w3.DEFLATE:
        case w3.GZIP:
        case w3.DEFLATERAW:
          this.err = Rn.deflate(this.strm, this.flush);
          break;
        case w3.UNZIP:
          switch (this.strm.avail_in > 0 && (e = this.strm.next_in), this.gzip_id_bytes_read) {
            case 0:
              if (e === null)
                break;
              if (this.strm.input[e] === gA) {
                if (this.gzip_id_bytes_read = 1, e++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = w3.INFLATE;
                break;
              }
            case 1:
              if (e === null)
                break;
              this.strm.input[e] === bA ? (this.gzip_id_bytes_read = 2, this.mode = w3.GUNZIP) : this.mode = w3.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case w3.INFLATE:
        case w3.GUNZIP:
        case w3.INFLATERAW:
          for (this.err = Gt.inflate(this.strm, this.flush), this.err === w3.Z_NEED_DICT && this.dictionary && (this.err = Gt.inflateSetDictionary(this.strm, this.dictionary), this.err === w3.Z_OK ? this.err = Gt.inflate(this.strm, this.flush) : this.err === w3.Z_DATA_ERROR && (this.err = w3.Z_NEED_DICT));this.strm.avail_in > 0 && this.mode === w3.GUNZIP && this.err === w3.Z_STREAM_END && this.strm.next_in[0] !== 0; )
            this.reset(), this.err = Gt.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    re2.prototype._checkError = function() {
      switch (this.err) {
        case w3.Z_OK:
        case w3.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === w3.Z_FINISH)
            return this._error("unexpected end of file"), false;
          break;
        case w3.Z_STREAM_END:
          break;
        case w3.Z_NEED_DICT:
          return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), false;
        default:
          return this._error("Zlib error"), false;
      }
      return true;
    };
    re2.prototype._after = function() {
      if (!!this._checkError()) {
        var e = this.strm.avail_out, t = this.strm.avail_in;
        this.write_in_progress = false, this.callback(t, e), this.pending_close && this.close();
      }
    };
    re2.prototype._error = function(e) {
      this.strm.msg && (e = this.strm.msg), this.onerror(e, this.err), this.write_in_progress = false, this.pending_close && this.close();
    };
    re2.prototype.init = function(e, t, r, n, i) {
      he(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), he(e >= 8 && e <= 15, "invalid windowBits"), he(t >= -1 && t <= 9, "invalid compression level"), he(r >= 1 && r <= 9, "invalid memlevel"), he(n === w3.Z_FILTERED || n === w3.Z_HUFFMAN_ONLY || n === w3.Z_RLE || n === w3.Z_FIXED || n === w3.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(t, e, r, n, i), this._setDictionary();
    };
    re2.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    re2.prototype.reset = function() {
      this._reset(), this._setDictionary();
    };
    re2.prototype._init = function(e, t, r, n, i) {
      switch (this.level = e, this.windowBits = t, this.memLevel = r, this.strategy = n, this.flush = w3.Z_NO_FLUSH, this.err = w3.Z_OK, (this.mode === w3.GZIP || this.mode === w3.GUNZIP) && (this.windowBits += 16), this.mode === w3.UNZIP && (this.windowBits += 32), (this.mode === w3.DEFLATERAW || this.mode === w3.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new _A, this.mode) {
        case w3.DEFLATE:
        case w3.GZIP:
        case w3.DEFLATERAW:
          this.err = Rn.deflateInit2(this.strm, this.level, w3.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case w3.INFLATE:
        case w3.GUNZIP:
        case w3.INFLATERAW:
        case w3.UNZIP:
          this.err = Gt.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      this.err !== w3.Z_OK && this._error("Init error"), this.dictionary = i, this.write_in_progress = false, this.init_done = true;
    };
    re2.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (this.err = w3.Z_OK, this.mode) {
          case w3.DEFLATE:
          case w3.DEFLATERAW:
            this.err = Rn.deflateSetDictionary(this.strm, this.dictionary);
            break;
          default:
            break;
        }
        this.err !== w3.Z_OK && this._error("Failed to set dictionary");
      }
    };
    re2.prototype._reset = function() {
      switch (this.err = w3.Z_OK, this.mode) {
        case w3.DEFLATE:
        case w3.DEFLATERAW:
        case w3.GZIP:
          this.err = Rn.deflateReset(this.strm);
          break;
        case w3.INFLATE:
        case w3.INFLATERAW:
        case w3.GUNZIP:
          this.err = Gt.inflateReset(this.strm);
          break;
        default:
          break;
      }
      this.err !== w3.Z_OK && this._error("Failed to reset stream");
    };
    w3.Zlib = re2;
  });
  ol = g4((x5) => {
    var Ve = xe().Buffer, Gy = (_c(), se(br2)).Transform, N6 = zy(), Et = ff(), In = tn().ok, il = xe().kMaxLength, Hy = "Cannot create final Buffer. It would be larger than 0x" + il.toString(16) + " bytes";
    N6.Z_MIN_WINDOWBITS = 8;
    N6.Z_MAX_WINDOWBITS = 15;
    N6.Z_DEFAULT_WINDOWBITS = 15;
    N6.Z_MIN_CHUNK = 64;
    N6.Z_MAX_CHUNK = 1 / 0;
    N6.Z_DEFAULT_CHUNK = 16 * 1024;
    N6.Z_MIN_MEMLEVEL = 1;
    N6.Z_MAX_MEMLEVEL = 9;
    N6.Z_DEFAULT_MEMLEVEL = 8;
    N6.Z_MIN_LEVEL = -1;
    N6.Z_MAX_LEVEL = 9;
    N6.Z_DEFAULT_LEVEL = N6.Z_DEFAULT_COMPRESSION;
    var Wy = Object.keys(N6);
    for (po = 0;po < Wy.length; po++)
      yo = Wy[po], yo.match(/^Z/) && Object.defineProperty(x5, yo, { enumerable: true, value: N6[yo], writable: false });
    var yo, po, go = { Z_OK: N6.Z_OK, Z_STREAM_END: N6.Z_STREAM_END, Z_NEED_DICT: N6.Z_NEED_DICT, Z_ERRNO: N6.Z_ERRNO, Z_STREAM_ERROR: N6.Z_STREAM_ERROR, Z_DATA_ERROR: N6.Z_DATA_ERROR, Z_MEM_ERROR: N6.Z_MEM_ERROR, Z_BUF_ERROR: N6.Z_BUF_ERROR, Z_VERSION_ERROR: N6.Z_VERSION_ERROR }, Zy = Object.keys(go);
    for (_o = 0;_o < Zy.length; _o++)
      nl = Zy[_o], go[go[nl]] = nl;
    var nl, _o;
    Object.defineProperty(x5, "codes", { enumerable: true, value: Object.freeze(go), writable: false });
    x5.Deflate = Ht;
    x5.Inflate = Vt;
    x5.Gzip = Yt;
    x5.Gunzip = Kt;
    x5.DeflateRaw = Xt;
    x5.InflateRaw = Jt;
    x5.Unzip = Qt;
    x5.createDeflate = function(e) {
      return new Ht(e);
    };
    x5.createInflate = function(e) {
      return new Vt(e);
    };
    x5.createDeflateRaw = function(e) {
      return new Xt(e);
    };
    x5.createInflateRaw = function(e) {
      return new Jt(e);
    };
    x5.createGzip = function(e) {
      return new Yt(e);
    };
    x5.createGunzip = function(e) {
      return new Kt(e);
    };
    x5.createUnzip = function(e) {
      return new Qt(e);
    };
    x5.deflate = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Ht(t), e, r);
    };
    x5.deflateSync = function(e, t) {
      return tr(new Ht(t), e);
    };
    x5.gzip = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Yt(t), e, r);
    };
    x5.gzipSync = function(e, t) {
      return tr(new Yt(t), e);
    };
    x5.deflateRaw = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Xt(t), e, r);
    };
    x5.deflateRawSync = function(e, t) {
      return tr(new Xt(t), e);
    };
    x5.unzip = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Qt(t), e, r);
    };
    x5.unzipSync = function(e, t) {
      return tr(new Qt(t), e);
    };
    x5.inflate = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Vt(t), e, r);
    };
    x5.inflateSync = function(e, t) {
      return tr(new Vt(t), e);
    };
    x5.gunzip = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Kt(t), e, r);
    };
    x5.gunzipSync = function(e, t) {
      return tr(new Kt(t), e);
    };
    x5.inflateRaw = function(e, t, r) {
      return typeof t == "function" && (r = t, t = {}), er(new Jt(t), e, r);
    };
    x5.inflateRawSync = function(e, t) {
      return tr(new Jt(t), e);
    };
    function er(e, t, r) {
      var n = [], i = 0;
      e.on("error", a3), e.on("end", f3), e.end(t), o2();
      function o2() {
        for (var u3;(u3 = e.read()) !== null; )
          n.push(u3), i += u3.length;
        e.once("readable", o2);
      }
      function a3(u3) {
        e.removeListener("end", f3), e.removeListener("readable", o2), r(u3);
      }
      function f3() {
        var u3, l3 = null;
        i >= il ? l3 = new RangeError(Hy) : u3 = Ve.concat(n, i), n = [], e.close(), r(l3, u3);
      }
    }
    function tr(e, t) {
      if (typeof t == "string" && (t = Ve.from(t)), !Ve.isBuffer(t))
        throw new TypeError("Not a string or buffer");
      var r = e._finishFlushFlag;
      return e._processChunk(t, r);
    }
    function Ht(e) {
      if (!(this instanceof Ht))
        return new Ht(e);
      Z2.call(this, e, N6.DEFLATE);
    }
    function Vt(e) {
      if (!(this instanceof Vt))
        return new Vt(e);
      Z2.call(this, e, N6.INFLATE);
    }
    function Yt(e) {
      if (!(this instanceof Yt))
        return new Yt(e);
      Z2.call(this, e, N6.GZIP);
    }
    function Kt(e) {
      if (!(this instanceof Kt))
        return new Kt(e);
      Z2.call(this, e, N6.GUNZIP);
    }
    function Xt(e) {
      if (!(this instanceof Xt))
        return new Xt(e);
      Z2.call(this, e, N6.DEFLATERAW);
    }
    function Jt(e) {
      if (!(this instanceof Jt))
        return new Jt(e);
      Z2.call(this, e, N6.INFLATERAW);
    }
    function Qt(e) {
      if (!(this instanceof Qt))
        return new Qt(e);
      Z2.call(this, e, N6.UNZIP);
    }
    function $y(e) {
      return e === N6.Z_NO_FLUSH || e === N6.Z_PARTIAL_FLUSH || e === N6.Z_SYNC_FLUSH || e === N6.Z_FULL_FLUSH || e === N6.Z_FINISH || e === N6.Z_BLOCK;
    }
    function Z2(e, t) {
      var r = this;
      if (this._opts = e = e || {}, this._chunkSize = e.chunkSize || x5.Z_DEFAULT_CHUNK, Gy.call(this, e), e.flush && !$y(e.flush))
        throw new Error("Invalid flush flag: " + e.flush);
      if (e.finishFlush && !$y(e.finishFlush))
        throw new Error("Invalid flush flag: " + e.finishFlush);
      if (this._flushFlag = e.flush || N6.Z_NO_FLUSH, this._finishFlushFlag = typeof e.finishFlush < "u" ? e.finishFlush : N6.Z_FINISH, e.chunkSize && (e.chunkSize < x5.Z_MIN_CHUNK || e.chunkSize > x5.Z_MAX_CHUNK))
        throw new Error("Invalid chunk size: " + e.chunkSize);
      if (e.windowBits && (e.windowBits < x5.Z_MIN_WINDOWBITS || e.windowBits > x5.Z_MAX_WINDOWBITS))
        throw new Error("Invalid windowBits: " + e.windowBits);
      if (e.level && (e.level < x5.Z_MIN_LEVEL || e.level > x5.Z_MAX_LEVEL))
        throw new Error("Invalid compression level: " + e.level);
      if (e.memLevel && (e.memLevel < x5.Z_MIN_MEMLEVEL || e.memLevel > x5.Z_MAX_MEMLEVEL))
        throw new Error("Invalid memLevel: " + e.memLevel);
      if (e.strategy && e.strategy != x5.Z_FILTERED && e.strategy != x5.Z_HUFFMAN_ONLY && e.strategy != x5.Z_RLE && e.strategy != x5.Z_FIXED && e.strategy != x5.Z_DEFAULT_STRATEGY)
        throw new Error("Invalid strategy: " + e.strategy);
      if (e.dictionary && !Ve.isBuffer(e.dictionary))
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      this._handle = new N6.Zlib(t);
      var n = this;
      this._hadError = false, this._handle.onerror = function(a3, f3) {
        bo(n), n._hadError = true;
        var u3 = new Error(a3);
        u3.errno = f3, u3.code = x5.codes[f3], n.emit("error", u3);
      };
      var i = x5.Z_DEFAULT_COMPRESSION;
      typeof e.level == "number" && (i = e.level);
      var o2 = x5.Z_DEFAULT_STRATEGY;
      typeof e.strategy == "number" && (o2 = e.strategy), this._handle.init(e.windowBits || x5.Z_DEFAULT_WINDOWBITS, i, e.memLevel || x5.Z_DEFAULT_MEMLEVEL, o2, e.dictionary), this._buffer = Ve.allocUnsafe(this._chunkSize), this._offset = 0, this._level = i, this._strategy = o2, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
        return !r._handle;
      }, configurable: true, enumerable: true });
    }
    Et.inherits(Z2, Gy);
    Z2.prototype.params = function(e, t, r) {
      if (e < x5.Z_MIN_LEVEL || e > x5.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + e);
      if (t != x5.Z_FILTERED && t != x5.Z_HUFFMAN_ONLY && t != x5.Z_RLE && t != x5.Z_FIXED && t != x5.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + t);
      if (this._level !== e || this._strategy !== t) {
        var n = this;
        this.flush(N6.Z_SYNC_FLUSH, function() {
          In(n._handle, "zlib binding closed"), n._handle.params(e, t), n._hadError || (n._level = e, n._strategy = t, r && r());
        });
      } else
        process.nextTick(r);
    };
    Z2.prototype.reset = function() {
      return In(this._handle, "zlib binding closed"), this._handle.reset();
    };
    Z2.prototype._flush = function(e) {
      this._transform(Ve.alloc(0), "", e);
    };
    Z2.prototype.flush = function(e, t) {
      var r = this, n = this._writableState;
      (typeof e == "function" || e === undefined && !t) && (t = e, e = N6.Z_FULL_FLUSH), n.ended ? t && process.nextTick(t) : n.ending ? t && this.once("end", t) : n.needDrain ? t && this.once("drain", function() {
        return r.flush(e, t);
      }) : (this._flushFlag = e, this.write(Ve.alloc(0), "", t));
    };
    Z2.prototype.close = function(e) {
      bo(this, e), process.nextTick(wA, this);
    };
    function bo(e, t) {
      t && process.nextTick(t), e._handle && (e._handle.close(), e._handle = null);
    }
    function wA(e) {
      e.emit("close");
    }
    Z2.prototype._transform = function(e, t, r) {
      var n, i = this._writableState, o2 = i.ending || i.ended, a3 = o2 && (!e || i.length === e.length);
      if (e !== null && !Ve.isBuffer(e))
        return r(new Error("invalid input"));
      if (!this._handle)
        return r(new Error("zlib binding closed"));
      a3 ? n = this._finishFlushFlag : (n = this._flushFlag, e.length >= i.length && (this._flushFlag = this._opts.flush || N6.Z_NO_FLUSH)), this._processChunk(e, n, r);
    };
    Z2.prototype._processChunk = function(e, t, r) {
      var n = e && e.length, i = this._chunkSize - this._offset, o2 = 0, a3 = this, f3 = typeof r == "function";
      if (!f3) {
        var u3 = [], l3 = 0, s2;
        this.on("error", function(b4) {
          s2 = b4;
        }), In(this._handle, "zlib binding closed");
        do
          var c2 = this._handle.writeSync(t, e, o2, n, this._buffer, this._offset, i);
        while (!this._hadError && y5(c2[0], c2[1]));
        if (this._hadError)
          throw s2;
        if (l3 >= il)
          throw bo(this), new RangeError(Hy);
        var h5 = Ve.concat(u3, l3);
        return bo(this), h5;
      }
      In(this._handle, "zlib binding closed");
      var d4 = this._handle.write(t, e, o2, n, this._buffer, this._offset, i);
      d4.buffer = e, d4.callback = y5;
      function y5(b4, R3) {
        if (this && (this.buffer = null, this.callback = null), !a3._hadError) {
          var _4 = i - R3;
          if (In(_4 >= 0, "have should not go down"), _4 > 0) {
            var E5 = a3._buffer.slice(a3._offset, a3._offset + _4);
            a3._offset += _4, f3 ? a3.push(E5) : (u3.push(E5), l3 += E5.length);
          }
          if ((R3 === 0 || a3._offset >= a3._chunkSize) && (i = a3._chunkSize, a3._offset = 0, a3._buffer = Ve.allocUnsafe(a3._chunkSize)), R3 === 0) {
            if (o2 += n - b4, n = b4, !f3)
              return true;
            var m3 = a3._handle.write(t, e, o2, n, a3._buffer, a3._offset, a3._chunkSize);
            m3.callback = y5, m3.buffer = e;
            return;
          }
          if (!f3)
            return false;
          r();
        }
      }
    };
    Et.inherits(Ht, Z2);
    Et.inherits(Vt, Z2);
    Et.inherits(Yt, Z2);
    Et.inherits(Kt, Z2);
    Et.inherits(Xt, Z2);
    Et.inherits(Jt, Z2);
    Et.inherits(Qt, Z2);
  });
  Tn = {};
  Bn(Tn, { default: () => EA });
  X3(Tn, vt(ol()));
  EA = vt(ol());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var _require$codes = require_errors_browser().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex();
  require_inherits_browser()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  require_inherits_browser()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  }
  var _require$codes = require_errors_browser().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call2(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call2);
        if (reading)
          return;
        destroys.forEach(call2);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module.exports = pipeline;
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS((exports, module) => {
  exports = module.exports = require__stream_readable();
  exports.Stream = exports;
  exports.Readable = exports;
  exports.Writable = require__stream_writable();
  exports.Duplex = require__stream_duplex();
  exports.Transform = require__stream_transform();
  exports.PassThrough = require__stream_passthrough();
  exports.finished = require_end_of_stream();
  exports.pipeline = require_pipeline();
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var adapters = [];
  var modifiers2 = [];
  var logger = function devnull() {
  };
  function use(adapter) {
    if (~adapters.indexOf(adapter))
      return false;
    adapters.push(adapter);
    return true;
  }
  function set(custom) {
    logger = custom;
  }
  function enabled(namespace) {
    var async = [];
    for (var i = 0;i < adapters.length; i++) {
      if (adapters[i].async) {
        async.push(adapters[i]);
        continue;
      }
      if (adapters[i](namespace))
        return true;
    }
    if (!async.length)
      return false;
    return new Promise(function pinky(resolve) {
      Promise.all(async.map(function prebind(fn) {
        return fn(namespace);
      })).then(function resolved(values) {
        resolve(values.some(Boolean));
      });
    });
  }
  function modify(fn) {
    if (~modifiers2.indexOf(fn))
      return false;
    modifiers2.push(fn);
    return true;
  }
  function write() {
    logger.apply(logger, arguments);
  }
  function process2(message) {
    for (var i = 0;i < modifiers2.length; i++) {
      message = modifiers2[i].apply(modifiers2[i], arguments);
    }
    return message;
  }
  function introduce(fn, options) {
    var has = Object.prototype.hasOwnProperty;
    for (var key in options) {
      if (has.call(options, key)) {
        fn[key] = options[key];
      }
    }
    return fn;
  }
  function nope(options) {
    options.enabled = false;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(function diagnopes() {
      return false;
    }, options);
  }
  function yep(options) {
    function diagnostics() {
      var args = Array.prototype.slice.call(arguments, 0);
      write.call(write, options, process2(args, options));
      return true;
    }
    options.enabled = true;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(diagnostics, options);
  }
  module.exports = function create(diagnostics) {
    diagnostics.introduce = introduce;
    diagnostics.enabled = enabled;
    diagnostics.process = process2;
    diagnostics.modify = modify;
    diagnostics.write = write;
    diagnostics.nope = nope;
    diagnostics.yep = yep;
    diagnostics.set = set;
    diagnostics.use = use;
    return diagnostics;
  };
});

// node_modules/color-string/node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports, module) => {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS((exports, module) => {
  var isArrayish = require_is_arrayish();
  var concat2 = Array.prototype.concat;
  var slice2 = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length;i < len; i++) {
      var arg = args[i];
      if (isArrayish(arg)) {
        results = concat2.call(results, slice2.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
});

// node_modules/color-string/index.js
var require_color_string = __commonJS((exports, module) => {
  var colorNames = require_color_name();
  var swizzle = require_simple_swizzle();
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);
  for (name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var name;
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case "hsl":
        val = cs.get.hsl(string);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0;i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h5 = (parseFloat(match[1]) % 360 + 360) % 360;
      var s2 = clamp(parseFloat(match[2]), 0, 100);
      var l3 = clamp(parseFloat(match[3]), 0, 100);
      var a3 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h5, s2, l3, a3];
    }
    return null;
  };
  cs.get.hwb = function(string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h5 = (parseFloat(match[1]) % 360 + 360) % 360;
      var w3 = clamp(parseFloat(match[2]), 0, 100);
      var b4 = clamp(parseFloat(match[3]), 0, 100);
      var a3 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h5, w3, b4, a3];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g5 = Math.round(rgba[1] / 255 * 100);
    var b4 = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g5 + "%, " + b4 + "%)" : "rgba(" + r + "%, " + g5 + "%, " + b4 + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a3 = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a3 = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(num2, min, max) {
    return Math.min(Math.max(min, num2), max);
  }
  function hexDouble(num2) {
    var str = Math.round(num2).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  }
});

// node_modules/color/node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var key;
  var convert = module.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
  }
  var channels;
  var labels;
  var model;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g5 = rgb[1] / 255;
    var b4 = rgb[2] / 255;
    var min = Math.min(r, g5, b4);
    var max = Math.max(r, g5, b4);
    var delta = max - min;
    var h5;
    var s2;
    var l3;
    if (max === min) {
      h5 = 0;
    } else if (r === max) {
      h5 = (g5 - b4) / delta;
    } else if (g5 === max) {
      h5 = 2 + (b4 - r) / delta;
    } else if (b4 === max) {
      h5 = 4 + (r - g5) / delta;
    }
    h5 = Math.min(h5 * 60, 360);
    if (h5 < 0) {
      h5 += 360;
    }
    l3 = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l3 <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h5, s2 * 100, l3 * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h5;
    var s2;
    var r = rgb[0] / 255;
    var g5 = rgb[1] / 255;
    var b4 = rgb[2] / 255;
    var v4 = Math.max(r, g5, b4);
    var diff = v4 - Math.min(r, g5, b4);
    var diffc = function(c2) {
      return (v4 - c2) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h5 = s2 = 0;
    } else {
      s2 = diff / v4;
      rdif = diffc(r);
      gdif = diffc(g5);
      bdif = diffc(b4);
      if (r === v4) {
        h5 = bdif - gdif;
      } else if (g5 === v4) {
        h5 = 1 / 3 + rdif - bdif;
      } else if (b4 === v4) {
        h5 = 2 / 3 + gdif - rdif;
      }
      if (h5 < 0) {
        h5 += 1;
      } else if (h5 > 1) {
        h5 -= 1;
      }
    }
    return [
      h5 * 360,
      s2 * 100,
      v4 * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g5 = rgb[1];
    var b4 = rgb[2];
    var h5 = convert.rgb.hsl(rgb)[0];
    var w3 = 1 / 255 * Math.min(r, Math.min(g5, b4));
    b4 = 1 - 1 / 255 * Math.max(r, Math.max(g5, b4));
    return [h5, w3 * 100, b4 * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g5 = rgb[1] / 255;
    var b4 = rgb[2] / 255;
    var c2;
    var m3;
    var y5;
    var k3;
    k3 = Math.min(1 - r, 1 - g5, 1 - b4);
    c2 = (1 - r - k3) / (1 - k3) || 0;
    m3 = (1 - g5 - k3) / (1 - k3) || 0;
    y5 = (1 - b4 - k3) / (1 - k3) || 0;
    return [c2 * 100, m3 * 100, y5 * 100, k3 * 100];
  };
  function comparativeDistance(x5, y5) {
    return Math.pow(x5[0] - y5[0], 2) + Math.pow(x5[1] - y5[1], 2) + Math.pow(x5[2] - y5[2], 2);
  }
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g5 = rgb[1] / 255;
    var b4 = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g5 = g5 > 0.04045 ? Math.pow((g5 + 0.055) / 1.055, 2.4) : g5 / 12.92;
    b4 = b4 > 0.04045 ? Math.pow((b4 + 0.055) / 1.055, 2.4) : b4 / 12.92;
    var x5 = r * 0.4124 + g5 * 0.3576 + b4 * 0.1805;
    var y5 = r * 0.2126 + g5 * 0.7152 + b4 * 0.0722;
    var z = r * 0.0193 + g5 * 0.1192 + b4 * 0.9505;
    return [x5 * 100, y5 * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x5 = xyz[0];
    var y5 = xyz[1];
    var z = xyz[2];
    var l3;
    var a3;
    var b4;
    x5 /= 95.047;
    y5 /= 100;
    z /= 108.883;
    x5 = x5 > 0.008856 ? Math.pow(x5, 1 / 3) : 7.787 * x5 + 16 / 116;
    y5 = y5 > 0.008856 ? Math.pow(y5, 1 / 3) : 7.787 * y5 + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l3 = 116 * y5 - 16;
    a3 = 500 * (x5 - y5);
    b4 = 200 * (y5 - z);
    return [l3, a3, b4];
  };
  convert.hsl.rgb = function(hsl) {
    var h5 = hsl[0] / 360;
    var s2 = hsl[1] / 100;
    var l3 = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s2 === 0) {
      val = l3 * 255;
      return [val, val, val];
    }
    if (l3 < 0.5) {
      t2 = l3 * (1 + s2);
    } else {
      t2 = l3 + s2 - l3 * s2;
    }
    t1 = 2 * l3 - t2;
    rgb = [0, 0, 0];
    for (var i = 0;i < 3; i++) {
      t3 = h5 + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h5 = hsl[0];
    var s2 = hsl[1] / 100;
    var l3 = hsl[2] / 100;
    var smin = s2;
    var lmin = Math.max(l3, 0.01);
    var sv;
    var v4;
    l3 *= 2;
    s2 *= l3 <= 1 ? l3 : 2 - l3;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v4 = (l3 + s2) / 2;
    sv = l3 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l3 + s2);
    return [h5, sv * 100, v4 * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h5 = hsv[0] / 60;
    var s2 = hsv[1] / 100;
    var v4 = hsv[2] / 100;
    var hi = Math.floor(h5) % 6;
    var f3 = h5 - Math.floor(h5);
    var p3 = 255 * v4 * (1 - s2);
    var q3 = 255 * v4 * (1 - s2 * f3);
    var t = 255 * v4 * (1 - s2 * (1 - f3));
    v4 *= 255;
    switch (hi) {
      case 0:
        return [v4, t, p3];
      case 1:
        return [q3, v4, p3];
      case 2:
        return [p3, v4, t];
      case 3:
        return [p3, q3, v4];
      case 4:
        return [t, p3, v4];
      case 5:
        return [v4, p3, q3];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h5 = hsv[0];
    var s2 = hsv[1] / 100;
    var v4 = hsv[2] / 100;
    var vmin = Math.max(v4, 0.01);
    var lmin;
    var sl2;
    var l3;
    l3 = (2 - s2) * v4;
    lmin = (2 - s2) * vmin;
    sl2 = s2 * vmin;
    sl2 /= lmin <= 1 ? lmin : 2 - lmin;
    sl2 = sl2 || 0;
    l3 /= 2;
    return [h5, sl2 * 100, l3 * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h5 = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v4;
    var f3;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h5);
    v4 = 1 - bl;
    f3 = 6 * h5 - i;
    if ((i & 1) !== 0) {
      f3 = 1 - f3;
    }
    n = wh + f3 * (v4 - wh);
    var r;
    var g5;
    var b4;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v4;
        g5 = n;
        b4 = wh;
        break;
      case 1:
        r = n;
        g5 = v4;
        b4 = wh;
        break;
      case 2:
        r = wh;
        g5 = v4;
        b4 = n;
        break;
      case 3:
        r = wh;
        g5 = n;
        b4 = v4;
        break;
      case 4:
        r = n;
        g5 = wh;
        b4 = v4;
        break;
      case 5:
        r = v4;
        g5 = wh;
        b4 = n;
        break;
    }
    return [r * 255, g5 * 255, b4 * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c2 = cmyk[0] / 100;
    var m3 = cmyk[1] / 100;
    var y5 = cmyk[2] / 100;
    var k3 = cmyk[3] / 100;
    var r;
    var g5;
    var b4;
    r = 1 - Math.min(1, c2 * (1 - k3) + k3);
    g5 = 1 - Math.min(1, m3 * (1 - k3) + k3);
    b4 = 1 - Math.min(1, y5 * (1 - k3) + k3);
    return [r * 255, g5 * 255, b4 * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x5 = xyz[0] / 100;
    var y5 = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g5;
    var b4;
    r = x5 * 3.2406 + y5 * -1.5372 + z * -0.4986;
    g5 = x5 * -0.9689 + y5 * 1.8758 + z * 0.0415;
    b4 = x5 * 0.0557 + y5 * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g5 = g5 > 0.0031308 ? 1.055 * Math.pow(g5, 1 / 2.4) - 0.055 : g5 * 12.92;
    b4 = b4 > 0.0031308 ? 1.055 * Math.pow(b4, 1 / 2.4) - 0.055 : b4 * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g5 = Math.min(Math.max(0, g5), 1);
    b4 = Math.min(Math.max(0, b4), 1);
    return [r * 255, g5 * 255, b4 * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x5 = xyz[0];
    var y5 = xyz[1];
    var z = xyz[2];
    var l3;
    var a3;
    var b4;
    x5 /= 95.047;
    y5 /= 100;
    z /= 108.883;
    x5 = x5 > 0.008856 ? Math.pow(x5, 1 / 3) : 7.787 * x5 + 16 / 116;
    y5 = y5 > 0.008856 ? Math.pow(y5, 1 / 3) : 7.787 * y5 + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l3 = 116 * y5 - 16;
    a3 = 500 * (x5 - y5);
    b4 = 200 * (y5 - z);
    return [l3, a3, b4];
  };
  convert.lab.xyz = function(lab) {
    var l3 = lab[0];
    var a3 = lab[1];
    var b4 = lab[2];
    var x5;
    var y5;
    var z;
    y5 = (l3 + 16) / 116;
    x5 = a3 / 500 + y5;
    z = y5 - b4 / 200;
    var y22 = Math.pow(y5, 3);
    var x22 = Math.pow(x5, 3);
    var z2 = Math.pow(z, 3);
    y5 = y22 > 0.008856 ? y22 : (y5 - 16 / 116) / 7.787;
    x5 = x22 > 0.008856 ? x22 : (x5 - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x5 *= 95.047;
    y5 *= 100;
    z *= 108.883;
    return [x5, y5, z];
  };
  convert.lab.lch = function(lab) {
    var l3 = lab[0];
    var a3 = lab[1];
    var b4 = lab[2];
    var hr;
    var h5;
    var c2;
    hr = Math.atan2(b4, a3);
    h5 = hr * 360 / 2 / Math.PI;
    if (h5 < 0) {
      h5 += 360;
    }
    c2 = Math.sqrt(a3 * a3 + b4 * b4);
    return [l3, c2, h5];
  };
  convert.lch.lab = function(lch) {
    var l3 = lch[0];
    var c2 = lch[1];
    var h5 = lch[2];
    var a3;
    var b4;
    var hr;
    hr = h5 / 360 * 2 * Math.PI;
    a3 = c2 * Math.cos(hr);
    b4 = c2 * Math.sin(hr);
    return [l3, a3, b4];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g5 = args[1];
    var b4 = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b4 / 255) << 2 | Math.round(g5 / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g5 = args[1];
    var b4 = args[2];
    if (r === g5 && g5 === b4) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g5 / 255 * 5) + Math.round(b4 / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g5 = (color >> 1 & 1) * mult * 255;
    var b4 = (color >> 2 & 1) * mult * 255;
    return [r, g5, b4];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c2 = (args - 232) * 10 + 8;
      return [c2, c2, c2];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g5 = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b4 = rem % 6 / 5 * 255;
    return [r, g5, b4];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g5 = integer >> 8 & 255;
    var b4 = integer & 255;
    return [r, g5, b4];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g5 = rgb[1] / 255;
    var b4 = rgb[2] / 255;
    var max = Math.max(Math.max(r, g5), b4);
    var min = Math.min(Math.min(r, g5), b4);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g5 - b4) / chroma % 6;
    } else if (max === g5) {
      hue = 2 + (b4 - r) / chroma;
    } else {
      hue = 4 + (r - g5) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s2 = hsl[1] / 100;
    var l3 = hsl[2] / 100;
    var c2 = 1;
    var f3 = 0;
    if (l3 < 0.5) {
      c2 = 2 * s2 * l3;
    } else {
      c2 = 2 * s2 * (1 - l3);
    }
    if (c2 < 1) {
      f3 = (l3 - 0.5 * c2) / (1 - c2);
    }
    return [hsl[0], c2 * 100, f3 * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s2 = hsv[1] / 100;
    var v4 = hsv[2] / 100;
    var c2 = s2 * v4;
    var f3 = 0;
    if (c2 < 1) {
      f3 = (v4 - c2) / (1 - c2);
    }
    return [hsv[0], c2 * 100, f3 * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h5 = hcg[0] / 360;
    var c2 = hcg[1] / 100;
    var g5 = hcg[2] / 100;
    if (c2 === 0) {
      return [g5 * 255, g5 * 255, g5 * 255];
    }
    var pure = [0, 0, 0];
    var hi = h5 % 1 * 6;
    var v4 = hi % 1;
    var w3 = 1 - v4;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v4;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w3;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v4;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w3;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v4;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w3;
    }
    mg = (1 - c2) * g5;
    return [
      (c2 * pure[0] + mg) * 255,
      (c2 * pure[1] + mg) * 255,
      (c2 * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c2 = hcg[1] / 100;
    var g5 = hcg[2] / 100;
    var v4 = c2 + g5 * (1 - c2);
    var f3 = 0;
    if (v4 > 0) {
      f3 = c2 / v4;
    }
    return [hcg[0], f3 * 100, v4 * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c2 = hcg[1] / 100;
    var g5 = hcg[2] / 100;
    var l3 = g5 * (1 - c2) + 0.5 * c2;
    var s2 = 0;
    if (l3 > 0 && l3 < 0.5) {
      s2 = c2 / (2 * l3);
    } else if (l3 >= 0.5 && l3 < 1) {
      s2 = c2 / (2 * (1 - l3));
    }
    return [hcg[0], s2 * 100, l3 * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c2 = hcg[1] / 100;
    var g5 = hcg[2] / 100;
    var v4 = c2 + g5 * (1 - c2);
    return [hcg[0], (v4 - c2) * 100, (1 - v4) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w3 = hwb[1] / 100;
    var b4 = hwb[2] / 100;
    var v4 = 1 - b4;
    var c2 = v4 - w3;
    var g5 = 0;
    if (c2 < 1) {
      g5 = (v4 - c2) / (1 - c2);
    }
    return [hwb[0], c2 * 100, g5 * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var conversions = require_conversions();
  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0;i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0;i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// node_modules/color/index.js
var require_color = __commonJS((exports, module) => {
  var colorString = require_color_string();
  var convert = require_color_convert();
  var _slice = [].slice;
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  Object.keys(convert).forEach(function(model) {
    hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
  });
  var limiters = {};
  function Color(obj, model) {
    if (!(this instanceof Color)) {
      return new Color(obj, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error("Unknown model: " + model);
    }
    var i;
    var channels;
    if (obj == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (obj instanceof Color) {
      this.model = obj.model;
      this.color = obj.color.slice();
      this.valpha = obj.valpha;
    } else if (typeof obj === "string") {
      var result = colorString.get(obj);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + obj);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (obj.length) {
      this.model = model || "rgb";
      channels = convert[this.model].channels;
      var newArr = _slice.call(obj, 0, channels);
      this.color = zeroArray(newArr, channels);
      this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
    } else if (typeof obj === "number") {
      obj &= 16777215;
      this.model = "rgb";
      this.color = [
        obj >> 16 & 255,
        obj >> 8 & 255,
        obj & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      var keys = Object.keys(obj);
      if ("alpha" in obj) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
      }
      var hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
      }
      this.model = hashedModelKeys[hashedKeys];
      var labels = convert[this.model].labels;
      var color = [];
      for (i = 0;i < labels.length; i++) {
        color.push(obj[labels[i]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i = 0;i < channels; i++) {
        var limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color.prototype = {
    toString: function() {
      return this.string();
    },
    toJSON: function() {
      return this[this.model]();
    },
    string: function(places) {
      var self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to[self2.model](args);
    },
    percentString: function(places) {
      var self2 = this.rgb().round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to.rgb.percent(args);
    },
    array: function() {
      return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    },
    object: function() {
      var result = {};
      var channels = convert[this.model].channels;
      var labels = convert[this.model].labels;
      for (var i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray: function() {
      var rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject: function() {
      var rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round: function(places) {
      places = Math.max(places || 0, 0);
      return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
    },
    alpha: function(val) {
      if (arguments.length) {
        return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
      return (val % 360 + 360) % 360;
    }),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(100)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(100)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return convert[this.model].keyword(this.color);
    },
    hex: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    rgbNumber: function() {
      var rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity: function() {
      var rgb = this.rgb().color;
      var lum = [];
      for (var i = 0;i < rgb.length; i++) {
        var chan = rgb[i] / 255;
        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function(color2) {
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function(color2) {
      var contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7.1) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark: function() {
      var rgb = this.rgb().color;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    isLight: function() {
      return !this.isDark();
    },
    negate: function() {
      var rgb = this.rgb();
      for (var i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten: function(ratio) {
      var hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken: function(ratio) {
      var hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale: function() {
      var rgb = this.rgb().color;
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(val, val, val);
    },
    fade: function(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer: function(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate: function(degrees) {
      var hsl = this.hsl();
      var hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix: function(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      var color1 = mixinColor.rgb();
      var color2 = this.rgb();
      var p3 = weight === undefined ? 0.5 : weight;
      var w3 = 2 * p3 - 1;
      var a3 = color1.alpha() - color2.alpha();
      var w1 = ((w3 * a3 === -1 ? w3 : (w3 + a3) / (1 + w3 * a3)) + 1) / 2;
      var w22 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w22 * color2.red(), w1 * color1.green() + w22 * color2.green(), w1 * color1.blue() + w22 * color2.blue(), color1.alpha() * p3 + color2.alpha() * (1 - p3));
    }
  };
  Object.keys(convert).forEach(function(model) {
    if (skippedModels.indexOf(model) !== -1) {
      return;
    }
    var channels = convert[model].channels;
    Color.prototype[model] = function() {
      if (this.model === model) {
        return new Color(this);
      }
      if (arguments.length) {
        return new Color(arguments, model);
      }
      var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
      return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
    };
    Color[model] = function(color) {
      if (typeof color === "number") {
        color = zeroArray(_slice.call(arguments), channels);
      }
      return new Color(color, model);
    };
  });
  function roundTo(num2, places) {
    return Number(num2.toFixed(places));
  }
  function roundToPlace(places) {
    return function(num2) {
      return roundTo(num2, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    model.forEach(function(m3) {
      (limiters[m3] || (limiters[m3] = []))[channel] = modifier;
    });
    model = model[0];
    return function(val) {
      var result;
      if (arguments.length) {
        if (modifier) {
          val = modifier(val);
        }
        result = this[model]();
        result.color[channel] = val;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function(v4) {
      return Math.max(0, Math.min(max, v4));
    };
  }
  function assertArray(val) {
    return Array.isArray(val) ? val : [val];
  }
  function zeroArray(arr, length) {
    for (var i = 0;i < length; i++) {
      if (typeof arr[i] !== "number") {
        arr[i] = 0;
      }
    }
    return arr;
  }
  module.exports = Color;
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS((exports, module) => {
  module.exports = function hex(str) {
    for (var i = 0, hash2 = 0;i < str.length; hash2 = str.charCodeAt(i++) + ((hash2 << 5) - hash2))
      ;
    var color = Math.floor(Math.abs(Math.sin(hash2) * 1e4 % 1 * 16777216)).toString(16);
    return "#" + Array(6 - color.length + 1).join("0") + color;
  };
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS((exports, module) => {
  var color = require_color();
  var hex = require_text_hex();
  module.exports = function colorspace(namespace, delimiter) {
    var split2 = namespace.split(delimiter || ":");
    var base2 = hex(split2[0]);
    if (!split2.length)
      return base2;
    for (var i = 0, l3 = split2.length - 1;i < l3; i++) {
      base2 = color(base2).mix(color(hex(split2[i + 1]))).saturate(1).hex();
    }
    return base2;
  };
});

// node_modules/@dabh/diagnostics/modifiers/namespace.js
var require_namespace = __commonJS((exports, module) => {
  var colorspace = require_colorspace();
  module.exports = function colorNamespace(args, options) {
    var namespace = options.namespace;
    if (options.colors === false) {
      args[0] = namespace + ": " + args[0];
      return args;
    }
    var color = colorspace(namespace);
    args[0] = "%c" + namespace + ":%c " + args[0];
    args.splice(1, 0, "color:" + color, "color:inherit");
    return args;
  };
});

// node_modules/enabled/index.js
var require_enabled = __commonJS((exports, module) => {
  module.exports = function enabled(name, variable) {
    if (!variable)
      return false;
    var variables = variable.split(/[\s,]+/), i = 0;
    for (;i < variables.length; i++) {
      variable = variables[i].replace("*", ".*?");
      if (variable.charAt(0) === "-") {
        if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
          return false;
        }
        continue;
      }
      if (new RegExp("^" + variable + "$").test(name)) {
        return true;
      }
    }
    return false;
  };
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS((exports, module) => {
  var enabled = require_enabled();
  module.exports = function create(fn) {
    return function adapter(namespace) {
      try {
        return enabled(namespace, fn());
      } catch (e) {
      }
      return false;
    };
  };
});

// node_modules/@dabh/diagnostics/adapters/localstorage.js
var require_localstorage = __commonJS((exports, module) => {
  var adapter = require_adapters();
  module.exports = adapter(function storage() {
    return localStorage.getItem("debug") || localStorage.getItem("diagnostics");
  });
});

// node_modules/@dabh/diagnostics/adapters/hash.js
var require_hash = __commonJS((exports, module) => {
  var adapter = require_adapters();
  module.exports = adapter(function hash() {
    return /(debug|diagnostics)=([^&]+)/i.exec(window.location.hash)[2];
  });
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS((exports, module) => {
  module.exports = function(meta, messages) {
    try {
      Function.prototype.apply.call(console.log, console, messages);
    } catch (e) {
    }
  };
});

// node_modules/@dabh/diagnostics/browser/development.js
var require_development = __commonJS((exports, module) => {
  var create = require_diagnostics();
  var diagnostics = create(function dev(namespace, options) {
    options = options || {};
    options.namespace = namespace;
    options.prod = false;
    options.dev = true;
    if (!dev.enabled(namespace) && !(options.force || dev.force)) {
      return dev.nope(options);
    }
    return dev.yep(options);
  });
  diagnostics.modify(require_namespace());
  diagnostics.use(require_localstorage());
  diagnostics.use(require_hash());
  diagnostics.set(require_console2());
  module.exports = diagnostics;
});

// node_modules/@dabh/diagnostics/browser/index.js
var require_browser3 = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_development();
  }
});

// node:string_decoder
var exports_string_decoder = {};
__export(exports_string_decoder, {
  default: () => export_default2,
  StringDecoder: () => export_StringDecoder
});
var Tt2, Z2, Nt, St, Rt, _t, R3 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Lt = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of St(t))
      !_t.call(e, n) && n !== r && Z2(e, n, { get: () => t[n], enumerable: !(i = Nt(t, n)) || i.enumerable });
  return e;
}, kt = (e, t, r) => (r = e != null ? Tt2(Rt(e)) : {}, Lt(t || !e || !e.__esModule ? Z2(r, "default", { value: e, enumerable: true }) : r, e)), tt2, rt2, Bt, mt2, At2, Ut, export_StringDecoder, export_default2;
var init_string_decoder = __esm(() => {
  Tt2 = Object.create;
  Z2 = Object.defineProperty;
  Nt = Object.getOwnPropertyDescriptor;
  St = Object.getOwnPropertyNames;
  Rt = Object.getPrototypeOf;
  _t = Object.prototype.hasOwnProperty;
  tt2 = R3((k3) => {
    k3.byteLength = Mt;
    k3.toByteArray = Pt;
    k3.fromByteArray = Gt;
    var d4 = [], w3 = [], Dt = typeof Uint8Array < "u" ? Uint8Array : Array, O4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (I4 = 0, Q3 = O4.length;I4 < Q3; ++I4)
      d4[I4] = O4[I4], w3[O4.charCodeAt(I4)] = I4;
    var I4, Q3;
    w3[45] = 62;
    w3[95] = 63;
    function v4(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var i = r === t ? 0 : 4 - r % 4;
      return [r, i];
    }
    function Mt(e) {
      var t = v4(e), r = t[0], i = t[1];
      return (r + i) * 3 / 4 - i;
    }
    function $t(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function Pt(e) {
      var t, r = v4(e), i = r[0], n = r[1], o2 = new Dt($t(e, i, n)), u3 = 0, s2 = n > 0 ? i - 4 : i, f3;
      for (f3 = 0;f3 < s2; f3 += 4)
        t = w3[e.charCodeAt(f3)] << 18 | w3[e.charCodeAt(f3 + 1)] << 12 | w3[e.charCodeAt(f3 + 2)] << 6 | w3[e.charCodeAt(f3 + 3)], o2[u3++] = t >> 16 & 255, o2[u3++] = t >> 8 & 255, o2[u3++] = t & 255;
      return n === 2 && (t = w3[e.charCodeAt(f3)] << 2 | w3[e.charCodeAt(f3 + 1)] >> 4, o2[u3++] = t & 255), n === 1 && (t = w3[e.charCodeAt(f3)] << 10 | w3[e.charCodeAt(f3 + 1)] << 4 | w3[e.charCodeAt(f3 + 2)] >> 2, o2[u3++] = t >> 8 & 255, o2[u3++] = t & 255), o2;
    }
    function Ot(e) {
      return d4[e >> 18 & 63] + d4[e >> 12 & 63] + d4[e >> 6 & 63] + d4[e & 63];
    }
    function qt(e, t, r) {
      for (var i, n = [], o2 = t;o2 < r; o2 += 3)
        i = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), n.push(Ot(i));
      return n.join("");
    }
    function Gt(e) {
      for (var t, r = e.length, i = r % 3, n = [], o2 = 16383, u3 = 0, s2 = r - i;u3 < s2; u3 += o2)
        n.push(qt(e, u3, u3 + o2 > s2 ? s2 : u3 + o2));
      return i === 1 ? (t = e[r - 1], n.push(d4[t >> 2] + d4[t << 4 & 63] + "==")) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], n.push(d4[t >> 10] + d4[t >> 4 & 63] + d4[t << 2 & 63] + "=")), n.join("");
    }
  });
  rt2 = R3((q3) => {
    q3.read = function(e, t, r, i, n) {
      var o2, u3, s2 = n * 8 - i - 1, f3 = (1 << s2) - 1, l3 = f3 >> 1, a3 = -7, c2 = r ? n - 1 : 0, U3 = r ? -1 : 1, x5 = e[t + c2];
      for (c2 += U3, o2 = x5 & (1 << -a3) - 1, x5 >>= -a3, a3 += s2;a3 > 0; o2 = o2 * 256 + e[t + c2], c2 += U3, a3 -= 8)
        ;
      for (u3 = o2 & (1 << -a3) - 1, o2 >>= -a3, a3 += i;a3 > 0; u3 = u3 * 256 + e[t + c2], c2 += U3, a3 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l3;
      else {
        if (o2 === f3)
          return u3 ? NaN : (x5 ? -1 : 1) * (1 / 0);
        u3 = u3 + Math.pow(2, i), o2 = o2 - l3;
      }
      return (x5 ? -1 : 1) * u3 * Math.pow(2, o2 - i);
    };
    q3.write = function(e, t, r, i, n, o2) {
      var u3, s2, f3, l3 = o2 * 8 - n - 1, a3 = (1 << l3) - 1, c2 = a3 >> 1, U3 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x5 = i ? 0 : o2 - 1, P4 = i ? 1 : -1, Ct = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s2 = isNaN(t) ? 1 : 0, u3 = a3) : (u3 = Math.floor(Math.log(t) / Math.LN2), t * (f3 = Math.pow(2, -u3)) < 1 && (u3--, f3 *= 2), u3 + c2 >= 1 ? t += U3 / f3 : t += U3 * Math.pow(2, 1 - c2), t * f3 >= 2 && (u3++, f3 /= 2), u3 + c2 >= a3 ? (s2 = 0, u3 = a3) : u3 + c2 >= 1 ? (s2 = (t * f3 - 1) * Math.pow(2, n), u3 = u3 + c2) : (s2 = t * Math.pow(2, c2 - 1) * Math.pow(2, n), u3 = 0));n >= 8; e[r + x5] = s2 & 255, x5 += P4, s2 /= 256, n -= 8)
        ;
      for (u3 = u3 << n | s2, l3 += n;l3 > 0; e[r + x5] = u3 & 255, x5 += P4, u3 /= 256, l3 -= 8)
        ;
      e[r + x5 - P4] |= Ct * 128;
    };
  });
  Bt = R3((S3) => {
    var G2 = tt2(), T3 = rt2(), et = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    S3.Buffer = h5;
    S3.SlowBuffer = Vt;
    S3.INSPECT_MAX_BYTES = 50;
    var D3 = 2147483647;
    S3.kMaxLength = D3;
    h5.TYPED_ARRAY_SUPPORT = Wt();
    !h5.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Wt() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h5.prototype, "parent", { enumerable: true, get: function() {
      if (!!h5.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h5.prototype, "offset", { enumerable: true, get: function() {
      if (!!h5.isBuffer(this))
        return this.byteOffset;
    } });
    function E5(e) {
      if (e > D3)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, h5.prototype), t;
    }
    function h5(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return b4(e);
      }
      return ut2(e, t, r);
    }
    h5.poolSize = 8192;
    function ut2(e, t, r) {
      if (typeof e == "string")
        return jt(e, t);
      if (ArrayBuffer.isView(e))
        return bt2(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (B3(e, ArrayBuffer) || e && B3(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (B3(e, SharedArrayBuffer) || e && B3(e.buffer, SharedArrayBuffer)))
        return Y3(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let i = e.valueOf && e.valueOf();
      if (i != null && i !== e)
        return h5.from(i, t, r);
      let n = Ht(e);
      if (n)
        return n;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return h5.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    h5.from = function(e, t, r) {
      return ut2(e, t, r);
    };
    Object.setPrototypeOf(h5.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h5, Uint8Array);
    function ht2(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Yt(e, t, r) {
      return ht2(e), e <= 0 ? E5(e) : t !== undefined ? typeof r == "string" ? E5(e).fill(t, r) : E5(e).fill(t) : E5(e);
    }
    h5.alloc = function(e, t, r) {
      return Yt(e, t, r);
    };
    function b4(e) {
      return ht2(e), E5(e < 0 ? 0 : H3(e) | 0);
    }
    h5.allocUnsafe = function(e) {
      return b4(e);
    };
    h5.allocUnsafeSlow = function(e) {
      return b4(e);
    };
    function jt(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !h5.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = st3(e, t) | 0, i = E5(r), n = i.write(e, t);
      return n !== r && (i = i.slice(0, n)), i;
    }
    function W(e) {
      let t = e.length < 0 ? 0 : H3(e.length) | 0, r = E5(t);
      for (let i = 0;i < t; i += 1)
        r[i] = e[i] & 255;
      return r;
    }
    function bt2(e) {
      if (B3(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Y3(t.buffer, t.byteOffset, t.byteLength);
      }
      return W(e);
    }
    function Y3(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let i;
      return t === undefined && r === undefined ? i = new Uint8Array(e) : r === undefined ? i = new Uint8Array(e, t) : i = new Uint8Array(e, t, r), Object.setPrototypeOf(i, h5.prototype), i;
    }
    function Ht(e) {
      if (h5.isBuffer(e)) {
        let t = H3(e.length) | 0, r = E5(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || X4(e.length) ? E5(0) : W(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return W(e.data);
    }
    function H3(e) {
      if (e >= D3)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + D3.toString(16) + " bytes");
      return e | 0;
    }
    function Vt(e) {
      return +e != e && (e = 0), h5.alloc(+e);
    }
    h5.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== h5.prototype;
    };
    h5.compare = function(t, r) {
      if (B3(t, Uint8Array) && (t = h5.from(t, t.offset, t.byteLength)), B3(r, Uint8Array) && (r = h5.from(r, r.offset, r.byteLength)), !h5.isBuffer(t) || !h5.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let i = t.length, n = r.length;
      for (let o2 = 0, u3 = Math.min(i, n);o2 < u3; ++o2)
        if (t[o2] !== r[o2]) {
          i = t[o2], n = r[o2];
          break;
        }
      return i < n ? -1 : n < i ? 1 : 0;
    };
    h5.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h5.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return h5.alloc(0);
      let i;
      if (r === undefined)
        for (r = 0, i = 0;i < t.length; ++i)
          r += t[i].length;
      let n = h5.allocUnsafe(r), o2 = 0;
      for (i = 0;i < t.length; ++i) {
        let u3 = t[i];
        if (B3(u3, Uint8Array))
          o2 + u3.length > n.length ? (h5.isBuffer(u3) || (u3 = h5.from(u3)), u3.copy(n, o2)) : Uint8Array.prototype.set.call(n, u3, o2);
        else if (h5.isBuffer(u3))
          u3.copy(n, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += u3.length;
      }
      return n;
    };
    function st3(e, t) {
      if (h5.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || B3(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, i = arguments.length > 2 && arguments[2] === true;
      if (!i && r === 0)
        return 0;
      let n = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return j5(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return dt2(e).length;
          default:
            if (n)
              return i ? -1 : j5(e).length;
            t = ("" + t).toLowerCase(), n = true;
        }
    }
    h5.byteLength = st3;
    function Xt(e, t, r) {
      let i = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return ir(this, t, r);
          case "utf8":
          case "utf-8":
            return ct3(this, t, r);
          case "ascii":
            return rr2(this, t, r);
          case "latin1":
          case "binary":
            return er(this, t, r);
          case "base64":
            return vt2(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return nr(this, t, r);
          default:
            if (i)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), i = true;
        }
    }
    h5.prototype._isBuffer = true;
    function F2(e, t, r) {
      let i = e[t];
      e[t] = e[r], e[r] = i;
    }
    h5.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        F2(this, r, r + 1);
      return this;
    };
    h5.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        F2(this, r, r + 3), F2(this, r + 1, r + 2);
      return this;
    };
    h5.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        F2(this, r, r + 7), F2(this, r + 1, r + 6), F2(this, r + 2, r + 5), F2(this, r + 3, r + 4);
      return this;
    };
    h5.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? ct3(this, 0, t) : Xt.apply(this, arguments);
    };
    h5.prototype.toLocaleString = h5.prototype.toString;
    h5.prototype.equals = function(t) {
      if (!h5.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : h5.compare(this, t) === 0;
    };
    h5.prototype.inspect = function() {
      let t = "", r = S3.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    et && (h5.prototype[et] = h5.prototype.inspect);
    h5.prototype.compare = function(t, r, i, n, o2) {
      if (B3(t, Uint8Array) && (t = h5.from(t, t.offset, t.byteLength)), !h5.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), i === undefined && (i = t ? t.length : 0), n === undefined && (n = 0), o2 === undefined && (o2 = this.length), r < 0 || i > t.length || n < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (n >= o2 && r >= i)
        return 0;
      if (n >= o2)
        return -1;
      if (r >= i)
        return 1;
      if (r >>>= 0, i >>>= 0, n >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let u3 = o2 - n, s2 = i - r, f3 = Math.min(u3, s2), l3 = this.slice(n, o2), a3 = t.slice(r, i);
      for (let c2 = 0;c2 < f3; ++c2)
        if (l3[c2] !== a3[c2]) {
          u3 = l3[c2], s2 = a3[c2];
          break;
        }
      return u3 < s2 ? -1 : s2 < u3 ? 1 : 0;
    };
    function ft2(e, t, r, i, n) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, X4(r) && (r = n ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (n)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (n)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = h5.from(t, i)), h5.isBuffer(t))
        return t.length === 0 ? -1 : it2(e, t, r, i, n);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : it2(e, [t], r, i, n);
      throw new TypeError("val must be string, number or Buffer");
    }
    function it2(e, t, r, i, n) {
      let o2 = 1, u3 = e.length, s2 = t.length;
      if (i !== undefined && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, u3 /= 2, s2 /= 2, r /= 2;
      }
      function f3(a3, c2) {
        return o2 === 1 ? a3[c2] : a3.readUInt16BE(c2 * o2);
      }
      let l3;
      if (n) {
        let a3 = -1;
        for (l3 = r;l3 < u3; l3++)
          if (f3(e, l3) === f3(t, a3 === -1 ? 0 : l3 - a3)) {
            if (a3 === -1 && (a3 = l3), l3 - a3 + 1 === s2)
              return a3 * o2;
          } else
            a3 !== -1 && (l3 -= l3 - a3), a3 = -1;
      } else
        for (r + s2 > u3 && (r = u3 - s2), l3 = r;l3 >= 0; l3--) {
          let a3 = true;
          for (let c2 = 0;c2 < s2; c2++)
            if (f3(e, l3 + c2) !== f3(t, c2)) {
              a3 = false;
              break;
            }
          if (a3)
            return l3;
        }
      return -1;
    }
    h5.prototype.includes = function(t, r, i) {
      return this.indexOf(t, r, i) !== -1;
    };
    h5.prototype.indexOf = function(t, r, i) {
      return ft2(this, t, r, i, true);
    };
    h5.prototype.lastIndexOf = function(t, r, i) {
      return ft2(this, t, r, i, false);
    };
    function Jt(e, t, r, i) {
      r = Number(r) || 0;
      let n = e.length - r;
      i ? (i = Number(i), i > n && (i = n)) : i = n;
      let o2 = t.length;
      i > o2 / 2 && (i = o2 / 2);
      let u3;
      for (u3 = 0;u3 < i; ++u3) {
        let s2 = parseInt(t.substr(u3 * 2, 2), 16);
        if (X4(s2))
          return u3;
        e[r + u3] = s2;
      }
      return u3;
    }
    function zt(e, t, r, i) {
      return M3(j5(t, e.length - r), e, r, i);
    }
    function Kt(e, t, r, i) {
      return M3(sr(t), e, r, i);
    }
    function Zt(e, t, r, i) {
      return M3(dt2(t), e, r, i);
    }
    function Qt(e, t, r, i) {
      return M3(fr(t, e.length - r), e, r, i);
    }
    h5.prototype.write = function(t, r, i, n) {
      if (r === undefined)
        n = "utf8", i = this.length, r = 0;
      else if (i === undefined && typeof r == "string")
        n = r, i = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(i) ? (i = i >>> 0, n === undefined && (n = "utf8")) : (n = i, i = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((i === undefined || i > o2) && (i = o2), t.length > 0 && (i < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      let u3 = false;
      for (;; )
        switch (n) {
          case "hex":
            return Jt(this, t, r, i);
          case "utf8":
          case "utf-8":
            return zt(this, t, r, i);
          case "ascii":
          case "latin1":
          case "binary":
            return Kt(this, t, r, i);
          case "base64":
            return Zt(this, t, r, i);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Qt(this, t, r, i);
          default:
            if (u3)
              throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), u3 = true;
        }
    };
    h5.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function vt2(e, t, r) {
      return t === 0 && r === e.length ? G2.fromByteArray(e) : G2.fromByteArray(e.slice(t, r));
    }
    function ct3(e, t, r) {
      r = Math.min(e.length, r);
      let i = [], n = t;
      for (;n < r; ) {
        let o2 = e[n], u3 = null, s2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (n + s2 <= r) {
          let f3, l3, a3, c2;
          switch (s2) {
            case 1:
              o2 < 128 && (u3 = o2);
              break;
            case 2:
              f3 = e[n + 1], (f3 & 192) === 128 && (c2 = (o2 & 31) << 6 | f3 & 63, c2 > 127 && (u3 = c2));
              break;
            case 3:
              f3 = e[n + 1], l3 = e[n + 2], (f3 & 192) === 128 && (l3 & 192) === 128 && (c2 = (o2 & 15) << 12 | (f3 & 63) << 6 | l3 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (u3 = c2));
              break;
            case 4:
              f3 = e[n + 1], l3 = e[n + 2], a3 = e[n + 3], (f3 & 192) === 128 && (l3 & 192) === 128 && (a3 & 192) === 128 && (c2 = (o2 & 15) << 18 | (f3 & 63) << 12 | (l3 & 63) << 6 | a3 & 63, c2 > 65535 && c2 < 1114112 && (u3 = c2));
          }
        }
        u3 === null ? (u3 = 65533, s2 = 1) : u3 > 65535 && (u3 -= 65536, i.push(u3 >>> 10 & 1023 | 55296), u3 = 56320 | u3 & 1023), i.push(u3), n += s2;
      }
      return tr(i);
    }
    var nt3 = 4096;
    function tr(e) {
      let t = e.length;
      if (t <= nt3)
        return String.fromCharCode.apply(String, e);
      let r = "", i = 0;
      for (;i < t; )
        r += String.fromCharCode.apply(String, e.slice(i, i += nt3));
      return r;
    }
    function rr2(e, t, r) {
      let i = "";
      r = Math.min(e.length, r);
      for (let n = t;n < r; ++n)
        i += String.fromCharCode(e[n] & 127);
      return i;
    }
    function er(e, t, r) {
      let i = "";
      r = Math.min(e.length, r);
      for (let n = t;n < r; ++n)
        i += String.fromCharCode(e[n]);
      return i;
    }
    function ir(e, t, r) {
      let i = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
      let n = "";
      for (let o2 = t;o2 < r; ++o2)
        n += cr[e[o2]];
      return n;
    }
    function nr(e, t, r) {
      let i = e.slice(t, r), n = "";
      for (let o2 = 0;o2 < i.length - 1; o2 += 2)
        n += String.fromCharCode(i[o2] + i[o2 + 1] * 256);
      return n;
    }
    h5.prototype.slice = function(t, r) {
      let i = this.length;
      t = ~~t, r = r === undefined ? i : ~~r, t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < t && (r = t);
      let n = this.subarray(t, r);
      return Object.setPrototypeOf(n, h5.prototype), n;
    };
    function p3(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h5.prototype.readUintLE = h5.prototype.readUIntLE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p3(t, r, this.length);
      let n = this[t], o2 = 1, u3 = 0;
      for (;++u3 < r && (o2 *= 256); )
        n += this[t + u3] * o2;
      return n;
    };
    h5.prototype.readUintBE = h5.prototype.readUIntBE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p3(t, r, this.length);
      let n = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        n += this[t + --r] * o2;
      return n;
    };
    h5.prototype.readUint8 = h5.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || p3(t, 1, this.length), this[t];
    };
    h5.prototype.readUint16LE = h5.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || p3(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    h5.prototype.readUint16BE = h5.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || p3(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    h5.prototype.readUint32LE = h5.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || p3(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    h5.prototype.readUint32BE = h5.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || p3(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    h5.prototype.readBigUInt64LE = m3(function(t) {
      t = t >>> 0, N6(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _4(t, this.length - 8);
      let n = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + i * 2 ** 24;
      return BigInt(n) + (BigInt(o2) << BigInt(32));
    });
    h5.prototype.readBigUInt64BE = m3(function(t) {
      t = t >>> 0, N6(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _4(t, this.length - 8);
      let n = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i;
      return (BigInt(n) << BigInt(32)) + BigInt(o2);
    });
    h5.prototype.readIntLE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p3(t, r, this.length);
      let n = this[t], o2 = 1, u3 = 0;
      for (;++u3 < r && (o2 *= 256); )
        n += this[t + u3] * o2;
      return o2 *= 128, n >= o2 && (n -= Math.pow(2, 8 * r)), n;
    };
    h5.prototype.readIntBE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p3(t, r, this.length);
      let n = r, o2 = 1, u3 = this[t + --n];
      for (;n > 0 && (o2 *= 256); )
        u3 += this[t + --n] * o2;
      return o2 *= 128, u3 >= o2 && (u3 -= Math.pow(2, 8 * r)), u3;
    };
    h5.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || p3(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    h5.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || p3(t, 2, this.length);
      let i = this[t] | this[t + 1] << 8;
      return i & 32768 ? i | 4294901760 : i;
    };
    h5.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || p3(t, 2, this.length);
      let i = this[t + 1] | this[t] << 8;
      return i & 32768 ? i | 4294901760 : i;
    };
    h5.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || p3(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    h5.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || p3(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    h5.prototype.readBigInt64LE = m3(function(t) {
      t = t >>> 0, N6(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _4(t, this.length - 8);
      let n = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (i << 24);
      return (BigInt(n) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    h5.prototype.readBigInt64BE = m3(function(t) {
      t = t >>> 0, N6(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _4(t, this.length - 8);
      let n = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(n) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i);
    });
    h5.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || p3(t, 4, this.length), T3.read(this, t, true, 23, 4);
    };
    h5.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || p3(t, 4, this.length), T3.read(this, t, false, 23, 4);
    };
    h5.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || p3(t, 8, this.length), T3.read(this, t, true, 52, 8);
    };
    h5.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || p3(t, 8, this.length), T3.read(this, t, false, 52, 8);
    };
    function y5(e, t, r, i, n, o2) {
      if (!h5.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > n || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + i > e.length)
        throw new RangeError("Index out of range");
    }
    h5.prototype.writeUintLE = h5.prototype.writeUIntLE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
        let s2 = Math.pow(2, 8 * i) - 1;
        y5(this, t, r, i, s2, 0);
      }
      let o2 = 1, u3 = 0;
      for (this[r] = t & 255;++u3 < i && (o2 *= 256); )
        this[r + u3] = t / o2 & 255;
      return r + i;
    };
    h5.prototype.writeUintBE = h5.prototype.writeUIntBE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
        let s2 = Math.pow(2, 8 * i) - 1;
        y5(this, t, r, i, s2, 0);
      }
      let o2 = i - 1, u3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (u3 *= 256); )
        this[r + o2] = t / u3 & 255;
      return r + i;
    };
    h5.prototype.writeUint8 = h5.prototype.writeUInt8 = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    h5.prototype.writeUint16LE = h5.prototype.writeUInt16LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    h5.prototype.writeUint16BE = h5.prototype.writeUInt16BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    h5.prototype.writeUint32LE = h5.prototype.writeUInt32LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    h5.prototype.writeUint32BE = h5.prototype.writeUInt32BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function at3(e, t, r, i, n) {
      xt(t, i, n, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let u3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = u3, u3 = u3 >> 8, e[r++] = u3, u3 = u3 >> 8, e[r++] = u3, u3 = u3 >> 8, e[r++] = u3, r;
    }
    function lt3(e, t, r, i, n) {
      xt(t, i, n, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let u3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = u3, u3 = u3 >> 8, e[r + 2] = u3, u3 = u3 >> 8, e[r + 1] = u3, u3 = u3 >> 8, e[r] = u3, r + 8;
    }
    h5.prototype.writeBigUInt64LE = m3(function(t, r = 0) {
      return at3(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h5.prototype.writeBigUInt64BE = m3(function(t, r = 0) {
      return lt3(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h5.prototype.writeIntLE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, !n) {
        let f3 = Math.pow(2, 8 * i - 1);
        y5(this, t, r, i, f3 - 1, -f3);
      }
      let o2 = 0, u3 = 1, s2 = 0;
      for (this[r] = t & 255;++o2 < i && (u3 *= 256); )
        t < 0 && s2 === 0 && this[r + o2 - 1] !== 0 && (s2 = 1), this[r + o2] = (t / u3 >> 0) - s2 & 255;
      return r + i;
    };
    h5.prototype.writeIntBE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, !n) {
        let f3 = Math.pow(2, 8 * i - 1);
        y5(this, t, r, i, f3 - 1, -f3);
      }
      let o2 = i - 1, u3 = 1, s2 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (u3 *= 256); )
        t < 0 && s2 === 0 && this[r + o2 + 1] !== 0 && (s2 = 1), this[r + o2] = (t / u3 >> 0) - s2 & 255;
      return r + i;
    };
    h5.prototype.writeInt8 = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    h5.prototype.writeInt16LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    h5.prototype.writeInt16BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    h5.prototype.writeInt32LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    h5.prototype.writeInt32BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y5(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    h5.prototype.writeBigInt64LE = m3(function(t, r = 0) {
      return at3(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h5.prototype.writeBigInt64BE = m3(function(t, r = 0) {
      return lt3(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function pt3(e, t, r, i, n, o2) {
      if (r + i > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function yt2(e, t, r, i, n) {
      return t = +t, r = r >>> 0, n || pt3(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T3.write(e, t, r, i, 23, 4), r + 4;
    }
    h5.prototype.writeFloatLE = function(t, r, i) {
      return yt2(this, t, r, true, i);
    };
    h5.prototype.writeFloatBE = function(t, r, i) {
      return yt2(this, t, r, false, i);
    };
    function wt(e, t, r, i, n) {
      return t = +t, r = r >>> 0, n || pt3(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T3.write(e, t, r, i, 52, 8), r + 8;
    }
    h5.prototype.writeDoubleLE = function(t, r, i) {
      return wt(this, t, r, true, i);
    };
    h5.prototype.writeDoubleBE = function(t, r, i) {
      return wt(this, t, r, false, i);
    };
    h5.prototype.copy = function(t, r, i, n) {
      if (!h5.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (i < 0 || i >= this.length)
        throw new RangeError("Index out of range");
      if (n < 0)
        throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), t.length - r < n - i && (n = t.length - r + i);
      let o2 = n - i;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, i, n) : Uint8Array.prototype.set.call(t, this.subarray(i, n), r), o2;
    };
    h5.prototype.fill = function(t, r, i, n) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== undefined && typeof n != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n == "string" && !h5.isEncoding(n))
          throw new TypeError("Unknown encoding: " + n);
        if (t.length === 1) {
          let u3 = t.charCodeAt(0);
          (n === "utf8" && u3 < 128 || n === "latin1") && (t = u3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < i)
        throw new RangeError("Out of range index");
      if (i <= r)
        return this;
      r = r >>> 0, i = i === undefined ? this.length : i >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < i; ++o2)
          this[o2] = t;
      else {
        let u3 = h5.isBuffer(t) ? t : h5.from(t, n), s2 = u3.length;
        if (s2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < i - r; ++o2)
          this[o2 + r] = u3[o2 % s2];
      }
      return this;
    };
    var C3 = {};
    function V5(e, t, r) {
      C3[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(n) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    V5("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V5("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    V5("ERR_OUT_OF_RANGE", function(e, t, r) {
      let i = `The value of "${e}" is out of range.`, n = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = ot3(String(r)) : typeof r == "bigint" && (n = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (n = ot3(n)), n += "n"), i += ` It must be ${t}. Received ${n}`, i;
    }, RangeError);
    function ot3(e) {
      let t = "", r = e.length, i = e[0] === "-" ? 1 : 0;
      for (;r >= i + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function or(e, t, r) {
      N6(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && _4(t, e.length - (r + 1));
    }
    function xt(e, t, r, i, n, o2) {
      if (e > r || e < t) {
        let u3 = typeof t == "bigint" ? "n" : "", s2;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? s2 = `>= 0${u3} and < 2${u3} ** ${(o2 + 1) * 8}${u3}` : s2 = `>= -(2${u3} ** ${(o2 + 1) * 8 - 1}${u3}) and < 2 ** ${(o2 + 1) * 8 - 1}${u3}` : s2 = `>= ${t}${u3} and <= ${r}${u3}`, new C3.ERR_OUT_OF_RANGE("value", s2, e);
      }
      or(i, n, o2);
    }
    function N6(e, t) {
      if (typeof e != "number")
        throw new C3.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function _4(e, t, r) {
      throw Math.floor(e) !== e ? (N6(e, r), new C3.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new C3.ERR_BUFFER_OUT_OF_BOUNDS : new C3.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var ur = /[^+/0-9A-Za-z-_]/g;
    function hr(e) {
      if (e = e.split("=")[0], e = e.trim().replace(ur, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function j5(e, t) {
      t = t || 1 / 0;
      let r, i = e.length, n = null, o2 = [];
      for (let u3 = 0;u3 < i; ++u3) {
        if (r = e.charCodeAt(u3), r > 55295 && r < 57344) {
          if (!n) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (u3 + 1 === i) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            n = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), n = r;
            continue;
          }
          r = (n - 55296 << 10 | r - 56320) + 65536;
        } else
          n && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (n = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function sr(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function fr(e, t) {
      let r, i, n, o2 = [];
      for (let u3 = 0;u3 < e.length && !((t -= 2) < 0); ++u3)
        r = e.charCodeAt(u3), i = r >> 8, n = r % 256, o2.push(n), o2.push(i);
      return o2;
    }
    function dt2(e) {
      return G2.toByteArray(hr(e));
    }
    function M3(e, t, r, i) {
      let n;
      for (n = 0;n < i && !(n + r >= t.length || n >= e.length); ++n)
        t[n + r] = e[n];
      return n;
    }
    function B3(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function X4(e) {
      return e !== e;
    }
    var cr = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let i = r * 16;
        for (let n = 0;n < 16; ++n)
          t[i + n] = e[r] + e[n];
      }
      return t;
    }();
    function m3(e) {
      return typeof BigInt > "u" ? ar : e;
    }
    function ar() {
      throw new Error("BigInt not supported");
    }
  });
  mt2 = R3((J2, Et) => {
    var $3 = Bt(), g5 = $3.Buffer;
    function gt2(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    g5.from && g5.alloc && g5.allocUnsafe && g5.allocUnsafeSlow ? Et.exports = $3 : (gt2($3, J2), J2.Buffer = A4);
    function A4(e, t, r) {
      return g5(e, t, r);
    }
    A4.prototype = Object.create(g5.prototype);
    gt2(g5, A4);
    A4.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return g5(e, t, r);
    };
    A4.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var i = g5(e);
      return t !== undefined ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
    };
    A4.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return g5(e);
    };
    A4.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return $3.SlowBuffer(e);
    };
  });
  At2 = R3((Ft) => {
    var K3 = mt2().Buffer, It = K3.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function lr(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function pr(e) {
      var t = lr(e);
      if (typeof t != "string" && (K3.isEncoding === It || !It(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    Ft.StringDecoder = L4;
    function L4(e) {
      this.encoding = pr(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = gr3, this.end = Er2, t = 4;
          break;
        case "utf8":
          this.fillLast = xr, t = 4;
          break;
        case "base64":
          this.text = mr2, this.end = Ir3, t = 3;
          break;
        default:
          this.write = Fr3, this.end = Ar2;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = K3.allocUnsafe(t);
    }
    L4.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    L4.prototype.end = Br3;
    L4.prototype.text = dr2;
    L4.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function z(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function yr(e, t, r) {
      var i = t.length - 1;
      if (i < r)
        return 0;
      var n = z(t[i]);
      return n >= 0 ? (n > 0 && (e.lastNeed = n - 1), n) : --i < r || n === -2 ? 0 : (n = z(t[i]), n >= 0 ? (n > 0 && (e.lastNeed = n - 2), n) : --i < r || n === -2 ? 0 : (n = z(t[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : e.lastNeed = n - 3), n) : 0));
    }
    function wr(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function xr(e) {
      var t = this.lastTotal - this.lastNeed, r = wr(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function dr2(e, t) {
      var r = yr(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var i = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, i), e.toString("utf8", t, i);
    }
    function Br3(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function gr3(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var i = r.charCodeAt(r.length - 1);
          if (i >= 55296 && i <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Er2(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function mr2(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Ir3(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Fr3(e) {
      return e.toString(this.encoding);
    }
    function Ar2(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Ut = kt(At2());
  export_StringDecoder = Ut.StringDecoder;
  export_default2 = Ut.StringDecoder;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/winston/dist/winston/tail-file.js
var require_tail_file = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var _require = (init_string_decoder(), __toCommonJS(exports_string_decoder));
  var StringDecoder = _require.StringDecoder;
  var _require2 = require_readable_browser();
  var Stream = _require2.Stream;
  function noop() {
  }
  module.exports = function(options, iter) {
    var buffer2 = Buffer.alloc(64 * 1024);
    var decode = new StringDecoder("utf8");
    var stream = new Stream;
    var buff = "";
    var pos = 0;
    var row = 0;
    if (options.start === -1) {
      delete options.start;
    }
    stream.readable = true;
    stream.destroy = function() {
      stream.destroyed = true;
      stream.emit("end");
      stream.emit("close");
    };
    fs.open(options.file, "a+", "0644", function(err, fd) {
      if (err) {
        if (!iter) {
          stream.emit("error", err);
        } else {
          iter(err);
        }
        stream.destroy();
        return;
      }
      (function read() {
        if (stream.destroyed) {
          fs.close(fd, noop);
          return;
        }
        return fs.read(fd, buffer2, 0, buffer2.length, pos, function(error, bytes) {
          if (error) {
            if (!iter) {
              stream.emit("error", error);
            } else {
              iter(error);
            }
            stream.destroy();
            return;
          }
          if (!bytes) {
            if (buff) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", buff);
                } else {
                  iter(null, buff);
                }
              }
              row++;
              buff = "";
            }
            return setTimeout(read, 1000);
          }
          var data = decode.write(buffer2.slice(0, bytes));
          if (!iter) {
            stream.emit("data", data);
          }
          data = (buff + data).split(/\n+/);
          var l3 = data.length - 1;
          var i = 0;
          for (;i < l3; i++) {
            if (options.start == null || row > options.start) {
              if (!iter) {
                stream.emit("line", data[i]);
              } else {
                iter(null, data[i]);
              }
            }
            row++;
          }
          buff = data[l3];
          pos += bytes;
          return read();
        });
      })();
    });
    if (!iter) {
      return stream;
    }
    return stream.destroy;
  };
});

// node_modules/winston/dist/winston/transports/file.js
var require_file = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var fs = (() => ({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var asyncSeries = require_series();
  var zlib = (init_zlib(), __toCommonJS(exports_zlib));
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  var _require2 = require_readable_browser();
  var Stream = _require2.Stream;
  var PassThrough = _require2.PassThrough;
  var TransportStream = require_dist();
  var debug = require_browser3()("winston:file");
  var os = (init_os(), __toCommonJS(exports_os));
  var tailFile = require_tail_file();
  module.exports = /* @__PURE__ */ function(_TransportStream) {
    function File() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, File);
      _this = _callSuper(this, File, [options]);
      _this.name = options.name || "file";
      function throwIf(target) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        args.slice(1).forEach(function(name) {
          if (options[name]) {
            throw new Error("Cannot set ".concat(name, " and ").concat(target, " together"));
          }
        });
      }
      _this._stream = new PassThrough;
      _this._stream.setMaxListeners(30);
      _this._onError = _this._onError.bind(_this);
      if (options.filename || options.dirname) {
        throwIf("filename or dirname", "stream");
        _this._basename = _this.filename = options.filename ? path.basename(options.filename) : "winston.log";
        _this.dirname = options.dirname || path.dirname(options.filename);
        _this.options = options.options || {
          flags: "a"
        };
      } else if (options.stream) {
        console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
        throwIf("stream", "filename", "maxsize");
        _this._dest = _this._stream.pipe(_this._setupStream(options.stream));
        _this.dirname = path.dirname(_this._dest.path);
      } else {
        throw new Error("Cannot log to file without filename or stream.");
      }
      _this.maxsize = options.maxsize || null;
      _this.rotationFormat = options.rotationFormat || false;
      _this.zippedArchive = options.zippedArchive || false;
      _this.maxFiles = options.maxFiles || null;
      _this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      _this.tailable = options.tailable || false;
      _this.lazy = options.lazy || false;
      _this._size = 0;
      _this._pendingSize = 0;
      _this._created = 0;
      _this._drain = false;
      _this._opening = false;
      _this._ending = false;
      _this._fileExist = false;
      if (_this.dirname)
        _this._createLogDirIfNotExist(_this.dirname);
      if (!_this.lazy)
        _this.open();
      return _this;
    }
    _inherits(File, _TransportStream);
    return _createClass(File, [{
      key: "finishIfEnding",
      value: function finishIfEnding() {
        var _this2 = this;
        if (this._ending) {
          if (this._opening) {
            this.once("open", function() {
              _this2._stream.once("finish", function() {
                return _this2.emit("finish");
              });
              setImmediate(function() {
                return _this2._stream.end();
              });
            });
          } else {
            this._stream.once("finish", function() {
              return _this2.emit("finish");
            });
            setImmediate(function() {
              return _this2._stream.end();
            });
          }
        }
      }
    }, {
      key: "log",
      value: function log(info) {
        var _this3 = this;
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function() {
        };
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", function() {
            _this3._drain = false;
            _this3.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", function() {
            _this3._rotate = false;
            _this3.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", function() {
              _this3._fileExist = true;
              _this3.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", function() {
              if (!_this3._opening) {
                _this3.open();
              }
              _this3.once("open", function() {
                _this3.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        var output = "".concat(info[MESSAGE]).concat(this.eol);
        var bytes = Buffer.byteLength(output);
        function logged() {
          var _this4 = this;
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(function() {
              _this4.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(function() {
            return _this4._rotateFile();
          });
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        var written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", function() {
            _this3._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
    }, {
      key: "query",
      value: function query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        var file = path.join(this.dirname, this.filename);
        var buff = "";
        var results = [];
        var row = 0;
        var stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", function(err) {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", function(data) {
          data = (buff + data).split(/\n+/);
          var l3 = data.length - 1;
          var i = 0;
          for (;i < l3; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l3];
        });
        stream.on("close", function() {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            var log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce(function(obj, key) {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (_typeof(log) !== "object") {
            return;
          }
          var time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || new Date;
          if (_typeof(options2.until) !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1000;
          if (_typeof(options2.from) !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
    }, {
      key: "stream",
      value: function stream() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var file = path.join(this.dirname, this.filename);
        var stream = new Stream;
        var tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, function(err, line) {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
    }, {
      key: "open",
      value: function open() {
        var _this5 = this;
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat(function(err, size4) {
          if (err) {
            return _this5.emit("error", err);
          }
          debug("stat done: %s { size: %s }", _this5.filename, size4);
          _this5._size = size4;
          _this5._dest = _this5._createStream(_this5._stream);
          _this5._opening = false;
          _this5.once("open", function() {
            if (!_this5._stream.emit("rotate")) {
              _this5._rotate = false;
            }
          });
        });
      }
    }, {
      key: "stat",
      value: function stat(callback) {
        var _this6 = this;
        var target = this._getFile();
        var fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, function(err, stat) {
          if (err && err.code === "ENOENT") {
            debug("ENOENT ok", fullpath);
            _this6.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug("err ".concat(err.code, " ").concat(fullpath));
            return callback(err);
          }
          if (!stat || _this6._needsNewFile(stat.size)) {
            return _this6._incFile(function() {
              return _this6.stat(callback);
            });
          }
          _this6.filename = target;
          callback(null, stat.size);
        });
      }
    }, {
      key: "close",
      value: function close(cb) {
        var _this7 = this;
        if (!this._stream) {
          return;
        }
        this._stream.end(function() {
          if (cb) {
            cb();
          }
          _this7.emit("flush");
          _this7.emit("closed");
        });
      }
    }, {
      key: "_needsNewFile",
      value: function _needsNewFile(size4) {
        size4 = size4 || this._size;
        return this.maxsize && size4 >= this.maxsize;
      }
    }, {
      key: "_onError",
      value: function _onError(err) {
        this.emit("error", err);
      }
    }, {
      key: "_setupStream",
      value: function _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
    }, {
      key: "_cleanupStream",
      value: function _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
    }, {
      key: "_rotateFile",
      value: function _rotateFile() {
        var _this8 = this;
        this._incFile(function() {
          return _this8.open();
        });
      }
    }, {
      key: "_endStream",
      value: function _endStream() {
        var _this9 = this;
        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function() {
        };
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(function() {
            _this9._cleanupStream(_this9._dest);
            callback();
          });
        } else {
          callback();
        }
      }
    }, {
      key: "_createStream",
      value: function _createStream(source) {
        var _this10 = this;
        var fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        var dest = fs.createWriteStream(fullpath, this.options).on("error", function(err) {
          return debug(err);
        }).on("close", function() {
          return debug("close", dest.path, dest.bytesWritten);
        }).on("open", function() {
          debug("file open ok", fullpath);
          _this10.emit("open", fullpath);
          source.pipe(dest);
          if (_this10.rotatedWhileOpening) {
            _this10._stream = new PassThrough;
            _this10._stream.setMaxListeners(30);
            _this10._rotateFile();
            _this10.rotatedWhileOpening = false;
            _this10._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        return dest;
      }
    }, {
      key: "_incFile",
      value: function _incFile(callback) {
        debug("_incFile", this.filename);
        var ext = path.extname(this._basename);
        var basename = path.basename(this._basename, ext);
        var tasks = [];
        if (this.zippedArchive) {
          tasks.push(function(cb) {
            var num2 = this._created > 0 && !this.tailable ? this._created : "";
            this._compressFile(path.join(this.dirname, "".concat(basename).concat(num2).concat(ext)), path.join(this.dirname, "".concat(basename).concat(num2).concat(ext, ".gz")), cb);
          }.bind(this));
        }
        tasks.push(function(cb) {
          if (!this.tailable) {
            this._created += 1;
            this._checkMaxFilesIncrementing(ext, basename, cb);
          } else {
            this._checkMaxFilesTailable(ext, basename, cb);
          }
        }.bind(this));
        asyncSeries(tasks, callback);
      }
    }, {
      key: "_getFile",
      value: function _getFile() {
        var ext = path.extname(this._basename);
        var basename = path.basename(this._basename, ext);
        var isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? "".concat(basename).concat(isRotation).concat(ext) : "".concat(basename).concat(ext);
      }
    }, {
      key: "_checkMaxFilesIncrementing",
      value: function _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        var oldest = this._created - this.maxFiles;
        var isOldest = oldest !== 0 ? oldest : "";
        var isZipped = this.zippedArchive ? ".gz" : "";
        var filePath = "".concat(basename).concat(isOldest).concat(ext).concat(isZipped);
        var target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
    }, {
      key: "_checkMaxFilesTailable",
      value: function _checkMaxFilesTailable(ext, basename, callback) {
        var _this12 = this;
        var tasks = [];
        if (!this.maxFiles) {
          return;
        }
        var isZipped = this.zippedArchive ? ".gz" : "";
        for (var x5 = this.maxFiles - 1;x5 > 1; x5--) {
          tasks.push(function(i, cb) {
            var _this11 = this;
            var fileName = "".concat(basename).concat(i - 1).concat(ext).concat(isZipped);
            var tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, function(exists) {
              if (!exists) {
                return cb(null);
              }
              fileName = "".concat(basename).concat(i).concat(ext).concat(isZipped);
              fs.rename(tmppath, path.join(_this11.dirname, fileName), cb);
            });
          }.bind(this, x5));
        }
        asyncSeries(tasks, function() {
          fs.rename(path.join(_this12.dirname, "".concat(basename).concat(ext).concat(isZipped)), path.join(_this12.dirname, "".concat(basename, "1").concat(ext).concat(isZipped)), callback);
        });
      }
    }, {
      key: "_compressFile",
      value: function _compressFile(src, dest, callback) {
        fs.access(src, fs.F_OK, function(err) {
          if (err) {
            return callback();
          }
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(src);
          var out = fs.createWriteStream(dest);
          out.on("finish", function() {
            fs.unlink(src, callback);
          });
          inp.pipe(gzip).pipe(out);
        });
      }
    }, {
      key: "_createLogDirIfNotExist",
      value: function _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, {
            recursive: true
          });
        }
      }
    }]);
  }(TransportStream);
});

// node:http
var exports_http = {};
__export(exports_http, {
  request: () => ou,
  globalAgent: () => lu,
  get: () => au,
  default: () => iu,
  STATUS_CODES: () => hu,
  METHODS: () => cu,
  IncomingMessage: () => fu,
  ClientRequest: () => su,
  Agent: () => uu
});
function oe(e) {
  throw new RangeError($s[e]);
}
function Gs(e, t) {
  let r = [], n = e.length;
  for (;n--; )
    r[n] = t(e[n]);
  return r;
}
function yi(e, t) {
  let r = e.split("@"), n = "";
  r.length > 1 && (n = r[0] + "@", e = r[1]), e = e.replace(Ws, ".");
  let i = e.split("."), o2 = Gs(i, t).join(".");
  return n + o2;
}
function dr2(e) {
  let t = [], r = 0, n = e.length;
  for (;r < n; ) {
    let i = e.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      let o2 = e.charCodeAt(r++);
      (o2 & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o2 & 1023) + 65536) : (t.push(i), r--);
    } else
      t.push(i);
  }
  return t;
}
var Gi, ke, Ki, Vi, Yi, Xi, vr = (e, t) => () => (e && (t = e(e = 0)), t), b4 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Er2 = (e, t) => {
  for (var r in t)
    ke(e, r, { get: t[r], enumerable: true });
}, xr = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Vi(t))
      !Xi.call(e, i) && i !== r && ke(e, i, { get: () => t[i], enumerable: !(n = Ki(t, i)) || n.enumerable });
  return e;
}, Rr2 = (e, t, r) => (r = e != null ? Gi(Yi(e)) : {}, xr(t || !e || !e.__esModule ? ke(r, "default", { value: e, enumerable: true }) : r, e)), dt2 = (e) => xr(ke({}, "__esModule", { value: true }), e), gt2, Q3, bt2, _t2, qr, Dr, _e, Lt2, an, Ft, fe, Nt2, pn, Dt, ue, Sn, Bn2, Kt, Qe, Vt, et, On, Nn, Ht, ir, zn, ti, ar, ur, fi, li, ci, _i, pi, js, Hs, Ws, $s, hr, K3, cr, gi2, Ks, di, wi2, pr, yr, mi, bi, Vs, Ys, vi, xi, Si2, Ni, Di, Hi, _r, iu, ou, au, su, fu, uu, lu, hu, cu;
var init_http = __esm(() => {
  Gi = Object.create;
  ke = Object.defineProperty;
  Ki = Object.getOwnPropertyDescriptor;
  Vi = Object.getOwnPropertyNames;
  Yi = Object.getPrototypeOf;
  Xi = Object.prototype.hasOwnProperty;
  gt2 = b4((N6) => {
    N6.fetch = Ce2(global.fetch) && Ce2(global.ReadableStream);
    N6.writableStream = Ce2(global.WritableStream);
    N6.abortController = Ce2(global.AbortController);
    var J2;
    function pt3() {
      if (J2 !== undefined)
        return J2;
      if (global.XMLHttpRequest) {
        J2 = new global.XMLHttpRequest;
        try {
          J2.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch {
          J2 = null;
        }
      } else
        J2 = null;
      return J2;
    }
    function yt2(e) {
      var t = pt3();
      if (!t)
        return false;
      try {
        return t.responseType = e, t.responseType === e;
      } catch {
      }
      return false;
    }
    N6.arraybuffer = N6.fetch || yt2("arraybuffer");
    N6.msstream = !N6.fetch && yt2("ms-stream");
    N6.mozchunkedarraybuffer = !N6.fetch && yt2("moz-chunked-arraybuffer");
    N6.overrideMimeType = N6.fetch || (pt3() ? Ce2(pt3().overrideMimeType) : false);
    function Ce2(e) {
      return typeof e == "function";
    }
    J2 = null;
  });
  Q3 = b4((Rf, wt) => {
    typeof Object.create == "function" ? wt.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : wt.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {
        };
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  bt2 = b4((Sf2, mt3) => {
    var ye2 = typeof Reflect == "object" ? Reflect : null, Sr = ye2 && typeof ye2.apply == "function" ? ye2.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, je;
    ye2 && typeof ye2.ownKeys == "function" ? je = ye2.ownKeys : Object.getOwnPropertySymbols ? je = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : je = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function zi(e) {
      console && console.warn && console.warn(e);
    }
    var Ar2 = Number.isNaN || function(t) {
      return t !== t;
    };
    function x5() {
      x5.init.call(this);
    }
    mt3.exports = x5;
    mt3.exports.once = eo;
    x5.EventEmitter = x5;
    x5.prototype._events = undefined;
    x5.prototype._eventsCount = 0;
    x5.prototype._maxListeners = undefined;
    var Tr = 10;
    function He(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(x5, "defaultMaxListeners", { enumerable: true, get: function() {
      return Tr;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || Ar2(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Tr = e;
    } });
    x5.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    x5.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || Ar2(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Br3(e) {
      return e._maxListeners === undefined ? x5.defaultMaxListeners : e._maxListeners;
    }
    x5.prototype.getMaxListeners = function() {
      return Br3(this);
    };
    x5.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a3;
        if (r.length > 0 && (a3 = r[0]), a3 instanceof Error)
          throw a3;
        var s2 = new Error("Unhandled error." + (a3 ? " (" + a3.message + ")" : ""));
        throw s2.context = a3, s2;
      }
      var u3 = o2[t];
      if (u3 === undefined)
        return false;
      if (typeof u3 == "function")
        Sr(u3, this, r);
      else
        for (var l3 = u3.length, h5 = Or(u3, l3), n = 0;n < l3; ++n)
          Sr(h5[n], this, r);
      return true;
    };
    function Cr(e, t, r, n) {
      var i, o2, a3;
      if (He(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), a3 = o2[t]), a3 === undefined)
        a3 = o2[t] = r, ++e._eventsCount;
      else if (typeof a3 == "function" ? a3 = o2[t] = n ? [r, a3] : [a3, r] : n ? a3.unshift(r) : a3.push(r), i = Br3(e), i > 0 && a3.length > i && !a3.warned) {
        a3.warned = true;
        var s2 = new Error("Possible EventEmitter memory leak detected. " + a3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s2.name = "MaxListenersExceededWarning", s2.emitter = e, s2.type = t, s2.count = a3.length, zi(s2);
      }
      return e;
    }
    x5.prototype.addListener = function(t, r) {
      return Cr(this, t, r, false);
    };
    x5.prototype.on = x5.prototype.addListener;
    x5.prototype.prependListener = function(t, r) {
      return Cr(this, t, r, true);
    };
    function Zi() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ir3(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = Zi.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    x5.prototype.once = function(t, r) {
      return He(r), this.on(t, Ir3(this, t, r)), this;
    };
    x5.prototype.prependOnceListener = function(t, r) {
      return He(r), this.prependListener(t, Ir3(this, t, r)), this;
    };
    x5.prototype.removeListener = function(t, r) {
      var n, i, o2, a3, s2;
      if (He(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, a3 = n.length - 1;a3 >= 0; a3--)
          if (n[a3] === r || n[a3].listener === r) {
            s2 = n[a3].listener, o2 = a3;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : Ji(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, s2 || r);
      }
      return this;
    };
    x5.prototype.off = x5.prototype.removeListener;
    x5.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), a3;
        for (i = 0;i < o2.length; ++i)
          a3 = o2[i], a3 !== "removeListener" && this.removeAllListeners(a3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Lr(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? Qi(i) : Or(i, i.length);
    }
    x5.prototype.listeners = function(t) {
      return Lr(this, t, true);
    };
    x5.prototype.rawListeners = function(t) {
      return Lr(this, t, false);
    };
    x5.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Mr.call(e, t);
    };
    x5.prototype.listenerCount = Mr;
    function Mr(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    x5.prototype.eventNames = function() {
      return this._eventsCount > 0 ? je(this._events) : [];
    };
    function Or(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function Ji(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function Qi(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function eo(e, t) {
      return new Promise(function(r, n) {
        function i(a3) {
          e.removeListener(t, o2), n(a3);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        Fr3(e, t, o2, { once: true }), t !== "error" && to(e, i, { once: true });
      });
    }
    function to(e, t, r) {
      typeof e.on == "function" && Fr3(e, "error", t, r);
    }
    function Fr3(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  _t2 = b4((Tf, Nr) => {
    Nr.exports = bt2().EventEmitter;
  });
  qr = b4((We) => {
    We.byteLength = no;
    We.toByteArray = oo;
    We.fromByteArray = fo;
    var H3 = [], U3 = [], ro = typeof Uint8Array < "u" ? Uint8Array : Array, vt2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ae = 0, Ur4 = vt2.length;ae < Ur4; ++ae)
      H3[ae] = vt2[ae], U3[vt2.charCodeAt(ae)] = ae;
    var ae, Ur4;
    U3[45] = 62;
    U3[95] = 63;
    function Pr(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function no(e) {
      var t = Pr(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function io(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function oo(e) {
      var t, r = Pr(e), n = r[0], i = r[1], o2 = new ro(io(e, n, i)), a3 = 0, s2 = i > 0 ? n - 4 : n, u3;
      for (u3 = 0;u3 < s2; u3 += 4)
        t = U3[e.charCodeAt(u3)] << 18 | U3[e.charCodeAt(u3 + 1)] << 12 | U3[e.charCodeAt(u3 + 2)] << 6 | U3[e.charCodeAt(u3 + 3)], o2[a3++] = t >> 16 & 255, o2[a3++] = t >> 8 & 255, o2[a3++] = t & 255;
      return i === 2 && (t = U3[e.charCodeAt(u3)] << 2 | U3[e.charCodeAt(u3 + 1)] >> 4, o2[a3++] = t & 255), i === 1 && (t = U3[e.charCodeAt(u3)] << 10 | U3[e.charCodeAt(u3 + 1)] << 4 | U3[e.charCodeAt(u3 + 2)] >> 2, o2[a3++] = t >> 8 & 255, o2[a3++] = t & 255), o2;
    }
    function ao(e) {
      return H3[e >> 18 & 63] + H3[e >> 12 & 63] + H3[e >> 6 & 63] + H3[e & 63];
    }
    function so2(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(ao(n));
      return i.join("");
    }
    function fo(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, a3 = 0, s2 = r - n;a3 < s2; a3 += o2)
        i.push(so2(e, a3, a3 + o2 > s2 ? s2 : a3 + o2));
      return n === 1 ? (t = e[r - 1], i.push(H3[t >> 2] + H3[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(H3[t >> 10] + H3[t >> 4 & 63] + H3[t << 2 & 63] + "=")), i.join("");
    }
  });
  Dr = b4((Et) => {
    Et.read = function(e, t, r, n, i) {
      var o2, a3, s2 = i * 8 - n - 1, u3 = (1 << s2) - 1, l3 = u3 >> 1, h5 = -7, c2 = r ? i - 1 : 0, d4 = r ? -1 : 1, p3 = e[t + c2];
      for (c2 += d4, o2 = p3 & (1 << -h5) - 1, p3 >>= -h5, h5 += s2;h5 > 0; o2 = o2 * 256 + e[t + c2], c2 += d4, h5 -= 8)
        ;
      for (a3 = o2 & (1 << -h5) - 1, o2 >>= -h5, h5 += n;h5 > 0; a3 = a3 * 256 + e[t + c2], c2 += d4, h5 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l3;
      else {
        if (o2 === u3)
          return a3 ? NaN : (p3 ? -1 : 1) * (1 / 0);
        a3 = a3 + Math.pow(2, n), o2 = o2 - l3;
      }
      return (p3 ? -1 : 1) * a3 * Math.pow(2, o2 - n);
    };
    Et.write = function(e, t, r, n, i, o2) {
      var a3, s2, u3, l3 = o2 * 8 - i - 1, h5 = (1 << l3) - 1, c2 = h5 >> 1, d4 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p3 = n ? 0 : o2 - 1, g5 = n ? 1 : -1, E5 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s2 = isNaN(t) ? 1 : 0, a3 = h5) : (a3 = Math.floor(Math.log(t) / Math.LN2), t * (u3 = Math.pow(2, -a3)) < 1 && (a3--, u3 *= 2), a3 + c2 >= 1 ? t += d4 / u3 : t += d4 * Math.pow(2, 1 - c2), t * u3 >= 2 && (a3++, u3 /= 2), a3 + c2 >= h5 ? (s2 = 0, a3 = h5) : a3 + c2 >= 1 ? (s2 = (t * u3 - 1) * Math.pow(2, i), a3 = a3 + c2) : (s2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), a3 = 0));i >= 8; e[r + p3] = s2 & 255, p3 += g5, s2 /= 256, i -= 8)
        ;
      for (a3 = a3 << i | s2, l3 += i;l3 > 0; e[r + p3] = a3 & 255, p3 += g5, a3 /= 256, l3 -= 8)
        ;
      e[r + p3 - g5] |= E5 * 128;
    };
  });
  _e = b4((be2) => {
    var xt = qr(), we = Dr(), kr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    be2.Buffer = f3;
    be2.SlowBuffer = yo;
    be2.INSPECT_MAX_BYTES = 50;
    var $e = 2147483647;
    be2.kMaxLength = $e;
    f3.TYPED_ARRAY_SUPPORT = uo();
    !f3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function uo() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(f3.prototype, "parent", { enumerable: true, get: function() {
      if (!!f3.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(f3.prototype, "offset", { enumerable: true, get: function() {
      if (!!f3.isBuffer(this))
        return this.byteOffset;
    } });
    function X4(e) {
      if (e > $e)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, f3.prototype), t;
    }
    function f3(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return At3(e);
      }
      return $r(e, t, r);
    }
    f3.poolSize = 8192;
    function $r(e, t, r) {
      if (typeof e == "string")
        return ho(e, t);
      if (ArrayBuffer.isView(e))
        return co(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (W(e, ArrayBuffer) || e && W(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (W(e, SharedArrayBuffer) || e && W(e.buffer, SharedArrayBuffer)))
        return St2(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return f3.from(n, t, r);
      let i = po(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return f3.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    f3.from = function(e, t, r) {
      return $r(e, t, r);
    };
    Object.setPrototypeOf(f3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(f3, Uint8Array);
    function Gr(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function lo(e, t, r) {
      return Gr(e), e <= 0 ? X4(e) : t !== undefined ? typeof r == "string" ? X4(e).fill(t, r) : X4(e).fill(t) : X4(e);
    }
    f3.alloc = function(e, t, r) {
      return lo(e, t, r);
    };
    function At3(e) {
      return Gr(e), X4(e < 0 ? 0 : Bt2(e) | 0);
    }
    f3.allocUnsafe = function(e) {
      return At3(e);
    };
    f3.allocUnsafeSlow = function(e) {
      return At3(e);
    };
    function ho(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !f3.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = Kr2(e, t) | 0, n = X4(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Rt2(e) {
      let t = e.length < 0 ? 0 : Bt2(e.length) | 0, r = X4(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function co(e) {
      if (W(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return St2(t.buffer, t.byteOffset, t.byteLength);
      }
      return Rt2(e);
    }
    function St2(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, f3.prototype), n;
    }
    function po(e) {
      if (f3.isBuffer(e)) {
        let t = Bt2(e.length) | 0, r = X4(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || It(e.length) ? X4(0) : Rt2(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Rt2(e.data);
    }
    function Bt2(e) {
      if (e >= $e)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $e.toString(16) + " bytes");
      return e | 0;
    }
    function yo(e) {
      return +e != e && (e = 0), f3.alloc(+e);
    }
    f3.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== f3.prototype;
    };
    f3.compare = function(t, r) {
      if (W(t, Uint8Array) && (t = f3.from(t, t.offset, t.byteLength)), W(r, Uint8Array) && (r = f3.from(r, r.offset, r.byteLength)), !f3.isBuffer(t) || !f3.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, a3 = Math.min(n, i);o2 < a3; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    f3.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    f3.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return f3.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = f3.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let a3 = t[n];
        if (W(a3, Uint8Array))
          o2 + a3.length > i.length ? (f3.isBuffer(a3) || (a3 = f3.from(a3)), a3.copy(i, o2)) : Uint8Array.prototype.set.call(i, a3, o2);
        else if (f3.isBuffer(a3))
          a3.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += a3.length;
      }
      return i;
    };
    function Kr2(e, t) {
      if (f3.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || W(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Tt3(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return tn2(e).length;
          default:
            if (i)
              return n ? -1 : Tt3(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    f3.byteLength = Kr2;
    function go(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return To(this, t, r);
          case "utf8":
          case "utf-8":
            return Yr2(this, t, r);
          case "ascii":
            return Ro(this, t, r);
          case "latin1":
          case "binary":
            return So(this, t, r);
          case "base64":
            return Eo(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ao(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    f3.prototype._isBuffer = true;
    function se2(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    f3.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        se2(this, r, r + 1);
      return this;
    };
    f3.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        se2(this, r, r + 3), se2(this, r + 1, r + 2);
      return this;
    };
    f3.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        se2(this, r, r + 7), se2(this, r + 1, r + 6), se2(this, r + 2, r + 5), se2(this, r + 3, r + 4);
      return this;
    };
    f3.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? Yr2(this, 0, t) : go.apply(this, arguments);
    };
    f3.prototype.toLocaleString = f3.prototype.toString;
    f3.prototype.equals = function(t) {
      if (!f3.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : f3.compare(this, t) === 0;
    };
    f3.prototype.inspect = function() {
      let t = "", r = be2.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    kr && (f3.prototype[kr] = f3.prototype.inspect);
    f3.prototype.compare = function(t, r, n, i, o2) {
      if (W(t, Uint8Array) && (t = f3.from(t, t.offset, t.byteLength)), !f3.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let a3 = o2 - i, s2 = n - r, u3 = Math.min(a3, s2), l3 = this.slice(i, o2), h5 = t.slice(r, n);
      for (let c2 = 0;c2 < u3; ++c2)
        if (l3[c2] !== h5[c2]) {
          a3 = l3[c2], s2 = h5[c2];
          break;
        }
      return a3 < s2 ? -1 : s2 < a3 ? 1 : 0;
    };
    function Vr(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, It(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = f3.from(t, n)), f3.isBuffer(t))
        return t.length === 0 ? -1 : jr(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : jr(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function jr(e, t, r, n, i) {
      let o2 = 1, a3 = e.length, s2 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, a3 /= 2, s2 /= 2, r /= 2;
      }
      function u3(h5, c2) {
        return o2 === 1 ? h5[c2] : h5.readUInt16BE(c2 * o2);
      }
      let l3;
      if (i) {
        let h5 = -1;
        for (l3 = r;l3 < a3; l3++)
          if (u3(e, l3) === u3(t, h5 === -1 ? 0 : l3 - h5)) {
            if (h5 === -1 && (h5 = l3), l3 - h5 + 1 === s2)
              return h5 * o2;
          } else
            h5 !== -1 && (l3 -= l3 - h5), h5 = -1;
      } else
        for (r + s2 > a3 && (r = a3 - s2), l3 = r;l3 >= 0; l3--) {
          let h5 = true;
          for (let c2 = 0;c2 < s2; c2++)
            if (u3(e, l3 + c2) !== u3(t, c2)) {
              h5 = false;
              break;
            }
          if (h5)
            return l3;
        }
      return -1;
    }
    f3.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    f3.prototype.indexOf = function(t, r, n) {
      return Vr(this, t, r, n, true);
    };
    f3.prototype.lastIndexOf = function(t, r, n) {
      return Vr(this, t, r, n, false);
    };
    function wo2(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let a3;
      for (a3 = 0;a3 < n; ++a3) {
        let s2 = parseInt(t.substr(a3 * 2, 2), 16);
        if (It(s2))
          return a3;
        e[r + a3] = s2;
      }
      return a3;
    }
    function mo(e, t, r, n) {
      return Ge(Tt3(t, e.length - r), e, r, n);
    }
    function bo(e, t, r, n) {
      return Ge(Lo(t), e, r, n);
    }
    function _o(e, t, r, n) {
      return Ge(tn2(t), e, r, n);
    }
    function vo(e, t, r, n) {
      return Ge(Mo2(t, e.length - r), e, r, n);
    }
    f3.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a3 = false;
      for (;; )
        switch (i) {
          case "hex":
            return wo2(this, t, r, n);
          case "utf8":
          case "utf-8":
            return mo(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return bo(this, t, r, n);
          case "base64":
            return _o(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return vo(this, t, r, n);
          default:
            if (a3)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a3 = true;
        }
    };
    f3.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Eo(e, t, r) {
      return t === 0 && r === e.length ? xt.fromByteArray(e) : xt.fromByteArray(e.slice(t, r));
    }
    function Yr2(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], a3 = null, s2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + s2 <= r) {
          let u3, l3, h5, c2;
          switch (s2) {
            case 1:
              o2 < 128 && (a3 = o2);
              break;
            case 2:
              u3 = e[i + 1], (u3 & 192) === 128 && (c2 = (o2 & 31) << 6 | u3 & 63, c2 > 127 && (a3 = c2));
              break;
            case 3:
              u3 = e[i + 1], l3 = e[i + 2], (u3 & 192) === 128 && (l3 & 192) === 128 && (c2 = (o2 & 15) << 12 | (u3 & 63) << 6 | l3 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (a3 = c2));
              break;
            case 4:
              u3 = e[i + 1], l3 = e[i + 2], h5 = e[i + 3], (u3 & 192) === 128 && (l3 & 192) === 128 && (h5 & 192) === 128 && (c2 = (o2 & 15) << 18 | (u3 & 63) << 12 | (l3 & 63) << 6 | h5 & 63, c2 > 65535 && c2 < 1114112 && (a3 = c2));
          }
        }
        a3 === null ? (a3 = 65533, s2 = 1) : a3 > 65535 && (a3 -= 65536, n.push(a3 >>> 10 & 1023 | 55296), a3 = 56320 | a3 & 1023), n.push(a3), i += s2;
      }
      return xo(n);
    }
    var Hr2 = 4096;
    function xo(e) {
      let t = e.length;
      if (t <= Hr2)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += Hr2));
      return r;
    }
    function Ro(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function So(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function To(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += Oo[e[o2]];
      return i;
    }
    function Ao(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    f3.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, f3.prototype), i;
    };
    function C3(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    f3.prototype.readUintLE = f3.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C3(t, r, this.length);
      let i = this[t], o2 = 1, a3 = 0;
      for (;++a3 < r && (o2 *= 256); )
        i += this[t + a3] * o2;
      return i;
    };
    f3.prototype.readUintBE = f3.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C3(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    f3.prototype.readUint8 = f3.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || C3(t, 1, this.length), this[t];
    };
    f3.prototype.readUint16LE = f3.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || C3(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    f3.prototype.readUint16BE = f3.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || C3(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    f3.prototype.readUint32LE = f3.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || C3(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    f3.prototype.readUint32BE = f3.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || C3(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    f3.prototype.readBigUInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    f3.prototype.readBigUInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    f3.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C3(t, r, this.length);
      let i = this[t], o2 = 1, a3 = 0;
      for (;++a3 < r && (o2 *= 256); )
        i += this[t + a3] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    f3.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C3(t, r, this.length);
      let i = r, o2 = 1, a3 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        a3 += this[t + --i] * o2;
      return o2 *= 128, a3 >= o2 && (a3 -= Math.pow(2, 8 * r)), a3;
    };
    f3.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || C3(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    f3.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || C3(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f3.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || C3(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f3.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || C3(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    f3.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || C3(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    f3.prototype.readBigInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    f3.prototype.readBigInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    f3.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || C3(t, 4, this.length), we.read(this, t, true, 23, 4);
    };
    f3.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || C3(t, 4, this.length), we.read(this, t, false, 23, 4);
    };
    f3.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || C3(t, 8, this.length), we.read(this, t, true, 52, 8);
    };
    f3.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || C3(t, 8, this.length), we.read(this, t, false, 52, 8);
    };
    function O4(e, t, r, n, i, o2) {
      if (!f3.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    f3.prototype.writeUintLE = f3.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O4(this, t, r, n, s2, 0);
      }
      let o2 = 1, a3 = 0;
      for (this[r] = t & 255;++a3 < n && (o2 *= 256); )
        this[r + a3] = t / o2 & 255;
      return r + n;
    };
    f3.prototype.writeUintBE = f3.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O4(this, t, r, n, s2, 0);
      }
      let o2 = n - 1, a3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a3 *= 256); )
        this[r + o2] = t / a3 & 255;
      return r + n;
    };
    f3.prototype.writeUint8 = f3.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    f3.prototype.writeUint16LE = f3.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f3.prototype.writeUint16BE = f3.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f3.prototype.writeUint32LE = f3.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    f3.prototype.writeUint32BE = f3.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function Xr(e, t, r, n, i) {
      en(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let a3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, r;
    }
    function zr2(e, t, r, n, i) {
      en(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let a3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a3, a3 = a3 >> 8, e[r + 2] = a3, a3 = a3 >> 8, e[r + 1] = a3, a3 = a3 >> 8, e[r] = a3, r + 8;
    }
    f3.prototype.writeBigUInt64LE = ee(function(t, r = 0) {
      return Xr(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f3.prototype.writeBigUInt64BE = ee(function(t, r = 0) {
      return zr2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f3.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n - 1);
        O4(this, t, r, n, u3 - 1, -u3);
      }
      let o2 = 0, a3 = 1, s2 = 0;
      for (this[r] = t & 255;++o2 < n && (a3 *= 256); )
        t < 0 && s2 === 0 && this[r + o2 - 1] !== 0 && (s2 = 1), this[r + o2] = (t / a3 >> 0) - s2 & 255;
      return r + n;
    };
    f3.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n - 1);
        O4(this, t, r, n, u3 - 1, -u3);
      }
      let o2 = n - 1, a3 = 1, s2 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a3 *= 256); )
        t < 0 && s2 === 0 && this[r + o2 + 1] !== 0 && (s2 = 1), this[r + o2] = (t / a3 >> 0) - s2 & 255;
      return r + n;
    };
    f3.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    f3.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f3.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f3.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    f3.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    f3.prototype.writeBigInt64LE = ee(function(t, r = 0) {
      return Xr(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    f3.prototype.writeBigInt64BE = ee(function(t, r = 0) {
      return zr2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Zr2(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function Jr(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Zr2(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), we.write(e, t, r, n, 23, 4), r + 4;
    }
    f3.prototype.writeFloatLE = function(t, r, n) {
      return Jr(this, t, r, true, n);
    };
    f3.prototype.writeFloatBE = function(t, r, n) {
      return Jr(this, t, r, false, n);
    };
    function Qr(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Zr2(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), we.write(e, t, r, n, 52, 8), r + 8;
    }
    f3.prototype.writeDoubleLE = function(t, r, n) {
      return Qr(this, t, r, true, n);
    };
    f3.prototype.writeDoubleBE = function(t, r, n) {
      return Qr(this, t, r, false, n);
    };
    f3.prototype.copy = function(t, r, n, i) {
      if (!f3.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    f3.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !f3.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a3 = t.charCodeAt(0);
          (i === "utf8" && a3 < 128 || i === "latin1") && (t = a3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let a3 = f3.isBuffer(t) ? t : f3.from(t, i), s2 = a3.length;
        if (s2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = a3[o2 % s2];
      }
      return this;
    };
    var ge = {};
    function Ct(e, t, r) {
      ge[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    Ct("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Ct("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    Ct("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Wr(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Wr(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function Wr(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function Bo(e, t, r) {
      me(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ie(t, e.length - (r + 1));
    }
    function en(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let a3 = typeof t == "bigint" ? "n" : "", s2;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? s2 = `>= 0${a3} and < 2${a3} ** ${(o2 + 1) * 8}${a3}` : s2 = `>= -(2${a3} ** ${(o2 + 1) * 8 - 1}${a3}) and < 2 ** ${(o2 + 1) * 8 - 1}${a3}` : s2 = `>= ${t}${a3} and <= ${r}${a3}`, new ge.ERR_OUT_OF_RANGE("value", s2, e);
      }
      Bo(n, i, o2);
    }
    function me(e, t) {
      if (typeof e != "number")
        throw new ge.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ie(e, t, r) {
      throw Math.floor(e) !== e ? (me(e, r), new ge.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS : new ge.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var Co = /[^+/0-9A-Za-z-_]/g;
    function Io(e) {
      if (e = e.split("=")[0], e = e.trim().replace(Co, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Tt3(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let a3 = 0;a3 < n; ++a3) {
        if (r = e.charCodeAt(a3), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (a3 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function Lo(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Mo2(e, t) {
      let r, n, i, o2 = [];
      for (let a3 = 0;a3 < e.length && !((t -= 2) < 0); ++a3)
        r = e.charCodeAt(a3), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function tn2(e) {
      return xt.toByteArray(Io(e));
    }
    function Ge(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function W(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function It(e) {
      return e !== e;
    }
    var Oo = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function ee(e) {
      return typeof BigInt > "u" ? Fo : e;
    }
    function Fo() {
      throw new Error("BigInt not supported");
    }
  });
  Lt2 = b4(() => {
  });
  an = b4((Of, on) => {
    function rn(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function No(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? rn(Object(r), true).forEach(function(n) {
          Uo(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : rn(Object(r)).forEach(function(n) {
          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return e;
    }
    function Uo(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function Po(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function nn(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function qo(e, t, r) {
      return t && nn(e.prototype, t), r && nn(e, r), e;
    }
    var Do = _e(), Ke = Do.Buffer, ko = Lt2(), Mt = ko.inspect, jo = Mt && Mt.custom || "inspect";
    function Ho(e, t, r) {
      Ke.prototype.copy.call(e, t, r);
    }
    on.exports = function() {
      function e() {
        Po(this, e), this.head = null, this.tail = null, this.length = 0;
      }
      return qo(e, [{ key: "push", value: function(r) {
        var n = { data: r, next: null };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var n = { data: r, next: this.head };
        this.length === 0 && (this.tail = n), this.head = n, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var n = this.head, i = "" + n.data;n = n.next; )
          i += r + n.data;
        return i;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return Ke.alloc(0);
        for (var n = Ke.allocUnsafe(r >>> 0), i = this.head, o2 = 0;i; )
          Ho(i.data, n, o2), o2 += i.data.length, i = i.next;
        return n;
      } }, { key: "consume", value: function(r, n) {
        var i;
        return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var n = this.head, i = 1, o2 = n.data;
        for (r -= o2.length;n = n.next; ) {
          var a3 = n.data, s2 = r > a3.length ? a3.length : r;
          if (s2 === a3.length ? o2 += a3 : o2 += a3.slice(0, r), r -= s2, r === 0) {
            s2 === a3.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = a3.slice(s2));
            break;
          }
          ++i;
        }
        return this.length -= i, o2;
      } }, { key: "_getBuffer", value: function(r) {
        var n = Ke.allocUnsafe(r), i = this.head, o2 = 1;
        for (i.data.copy(n), r -= i.data.length;i = i.next; ) {
          var a3 = i.data, s2 = r > a3.length ? a3.length : r;
          if (a3.copy(n, n.length - r, 0, s2), r -= s2, r === 0) {
            s2 === a3.length ? (++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = a3.slice(s2));
            break;
          }
          ++o2;
        }
        return this.length -= o2, n;
      } }, { key: jo, value: function(r, n) {
        return Mt(this, No({}, n, { depth: 0, customInspect: false }));
      } }]), e;
    }();
  });
  Ft = b4((Ff, fn) => {
    function Wo(e, t) {
      var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
      return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(Ot, this, e)) : process.nextTick(Ot, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(o2) {
        !t && o2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ve, r) : (r._writableState.errorEmitted = true, process.nextTick(sn, r, o2)) : process.nextTick(sn, r, o2) : t ? (process.nextTick(Ve, r), t(o2)) : process.nextTick(Ve, r);
      }), this);
    }
    function sn(e, t) {
      Ot(e, t), Ve(e);
    }
    function Ve(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function $o() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function Ot(e, t) {
      e.emit("error", t);
    }
    function Go(e, t) {
      var { _readableState: r, _writableState: n } = e;
      r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    fn.exports = { destroy: Wo, undestroy: $o, errorOrDestroy: Go };
  });
  fe = b4((Nf, hn) => {
    function Ko(e, t) {
      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var ln = {};
    function P4(e, t, r) {
      r || (r = Error);
      function n(o2, a3, s2) {
        return typeof t == "string" ? t : t(o2, a3, s2);
      }
      var i = function(o2) {
        Ko(a3, o2);
        function a3(s2, u3, l3) {
          return o2.call(this, n(s2, u3, l3)) || this;
        }
        return a3;
      }(r);
      i.prototype.name = r.name, i.prototype.code = e, ln[e] = i;
    }
    function un2(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function Vo(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Yo(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Xo(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    P4("ERR_INVALID_OPT_VALUE", function(e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    P4("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      var n;
      typeof t == "string" && Vo(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (Yo(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(un2(t, "type"));
      else {
        var o2 = Xo(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o2, " ").concat(n, " ").concat(un2(t, "type"));
      }
      return i += ". Received type ".concat(typeof r), i;
    }, TypeError);
    P4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    P4("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
      return "The " + e + " method is not implemented";
    });
    P4("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    P4("ERR_STREAM_DESTROYED", function(e) {
      return "Cannot call " + e + " after a stream was destroyed";
    });
    P4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    P4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    P4("ERR_STREAM_WRITE_AFTER_END", "write after end");
    P4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    P4("ERR_UNKNOWN_ENCODING", function(e) {
      return "Unknown encoding: " + e;
    }, TypeError);
    P4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    hn.exports.codes = ln;
  });
  Nt2 = b4((Uf, cn) => {
    var zo = fe().codes.ERR_INVALID_OPT_VALUE;
    function Zo(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Jo(e, t, r, n) {
      var i = Zo(t, n, r);
      if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
          var o2 = n ? r : "highWaterMark";
          throw new zo(o2, i);
        }
        return Math.floor(i);
      }
      return e.objectMode ? 16 : 16 * 1024;
    }
    cn.exports = { getHighWaterMark: Jo };
  });
  pn = b4((Pf, dn) => {
    dn.exports = Qo2;
    function Qo2(e, t) {
      if (Ut2("noDeprecation"))
        return e;
      var r = false;
      function n() {
        if (!r) {
          if (Ut2("throwDeprecation"))
            throw new Error(t);
          Ut2("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    }
    function Ut2(e) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var t = global.localStorage[e];
      return t == null ? false : String(t).toLowerCase() === "true";
    }
  });
  Dt = b4((qf, _n) => {
    _n.exports = A4;
    function gn(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        Ta(t, e);
      };
    }
    var ve;
    A4.WritableState = Me;
    var ea = { deprecate: pn() }, wn = _t2(), Xe = _e().Buffer, ta = global.Uint8Array || function() {
    };
    function ra(e) {
      return Xe.from(e);
    }
    function na(e) {
      return Xe.isBuffer(e) || e instanceof ta;
    }
    var qt = Ft(), ia = Nt2(), oa = ia.getHighWaterMark, te = fe().codes, aa = te.ERR_INVALID_ARG_TYPE, sa = te.ERR_METHOD_NOT_IMPLEMENTED, fa = te.ERR_MULTIPLE_CALLBACK, ua = te.ERR_STREAM_CANNOT_PIPE, la = te.ERR_STREAM_DESTROYED, ha = te.ERR_STREAM_NULL_VALUES, ca = te.ERR_STREAM_WRITE_AFTER_END, da2 = te.ERR_UNKNOWN_ENCODING, Ee = qt.errorOrDestroy;
    Q3()(A4, wn);
    function pa() {
    }
    function Me(e, t, r) {
      ve = ve || ue(), e = e || {}, typeof r != "boolean" && (r = t instanceof ve), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = oa(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var n = e.decodeStrings === false;
      this.decodeStrings = !n, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
        va2(t, i);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new gn(this);
    }
    Me.prototype.getBuffer = function() {
      for (var t = this.bufferedRequest, r = [];t; )
        r.push(t), t = t.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Me.prototype, "buffer", { get: ea.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ye;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ye = Function.prototype[Symbol.hasInstance], Object.defineProperty(A4, Symbol.hasInstance, { value: function(t) {
      return Ye.call(this, t) ? true : this !== A4 ? false : t && t._writableState instanceof Me;
    } })) : Ye = function(t) {
      return t instanceof this;
    };
    function A4(e) {
      ve = ve || ue();
      var t = this instanceof ve;
      if (!t && !Ye.call(A4, this))
        return new A4(e);
      this._writableState = new Me(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), wn.call(this);
    }
    A4.prototype.pipe = function() {
      Ee(this, new ua);
    };
    function ya(e, t) {
      var r = new ca;
      Ee(e, r), process.nextTick(t, r);
    }
    function ga(e, t, r, n) {
      var i;
      return r === null ? i = new ha : typeof r != "string" && !t.objectMode && (i = new aa("chunk", ["string", "Buffer"], r)), i ? (Ee(e, i), process.nextTick(n, i), false) : true;
    }
    A4.prototype.write = function(e, t, r) {
      var n = this._writableState, i = false, o2 = !n.objectMode && na(e);
      return o2 && !Xe.isBuffer(e) && (e = ra(e)), typeof t == "function" && (r = t, t = null), o2 ? t = "buffer" : t || (t = n.defaultEncoding), typeof r != "function" && (r = pa), n.ending ? ya(this, r) : (o2 || ga(this, n, e, r)) && (n.pendingcb++, i = ma(this, n, o2, e, t, r)), i;
    };
    A4.prototype.cork = function() {
      this._writableState.corked++;
    };
    A4.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && mn(this, e));
    };
    A4.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
        throw new da2(t);
      return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(A4.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function wa2(e, t, r) {
      return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = Xe.from(t, r)), t;
    }
    Object.defineProperty(A4.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function ma(e, t, r, n, i, o2) {
      if (!r) {
        var a3 = wa2(t, n, i);
        n !== a3 && (r = true, i = "buffer", n = a3);
      }
      var s2 = t.objectMode ? 1 : n.length;
      t.length += s2;
      var u3 = t.length < t.highWaterMark;
      if (u3 || (t.needDrain = true), t.writing || t.corked) {
        var l3 = t.lastBufferedRequest;
        t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o2, next: null }, l3 ? l3.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
      } else
        Pt(e, t, false, s2, n, i, o2);
      return u3;
    }
    function Pt(e, t, r, n, i, o2, a3) {
      t.writelen = n, t.writecb = a3, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new la("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function ba(e, t, r, n, i) {
      --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(Le, e, t), e._writableState.errorEmitted = true, Ee(e, n)) : (i(n), e._writableState.errorEmitted = true, Ee(e, n), Le(e, t));
    }
    function _a(e) {
      e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function va2(e, t) {
      var r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function")
        throw new fa;
      if (_a(r), t)
        ba(e, r, n, t, i);
      else {
        var o2 = bn(r) || e.destroyed;
        !o2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && mn(e, r), n ? process.nextTick(yn2, e, r, o2, i) : yn2(e, r, o2, i);
      }
    }
    function yn2(e, t, r, n) {
      r || Ea(e, t), t.pendingcb--, n(), Le(e, t);
    }
    function Ea(e, t) {
      t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
    }
    function mn(e, t) {
      t.bufferProcessing = true;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount, i = new Array(n), o2 = t.corkedRequestsFree;
        o2.entry = r;
        for (var a3 = 0, s2 = true;r; )
          i[a3] = r, r.isBuf || (s2 = false), r = r.next, a3 += 1;
        i.allBuffers = s2, Pt(e, t, true, t.length, i, "", o2.finish), t.pendingcb++, t.lastBufferedRequest = null, o2.next ? (t.corkedRequestsFree = o2.next, o2.next = null) : t.corkedRequestsFree = new gn(t), t.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: u3, encoding: l3, callback: h5 } = r, c2 = t.objectMode ? 1 : u3.length;
          if (Pt(e, t, false, c2, u3, l3, h5), r = r.next, t.bufferedRequestCount--, t.writing)
            break;
        }
        r === null && (t.lastBufferedRequest = null);
      }
      t.bufferedRequest = r, t.bufferProcessing = false;
    }
    A4.prototype._write = function(e, t, r) {
      r(new sa("_write()"));
    };
    A4.prototype._writev = null;
    A4.prototype.end = function(e, t, r) {
      var n = this._writableState;
      return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || Sa(this, n, r), this;
    };
    Object.defineProperty(A4.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function bn(e) {
      return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function xa(e, t) {
      e._final(function(r) {
        t.pendingcb--, r && Ee(e, r), t.prefinished = true, e.emit("prefinish"), Le(e, t);
      });
    }
    function Ra(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, process.nextTick(xa, e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Le(e, t) {
      var r = bn(t);
      if (r && (Ra(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
        var n = e._readableState;
        (!n || n.autoDestroy && n.endEmitted) && e.destroy();
      }
      return r;
    }
    function Sa(e, t, r) {
      t.ending = true, Le(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
    }
    function Ta(e, t, r) {
      var n = e.entry;
      for (e.entry = null;n; ) {
        var i = n.callback;
        t.pendingcb--, i(r), n = n.next;
      }
      t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(A4.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(t) {
      !this._writableState || (this._writableState.destroyed = t);
    } });
    A4.prototype.destroy = qt.destroy;
    A4.prototype._undestroy = qt.undestroy;
    A4.prototype._destroy = function(e, t) {
      t(e);
    };
  });
  ue = b4((Df, En) => {
    var Aa = Object.keys || function(e) {
      var t = [];
      for (var r in e)
        t.push(r);
      return t;
    };
    En.exports = $3;
    var vn = Ht(), jt = Dt();
    Q3()($3, vn);
    for (kt2 = Aa(jt.prototype), ze = 0;ze < kt2.length; ze++)
      Ze = kt2[ze], $3.prototype[Ze] || ($3.prototype[Ze] = jt.prototype[Ze]);
    var kt2, Ze, ze;
    function $3(e) {
      if (!(this instanceof $3))
        return new $3(e);
      vn.call(this, e), jt.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Ba)));
    }
    Object.defineProperty($3.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($3.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($3.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ba() {
      this._writableState.ended || process.nextTick(Ca, this);
    }
    function Ca(e) {
      e.end();
    }
    Object.defineProperty($3.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(t) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } });
  });
  Sn = b4((Wt, Rn) => {
    var Je = _e(), G2 = Je.Buffer;
    function xn(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    G2.from && G2.alloc && G2.allocUnsafe && G2.allocUnsafeSlow ? Rn.exports = Je : (xn(Je, Wt), Wt.Buffer = le);
    function le(e, t, r) {
      return G2(e, t, r);
    }
    le.prototype = Object.create(G2.prototype);
    xn(G2, le);
    le.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return G2(e, t, r);
    };
    le.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = G2(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    le.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return G2(e);
    };
    le.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Je.SlowBuffer(e);
    };
  });
  Bn2 = b4((An) => {
    var Gt = Sn().Buffer, Tn2 = Gt.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function Ia2(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function La(e) {
      var t = Ia2(e);
      if (typeof t != "string" && (Gt.isEncoding === Tn2 || !Tn2(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    An.StringDecoder = Oe;
    function Oe(e) {
      this.encoding = La(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Pa, this.end = qa, t = 4;
          break;
        case "utf8":
          this.fillLast = Fa, t = 4;
          break;
        case "base64":
          this.text = Da, this.end = ka2, t = 3;
          break;
        default:
          this.write = ja, this.end = Ha;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Gt.allocUnsafe(t);
    }
    Oe.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Oe.prototype.end = Ua;
    Oe.prototype.text = Na2;
    Oe.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function $t(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ma(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = $t(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = $t(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = $t(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function Oa(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function Fa(e) {
      var t = this.lastTotal - this.lastNeed, r = Oa(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Na2(e, t) {
      var r = Ma(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function Ua(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function Pa(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function qa(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Da(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function ka2(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function ja(e) {
      return e.toString(this.encoding);
    }
    function Ha(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Kt = {};
  Er2(Kt, { StringDecoder: () => Qe.StringDecoder, default: () => Qe.StringDecoder });
  Vt = vr(() => {
    Qe = Rr2(Bn2());
  });
  et = b4((jf, Ln2) => {
    var Cn = fe().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Wa2(e) {
      var t = false;
      return function() {
        if (!t) {
          t = true;
          for (var r = arguments.length, n = new Array(r), i = 0;i < r; i++)
            n[i] = arguments[i];
          e.apply(this, n);
        }
      };
    }
    function $a2() {
    }
    function Ga2(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function In(e, t, r) {
      if (typeof t == "function")
        return In(e, null, t);
      t || (t = {}), r = Wa2(r || $a2);
      var n = t.readable || t.readable !== false && e.readable, i = t.writable || t.writable !== false && e.writable, o2 = function() {
        e.writable || s2();
      }, a3 = e._writableState && e._writableState.finished, s2 = function() {
        i = false, a3 = true, n || r.call(e);
      }, u3 = e._readableState && e._readableState.endEmitted, l3 = function() {
        n = false, u3 = true, i || r.call(e);
      }, h5 = function(g5) {
        r.call(e, g5);
      }, c2 = function() {
        var g5;
        if (n && !u3)
          return (!e._readableState || !e._readableState.ended) && (g5 = new Cn), r.call(e, g5);
        if (i && !a3)
          return (!e._writableState || !e._writableState.ended) && (g5 = new Cn), r.call(e, g5);
      }, d4 = function() {
        e.req.on("finish", s2);
      };
      return Ga2(e) ? (e.on("complete", s2), e.on("abort", c2), e.req ? d4() : e.on("request", d4)) : i && !e._writableState && (e.on("end", o2), e.on("close", o2)), e.on("end", l3), e.on("finish", s2), t.error !== false && e.on("error", h5), e.on("close", c2), function() {
        e.removeListener("complete", s2), e.removeListener("abort", c2), e.removeListener("request", d4), e.req && e.req.removeListener("finish", s2), e.removeListener("end", o2), e.removeListener("close", o2), e.removeListener("finish", s2), e.removeListener("end", l3), e.removeListener("error", h5), e.removeListener("close", c2);
      };
    }
    Ln2.exports = In;
  });
  On = b4((Hf, Mn) => {
    var tt3;
    function re2(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    var Ka = et(), ne2 = Symbol("lastResolve"), he = Symbol("lastReject"), Fe = Symbol("error"), rt3 = Symbol("ended"), ce2 = Symbol("lastPromise"), Yt = Symbol("handlePromise"), de = Symbol("stream");
    function ie(e, t) {
      return { value: e, done: t };
    }
    function Va(e) {
      var t = e[ne2];
      if (t !== null) {
        var r = e[de].read();
        r !== null && (e[ce2] = null, e[ne2] = null, e[he] = null, t(ie(r, false)));
      }
    }
    function Ya2(e) {
      process.nextTick(Va, e);
    }
    function Xa(e, t) {
      return function(r, n) {
        e.then(function() {
          if (t[rt3]) {
            r(ie(undefined, true));
            return;
          }
          t[Yt](r, n);
        }, n);
      };
    }
    var za = Object.getPrototypeOf(function() {
    }), Za = Object.setPrototypeOf((tt3 = { get stream() {
      return this[de];
    }, next: function() {
      var t = this, r = this[Fe];
      if (r !== null)
        return Promise.reject(r);
      if (this[rt3])
        return Promise.resolve(ie(undefined, true));
      if (this[de].destroyed)
        return new Promise(function(a3, s2) {
          process.nextTick(function() {
            t[Fe] ? s2(t[Fe]) : a3(ie(undefined, true));
          });
        });
      var n = this[ce2], i;
      if (n)
        i = new Promise(Xa(n, this));
      else {
        var o2 = this[de].read();
        if (o2 !== null)
          return Promise.resolve(ie(o2, false));
        i = new Promise(this[Yt]);
      }
      return this[ce2] = i, i;
    } }, re2(tt3, Symbol.asyncIterator, function() {
      return this;
    }), re2(tt3, "return", function() {
      var t = this;
      return new Promise(function(r, n) {
        t[de].destroy(null, function(i) {
          if (i) {
            n(i);
            return;
          }
          r(ie(undefined, true));
        });
      });
    }), tt3), za), Ja = function(t) {
      var r, n = Object.create(Za, (r = {}, re2(r, de, { value: t, writable: true }), re2(r, ne2, { value: null, writable: true }), re2(r, he, { value: null, writable: true }), re2(r, Fe, { value: null, writable: true }), re2(r, rt3, { value: t._readableState.endEmitted, writable: true }), re2(r, Yt, { value: function(o2, a3) {
        var s2 = n[de].read();
        s2 ? (n[ce2] = null, n[ne2] = null, n[he] = null, o2(ie(s2, false))) : (n[ne2] = o2, n[he] = a3);
      }, writable: true }), r));
      return n[ce2] = null, Ka(t, function(i) {
        if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var o2 = n[he];
          o2 !== null && (n[ce2] = null, n[ne2] = null, n[he] = null, o2(i)), n[Fe] = i;
          return;
        }
        var a3 = n[ne2];
        a3 !== null && (n[ce2] = null, n[ne2] = null, n[he] = null, a3(ie(undefined, true))), n[rt3] = true;
      }), t.on("readable", Ya2.bind(null, n)), n;
    };
    Mn.exports = Ja;
  });
  Nn = b4((Wf, Fn) => {
    Fn.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Ht = b4((Gf, Gn) => {
    Gn.exports = _4;
    var xe2;
    _4.ReadableState = Dn2;
    var $f = bt2().EventEmitter, qn2 = function(t, r) {
      return t.listeners(r).length;
    }, Ue = _t2(), nt3 = _e().Buffer, Qa = global.Uint8Array || function() {
    };
    function es(e) {
      return nt3.from(e);
    }
    function ts(e) {
      return nt3.isBuffer(e) || e instanceof Qa;
    }
    var Xt = Lt2(), w3;
    Xt && Xt.debuglog ? w3 = Xt.debuglog("stream") : w3 = function() {
    };
    var rs = an(), rr2 = Ft(), ns = Nt2(), is = ns.getHighWaterMark, it2 = fe().codes, os = it2.ERR_INVALID_ARG_TYPE, as = it2.ERR_STREAM_PUSH_AFTER_EOF, ss = it2.ERR_METHOD_NOT_IMPLEMENTED, fs = it2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Re, zt, Zt;
    Q3()(_4, Ue);
    var Ne = rr2.errorOrDestroy, Jt = ["error", "close", "destroy", "pause", "resume"];
    function us(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    function Dn2(e, t, r) {
      xe2 = xe2 || ue(), e = e || {}, typeof r != "boolean" && (r = t instanceof xe2), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = is(this, e, "readableHighWaterMark", r), this.buffer = new rs, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (Re || (Re = (Vt(), dt2(Kt)).StringDecoder), this.decoder = new Re(e.encoding), this.encoding = e.encoding);
    }
    function _4(e) {
      if (xe2 = xe2 || ue(), !(this instanceof _4))
        return new _4(e);
      var t = this instanceof xe2;
      this._readableState = new Dn2(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), Ue.call(this);
    }
    Object.defineProperty(_4.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } });
    _4.prototype.destroy = rr2.destroy;
    _4.prototype._undestroy = rr2.undestroy;
    _4.prototype._destroy = function(e, t) {
      t(e);
    };
    _4.prototype.push = function(e, t) {
      var r = this._readableState, n;
      return r.objectMode ? n = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = nt3.from(e, t), t = ""), n = true), kn(this, e, t, false, n);
    };
    _4.prototype.unshift = function(e) {
      return kn(this, e, null, true, false);
    };
    function kn(e, t, r, n, i) {
      w3("readableAddChunk", t);
      var o2 = e._readableState;
      if (t === null)
        o2.reading = false, cs(e, o2);
      else {
        var a3;
        if (i || (a3 = ls(o2, t)), a3)
          Ne(e, a3);
        else if (o2.objectMode || t && t.length > 0)
          if (typeof t != "string" && !o2.objectMode && Object.getPrototypeOf(t) !== nt3.prototype && (t = es(t)), n)
            o2.endEmitted ? Ne(e, new fs) : Qt(e, o2, t, true);
          else if (o2.ended)
            Ne(e, new as);
          else {
            if (o2.destroyed)
              return false;
            o2.reading = false, o2.decoder && !r ? (t = o2.decoder.write(t), o2.objectMode || t.length !== 0 ? Qt(e, o2, t, false) : tr(e, o2)) : Qt(e, o2, t, false);
          }
        else
          n || (o2.reading = false, tr(e, o2));
      }
      return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
    }
    function Qt(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ot3(e)), tr(e, t);
    }
    function ls(e, t) {
      var r;
      return !ts(t) && typeof t != "string" && t !== undefined && !e.objectMode && (r = new os("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
    }
    _4.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    _4.prototype.setEncoding = function(e) {
      Re || (Re = (Vt(), dt2(Kt)).StringDecoder);
      var t = new Re(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, n = "";r !== null; )
        n += t.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
    };
    var Un = 1073741824;
    function hs(e) {
      return e >= Un ? e = Un : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Pn(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = hs(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
    }
    _4.prototype.read = function(e) {
      w3("read", e), e = parseInt(e, 10);
      var t = this._readableState, r = e;
      if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return w3("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? er(this) : ot3(this), null;
      if (e = Pn(e, t), e === 0 && t.ended)
        return t.length === 0 && er(this), null;
      var n = t.needReadable;
      w3("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, w3("length less than watermark", n)), t.ended || t.reading ? (n = false, w3("reading or ended", n)) : n && (w3("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = Pn(r, t)));
      var i;
      return e > 0 ? i = Wn(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && er(this)), i !== null && this.emit("data", i), i;
    };
    function cs(e, t) {
      if (w3("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ot3(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, jn(e)));
      }
    }
    function ot3(e) {
      var t = e._readableState;
      w3("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (w3("emitReadable", t.flowing), t.emittedReadable = true, process.nextTick(jn, e));
    }
    function jn(e) {
      var t = e._readableState;
      w3("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, nr(e);
    }
    function tr(e, t) {
      t.readingMore || (t.readingMore = true, process.nextTick(ds, e, t));
    }
    function ds(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        var r = t.length;
        if (w3("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    _4.prototype._read = function(e) {
      Ne(this, new ss("_read()"));
    };
    _4.prototype.pipe = function(e, t) {
      var r = this, n = this._readableState;
      switch (n.pipesCount) {
        case 0:
          n.pipes = e;
          break;
        case 1:
          n.pipes = [n.pipes, e];
          break;
        default:
          n.pipes.push(e);
          break;
      }
      n.pipesCount += 1, w3("pipe count=%d opts=%j", n.pipesCount, t);
      var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr, o2 = i ? s2 : E5;
      n.endEmitted ? process.nextTick(o2) : r.once("end", o2), e.on("unpipe", a3);
      function a3(v4, m3) {
        w3("onunpipe"), v4 === r && m3 && m3.hasUnpiped === false && (m3.hasUnpiped = true, h5());
      }
      function s2() {
        w3("onend"), e.end();
      }
      var u3 = ps(r);
      e.on("drain", u3);
      var l3 = false;
      function h5() {
        w3("cleanup"), e.removeListener("close", p3), e.removeListener("finish", g5), e.removeListener("drain", u3), e.removeListener("error", d4), e.removeListener("unpipe", a3), r.removeListener("end", s2), r.removeListener("end", E5), r.removeListener("data", c2), l3 = true, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && u3();
      }
      r.on("data", c2);
      function c2(v4) {
        w3("ondata");
        var m3 = e.write(v4);
        w3("dest.write", m3), m3 === false && ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && $n(n.pipes, e) !== -1) && !l3 && (w3("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
      }
      function d4(v4) {
        w3("onerror", v4), E5(), e.removeListener("error", d4), qn2(e, "error") === 0 && Ne(e, v4);
      }
      us(e, "error", d4);
      function p3() {
        e.removeListener("finish", g5), E5();
      }
      e.once("close", p3);
      function g5() {
        w3("onfinish"), e.removeListener("close", p3), E5();
      }
      e.once("finish", g5);
      function E5() {
        w3("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), n.flowing || (w3("pipe resume"), r.resume()), e;
    };
    function ps(e) {
      return function() {
        var r = e._readableState;
        w3("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && qn2(e, "data") && (r.flowing = true, nr(e));
      };
    }
    _4.prototype.unpipe = function(e) {
      var t = this._readableState, r = { hasUnpiped: false };
      if (t.pipesCount === 0)
        return this;
      if (t.pipesCount === 1)
        return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
      if (!e) {
        var { pipes: n, pipesCount: i } = t;
        t.pipes = null, t.pipesCount = 0, t.flowing = false;
        for (var o2 = 0;o2 < i; o2++)
          n[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var a3 = $n(t.pipes, e);
      return a3 === -1 ? this : (t.pipes.splice(a3, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    _4.prototype.on = function(e, t) {
      var r = Ue.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, w3("on readable", n.length, n.reading), n.length ? ot3(this) : n.reading || process.nextTick(ys, this)), r;
    };
    _4.prototype.addListener = _4.prototype.on;
    _4.prototype.removeListener = function(e, t) {
      var r = Ue.prototype.removeListener.call(this, e, t);
      return e === "readable" && process.nextTick(Hn, this), r;
    };
    _4.prototype.removeAllListeners = function(e) {
      var t = Ue.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && process.nextTick(Hn, this), t;
    };
    function Hn(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
    }
    function ys(e) {
      w3("readable nexttick read 0"), e.read(0);
    }
    _4.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (w3("resume"), e.flowing = !e.readableListening, gs(this, e)), e.paused = false, this;
    };
    function gs(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, process.nextTick(ws, e, t));
    }
    function ws(e, t) {
      w3("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), nr(e), t.flowing && !t.reading && e.read(0);
    }
    _4.prototype.pause = function() {
      return w3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (w3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function nr(e) {
      var t = e._readableState;
      for (w3("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    _4.prototype.wrap = function(e) {
      var t = this, r = this._readableState, n = false;
      e.on("end", function() {
        if (w3("wrapped end"), r.decoder && !r.ended) {
          var a3 = r.decoder.end();
          a3 && a3.length && t.push(a3);
        }
        t.push(null);
      }), e.on("data", function(a3) {
        if (w3("wrapped data"), r.decoder && (a3 = r.decoder.write(a3)), !(r.objectMode && a3 == null) && !(!r.objectMode && (!a3 || !a3.length))) {
          var s2 = t.push(a3);
          s2 || (n = true, e.pause());
        }
      });
      for (var i in e)
        this[i] === undefined && typeof e[i] == "function" && (this[i] = function(s2) {
          return function() {
            return e[s2].apply(e, arguments);
          };
        }(i));
      for (var o2 = 0;o2 < Jt.length; o2++)
        e.on(Jt[o2], this.emit.bind(this, Jt[o2]));
      return this._read = function(a3) {
        w3("wrapped _read", a3), n && (n = false, e.resume());
      }, this;
    };
    typeof Symbol == "function" && (_4.prototype[Symbol.asyncIterator] = function() {
      return zt === undefined && (zt = On()), zt(this);
    });
    Object.defineProperty(_4.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(_4.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(_4.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } });
    _4._fromList = Wn;
    Object.defineProperty(_4.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wn(e, t) {
      if (t.length === 0)
        return null;
      var r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function er(e) {
      var t = e._readableState;
      w3("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, process.nextTick(ms, t, e));
    }
    function ms(e, t) {
      if (w3("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy();
      }
    }
    typeof Symbol == "function" && (_4.from = function(e, t) {
      return Zt === undefined && (Zt = Nn()), Zt(_4, e, t);
    });
    function $n(e, t) {
      for (var r = 0, n = e.length;r < n; r++)
        if (e[r] === t)
          return r;
      return -1;
    }
  });
  ir = b4((Kf, Vn) => {
    Vn.exports = z;
    var at3 = fe().codes, bs = at3.ERR_METHOD_NOT_IMPLEMENTED, _s = at3.ERR_MULTIPLE_CALLBACK, vs = at3.ERR_TRANSFORM_ALREADY_TRANSFORMING, Es = at3.ERR_TRANSFORM_WITH_LENGTH_0, st3 = ue();
    Q3()(z, st3);
    function xs(e, t) {
      var r = this._transformState;
      r.transforming = false;
      var n = r.writecb;
      if (n === null)
        return this.emit("error", new _s);
      r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
      var i = this._readableState;
      i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function z(e) {
      if (!(this instanceof z))
        return new z(e);
      st3.call(this, e), this._transformState = { afterTransform: xs.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Rs);
    }
    function Rs() {
      var e = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
        Kn(e, t, r);
      }) : Kn(this, null, null);
    }
    z.prototype.push = function(e, t) {
      return this._transformState.needTransform = false, st3.prototype.push.call(this, e, t);
    };
    z.prototype._transform = function(e, t, r) {
      r(new bs("_transform()"));
    };
    z.prototype._write = function(e, t, r) {
      var n = this._transformState;
      if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
      }
    };
    z.prototype._read = function(e) {
      var t = this._transformState;
      t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
    };
    z.prototype._destroy = function(e, t) {
      st3.prototype._destroy.call(this, e, function(r) {
        t(r);
      });
    };
    function Kn(e, t, r) {
      if (t)
        return e.emit("error", t);
      if (r != null && e.push(r), e._writableState.length)
        throw new Es;
      if (e._transformState.transforming)
        throw new vs;
      return e.push(null);
    }
  });
  zn = b4((Vf, Xn) => {
    Xn.exports = Pe3;
    var Yn = ir();
    Q3()(Pe3, Yn);
    function Pe3(e) {
      if (!(this instanceof Pe3))
        return new Pe3(e);
      Yn.call(this, e);
    }
    Pe3.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  ti = b4((Yf, ei) => {
    var or;
    function Ss(e) {
      var t = false;
      return function() {
        t || (t = true, e.apply(undefined, arguments));
      };
    }
    var Qn2 = fe().codes, Ts = Qn2.ERR_MISSING_ARGS, As = Qn2.ERR_STREAM_DESTROYED;
    function Zn(e) {
      if (e)
        throw e;
    }
    function Bs(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Cs(e, t, r, n) {
      n = Ss(n);
      var i = false;
      e.on("close", function() {
        i = true;
      }), or === undefined && (or = et()), or(e, { readable: t, writable: r }, function(a3) {
        if (a3)
          return n(a3);
        i = true, n();
      });
      var o2 = false;
      return function(a3) {
        if (!i && !o2) {
          if (o2 = true, Bs(e))
            return e.abort();
          if (typeof e.destroy == "function")
            return e.destroy();
          n(a3 || new As("pipe"));
        }
      };
    }
    function Jn(e) {
      e();
    }
    function Is(e, t) {
      return e.pipe(t);
    }
    function Ls(e) {
      return !e.length || typeof e[e.length - 1] != "function" ? Zn : e.pop();
    }
    function Ms() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      var n = Ls(t);
      if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
        throw new Ts("streams");
      var i, o2 = t.map(function(a3, s2) {
        var u3 = s2 < t.length - 1, l3 = s2 > 0;
        return Cs(a3, u3, l3, function(h5) {
          i || (i = h5), h5 && o2.forEach(Jn), !u3 && (o2.forEach(Jn), n(i));
        });
      });
      return t.reduce(Is);
    }
    ei.exports = Ms;
  });
  ar = b4((q3, ri2) => {
    q3 = ri2.exports = Ht();
    q3.Stream = q3;
    q3.Readable = q3;
    q3.Writable = Dt();
    q3.Duplex = ue();
    q3.Transform = ir();
    q3.PassThrough = zn();
    q3.finished = et();
    q3.pipeline = ti();
  });
  ur = b4((fr) => {
    var ni = gt2(), Os = Q3(), ii2 = ar(), ft2 = fr.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, sr = fr.IncomingMessage = function(e, t, r, n) {
      var i = this;
      if (ii2.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
        process.nextTick(function() {
          i.emit("close");
        });
      }), r === "fetch") {
        let c2 = function() {
          a3.read().then(function(d4) {
            if (!i._destroyed) {
              if (n(d4.done), d4.done) {
                i.push(null);
                return;
              }
              i.push(Buffer.from(d4.value)), c2();
            }
          }).catch(function(d4) {
            n(true), i._destroyed || i.emit("error", d4);
          });
        };
        var h5 = c2;
        if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(d4, p3) {
          i.headers[p3.toLowerCase()] = d4, i.rawHeaders.push(p3, d4);
        }), ni.writableStream) {
          var o2 = new WritableStream({ write: function(d4) {
            return n(false), new Promise(function(p3, g5) {
              i._destroyed ? g5() : i.push(Buffer.from(d4)) ? p3() : i._resumeFetch = p3;
            });
          }, close: function() {
            n(true), i._destroyed || i.push(null);
          }, abort: function(d4) {
            n(true), i._destroyed || i.emit("error", d4);
          } });
          try {
            t.body.pipeTo(o2).catch(function(d4) {
              n(true), i._destroyed || i.emit("error", d4);
            });
            return;
          } catch {
          }
        }
        var a3 = t.body.getReader();
        c2();
      } else {
        i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
        var s2 = e.getAllResponseHeaders().split(/\r?\n/);
        if (s2.forEach(function(c2) {
          var d4 = c2.match(/^([^:]+):\s*(.*)/);
          if (d4) {
            var p3 = d4[1].toLowerCase();
            p3 === "set-cookie" ? (i.headers[p3] === undefined && (i.headers[p3] = []), i.headers[p3].push(d4[2])) : i.headers[p3] !== undefined ? i.headers[p3] += ", " + d4[2] : i.headers[p3] = d4[2], i.rawHeaders.push(d4[1], d4[2]);
          }
        }), i._charset = "x-user-defined", !ni.overrideMimeType) {
          var u3 = i.rawHeaders["mime-type"];
          if (u3) {
            var l3 = u3.match(/;\s*charset=([^;])(;|$)/);
            l3 && (i._charset = l3[1].toLowerCase());
          }
          i._charset || (i._charset = "utf-8");
        }
      }
    };
    Os(sr, ii2.Readable);
    sr.prototype._read = function() {
      var e = this, t = e._resumeFetch;
      t && (e._resumeFetch = null, t());
    };
    sr.prototype._onXHRProgress = function(e) {
      var t = this, r = t._xhr, n = null;
      switch (t._mode) {
        case "text":
          if (n = r.responseText, n.length > t._pos) {
            var i = n.substr(t._pos);
            if (t._charset === "x-user-defined") {
              for (var o2 = Buffer.alloc(i.length), a3 = 0;a3 < i.length; a3++)
                o2[a3] = i.charCodeAt(a3) & 255;
              t.push(o2);
            } else
              t.push(i, t._charset);
            t._pos = n.length;
          }
          break;
        case "arraybuffer":
          if (r.readyState !== ft2.DONE || !r.response)
            break;
          n = r.response, t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "moz-chunked-arraybuffer":
          if (n = r.response, r.readyState !== ft2.LOADING || !n)
            break;
          t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "ms-stream":
          if (n = r.response, r.readyState !== ft2.LOADING)
            break;
          var s2 = new global.MSStreamReader;
          s2.onprogress = function() {
            s2.result.byteLength > t._pos && (t.push(Buffer.from(new Uint8Array(s2.result.slice(t._pos)))), t._pos = s2.result.byteLength);
          }, s2.onload = function() {
            e(true), t.push(null);
          }, s2.readAsArrayBuffer(n);
          break;
      }
      t._xhr.readyState === ft2.DONE && t._mode !== "ms-stream" && (e(true), t.push(null));
    };
  });
  fi = b4((zf2, si) => {
    var pe = gt2(), Fs = Q3(), ai2 = ur(), lr = ar(), Ns = ai2.IncomingMessage, oi = ai2.readyStates;
    function Us2(e, t) {
      return pe.fetch && t ? "fetch" : pe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : pe.msstream ? "ms-stream" : pe.arraybuffer && e ? "arraybuffer" : "text";
    }
    var M3 = si.exports = function(e) {
      var t = this;
      lr.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
        t.setHeader(i, e.headers[i]);
      });
      var r, n = true;
      if (e.mode === "disable-fetch" || "requestTimeout" in e && !pe.abortController)
        n = false, r = true;
      else if (e.mode === "prefer-streaming")
        r = false;
      else if (e.mode === "allow-wrong-content-type")
        r = !pe.overrideMimeType;
      else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
        r = true;
      else
        throw new Error("Invalid value for opts.mode");
      t._mode = Us2(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
        t._onFinish();
      });
    };
    Fs(M3, lr.Writable);
    M3.prototype.setHeader = function(e, t) {
      var r = this, n = e.toLowerCase();
      qs.indexOf(n) === -1 && (r._headers[n] = { name: e, value: t });
    };
    M3.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null;
    };
    M3.prototype.removeHeader = function(e) {
      var t = this;
      delete t._headers[e.toLowerCase()];
    };
    M3.prototype._onFinish = function() {
      var e = this;
      if (!e._destroyed) {
        var t = e._opts;
        "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
        var r = e._headers, n = null;
        t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, { type: (r["content-type"] || {}).value || "" }));
        var i = [];
        if (Object.keys(r).forEach(function(u3) {
          var l3 = r[u3].name, h5 = r[u3].value;
          Array.isArray(h5) ? h5.forEach(function(c2) {
            i.push([l3, c2]);
          }) : i.push([l3, h5]);
        }), e._mode === "fetch") {
          var o2 = null;
          if (pe.abortController) {
            var a3 = new AbortController;
            o2 = a3.signal, e._fetchAbortController = a3, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = global.setTimeout(function() {
              e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
            }, t.requestTimeout));
          }
          global.fetch(e._opts.url, { method: e._opts.method, headers: i, body: n || undefined, mode: "cors", credentials: t.withCredentials ? "include" : "same-origin", signal: o2 }).then(function(u3) {
            e._fetchResponse = u3, e._resetTimers(false), e._connect();
          }, function(u3) {
            e._resetTimers(true), e._destroyed || e.emit("error", u3);
          });
        } else {
          var s2 = e._xhr = new global.XMLHttpRequest;
          try {
            s2.open(e._opts.method, e._opts.url, true);
          } catch (u3) {
            process.nextTick(function() {
              e.emit("error", u3);
            });
            return;
          }
          "responseType" in s2 && (s2.responseType = e._mode), "withCredentials" in s2 && (s2.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in s2 && s2.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (s2.timeout = t.requestTimeout, s2.ontimeout = function() {
            e.emit("requestTimeout");
          }), i.forEach(function(u3) {
            s2.setRequestHeader(u3[0], u3[1]);
          }), e._response = null, s2.onreadystatechange = function() {
            switch (s2.readyState) {
              case oi.LOADING:
              case oi.DONE:
                e._onXHRProgress();
                break;
            }
          }, e._mode === "moz-chunked-arraybuffer" && (s2.onprogress = function() {
            e._onXHRProgress();
          }), s2.onerror = function() {
            e._destroyed || (e._resetTimers(true), e.emit("error", new Error("XHR error")));
          };
          try {
            s2.send(n);
          } catch (u3) {
            process.nextTick(function() {
              e.emit("error", u3);
            });
            return;
          }
        }
      }
    };
    function Ps(e) {
      try {
        var t = e.status;
        return t !== null && t !== 0;
      } catch {
        return false;
      }
    }
    M3.prototype._onXHRProgress = function() {
      var e = this;
      e._resetTimers(false), !(!Ps(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
    };
    M3.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new Ns(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
        e.emit("error", t);
      }), e.emit("response", e._response));
    };
    M3.prototype._write = function(e, t, r) {
      var n = this;
      n._body.push(e), r();
    };
    M3.prototype._resetTimers = function(e) {
      var t = this;
      global.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (global.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = global.setTimeout(function() {
        t.emit("timeout");
      }, t._socketTimeout));
    };
    M3.prototype.abort = M3.prototype.destroy = function(e) {
      var t = this;
      t._destroyed = true, t._resetTimers(true), t._response && (t._response._destroyed = true), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
    };
    M3.prototype.end = function(e, t, r) {
      var n = this;
      typeof e == "function" && (r = e, e = undefined), lr.Writable.prototype.end.call(n, e, t, r);
    };
    M3.prototype.setTimeout = function(e, t) {
      var r = this;
      t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(false);
    };
    M3.prototype.flushHeaders = function() {
    };
    M3.prototype.setNoDelay = function() {
    };
    M3.prototype.setSocketKeepAlive = function() {
    };
    var qs = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  li = b4((Zf, ui) => {
    ui.exports = ks;
    var Ds = Object.prototype.hasOwnProperty;
    function ks() {
      for (var e = {}, t = 0;t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Ds.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }
  });
  ci = b4((Jf, hi) => {
    hi.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
  });
  _i = {};
  Er2(_i, { decode: () => pr, default: () => Ys, encode: () => yr, toASCII: () => bi, toUnicode: () => mi, ucs2decode: () => dr2, ucs2encode: () => gi2 });
  vi = vr(() => {
    pi = "-", js = /^xn--/, Hs = /[^\0-\x7F]/, Ws = /[\x2E\u3002\uFF0E\uFF61]/g, $s = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, hr = 36 - 1, K3 = Math.floor, cr = String.fromCharCode;
    gi2 = (e) => String.fromCodePoint(...e), Ks = function(e) {
      return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36;
    }, di = function(e, t) {
      return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
    }, wi2 = function(e, t, r) {
      let n = 0;
      for (e = r ? K3(e / 700) : e >> 1, e += K3(e / t);e > hr * 26 >> 1; n += 36)
        e = K3(e / hr);
      return K3(n + (hr + 1) * e / (e + 38));
    }, pr = function(e) {
      let t = [], r = e.length, n = 0, i = 128, o2 = 72, a3 = e.lastIndexOf(pi);
      a3 < 0 && (a3 = 0);
      for (let s2 = 0;s2 < a3; ++s2)
        e.charCodeAt(s2) >= 128 && oe("not-basic"), t.push(e.charCodeAt(s2));
      for (let s2 = a3 > 0 ? a3 + 1 : 0;s2 < r; ) {
        let u3 = n;
        for (let h5 = 1, c2 = 36;; c2 += 36) {
          s2 >= r && oe("invalid-input");
          let d4 = Ks(e.charCodeAt(s2++));
          d4 >= 36 && oe("invalid-input"), d4 > K3((2147483647 - n) / h5) && oe("overflow"), n += d4 * h5;
          let p3 = c2 <= o2 ? 1 : c2 >= o2 + 26 ? 26 : c2 - o2;
          if (d4 < p3)
            break;
          let g5 = 36 - p3;
          h5 > K3(2147483647 / g5) && oe("overflow"), h5 *= g5;
        }
        let l3 = t.length + 1;
        o2 = wi2(n - u3, l3, u3 == 0), K3(n / l3) > 2147483647 - i && oe("overflow"), i += K3(n / l3), n %= l3, t.splice(n++, 0, i);
      }
      return String.fromCodePoint(...t);
    }, yr = function(e) {
      let t = [];
      e = dr2(e);
      let r = e.length, n = 128, i = 0, o2 = 72;
      for (let u3 of e)
        u3 < 128 && t.push(cr(u3));
      let a3 = t.length, s2 = a3;
      for (a3 && t.push(pi);s2 < r; ) {
        let u3 = 2147483647;
        for (let h5 of e)
          h5 >= n && h5 < u3 && (u3 = h5);
        let l3 = s2 + 1;
        u3 - n > K3((2147483647 - i) / l3) && oe("overflow"), i += (u3 - n) * l3, n = u3;
        for (let h5 of e)
          if (h5 < n && ++i > 2147483647 && oe("overflow"), h5 === n) {
            let c2 = i;
            for (let d4 = 36;; d4 += 36) {
              let p3 = d4 <= o2 ? 1 : d4 >= o2 + 26 ? 26 : d4 - o2;
              if (c2 < p3)
                break;
              let g5 = c2 - p3, E5 = 36 - p3;
              t.push(cr(di(p3 + g5 % E5, 0))), c2 = K3(g5 / E5);
            }
            t.push(cr(di(c2, 0))), o2 = wi2(i, l3, s2 === a3), i = 0, ++s2;
          }
        ++i, ++n;
      }
      return t.join("");
    }, mi = function(e) {
      return yi(e, function(t) {
        return js.test(t) ? pr(t.slice(4).toLowerCase()) : t;
      });
    }, bi = function(e) {
      return yi(e, function(t) {
        return Hs.test(t) ? "xn--" + yr(t) : t;
      });
    }, Vs = { version: "2.1.0", ucs2: { decode: dr2, encode: gi2 }, decode: pr, encode: yr, toASCII: bi, toUnicode: mi }, Ys = Vs;
  });
  xi = b4((Qf, Ei) => {
    Ei.exports = { isString: function(e) {
      return typeof e == "string";
    }, isObject: function(e) {
      return typeof e == "object" && e !== null;
    }, isNull: function(e) {
      return e === null;
    }, isNullOrUndefined: function(e) {
      return e == null;
    } };
  });
  Si2 = b4((eu, Ri) => {
    var Xs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, zs = Object.keys || function() {
      var e = Object.prototype.hasOwnProperty, t = !{ toString: null }.propertyIsEnumerable("toString"), r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], n = r.length;
      return function(i) {
        if (typeof i != "function" && ((typeof i > "u" ? "undefined" : Xs(i)) !== "object" || i === null))
          throw new TypeError("Object.keys called on non-object");
        var o2 = [], a3, s2;
        for (a3 in i)
          e.call(i, a3) && o2.push(a3);
        if (t)
          for (s2 = 0;s2 < n; s2++)
            e.call(i, r[s2]) && o2.push(r[s2]);
        return o2;
      };
    }();
    Ri.exports = zs;
  });
  Ni = b4((tu, Fi) => {
    var Li = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, lt3 = Fi.exports = { unescapeBuffer: ef, unescape: Oi, escape: rf, stringify: Bi, encode: Bi, parse: Ii, decode: Ii }, Zs = _e().Buffer, Js = Si2(), Qs = function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    }, Ti = function(t, r, n) {
      var i;
      if (t == null)
        throw new TypeError('"arr" is null or not defined');
      var o2 = Object(t), a3 = o2.length >>> 0;
      if (a3 === 0)
        return -1;
      var s2 = n | 0;
      if (s2 >= a3)
        return -1;
      for (i = Math.max(s2 >= 0 ? s2 : a3 - Math.abs(s2), 0);i < a3; ) {
        if (i in o2 && o2[i] === r)
          return i;
        i++;
      }
      return -1;
    };
    function Mi() {
    }
    Mi.prototype = Object.create ? Object.create(null) : {};
    var Ai2 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    function ef(e, t) {
      for (var r = Zs.allocUnsafe(e.length), n = 0, i, o2, a3, s2, u3 = 0, l3 = 0;; u3++) {
        if (u3 < e.length)
          s2 = e.charCodeAt(u3);
        else {
          n > 0 && (r[l3++] = 37, n === 2 && (r[l3++] = a3));
          break;
        }
        switch (n) {
          case 0:
            switch (s2) {
              case 37:
                i = 0, o2 = 0, n = 1;
                break;
              case 43:
                t && (s2 = 32);
              default:
                r[l3++] = s2;
                break;
            }
            break;
          case 1:
            if (a3 = s2, i = Ai2[s2], !(i >= 0)) {
              r[l3++] = 37, r[l3++] = s2, n = 0;
              break;
            }
            n = 2;
            break;
          case 2:
            if (n = 0, o2 = Ai2[s2], !(o2 >= 0)) {
              r[l3++] = 37, r[l3++] = a3, r[l3++] = s2;
              break;
            }
            r[l3++] = 16 * i + o2;
            break;
        }
      }
      return r.slice(0, l3);
    }
    function Oi(e, t) {
      try {
        return decodeURIComponent(e);
      } catch {
        return lt3.unescapeBuffer(e, t).toString();
      }
    }
    var k3 = [];
    for (Se2 = 0;Se2 < 256; ++Se2)
      k3[Se2] = "%" + ((Se2 < 16 ? "0" : "") + Se2.toString(16)).toUpperCase();
    var Se2, tf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0];
    function rf(e) {
      typeof e != "string" && ((typeof e > "u" ? "undefined" : Li(e)) === "object" ? e = String(e) : e += "");
      for (var t = "", r = 0, n = 0;n < e.length; ++n) {
        var i = e.charCodeAt(n);
        if (i < 128) {
          if (tf[i] === 1)
            continue;
          r < n && (t += e.slice(r, n)), r = n + 1, t += k3[i];
          continue;
        }
        if (r < n && (t += e.slice(r, n)), i < 2048) {
          r = n + 1, t += k3[192 | i >> 6] + k3[128 | i & 63];
          continue;
        }
        if (i < 55296 || i >= 57344) {
          r = n + 1, t += k3[224 | i >> 12] + k3[128 | i >> 6 & 63] + k3[128 | i & 63];
          continue;
        }
        ++n;
        var o2;
        if (n < e.length)
          o2 = e.charCodeAt(n) & 1023;
        else
          throw new URIError("URI malformed");
        r = n + 1, i = 65536 + ((i & 1023) << 10 | o2), t += k3[240 | i >> 18] + k3[128 | i >> 12 & 63] + k3[128 | i >> 6 & 63] + k3[128 | i & 63];
      }
      return r === 0 ? e : r < e.length ? t + e.slice(r) : t;
    }
    function gr3(e) {
      return typeof e == "string" ? e : typeof e == "number" && isFinite(e) ? "" + e : typeof e == "boolean" ? e ? "true" : "false" : "";
    }
    function Bi(e, t, r, n) {
      t = t || "&", r = r || "=";
      var i = lt3.escape;
      if (n && typeof n.encodeURIComponent == "function" && (i = n.encodeURIComponent), e !== null && (typeof e > "u" ? "undefined" : Li(e)) === "object") {
        for (var o2 = Js(e), a3 = o2.length, s2 = a3 - 1, u3 = "", l3 = 0;l3 < a3; ++l3) {
          var h5 = o2[l3], c2 = e[h5], d4 = i(gr3(h5)) + r;
          if (Qs(c2)) {
            for (var p3 = c2.length, g5 = p3 - 1, E5 = 0;E5 < p3; ++E5)
              u3 += d4 + i(gr3(c2[E5])), E5 < g5 && (u3 += t);
            p3 && l3 < s2 && (u3 += t);
          } else
            u3 += d4 + i(gr3(c2)), l3 < s2 && (u3 += t);
        }
        return u3;
      }
      return "";
    }
    function Ci(e) {
      if (e.length === 0)
        return [];
      if (e.length === 1)
        return [e.charCodeAt(0)];
      for (var t = [], r = 0;r < e.length; ++r)
        t[t.length] = e.charCodeAt(r);
      return t;
    }
    var nf = [38], of = [61];
    function Ii(e, t, r, n) {
      var i = new Mi;
      if (typeof e != "string" || e.length === 0)
        return i;
      var o2 = t ? Ci(t + "") : nf, a3 = r ? Ci(r + "") : of, s2 = o2.length, u3 = a3.length, l3 = 1000;
      n && typeof n.maxKeys == "number" && (l3 = n.maxKeys > 0 ? n.maxKeys : -1);
      var h5 = lt3.unescape;
      n && typeof n.decodeURIComponent == "function" && (h5 = n.decodeURIComponent);
      for (var c2 = h5 !== Oi, d4 = [], p3 = 0, g5 = 0, E5 = 0, v4 = 0, m3 = "", y5 = "", R4 = c2, I4 = c2, T3 = 0, S3 = 0;S3 < e.length; ++S3) {
        var B3 = e.charCodeAt(S3);
        if (B3 === o2[E5]) {
          if (++E5 === s2) {
            var F2 = S3 - E5 + 1;
            if (v4 < u3 ? g5 < F2 && (m3 += e.slice(g5, F2)) : g5 < F2 && (y5 += e.slice(g5, F2)), R4 && (m3 = ut2(m3, h5)), I4 && (y5 = ut2(y5, h5)), m3 || y5 || g5 - p3 > s2 || S3 === 0)
              if (Ti(d4, m3) === -1)
                i[m3] = y5, d4[d4.length] = m3;
              else {
                var L4 = i[m3] || "";
                L4.pop ? L4[L4.length] = y5 : L4 && (i[m3] = [L4, y5]);
              }
            else
              S3 === 1 && delete i[m3];
            if (--l3 === 0)
              break;
            R4 = I4 = c2, T3 = 0, m3 = y5 = "", p3 = g5, g5 = S3 + 1, E5 = v4 = 0;
          }
          continue;
        } else
          E5 = 0, I4 || (B3 === 37 ? T3 = 1 : T3 > 0 && (B3 >= 48 && B3 <= 57 || B3 >= 65 && B3 <= 70 || B3 >= 97 && B3 <= 102) ? ++T3 === 3 && (I4 = true) : T3 = 0);
        if (v4 < u3)
          if (B3 === a3[v4]) {
            if (++v4 === u3) {
              var Y3 = S3 - v4 + 1;
              g5 < Y3 && (m3 += e.slice(g5, Y3)), T3 = 0, g5 = S3 + 1;
            }
            continue;
          } else
            v4 = 0, R4 || (B3 === 37 ? T3 = 1 : T3 > 0 && (B3 >= 48 && B3 <= 57 || B3 >= 65 && B3 <= 70 || B3 >= 97 && B3 <= 102) ? ++T3 === 3 && (R4 = true) : T3 = 0);
        B3 === 43 && (v4 < u3 ? (g5 < S3 && (m3 += e.slice(g5, S3)), m3 += "%20", R4 = true) : (g5 < S3 && (y5 += e.slice(g5, S3)), y5 += "%20", I4 = true), g5 = S3 + 1);
      }
      if (l3 !== 0 && (g5 < e.length || v4 > 0))
        if (g5 < e.length && (v4 < u3 ? m3 += e.slice(g5) : E5 < s2 && (y5 += e.slice(g5))), R4 && (m3 = ut2(m3, h5)), I4 && (y5 = ut2(y5, h5)), Ti(d4, m3) === -1)
          i[m3] = y5, d4[d4.length] = m3;
        else {
          var Z3 = i[m3];
          Z3.pop ? Z3[Z3.length] = y5 : i[m3] = [Z3, y5];
        }
      return i;
    }
    function ut2(e, t) {
      try {
        return t(e);
      } catch {
        return lt3.unescape(e, true);
      }
    }
  });
  Di = b4((Ae2) => {
    var af = (vi(), dt2(_i)), V5 = xi();
    Ae2.parse = qe2;
    Ae2.resolve = gf;
    Ae2.resolveObject = wf;
    Ae2.format = yf2;
    Ae2.Url = D3;
    function D3() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var sf = /^([a-z0-9.+-]+:)/i, ff2 = /:[0-9]*$/, uf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, lf = ["<", ">", '"', "`", " ", "\r", `
`, "\t"], hf = ["{", "}", "|", "\\", "^", "`"].concat(lf), wr = ["'"].concat(hf), Ui = ["%", "/", "?", ";", "#"].concat(wr), Pi = ["/", "?", "#"], cf2 = 255, qi = /^[+a-z0-9A-Z_-]{0,63}$/, df = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, pf = { javascript: true, "javascript:": true }, mr2 = { javascript: true, "javascript:": true }, Te = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, br3 = Ni();
    function qe2(e, t, r) {
      if (e && V5.isObject(e) && e instanceof D3)
        return e;
      var n = new D3;
      return n.parse(e, t, r), n;
    }
    D3.prototype.parse = function(e, t, r) {
      if (!V5.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
      var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o2 = e.split(i), a3 = /\\/g;
      o2[0] = o2[0].replace(a3, "/"), e = o2.join(i);
      var s2 = e;
      if (s2 = s2.trim(), !r && e.split("#").length === 1) {
        var u3 = uf.exec(s2);
        if (u3)
          return this.path = s2, this.href = s2, this.pathname = u3[1], u3[2] ? (this.search = u3[2], t ? this.query = br3.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
      }
      var l3 = sf.exec(s2);
      if (l3) {
        l3 = l3[0];
        var h5 = l3.toLowerCase();
        this.protocol = h5, s2 = s2.substr(l3.length);
      }
      if (r || l3 || s2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var c2 = s2.substr(0, 2) === "//";
        c2 && !(l3 && mr2[l3]) && (s2 = s2.substr(2), this.slashes = true);
      }
      if (!mr2[l3] && (c2 || l3 && !Te[l3])) {
        for (var d4 = -1, p3 = 0;p3 < Pi.length; p3++) {
          var g5 = s2.indexOf(Pi[p3]);
          g5 !== -1 && (d4 === -1 || g5 < d4) && (d4 = g5);
        }
        var E5, v4;
        d4 === -1 ? v4 = s2.lastIndexOf("@") : v4 = s2.lastIndexOf("@", d4), v4 !== -1 && (E5 = s2.slice(0, v4), s2 = s2.slice(v4 + 1), this.auth = decodeURIComponent(E5)), d4 = -1;
        for (var p3 = 0;p3 < Ui.length; p3++) {
          var g5 = s2.indexOf(Ui[p3]);
          g5 !== -1 && (d4 === -1 || g5 < d4) && (d4 = g5);
        }
        d4 === -1 && (d4 = s2.length), this.host = s2.slice(0, d4), s2 = s2.slice(d4), this.parseHost(), this.hostname = this.hostname || "";
        var m3 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!m3)
          for (var y5 = this.hostname.split(/\./), p3 = 0, R4 = y5.length;p3 < R4; p3++) {
            var I4 = y5[p3];
            if (!!I4 && !I4.match(qi)) {
              for (var T3 = "", S3 = 0, B3 = I4.length;S3 < B3; S3++)
                I4.charCodeAt(S3) > 127 ? T3 += "x" : T3 += I4[S3];
              if (!T3.match(qi)) {
                var F2 = y5.slice(0, p3), L4 = y5.slice(p3 + 1), Y3 = I4.match(df);
                Y3 && (F2.push(Y3[1]), L4.unshift(Y3[2])), L4.length && (s2 = "/" + L4.join(".") + s2), this.hostname = F2.join(".");
                break;
              }
            }
          }
        this.hostname.length > cf2 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m3 || (this.hostname = af.toASCII(this.hostname));
        var Z3 = this.port ? ":" + this.port : "", Wi = this.hostname || "";
        this.host = Wi + Z3, this.href += this.host, m3 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s2[0] !== "/" && (s2 = "/" + s2));
      }
      if (!pf[h5])
        for (var p3 = 0, R4 = wr.length;p3 < R4; p3++) {
          var Be = wr[p3];
          if (s2.indexOf(Be) !== -1) {
            var ht2 = encodeURIComponent(Be);
            ht2 === Be && (ht2 = escape(Be)), s2 = s2.split(Be).join(ht2);
          }
        }
      var ct3 = s2.indexOf("#");
      ct3 !== -1 && (this.hash = s2.substr(ct3), s2 = s2.slice(0, ct3));
      var De = s2.indexOf("?");
      if (De !== -1 ? (this.search = s2.substr(De), this.query = s2.substr(De + 1), t && (this.query = br3.parse(this.query)), s2 = s2.slice(0, De)) : t && (this.search = "", this.query = {}), s2 && (this.pathname = s2), Te[h5] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Z3 = this.pathname || "", $i = this.search || "";
        this.path = Z3 + $i;
      }
      return this.href = this.format(), this;
    };
    function yf2(e) {
      return V5.isString(e) && (e = qe2(e)), e instanceof D3 ? e.format() : D3.prototype.format.call(e);
    }
    D3.prototype.format = function() {
      var e = this.auth || "";
      e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
      var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = false, o2 = "";
      this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && V5.isObject(this.query) && Object.keys(this.query).length && (o2 = br3.stringify(this.query));
      var a3 = this.search || o2 && "?" + o2 || "";
      return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Te[t]) && i !== false ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a3 && a3.charAt(0) !== "?" && (a3 = "?" + a3), r = r.replace(/[?#]/g, function(s2) {
        return encodeURIComponent(s2);
      }), a3 = a3.replace("#", "%23"), t + i + r + a3 + n;
    };
    function gf(e, t) {
      return qe2(e, false, true).resolve(t);
    }
    D3.prototype.resolve = function(e) {
      return this.resolveObject(qe2(e, false, true)).format();
    };
    function wf(e, t) {
      return e ? qe2(e, false, true).resolveObject(t) : t;
    }
    D3.prototype.resolveObject = function(e) {
      if (V5.isString(e)) {
        var t = new D3;
        t.parse(e, false, true), e = t;
      }
      for (var r = new D3, n = Object.keys(this), i = 0;i < n.length; i++) {
        var o2 = n[i];
        r[o2] = this[o2];
      }
      if (r.hash = e.hash, e.href === "")
        return r.href = r.format(), r;
      if (e.slashes && !e.protocol) {
        for (var a3 = Object.keys(e), s2 = 0;s2 < a3.length; s2++) {
          var u3 = a3[s2];
          u3 !== "protocol" && (r[u3] = e[u3]);
        }
        return Te[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
      }
      if (e.protocol && e.protocol !== r.protocol) {
        if (!Te[e.protocol]) {
          for (var l3 = Object.keys(e), h5 = 0;h5 < l3.length; h5++) {
            var c2 = l3[h5];
            r[c2] = e[c2];
          }
          return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !mr2[e.protocol]) {
          for (var R4 = (e.pathname || "").split("/");R4.length && !(e.host = R4.shift()); )
            ;
          e.host || (e.host = ""), e.hostname || (e.hostname = ""), R4[0] !== "" && R4.unshift(""), R4.length < 2 && R4.unshift(""), r.pathname = R4.join("/");
        } else
          r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
          var d4 = r.pathname || "", p3 = r.search || "";
          r.path = d4 + p3;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }
      var g5 = r.pathname && r.pathname.charAt(0) === "/", E5 = e.host || e.pathname && e.pathname.charAt(0) === "/", v4 = E5 || g5 || r.host && e.pathname, m3 = v4, y5 = r.pathname && r.pathname.split("/") || [], R4 = e.pathname && e.pathname.split("/") || [], I4 = r.protocol && !Te[r.protocol];
      if (I4 && (r.hostname = "", r.port = null, r.host && (y5[0] === "" ? y5[0] = r.host : y5.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (R4[0] === "" ? R4[0] = e.host : R4.unshift(e.host)), e.host = null), v4 = v4 && (R4[0] === "" || y5[0] === "")), E5)
        r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, y5 = R4;
      else if (R4.length)
        y5 || (y5 = []), y5.pop(), y5 = y5.concat(R4), r.search = e.search, r.query = e.query;
      else if (!V5.isNullOrUndefined(e.search)) {
        if (I4) {
          r.hostname = r.host = y5.shift();
          var T3 = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
          T3 && (r.auth = T3.shift(), r.host = r.hostname = T3.shift());
        }
        return r.search = e.search, r.query = e.query, (!V5.isNull(r.pathname) || !V5.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
      }
      if (!y5.length)
        return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
      for (var S3 = y5.slice(-1)[0], B3 = (r.host || e.host || y5.length > 1) && (S3 === "." || S3 === "..") || S3 === "", F2 = 0, L4 = y5.length;L4 >= 0; L4--)
        S3 = y5[L4], S3 === "." ? y5.splice(L4, 1) : S3 === ".." ? (y5.splice(L4, 1), F2++) : F2 && (y5.splice(L4, 1), F2--);
      if (!v4 && !m3)
        for (;F2--; F2)
          y5.unshift("..");
      v4 && y5[0] !== "" && (!y5[0] || y5[0].charAt(0) !== "/") && y5.unshift(""), B3 && y5.join("/").substr(-1) !== "/" && y5.push("");
      var Y3 = y5[0] === "" || y5[0] && y5[0].charAt(0) === "/";
      if (I4) {
        r.hostname = r.host = Y3 ? "" : y5.length ? y5.shift() : "";
        var T3 = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
        T3 && (r.auth = T3.shift(), r.host = r.hostname = T3.shift());
      }
      return v4 = v4 || r.host && y5.length, v4 && !Y3 && y5.unshift(""), y5.length ? r.pathname = y5.join("/") : (r.pathname = null, r.path = null), (!V5.isNull(r.pathname) || !V5.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    };
    D3.prototype.parseHost = function() {
      var e = this.host, t = ff2.exec(e);
      t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
    };
  });
  Hi = b4((ji) => {
    var ki = fi(), mf2 = ur(), bf = li(), _f = ci(), vf2 = Di(), j5 = ji;
    j5.request = function(e, t) {
      typeof e == "string" ? e = vf2.parse(e) : e = bf(e);
      var r = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", n = e.protocol || r, i = e.hostname || e.host, o2 = e.port, a3 = e.path || "/";
      i && i.indexOf(":") !== -1 && (i = "[" + i + "]"), e.url = (i ? n + "//" + i : "") + (o2 ? ":" + o2 : "") + a3, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
      var s2 = new ki(e);
      return t && s2.on("response", t), s2;
    };
    j5.get = function(t, r) {
      var n = j5.request(t, r);
      return n.end(), n;
    };
    j5.ClientRequest = ki;
    j5.IncomingMessage = mf2.IncomingMessage;
    j5.Agent = function() {
    };
    j5.Agent.defaultMaxSockets = 4;
    j5.globalAgent = new j5.Agent;
    j5.STATUS_CODES = _f;
    j5.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  _r = Rr2(Hi());
  iu = _r.default;
  ({ request: ou, get: au, ClientRequest: su, IncomingMessage: fu, Agent: uu, globalAgent: lu, STATUS_CODES: hu, METHODS: cu } = _r.default);
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node:https
var exports_https = {};
__export(exports_https, {
  default: () => Cf2
});
function oe2(e) {
  throw new RangeError(Zs[e]);
}
function Js(e, t) {
  let r = [], n = e.length;
  for (;n--; )
    r[n] = t(e[n]);
  return r;
}
function vi2(e, t) {
  let r = e.split("@"), n = "";
  r.length > 1 && (n = r[0] + "@", e = r[1]), e = e.replace(zs, ".");
  let i = e.split("."), o2 = Js(i, t).join(".");
  return n + o2;
}
function _r2(e) {
  let t = [], r = 0, n = e.length;
  for (;r < n; ) {
    let i = e.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      let o2 = e.charCodeAt(r++);
      (o2 & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o2 & 1023) + 65536) : (t.push(i), r--);
    } else
      t.push(i);
  }
  return t;
}
var Ji, He, Qi, eo, to, ro, Cr = (e, t) => () => (e && (t = e(e = 0)), t), b5 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), mt3 = (e, t) => {
  for (var r in t)
    He(e, r, { get: t[r], enumerable: true });
}, We = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of eo(t))
      !ro.call(e, i) && i !== r && He(e, i, { get: () => t[i], enumerable: !(n = Qi(t, i)) || n.enumerable });
  return e;
}, $e = (e, t, r) => (We(e, t, "default"), r && We(r, t, "default")), bt3 = (e, t, r) => (r = e != null ? Ji(to(e)) : {}, We(t || !e || !e.__esModule ? He(r, "default", { value: e, enumerable: true }) : r, e)), _t3 = (e) => We(He({}, "__esModule", { value: true }), e), xt, Q4, Tt3, At3, $r, Gr, _e2, qt, cn, jt, fe2, Wt, _n, Kt2, ue2, Ln2, Fn, Qt, nt3, er, it2, Dn2, jn, Xt, hr2, ri2, si, dr3, gr3, pi2, gi3, mi2, Ti, _i2, Ys2, Xs, zs, Zs, mr2, K4, br3, Ei, Qs, bi2, xi2, vr2, Er3, Ri, Si3, ef, tf, Ai2, Ii, Li, ji, Ar2, Vi2, Ir3, ke2, Cf2;
var init_https = __esm(() => {
  Ji = Object.create;
  He = Object.defineProperty;
  Qi = Object.getOwnPropertyDescriptor;
  eo = Object.getOwnPropertyNames;
  to = Object.getPrototypeOf;
  ro = Object.prototype.hasOwnProperty;
  xt = b5((N6) => {
    N6.fetch = Ie(global.fetch) && Ie(global.ReadableStream);
    N6.writableStream = Ie(global.WritableStream);
    N6.abortController = Ie(global.AbortController);
    var J2;
    function vt2() {
      if (J2 !== undefined)
        return J2;
      if (global.XMLHttpRequest) {
        J2 = new global.XMLHttpRequest;
        try {
          J2.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch {
          J2 = null;
        }
      } else
        J2 = null;
      return J2;
    }
    function Et(e) {
      var t = vt2();
      if (!t)
        return false;
      try {
        return t.responseType = e, t.responseType === e;
      } catch {
      }
      return false;
    }
    N6.arraybuffer = N6.fetch || Et("arraybuffer");
    N6.msstream = !N6.fetch && Et("ms-stream");
    N6.mozchunkedarraybuffer = !N6.fetch && Et("moz-chunked-arraybuffer");
    N6.overrideMimeType = N6.fetch || (vt2() ? Ie(vt2().overrideMimeType) : false);
    function Ie(e) {
      return typeof e == "function";
    }
    J2 = null;
  });
  Q4 = b5((Of, Rt2) => {
    typeof Object.create == "function" ? Rt2.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : Rt2.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {
        };
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  Tt3 = b5((Ff, St2) => {
    var ye2 = typeof Reflect == "object" ? Reflect : null, Lr = ye2 && typeof ye2.apply == "function" ? ye2.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, Ge;
    ye2 && typeof ye2.ownKeys == "function" ? Ge = ye2.ownKeys : Object.getOwnPropertySymbols ? Ge = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : Ge = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function no(e) {
      console && console.warn && console.warn(e);
    }
    var Or = Number.isNaN || function(t) {
      return t !== t;
    };
    function x5() {
      x5.init.call(this);
    }
    St2.exports = x5;
    St2.exports.once = so2;
    x5.EventEmitter = x5;
    x5.prototype._events = undefined;
    x5.prototype._eventsCount = 0;
    x5.prototype._maxListeners = undefined;
    var Mr = 10;
    function Ke(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(x5, "defaultMaxListeners", { enumerable: true, get: function() {
      return Mr;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || Or(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Mr = e;
    } });
    x5.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    x5.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || Or(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Fr3(e) {
      return e._maxListeners === undefined ? x5.defaultMaxListeners : e._maxListeners;
    }
    x5.prototype.getMaxListeners = function() {
      return Fr3(this);
    };
    x5.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a3;
        if (r.length > 0 && (a3 = r[0]), a3 instanceof Error)
          throw a3;
        var s2 = new Error("Unhandled error." + (a3 ? " (" + a3.message + ")" : ""));
        throw s2.context = a3, s2;
      }
      var u3 = o2[t];
      if (u3 === undefined)
        return false;
      if (typeof u3 == "function")
        Lr(u3, this, r);
      else
        for (var l3 = u3.length, h5 = Dr2(u3, l3), n = 0;n < l3; ++n)
          Lr(h5[n], this, r);
      return true;
    };
    function Nr(e, t, r, n) {
      var i, o2, a3;
      if (Ke(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), a3 = o2[t]), a3 === undefined)
        a3 = o2[t] = r, ++e._eventsCount;
      else if (typeof a3 == "function" ? a3 = o2[t] = n ? [r, a3] : [a3, r] : n ? a3.unshift(r) : a3.push(r), i = Fr3(e), i > 0 && a3.length > i && !a3.warned) {
        a3.warned = true;
        var s2 = new Error("Possible EventEmitter memory leak detected. " + a3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s2.name = "MaxListenersExceededWarning", s2.emitter = e, s2.type = t, s2.count = a3.length, no(s2);
      }
      return e;
    }
    x5.prototype.addListener = function(t, r) {
      return Nr(this, t, r, false);
    };
    x5.prototype.on = x5.prototype.addListener;
    x5.prototype.prependListener = function(t, r) {
      return Nr(this, t, r, true);
    };
    function io() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ur4(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = io.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    x5.prototype.once = function(t, r) {
      return Ke(r), this.on(t, Ur4(this, t, r)), this;
    };
    x5.prototype.prependOnceListener = function(t, r) {
      return Ke(r), this.prependListener(t, Ur4(this, t, r)), this;
    };
    x5.prototype.removeListener = function(t, r) {
      var n, i, o2, a3, s2;
      if (Ke(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, a3 = n.length - 1;a3 >= 0; a3--)
          if (n[a3] === r || n[a3].listener === r) {
            s2 = n[a3].listener, o2 = a3;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : oo(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, s2 || r);
      }
      return this;
    };
    x5.prototype.off = x5.prototype.removeListener;
    x5.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), a3;
        for (i = 0;i < o2.length; ++i)
          a3 = o2[i], a3 !== "removeListener" && this.removeAllListeners(a3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Pr(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ao(i) : Dr2(i, i.length);
    }
    x5.prototype.listeners = function(t) {
      return Pr(this, t, true);
    };
    x5.prototype.rawListeners = function(t) {
      return Pr(this, t, false);
    };
    x5.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : qr2.call(e, t);
    };
    x5.prototype.listenerCount = qr2;
    function qr2(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    x5.prototype.eventNames = function() {
      return this._eventsCount > 0 ? Ge(this._events) : [];
    };
    function Dr2(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function oo(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function ao(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function so2(e, t) {
      return new Promise(function(r, n) {
        function i(a3) {
          e.removeListener(t, o2), n(a3);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        kr(e, t, o2, { once: true }), t !== "error" && fo(e, i, { once: true });
      });
    }
    function fo(e, t, r) {
      typeof e.on == "function" && kr(e, "error", t, r);
    }
    function kr(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  At3 = b5((Nf, jr) => {
    jr.exports = Tt3().EventEmitter;
  });
  $r = b5((Ve) => {
    Ve.byteLength = lo;
    Ve.toByteArray = co;
    Ve.fromByteArray = go;
    var W = [], U3 = [], uo = typeof Uint8Array < "u" ? Uint8Array : Array, Bt2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ae = 0, Wr = Bt2.length;ae < Wr; ++ae)
      W[ae] = Bt2[ae], U3[Bt2.charCodeAt(ae)] = ae;
    var ae, Wr;
    U3[45] = 62;
    U3[95] = 63;
    function Hr2(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function lo(e) {
      var t = Hr2(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function ho(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function co(e) {
      var t, r = Hr2(e), n = r[0], i = r[1], o2 = new uo(ho(e, n, i)), a3 = 0, s2 = i > 0 ? n - 4 : n, u3;
      for (u3 = 0;u3 < s2; u3 += 4)
        t = U3[e.charCodeAt(u3)] << 18 | U3[e.charCodeAt(u3 + 1)] << 12 | U3[e.charCodeAt(u3 + 2)] << 6 | U3[e.charCodeAt(u3 + 3)], o2[a3++] = t >> 16 & 255, o2[a3++] = t >> 8 & 255, o2[a3++] = t & 255;
      return i === 2 && (t = U3[e.charCodeAt(u3)] << 2 | U3[e.charCodeAt(u3 + 1)] >> 4, o2[a3++] = t & 255), i === 1 && (t = U3[e.charCodeAt(u3)] << 10 | U3[e.charCodeAt(u3 + 1)] << 4 | U3[e.charCodeAt(u3 + 2)] >> 2, o2[a3++] = t >> 8 & 255, o2[a3++] = t & 255), o2;
    }
    function po(e) {
      return W[e >> 18 & 63] + W[e >> 12 & 63] + W[e >> 6 & 63] + W[e & 63];
    }
    function yo(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(po(n));
      return i.join("");
    }
    function go(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, a3 = 0, s2 = r - n;a3 < s2; a3 += o2)
        i.push(yo(e, a3, a3 + o2 > s2 ? s2 : a3 + o2));
      return n === 1 ? (t = e[r - 1], i.push(W[t >> 2] + W[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(W[t >> 10] + W[t >> 4 & 63] + W[t << 2 & 63] + "=")), i.join("");
    }
  });
  Gr = b5((It) => {
    It.read = function(e, t, r, n, i) {
      var o2, a3, s2 = i * 8 - n - 1, u3 = (1 << s2) - 1, l3 = u3 >> 1, h5 = -7, c2 = r ? i - 1 : 0, d4 = r ? -1 : 1, p3 = e[t + c2];
      for (c2 += d4, o2 = p3 & (1 << -h5) - 1, p3 >>= -h5, h5 += s2;h5 > 0; o2 = o2 * 256 + e[t + c2], c2 += d4, h5 -= 8)
        ;
      for (a3 = o2 & (1 << -h5) - 1, o2 >>= -h5, h5 += n;h5 > 0; a3 = a3 * 256 + e[t + c2], c2 += d4, h5 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l3;
      else {
        if (o2 === u3)
          return a3 ? NaN : (p3 ? -1 : 1) * (1 / 0);
        a3 = a3 + Math.pow(2, n), o2 = o2 - l3;
      }
      return (p3 ? -1 : 1) * a3 * Math.pow(2, o2 - n);
    };
    It.write = function(e, t, r, n, i, o2) {
      var a3, s2, u3, l3 = o2 * 8 - i - 1, h5 = (1 << l3) - 1, c2 = h5 >> 1, d4 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p3 = n ? 0 : o2 - 1, g5 = n ? 1 : -1, E5 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s2 = isNaN(t) ? 1 : 0, a3 = h5) : (a3 = Math.floor(Math.log(t) / Math.LN2), t * (u3 = Math.pow(2, -a3)) < 1 && (a3--, u3 *= 2), a3 + c2 >= 1 ? t += d4 / u3 : t += d4 * Math.pow(2, 1 - c2), t * u3 >= 2 && (a3++, u3 /= 2), a3 + c2 >= h5 ? (s2 = 0, a3 = h5) : a3 + c2 >= 1 ? (s2 = (t * u3 - 1) * Math.pow(2, i), a3 = a3 + c2) : (s2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), a3 = 0));i >= 8; e[r + p3] = s2 & 255, p3 += g5, s2 /= 256, i -= 8)
        ;
      for (a3 = a3 << i | s2, l3 += i;l3 > 0; e[r + p3] = a3 & 255, p3 += g5, a3 /= 256, l3 -= 8)
        ;
      e[r + p3 - g5] |= E5 * 128;
    };
  });
  _e2 = b5((be2) => {
    var Ct = $r(), we = Gr(), Kr2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    be2.Buffer = f3;
    be2.SlowBuffer = Eo;
    be2.INSPECT_MAX_BYTES = 50;
    var Ye = 2147483647;
    be2.kMaxLength = Ye;
    f3.TYPED_ARRAY_SUPPORT = wo2();
    !f3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function wo2() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(f3.prototype, "parent", { enumerable: true, get: function() {
      if (!!f3.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(f3.prototype, "offset", { enumerable: true, get: function() {
      if (!!f3.isBuffer(this))
        return this.byteOffset;
    } });
    function X4(e) {
      if (e > Ye)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, f3.prototype), t;
    }
    function f3(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Ft2(e);
      }
      return zr2(e, t, r);
    }
    f3.poolSize = 8192;
    function zr2(e, t, r) {
      if (typeof e == "string")
        return bo(e, t);
      if (ArrayBuffer.isView(e))
        return _o(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H3(e, ArrayBuffer) || e && H3(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H3(e, SharedArrayBuffer) || e && H3(e.buffer, SharedArrayBuffer)))
        return Mt(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return f3.from(n, t, r);
      let i = vo(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return f3.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    f3.from = function(e, t, r) {
      return zr2(e, t, r);
    };
    Object.setPrototypeOf(f3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(f3, Uint8Array);
    function Zr2(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function mo(e, t, r) {
      return Zr2(e), e <= 0 ? X4(e) : t !== undefined ? typeof r == "string" ? X4(e).fill(t, r) : X4(e).fill(t) : X4(e);
    }
    f3.alloc = function(e, t, r) {
      return mo(e, t, r);
    };
    function Ft2(e) {
      return Zr2(e), X4(e < 0 ? 0 : Nt3(e) | 0);
    }
    f3.allocUnsafe = function(e) {
      return Ft2(e);
    };
    f3.allocUnsafeSlow = function(e) {
      return Ft2(e);
    };
    function bo(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !f3.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = Jr(e, t) | 0, n = X4(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Lt3(e) {
      let t = e.length < 0 ? 0 : Nt3(e.length) | 0, r = X4(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function _o(e) {
      if (H3(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Mt(t.buffer, t.byteOffset, t.byteLength);
      }
      return Lt3(e);
    }
    function Mt(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, f3.prototype), n;
    }
    function vo(e) {
      if (f3.isBuffer(e)) {
        let t = Nt3(e.length) | 0, r = X4(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Pt(e.length) ? X4(0) : Lt3(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Lt3(e.data);
    }
    function Nt3(e) {
      if (e >= Ye)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ye.toString(16) + " bytes");
      return e | 0;
    }
    function Eo(e) {
      return +e != e && (e = 0), f3.alloc(+e);
    }
    f3.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== f3.prototype;
    };
    f3.compare = function(t, r) {
      if (H3(t, Uint8Array) && (t = f3.from(t, t.offset, t.byteLength)), H3(r, Uint8Array) && (r = f3.from(r, r.offset, r.byteLength)), !f3.isBuffer(t) || !f3.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, a3 = Math.min(n, i);o2 < a3; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    f3.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    f3.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return f3.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = f3.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let a3 = t[n];
        if (H3(a3, Uint8Array))
          o2 + a3.length > i.length ? (f3.isBuffer(a3) || (a3 = f3.from(a3)), a3.copy(i, o2)) : Uint8Array.prototype.set.call(i, a3, o2);
        else if (f3.isBuffer(a3))
          a3.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += a3.length;
      }
      return i;
    };
    function Jr(e, t) {
      if (f3.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H3(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Ot(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return fn(e).length;
          default:
            if (i)
              return n ? -1 : Ot(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    f3.byteLength = Jr;
    function xo(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return Oo(this, t, r);
          case "utf8":
          case "utf-8":
            return en(this, t, r);
          case "ascii":
            return Lo(this, t, r);
          case "latin1":
          case "binary":
            return Mo2(this, t, r);
          case "base64":
            return Io(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Fo(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    f3.prototype._isBuffer = true;
    function se2(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    f3.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        se2(this, r, r + 1);
      return this;
    };
    f3.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        se2(this, r, r + 3), se2(this, r + 1, r + 2);
      return this;
    };
    f3.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        se2(this, r, r + 7), se2(this, r + 1, r + 6), se2(this, r + 2, r + 5), se2(this, r + 3, r + 4);
      return this;
    };
    f3.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? en(this, 0, t) : xo.apply(this, arguments);
    };
    f3.prototype.toLocaleString = f3.prototype.toString;
    f3.prototype.equals = function(t) {
      if (!f3.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : f3.compare(this, t) === 0;
    };
    f3.prototype.inspect = function() {
      let t = "", r = be2.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    Kr2 && (f3.prototype[Kr2] = f3.prototype.inspect);
    f3.prototype.compare = function(t, r, n, i, o2) {
      if (H3(t, Uint8Array) && (t = f3.from(t, t.offset, t.byteLength)), !f3.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let a3 = o2 - i, s2 = n - r, u3 = Math.min(a3, s2), l3 = this.slice(i, o2), h5 = t.slice(r, n);
      for (let c2 = 0;c2 < u3; ++c2)
        if (l3[c2] !== h5[c2]) {
          a3 = l3[c2], s2 = h5[c2];
          break;
        }
      return a3 < s2 ? -1 : s2 < a3 ? 1 : 0;
    };
    function Qr(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Pt(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = f3.from(t, n)), f3.isBuffer(t))
        return t.length === 0 ? -1 : Vr(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : Vr(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Vr(e, t, r, n, i) {
      let o2 = 1, a3 = e.length, s2 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, a3 /= 2, s2 /= 2, r /= 2;
      }
      function u3(h5, c2) {
        return o2 === 1 ? h5[c2] : h5.readUInt16BE(c2 * o2);
      }
      let l3;
      if (i) {
        let h5 = -1;
        for (l3 = r;l3 < a3; l3++)
          if (u3(e, l3) === u3(t, h5 === -1 ? 0 : l3 - h5)) {
            if (h5 === -1 && (h5 = l3), l3 - h5 + 1 === s2)
              return h5 * o2;
          } else
            h5 !== -1 && (l3 -= l3 - h5), h5 = -1;
      } else
        for (r + s2 > a3 && (r = a3 - s2), l3 = r;l3 >= 0; l3--) {
          let h5 = true;
          for (let c2 = 0;c2 < s2; c2++)
            if (u3(e, l3 + c2) !== u3(t, c2)) {
              h5 = false;
              break;
            }
          if (h5)
            return l3;
        }
      return -1;
    }
    f3.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    f3.prototype.indexOf = function(t, r, n) {
      return Qr(this, t, r, n, true);
    };
    f3.prototype.lastIndexOf = function(t, r, n) {
      return Qr(this, t, r, n, false);
    };
    function Ro(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let a3;
      for (a3 = 0;a3 < n; ++a3) {
        let s2 = parseInt(t.substr(a3 * 2, 2), 16);
        if (Pt(s2))
          return a3;
        e[r + a3] = s2;
      }
      return a3;
    }
    function So(e, t, r, n) {
      return Xe(Ot(t, e.length - r), e, r, n);
    }
    function To(e, t, r, n) {
      return Xe(qo(t), e, r, n);
    }
    function Ao(e, t, r, n) {
      return Xe(fn(t), e, r, n);
    }
    function Bo(e, t, r, n) {
      return Xe(Do(t, e.length - r), e, r, n);
    }
    f3.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a3 = false;
      for (;; )
        switch (i) {
          case "hex":
            return Ro(this, t, r, n);
          case "utf8":
          case "utf-8":
            return So(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return To(this, t, r, n);
          case "base64":
            return Ao(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Bo(this, t, r, n);
          default:
            if (a3)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a3 = true;
        }
    };
    f3.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Io(e, t, r) {
      return t === 0 && r === e.length ? Ct.fromByteArray(e) : Ct.fromByteArray(e.slice(t, r));
    }
    function en(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], a3 = null, s2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + s2 <= r) {
          let u3, l3, h5, c2;
          switch (s2) {
            case 1:
              o2 < 128 && (a3 = o2);
              break;
            case 2:
              u3 = e[i + 1], (u3 & 192) === 128 && (c2 = (o2 & 31) << 6 | u3 & 63, c2 > 127 && (a3 = c2));
              break;
            case 3:
              u3 = e[i + 1], l3 = e[i + 2], (u3 & 192) === 128 && (l3 & 192) === 128 && (c2 = (o2 & 15) << 12 | (u3 & 63) << 6 | l3 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (a3 = c2));
              break;
            case 4:
              u3 = e[i + 1], l3 = e[i + 2], h5 = e[i + 3], (u3 & 192) === 128 && (l3 & 192) === 128 && (h5 & 192) === 128 && (c2 = (o2 & 15) << 18 | (u3 & 63) << 12 | (l3 & 63) << 6 | h5 & 63, c2 > 65535 && c2 < 1114112 && (a3 = c2));
          }
        }
        a3 === null ? (a3 = 65533, s2 = 1) : a3 > 65535 && (a3 -= 65536, n.push(a3 >>> 10 & 1023 | 55296), a3 = 56320 | a3 & 1023), n.push(a3), i += s2;
      }
      return Co(n);
    }
    var Yr2 = 4096;
    function Co(e) {
      let t = e.length;
      if (t <= Yr2)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += Yr2));
      return r;
    }
    function Lo(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function Mo2(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function Oo(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += ko[e[o2]];
      return i;
    }
    function Fo(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    f3.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, f3.prototype), i;
    };
    function I4(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    f3.prototype.readUintLE = f3.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I4(t, r, this.length);
      let i = this[t], o2 = 1, a3 = 0;
      for (;++a3 < r && (o2 *= 256); )
        i += this[t + a3] * o2;
      return i;
    };
    f3.prototype.readUintBE = f3.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I4(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    f3.prototype.readUint8 = f3.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || I4(t, 1, this.length), this[t];
    };
    f3.prototype.readUint16LE = f3.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || I4(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    f3.prototype.readUint16BE = f3.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || I4(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    f3.prototype.readUint32LE = f3.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || I4(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    f3.prototype.readUint32BE = f3.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || I4(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    f3.prototype.readBigUInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce2(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    f3.prototype.readBigUInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce2(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    f3.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I4(t, r, this.length);
      let i = this[t], o2 = 1, a3 = 0;
      for (;++a3 < r && (o2 *= 256); )
        i += this[t + a3] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    f3.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I4(t, r, this.length);
      let i = r, o2 = 1, a3 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        a3 += this[t + --i] * o2;
      return o2 *= 128, a3 >= o2 && (a3 -= Math.pow(2, 8 * r)), a3;
    };
    f3.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || I4(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    f3.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || I4(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f3.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || I4(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f3.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || I4(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    f3.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || I4(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    f3.prototype.readBigInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce2(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    f3.prototype.readBigInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce2(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    f3.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || I4(t, 4, this.length), we.read(this, t, true, 23, 4);
    };
    f3.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || I4(t, 4, this.length), we.read(this, t, false, 23, 4);
    };
    f3.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || I4(t, 8, this.length), we.read(this, t, true, 52, 8);
    };
    f3.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || I4(t, 8, this.length), we.read(this, t, false, 52, 8);
    };
    function O4(e, t, r, n, i, o2) {
      if (!f3.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    f3.prototype.writeUintLE = f3.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O4(this, t, r, n, s2, 0);
      }
      let o2 = 1, a3 = 0;
      for (this[r] = t & 255;++a3 < n && (o2 *= 256); )
        this[r + a3] = t / o2 & 255;
      return r + n;
    };
    f3.prototype.writeUintBE = f3.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s2 = Math.pow(2, 8 * n) - 1;
        O4(this, t, r, n, s2, 0);
      }
      let o2 = n - 1, a3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a3 *= 256); )
        this[r + o2] = t / a3 & 255;
      return r + n;
    };
    f3.prototype.writeUint8 = f3.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    f3.prototype.writeUint16LE = f3.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f3.prototype.writeUint16BE = f3.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f3.prototype.writeUint32LE = f3.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    f3.prototype.writeUint32BE = f3.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function tn2(e, t, r, n, i) {
      sn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let a3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, a3 = a3 >> 8, e[r++] = a3, r;
    }
    function rn(e, t, r, n, i) {
      sn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let a3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a3, a3 = a3 >> 8, e[r + 2] = a3, a3 = a3 >> 8, e[r + 1] = a3, a3 = a3 >> 8, e[r] = a3, r + 8;
    }
    f3.prototype.writeBigUInt64LE = ee(function(t, r = 0) {
      return tn2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f3.prototype.writeBigUInt64BE = ee(function(t, r = 0) {
      return rn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f3.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n - 1);
        O4(this, t, r, n, u3 - 1, -u3);
      }
      let o2 = 0, a3 = 1, s2 = 0;
      for (this[r] = t & 255;++o2 < n && (a3 *= 256); )
        t < 0 && s2 === 0 && this[r + o2 - 1] !== 0 && (s2 = 1), this[r + o2] = (t / a3 >> 0) - s2 & 255;
      return r + n;
    };
    f3.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n - 1);
        O4(this, t, r, n, u3 - 1, -u3);
      }
      let o2 = n - 1, a3 = 1, s2 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a3 *= 256); )
        t < 0 && s2 === 0 && this[r + o2 + 1] !== 0 && (s2 = 1), this[r + o2] = (t / a3 >> 0) - s2 & 255;
      return r + n;
    };
    f3.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    f3.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f3.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f3.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    f3.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    f3.prototype.writeBigInt64LE = ee(function(t, r = 0) {
      return tn2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    f3.prototype.writeBigInt64BE = ee(function(t, r = 0) {
      return rn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function nn(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function on(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || nn(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), we.write(e, t, r, n, 23, 4), r + 4;
    }
    f3.prototype.writeFloatLE = function(t, r, n) {
      return on(this, t, r, true, n);
    };
    f3.prototype.writeFloatBE = function(t, r, n) {
      return on(this, t, r, false, n);
    };
    function an2(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || nn(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), we.write(e, t, r, n, 52, 8), r + 8;
    }
    f3.prototype.writeDoubleLE = function(t, r, n) {
      return an2(this, t, r, true, n);
    };
    f3.prototype.writeDoubleBE = function(t, r, n) {
      return an2(this, t, r, false, n);
    };
    f3.prototype.copy = function(t, r, n, i) {
      if (!f3.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    f3.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !f3.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a3 = t.charCodeAt(0);
          (i === "utf8" && a3 < 128 || i === "latin1") && (t = a3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let a3 = f3.isBuffer(t) ? t : f3.from(t, i), s2 = a3.length;
        if (s2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = a3[o2 % s2];
      }
      return this;
    };
    var ge = {};
    function Ut2(e, t, r) {
      ge[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    Ut2("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Ut2("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    Ut2("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Xr(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Xr(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function Xr(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function No(e, t, r) {
      me(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ce2(t, e.length - (r + 1));
    }
    function sn(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let a3 = typeof t == "bigint" ? "n" : "", s2;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? s2 = `>= 0${a3} and < 2${a3} ** ${(o2 + 1) * 8}${a3}` : s2 = `>= -(2${a3} ** ${(o2 + 1) * 8 - 1}${a3}) and < 2 ** ${(o2 + 1) * 8 - 1}${a3}` : s2 = `>= ${t}${a3} and <= ${r}${a3}`, new ge.ERR_OUT_OF_RANGE("value", s2, e);
      }
      No(n, i, o2);
    }
    function me(e, t) {
      if (typeof e != "number")
        throw new ge.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ce2(e, t, r) {
      throw Math.floor(e) !== e ? (me(e, r), new ge.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS : new ge.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var Uo = /[^+/0-9A-Za-z-_]/g;
    function Po(e) {
      if (e = e.split("=")[0], e = e.trim().replace(Uo, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Ot(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let a3 = 0;a3 < n; ++a3) {
        if (r = e.charCodeAt(a3), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (a3 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function qo(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Do(e, t) {
      let r, n, i, o2 = [];
      for (let a3 = 0;a3 < e.length && !((t -= 2) < 0); ++a3)
        r = e.charCodeAt(a3), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function fn(e) {
      return Ct.toByteArray(Po(e));
    }
    function Xe(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function H3(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Pt(e) {
      return e !== e;
    }
    var ko = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function ee(e) {
      return typeof BigInt > "u" ? jo : e;
    }
    function jo() {
      throw new Error("BigInt not supported");
    }
  });
  qt = b5(() => {
  });
  cn = b5((Wf, hn) => {
    function un2(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function Wo(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? un2(Object(r), true).forEach(function(n) {
          Ho(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : un2(Object(r)).forEach(function(n) {
          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return e;
    }
    function Ho(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function $o(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function ln(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function Go(e, t, r) {
      return t && ln(e.prototype, t), r && ln(e, r), e;
    }
    var Ko = _e2(), ze = Ko.Buffer, Vo = qt(), Dt2 = Vo.inspect, Yo = Dt2 && Dt2.custom || "inspect";
    function Xo(e, t, r) {
      ze.prototype.copy.call(e, t, r);
    }
    hn.exports = function() {
      function e() {
        $o(this, e), this.head = null, this.tail = null, this.length = 0;
      }
      return Go(e, [{ key: "push", value: function(r) {
        var n = { data: r, next: null };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var n = { data: r, next: this.head };
        this.length === 0 && (this.tail = n), this.head = n, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var n = this.head, i = "" + n.data;n = n.next; )
          i += r + n.data;
        return i;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ze.alloc(0);
        for (var n = ze.allocUnsafe(r >>> 0), i = this.head, o2 = 0;i; )
          Xo(i.data, n, o2), o2 += i.data.length, i = i.next;
        return n;
      } }, { key: "consume", value: function(r, n) {
        var i;
        return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var n = this.head, i = 1, o2 = n.data;
        for (r -= o2.length;n = n.next; ) {
          var a3 = n.data, s2 = r > a3.length ? a3.length : r;
          if (s2 === a3.length ? o2 += a3 : o2 += a3.slice(0, r), r -= s2, r === 0) {
            s2 === a3.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = a3.slice(s2));
            break;
          }
          ++i;
        }
        return this.length -= i, o2;
      } }, { key: "_getBuffer", value: function(r) {
        var n = ze.allocUnsafe(r), i = this.head, o2 = 1;
        for (i.data.copy(n), r -= i.data.length;i = i.next; ) {
          var a3 = i.data, s2 = r > a3.length ? a3.length : r;
          if (a3.copy(n, n.length - r, 0, s2), r -= s2, r === 0) {
            s2 === a3.length ? (++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = a3.slice(s2));
            break;
          }
          ++o2;
        }
        return this.length -= o2, n;
      } }, { key: Yo, value: function(r, n) {
        return Dt2(this, Wo({}, n, { depth: 0, customInspect: false }));
      } }]), e;
    }();
  });
  jt = b5((Hf, pn2) => {
    function zo(e, t) {
      var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
      return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(kt2, this, e)) : process.nextTick(kt2, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(o2) {
        !t && o2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ze, r) : (r._writableState.errorEmitted = true, process.nextTick(dn, r, o2)) : process.nextTick(dn, r, o2) : t ? (process.nextTick(Ze, r), t(o2)) : process.nextTick(Ze, r);
      }), this);
    }
    function dn(e, t) {
      kt2(e, t), Ze(e);
    }
    function Ze(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Zo() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function kt2(e, t) {
      e.emit("error", t);
    }
    function Jo(e, t) {
      var { _readableState: r, _writableState: n } = e;
      r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    pn2.exports = { destroy: zo, undestroy: Zo, errorOrDestroy: Jo };
  });
  fe2 = b5(($f, wn) => {
    function Qo2(e, t) {
      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var gn = {};
    function P4(e, t, r) {
      r || (r = Error);
      function n(o2, a3, s2) {
        return typeof t == "string" ? t : t(o2, a3, s2);
      }
      var i = function(o2) {
        Qo2(a3, o2);
        function a3(s2, u3, l3) {
          return o2.call(this, n(s2, u3, l3)) || this;
        }
        return a3;
      }(r);
      i.prototype.name = r.name, i.prototype.code = e, gn[e] = i;
    }
    function yn2(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function ea(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function ta(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function ra(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    P4("ERR_INVALID_OPT_VALUE", function(e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    P4("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      var n;
      typeof t == "string" && ea(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (ta(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(yn2(t, "type"));
      else {
        var o2 = ra(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o2, " ").concat(n, " ").concat(yn2(t, "type"));
      }
      return i += ". Received type ".concat(typeof r), i;
    }, TypeError);
    P4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    P4("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
      return "The " + e + " method is not implemented";
    });
    P4("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    P4("ERR_STREAM_DESTROYED", function(e) {
      return "Cannot call " + e + " after a stream was destroyed";
    });
    P4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    P4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    P4("ERR_STREAM_WRITE_AFTER_END", "write after end");
    P4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    P4("ERR_UNKNOWN_ENCODING", function(e) {
      return "Unknown encoding: " + e;
    }, TypeError);
    P4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    wn.exports.codes = gn;
  });
  Wt = b5((Gf, mn) => {
    var na = fe2().codes.ERR_INVALID_OPT_VALUE;
    function ia(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function oa(e, t, r, n) {
      var i = ia(t, n, r);
      if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
          var o2 = n ? r : "highWaterMark";
          throw new na(o2, i);
        }
        return Math.floor(i);
      }
      return e.objectMode ? 16 : 16 * 1024;
    }
    mn.exports = { getHighWaterMark: oa };
  });
  _n = b5((Kf, bn) => {
    bn.exports = aa;
    function aa(e, t) {
      if (Ht2("noDeprecation"))
        return e;
      var r = false;
      function n() {
        if (!r) {
          if (Ht2("throwDeprecation"))
            throw new Error(t);
          Ht2("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    }
    function Ht2(e) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var t = global.localStorage[e];
      return t == null ? false : String(t).toLowerCase() === "true";
    }
  });
  Kt2 = b5((Vf, Tn2) => {
    Tn2.exports = A4;
    function En(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        Oa(t, e);
      };
    }
    var ve;
    A4.WritableState = Me;
    var sa = { deprecate: _n() }, xn = At3(), Qe2 = _e2().Buffer, fa = global.Uint8Array || function() {
    };
    function ua(e) {
      return Qe2.from(e);
    }
    function la(e) {
      return Qe2.isBuffer(e) || e instanceof fa;
    }
    var Gt = jt(), ha = Wt(), ca = ha.getHighWaterMark, te = fe2().codes, da2 = te.ERR_INVALID_ARG_TYPE, pa = te.ERR_METHOD_NOT_IMPLEMENTED, ya = te.ERR_MULTIPLE_CALLBACK, ga = te.ERR_STREAM_CANNOT_PIPE, wa2 = te.ERR_STREAM_DESTROYED, ma = te.ERR_STREAM_NULL_VALUES, ba = te.ERR_STREAM_WRITE_AFTER_END, _a = te.ERR_UNKNOWN_ENCODING, Ee = Gt.errorOrDestroy;
    Q4()(A4, xn);
    function va2() {
    }
    function Me(e, t, r) {
      ve = ve || ue2(), e = e || {}, typeof r != "boolean" && (r = t instanceof ve), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = ca(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var n = e.decodeStrings === false;
      this.decodeStrings = !n, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
        Ba(t, i);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new En(this);
    }
    Me.prototype.getBuffer = function() {
      for (var t = this.bufferedRequest, r = [];t; )
        r.push(t), t = t.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Me.prototype, "buffer", { get: sa.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Je;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Je = Function.prototype[Symbol.hasInstance], Object.defineProperty(A4, Symbol.hasInstance, { value: function(t) {
      return Je.call(this, t) ? true : this !== A4 ? false : t && t._writableState instanceof Me;
    } })) : Je = function(t) {
      return t instanceof this;
    };
    function A4(e) {
      ve = ve || ue2();
      var t = this instanceof ve;
      if (!t && !Je.call(A4, this))
        return new A4(e);
      this._writableState = new Me(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), xn.call(this);
    }
    A4.prototype.pipe = function() {
      Ee(this, new ga);
    };
    function Ea(e, t) {
      var r = new ba;
      Ee(e, r), process.nextTick(t, r);
    }
    function xa(e, t, r, n) {
      var i;
      return r === null ? i = new ma : typeof r != "string" && !t.objectMode && (i = new da2("chunk", ["string", "Buffer"], r)), i ? (Ee(e, i), process.nextTick(n, i), false) : true;
    }
    A4.prototype.write = function(e, t, r) {
      var n = this._writableState, i = false, o2 = !n.objectMode && la(e);
      return o2 && !Qe2.isBuffer(e) && (e = ua(e)), typeof t == "function" && (r = t, t = null), o2 ? t = "buffer" : t || (t = n.defaultEncoding), typeof r != "function" && (r = va2), n.ending ? Ea(this, r) : (o2 || xa(this, n, e, r)) && (n.pendingcb++, i = Sa(this, n, o2, e, t, r)), i;
    };
    A4.prototype.cork = function() {
      this._writableState.corked++;
    };
    A4.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Rn(this, e));
    };
    A4.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
        throw new _a(t);
      return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(A4.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function Ra(e, t, r) {
      return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = Qe2.from(t, r)), t;
    }
    Object.defineProperty(A4.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function Sa(e, t, r, n, i, o2) {
      if (!r) {
        var a3 = Ra(t, n, i);
        n !== a3 && (r = true, i = "buffer", n = a3);
      }
      var s2 = t.objectMode ? 1 : n.length;
      t.length += s2;
      var u3 = t.length < t.highWaterMark;
      if (u3 || (t.needDrain = true), t.writing || t.corked) {
        var l3 = t.lastBufferedRequest;
        t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o2, next: null }, l3 ? l3.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
      } else
        $t(e, t, false, s2, n, i, o2);
      return u3;
    }
    function $t(e, t, r, n, i, o2, a3) {
      t.writelen = n, t.writecb = a3, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new wa2("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function Ta(e, t, r, n, i) {
      --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(Le, e, t), e._writableState.errorEmitted = true, Ee(e, n)) : (i(n), e._writableState.errorEmitted = true, Ee(e, n), Le(e, t));
    }
    function Aa(e) {
      e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Ba(e, t) {
      var r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function")
        throw new ya;
      if (Aa(r), t)
        Ta(e, r, n, t, i);
      else {
        var o2 = Sn2(r) || e.destroyed;
        !o2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Rn(e, r), n ? process.nextTick(vn, e, r, o2, i) : vn(e, r, o2, i);
      }
    }
    function vn(e, t, r, n) {
      r || Ia2(e, t), t.pendingcb--, n(), Le(e, t);
    }
    function Ia2(e, t) {
      t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
    }
    function Rn(e, t) {
      t.bufferProcessing = true;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount, i = new Array(n), o2 = t.corkedRequestsFree;
        o2.entry = r;
        for (var a3 = 0, s2 = true;r; )
          i[a3] = r, r.isBuf || (s2 = false), r = r.next, a3 += 1;
        i.allBuffers = s2, $t(e, t, true, t.length, i, "", o2.finish), t.pendingcb++, t.lastBufferedRequest = null, o2.next ? (t.corkedRequestsFree = o2.next, o2.next = null) : t.corkedRequestsFree = new En(t), t.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: u3, encoding: l3, callback: h5 } = r, c2 = t.objectMode ? 1 : u3.length;
          if ($t(e, t, false, c2, u3, l3, h5), r = r.next, t.bufferedRequestCount--, t.writing)
            break;
        }
        r === null && (t.lastBufferedRequest = null);
      }
      t.bufferedRequest = r, t.bufferProcessing = false;
    }
    A4.prototype._write = function(e, t, r) {
      r(new pa("_write()"));
    };
    A4.prototype._writev = null;
    A4.prototype.end = function(e, t, r) {
      var n = this._writableState;
      return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || Ma(this, n, r), this;
    };
    Object.defineProperty(A4.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Sn2(e) {
      return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function Ca(e, t) {
      e._final(function(r) {
        t.pendingcb--, r && Ee(e, r), t.prefinished = true, e.emit("prefinish"), Le(e, t);
      });
    }
    function La(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, process.nextTick(Ca, e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Le(e, t) {
      var r = Sn2(t);
      if (r && (La(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
        var n = e._readableState;
        (!n || n.autoDestroy && n.endEmitted) && e.destroy();
      }
      return r;
    }
    function Ma(e, t, r) {
      t.ending = true, Le(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
    }
    function Oa(e, t, r) {
      var n = e.entry;
      for (e.entry = null;n; ) {
        var i = n.callback;
        t.pendingcb--, i(r), n = n.next;
      }
      t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(A4.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(t) {
      !this._writableState || (this._writableState.destroyed = t);
    } });
    A4.prototype.destroy = Gt.destroy;
    A4.prototype._undestroy = Gt.undestroy;
    A4.prototype._destroy = function(e, t) {
      t(e);
    };
  });
  ue2 = b5((Yf, Bn3) => {
    var Fa = Object.keys || function(e) {
      var t = [];
      for (var r in e)
        t.push(r);
      return t;
    };
    Bn3.exports = $3;
    var An = Xt(), Yt = Kt2();
    Q4()($3, An);
    for (Vt2 = Fa(Yt.prototype), et2 = 0;et2 < Vt2.length; et2++)
      tt3 = Vt2[et2], $3.prototype[tt3] || ($3.prototype[tt3] = Yt.prototype[tt3]);
    var Vt2, tt3, et2;
    function $3(e) {
      if (!(this instanceof $3))
        return new $3(e);
      An.call(this, e), Yt.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Na2)));
    }
    Object.defineProperty($3.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($3.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($3.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Na2() {
      this._writableState.ended || process.nextTick(Ua, this);
    }
    function Ua(e) {
      e.end();
    }
    Object.defineProperty($3.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(t) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } });
  });
  Ln2 = b5((zt, Cn) => {
    var rt3 = _e2(), G2 = rt3.Buffer;
    function In(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    G2.from && G2.alloc && G2.allocUnsafe && G2.allocUnsafeSlow ? Cn.exports = rt3 : (In(rt3, zt), zt.Buffer = le);
    function le(e, t, r) {
      return G2(e, t, r);
    }
    le.prototype = Object.create(G2.prototype);
    In(G2, le);
    le.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return G2(e, t, r);
    };
    le.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = G2(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    le.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return G2(e);
    };
    le.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return rt3.SlowBuffer(e);
    };
  });
  Fn = b5((On2) => {
    var Jt = Ln2().Buffer, Mn = Jt.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function Pa(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function qa(e) {
      var t = Pa(e);
      if (typeof t != "string" && (Jt.isEncoding === Mn || !Mn(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    On2.StringDecoder = Oe;
    function Oe(e) {
      this.encoding = qa(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = $a2, this.end = Ga2, t = 4;
          break;
        case "utf8":
          this.fillLast = ja, t = 4;
          break;
        case "base64":
          this.text = Ka, this.end = Va, t = 3;
          break;
        default:
          this.write = Ya2, this.end = Xa;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Jt.allocUnsafe(t);
    }
    Oe.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Oe.prototype.end = Ha;
    Oe.prototype.text = Wa2;
    Oe.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function Zt(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Da(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = Zt(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = Zt(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = Zt(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ka2(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function ja(e) {
      var t = this.lastTotal - this.lastNeed, r = ka2(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Wa2(e, t) {
      var r = Da(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function Ha(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function $a2(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ga2(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Ka(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Va(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ya2(e) {
      return e.toString(this.encoding);
    }
    function Xa(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Qt = {};
  mt3(Qt, { StringDecoder: () => nt3.StringDecoder, default: () => nt3.StringDecoder });
  er = Cr(() => {
    nt3 = bt3(Fn());
  });
  it2 = b5((zf2, Pn) => {
    var Nn2 = fe2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function za(e) {
      var t = false;
      return function() {
        if (!t) {
          t = true;
          for (var r = arguments.length, n = new Array(r), i = 0;i < r; i++)
            n[i] = arguments[i];
          e.apply(this, n);
        }
      };
    }
    function Za() {
    }
    function Ja(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Un(e, t, r) {
      if (typeof t == "function")
        return Un(e, null, t);
      t || (t = {}), r = za(r || Za);
      var n = t.readable || t.readable !== false && e.readable, i = t.writable || t.writable !== false && e.writable, o2 = function() {
        e.writable || s2();
      }, a3 = e._writableState && e._writableState.finished, s2 = function() {
        i = false, a3 = true, n || r.call(e);
      }, u3 = e._readableState && e._readableState.endEmitted, l3 = function() {
        n = false, u3 = true, i || r.call(e);
      }, h5 = function(g5) {
        r.call(e, g5);
      }, c2 = function() {
        var g5;
        if (n && !u3)
          return (!e._readableState || !e._readableState.ended) && (g5 = new Nn2), r.call(e, g5);
        if (i && !a3)
          return (!e._writableState || !e._writableState.ended) && (g5 = new Nn2), r.call(e, g5);
      }, d4 = function() {
        e.req.on("finish", s2);
      };
      return Ja(e) ? (e.on("complete", s2), e.on("abort", c2), e.req ? d4() : e.on("request", d4)) : i && !e._writableState && (e.on("end", o2), e.on("close", o2)), e.on("end", l3), e.on("finish", s2), t.error !== false && e.on("error", h5), e.on("close", c2), function() {
        e.removeListener("complete", s2), e.removeListener("abort", c2), e.removeListener("request", d4), e.req && e.req.removeListener("finish", s2), e.removeListener("end", o2), e.removeListener("close", o2), e.removeListener("finish", s2), e.removeListener("end", l3), e.removeListener("error", h5), e.removeListener("close", c2);
      };
    }
    Pn.exports = Un;
  });
  Dn2 = b5((Zf, qn2) => {
    var ot3;
    function re2(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    var Qa = it2(), ne2 = Symbol("lastResolve"), he = Symbol("lastReject"), Fe = Symbol("error"), at3 = Symbol("ended"), ce2 = Symbol("lastPromise"), tr = Symbol("handlePromise"), de = Symbol("stream");
    function ie(e, t) {
      return { value: e, done: t };
    }
    function es(e) {
      var t = e[ne2];
      if (t !== null) {
        var r = e[de].read();
        r !== null && (e[ce2] = null, e[ne2] = null, e[he] = null, t(ie(r, false)));
      }
    }
    function ts(e) {
      process.nextTick(es, e);
    }
    function rs(e, t) {
      return function(r, n) {
        e.then(function() {
          if (t[at3]) {
            r(ie(undefined, true));
            return;
          }
          t[tr](r, n);
        }, n);
      };
    }
    var ns = Object.getPrototypeOf(function() {
    }), is = Object.setPrototypeOf((ot3 = { get stream() {
      return this[de];
    }, next: function() {
      var t = this, r = this[Fe];
      if (r !== null)
        return Promise.reject(r);
      if (this[at3])
        return Promise.resolve(ie(undefined, true));
      if (this[de].destroyed)
        return new Promise(function(a3, s2) {
          process.nextTick(function() {
            t[Fe] ? s2(t[Fe]) : a3(ie(undefined, true));
          });
        });
      var n = this[ce2], i;
      if (n)
        i = new Promise(rs(n, this));
      else {
        var o2 = this[de].read();
        if (o2 !== null)
          return Promise.resolve(ie(o2, false));
        i = new Promise(this[tr]);
      }
      return this[ce2] = i, i;
    } }, re2(ot3, Symbol.asyncIterator, function() {
      return this;
    }), re2(ot3, "return", function() {
      var t = this;
      return new Promise(function(r, n) {
        t[de].destroy(null, function(i) {
          if (i) {
            n(i);
            return;
          }
          r(ie(undefined, true));
        });
      });
    }), ot3), ns), os = function(t) {
      var r, n = Object.create(is, (r = {}, re2(r, de, { value: t, writable: true }), re2(r, ne2, { value: null, writable: true }), re2(r, he, { value: null, writable: true }), re2(r, Fe, { value: null, writable: true }), re2(r, at3, { value: t._readableState.endEmitted, writable: true }), re2(r, tr, { value: function(o2, a3) {
        var s2 = n[de].read();
        s2 ? (n[ce2] = null, n[ne2] = null, n[he] = null, o2(ie(s2, false))) : (n[ne2] = o2, n[he] = a3);
      }, writable: true }), r));
      return n[ce2] = null, Qa(t, function(i) {
        if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var o2 = n[he];
          o2 !== null && (n[ce2] = null, n[ne2] = null, n[he] = null, o2(i)), n[Fe] = i;
          return;
        }
        var a3 = n[ne2];
        a3 !== null && (n[ce2] = null, n[ne2] = null, n[he] = null, a3(ie(undefined, true))), n[at3] = true;
      }), t.on("readable", ts.bind(null, n)), n;
    };
    qn2.exports = os;
  });
  jn = b5((Jf, kn) => {
    kn.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Xt = b5((eu, Zn) => {
    Zn.exports = _4;
    var xe2;
    _4.ReadableState = Gn;
    var Qf = Tt3().EventEmitter, $n = function(t, r) {
      return t.listeners(r).length;
    }, Ue = At3(), st3 = _e2().Buffer, as = global.Uint8Array || function() {
    };
    function ss(e) {
      return st3.from(e);
    }
    function fs(e) {
      return st3.isBuffer(e) || e instanceof as;
    }
    var rr2 = qt(), w3;
    rr2 && rr2.debuglog ? w3 = rr2.debuglog("stream") : w3 = function() {
    };
    var us = cn(), ur2 = jt(), ls = Wt(), hs = ls.getHighWaterMark, ft2 = fe2().codes, cs = ft2.ERR_INVALID_ARG_TYPE, ds = ft2.ERR_STREAM_PUSH_AFTER_EOF, ps = ft2.ERR_METHOD_NOT_IMPLEMENTED, ys = ft2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Re, nr, ir2;
    Q4()(_4, Ue);
    var Ne = ur2.errorOrDestroy, or = ["error", "close", "destroy", "pause", "resume"];
    function gs(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    function Gn(e, t, r) {
      xe2 = xe2 || ue2(), e = e || {}, typeof r != "boolean" && (r = t instanceof xe2), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = hs(this, e, "readableHighWaterMark", r), this.buffer = new us, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (Re || (Re = (er(), _t3(Qt)).StringDecoder), this.decoder = new Re(e.encoding), this.encoding = e.encoding);
    }
    function _4(e) {
      if (xe2 = xe2 || ue2(), !(this instanceof _4))
        return new _4(e);
      var t = this instanceof xe2;
      this._readableState = new Gn(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), Ue.call(this);
    }
    Object.defineProperty(_4.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } });
    _4.prototype.destroy = ur2.destroy;
    _4.prototype._undestroy = ur2.undestroy;
    _4.prototype._destroy = function(e, t) {
      t(e);
    };
    _4.prototype.push = function(e, t) {
      var r = this._readableState, n;
      return r.objectMode ? n = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = st3.from(e, t), t = ""), n = true), Kn(this, e, t, false, n);
    };
    _4.prototype.unshift = function(e) {
      return Kn(this, e, null, true, false);
    };
    function Kn(e, t, r, n, i) {
      w3("readableAddChunk", t);
      var o2 = e._readableState;
      if (t === null)
        o2.reading = false, bs(e, o2);
      else {
        var a3;
        if (i || (a3 = ws(o2, t)), a3)
          Ne(e, a3);
        else if (o2.objectMode || t && t.length > 0)
          if (typeof t != "string" && !o2.objectMode && Object.getPrototypeOf(t) !== st3.prototype && (t = ss(t)), n)
            o2.endEmitted ? Ne(e, new ys) : ar2(e, o2, t, true);
          else if (o2.ended)
            Ne(e, new ds);
          else {
            if (o2.destroyed)
              return false;
            o2.reading = false, o2.decoder && !r ? (t = o2.decoder.write(t), o2.objectMode || t.length !== 0 ? ar2(e, o2, t, false) : fr(e, o2)) : ar2(e, o2, t, false);
          }
        else
          n || (o2.reading = false, fr(e, o2));
      }
      return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
    }
    function ar2(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ut2(e)), fr(e, t);
    }
    function ws(e, t) {
      var r;
      return !fs(t) && typeof t != "string" && t !== undefined && !e.objectMode && (r = new cs("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
    }
    _4.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    _4.prototype.setEncoding = function(e) {
      Re || (Re = (er(), _t3(Qt)).StringDecoder);
      var t = new Re(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, n = "";r !== null; )
        n += t.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
    };
    var Wn = 1073741824;
    function ms(e) {
      return e >= Wn ? e = Wn : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Hn(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = ms(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
    }
    _4.prototype.read = function(e) {
      w3("read", e), e = parseInt(e, 10);
      var t = this._readableState, r = e;
      if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return w3("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? sr(this) : ut2(this), null;
      if (e = Hn(e, t), e === 0 && t.ended)
        return t.length === 0 && sr(this), null;
      var n = t.needReadable;
      w3("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, w3("length less than watermark", n)), t.ended || t.reading ? (n = false, w3("reading or ended", n)) : n && (w3("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = Hn(r, t)));
      var i;
      return e > 0 ? i = Xn(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && sr(this)), i !== null && this.emit("data", i), i;
    };
    function bs(e, t) {
      if (w3("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ut2(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, Vn(e)));
      }
    }
    function ut2(e) {
      var t = e._readableState;
      w3("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (w3("emitReadable", t.flowing), t.emittedReadable = true, process.nextTick(Vn, e));
    }
    function Vn(e) {
      var t = e._readableState;
      w3("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, lr(e);
    }
    function fr(e, t) {
      t.readingMore || (t.readingMore = true, process.nextTick(_s, e, t));
    }
    function _s(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        var r = t.length;
        if (w3("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    _4.prototype._read = function(e) {
      Ne(this, new ps("_read()"));
    };
    _4.prototype.pipe = function(e, t) {
      var r = this, n = this._readableState;
      switch (n.pipesCount) {
        case 0:
          n.pipes = e;
          break;
        case 1:
          n.pipes = [n.pipes, e];
          break;
        default:
          n.pipes.push(e);
          break;
      }
      n.pipesCount += 1, w3("pipe count=%d opts=%j", n.pipesCount, t);
      var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr, o2 = i ? s2 : E5;
      n.endEmitted ? process.nextTick(o2) : r.once("end", o2), e.on("unpipe", a3);
      function a3(v4, m3) {
        w3("onunpipe"), v4 === r && m3 && m3.hasUnpiped === false && (m3.hasUnpiped = true, h5());
      }
      function s2() {
        w3("onend"), e.end();
      }
      var u3 = vs(r);
      e.on("drain", u3);
      var l3 = false;
      function h5() {
        w3("cleanup"), e.removeListener("close", p3), e.removeListener("finish", g5), e.removeListener("drain", u3), e.removeListener("error", d4), e.removeListener("unpipe", a3), r.removeListener("end", s2), r.removeListener("end", E5), r.removeListener("data", c2), l3 = true, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && u3();
      }
      r.on("data", c2);
      function c2(v4) {
        w3("ondata");
        var m3 = e.write(v4);
        w3("dest.write", m3), m3 === false && ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && zn2(n.pipes, e) !== -1) && !l3 && (w3("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
      }
      function d4(v4) {
        w3("onerror", v4), E5(), e.removeListener("error", d4), $n(e, "error") === 0 && Ne(e, v4);
      }
      gs(e, "error", d4);
      function p3() {
        e.removeListener("finish", g5), E5();
      }
      e.once("close", p3);
      function g5() {
        w3("onfinish"), e.removeListener("close", p3), E5();
      }
      e.once("finish", g5);
      function E5() {
        w3("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), n.flowing || (w3("pipe resume"), r.resume()), e;
    };
    function vs(e) {
      return function() {
        var r = e._readableState;
        w3("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && $n(e, "data") && (r.flowing = true, lr(e));
      };
    }
    _4.prototype.unpipe = function(e) {
      var t = this._readableState, r = { hasUnpiped: false };
      if (t.pipesCount === 0)
        return this;
      if (t.pipesCount === 1)
        return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
      if (!e) {
        var { pipes: n, pipesCount: i } = t;
        t.pipes = null, t.pipesCount = 0, t.flowing = false;
        for (var o2 = 0;o2 < i; o2++)
          n[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var a3 = zn2(t.pipes, e);
      return a3 === -1 ? this : (t.pipes.splice(a3, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    _4.prototype.on = function(e, t) {
      var r = Ue.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, w3("on readable", n.length, n.reading), n.length ? ut2(this) : n.reading || process.nextTick(Es, this)), r;
    };
    _4.prototype.addListener = _4.prototype.on;
    _4.prototype.removeListener = function(e, t) {
      var r = Ue.prototype.removeListener.call(this, e, t);
      return e === "readable" && process.nextTick(Yn, this), r;
    };
    _4.prototype.removeAllListeners = function(e) {
      var t = Ue.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && process.nextTick(Yn, this), t;
    };
    function Yn(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
    }
    function Es(e) {
      w3("readable nexttick read 0"), e.read(0);
    }
    _4.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (w3("resume"), e.flowing = !e.readableListening, xs(this, e)), e.paused = false, this;
    };
    function xs(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, process.nextTick(Rs, e, t));
    }
    function Rs(e, t) {
      w3("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), lr(e), t.flowing && !t.reading && e.read(0);
    }
    _4.prototype.pause = function() {
      return w3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (w3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function lr(e) {
      var t = e._readableState;
      for (w3("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    _4.prototype.wrap = function(e) {
      var t = this, r = this._readableState, n = false;
      e.on("end", function() {
        if (w3("wrapped end"), r.decoder && !r.ended) {
          var a3 = r.decoder.end();
          a3 && a3.length && t.push(a3);
        }
        t.push(null);
      }), e.on("data", function(a3) {
        if (w3("wrapped data"), r.decoder && (a3 = r.decoder.write(a3)), !(r.objectMode && a3 == null) && !(!r.objectMode && (!a3 || !a3.length))) {
          var s2 = t.push(a3);
          s2 || (n = true, e.pause());
        }
      });
      for (var i in e)
        this[i] === undefined && typeof e[i] == "function" && (this[i] = function(s2) {
          return function() {
            return e[s2].apply(e, arguments);
          };
        }(i));
      for (var o2 = 0;o2 < or.length; o2++)
        e.on(or[o2], this.emit.bind(this, or[o2]));
      return this._read = function(a3) {
        w3("wrapped _read", a3), n && (n = false, e.resume());
      }, this;
    };
    typeof Symbol == "function" && (_4.prototype[Symbol.asyncIterator] = function() {
      return nr === undefined && (nr = Dn2()), nr(this);
    });
    Object.defineProperty(_4.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(_4.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(_4.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } });
    _4._fromList = Xn;
    Object.defineProperty(_4.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Xn(e, t) {
      if (t.length === 0)
        return null;
      var r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function sr(e) {
      var t = e._readableState;
      w3("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, process.nextTick(Ss, t, e));
    }
    function Ss(e, t) {
      if (w3("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy();
      }
    }
    typeof Symbol == "function" && (_4.from = function(e, t) {
      return ir2 === undefined && (ir2 = jn()), ir2(_4, e, t);
    });
    function zn2(e, t) {
      for (var r = 0, n = e.length;r < n; r++)
        if (e[r] === t)
          return r;
      return -1;
    }
  });
  hr2 = b5((tu, Qn2) => {
    Qn2.exports = z;
    var lt3 = fe2().codes, Ts = lt3.ERR_METHOD_NOT_IMPLEMENTED, As = lt3.ERR_MULTIPLE_CALLBACK, Bs = lt3.ERR_TRANSFORM_ALREADY_TRANSFORMING, Is = lt3.ERR_TRANSFORM_WITH_LENGTH_0, ht2 = ue2();
    Q4()(z, ht2);
    function Cs(e, t) {
      var r = this._transformState;
      r.transforming = false;
      var n = r.writecb;
      if (n === null)
        return this.emit("error", new As);
      r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
      var i = this._readableState;
      i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function z(e) {
      if (!(this instanceof z))
        return new z(e);
      ht2.call(this, e), this._transformState = { afterTransform: Cs.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Ls);
    }
    function Ls() {
      var e = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
        Jn(e, t, r);
      }) : Jn(this, null, null);
    }
    z.prototype.push = function(e, t) {
      return this._transformState.needTransform = false, ht2.prototype.push.call(this, e, t);
    };
    z.prototype._transform = function(e, t, r) {
      r(new Ts("_transform()"));
    };
    z.prototype._write = function(e, t, r) {
      var n = this._transformState;
      if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
      }
    };
    z.prototype._read = function(e) {
      var t = this._transformState;
      t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
    };
    z.prototype._destroy = function(e, t) {
      ht2.prototype._destroy.call(this, e, function(r) {
        t(r);
      });
    };
    function Jn(e, t, r) {
      if (t)
        return e.emit("error", t);
      if (r != null && e.push(r), e._writableState.length)
        throw new Is;
      if (e._transformState.transforming)
        throw new Bs;
      return e.push(null);
    }
  });
  ri2 = b5((ru, ti2) => {
    ti2.exports = Pe3;
    var ei = hr2();
    Q4()(Pe3, ei);
    function Pe3(e) {
      if (!(this instanceof Pe3))
        return new Pe3(e);
      ei.call(this, e);
    }
    Pe3.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  si = b5((nu, ai2) => {
    var cr2;
    function Ms(e) {
      var t = false;
      return function() {
        t || (t = true, e.apply(undefined, arguments));
      };
    }
    var oi = fe2().codes, Os = oi.ERR_MISSING_ARGS, Fs = oi.ERR_STREAM_DESTROYED;
    function ni(e) {
      if (e)
        throw e;
    }
    function Ns(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Us2(e, t, r, n) {
      n = Ms(n);
      var i = false;
      e.on("close", function() {
        i = true;
      }), cr2 === undefined && (cr2 = it2()), cr2(e, { readable: t, writable: r }, function(a3) {
        if (a3)
          return n(a3);
        i = true, n();
      });
      var o2 = false;
      return function(a3) {
        if (!i && !o2) {
          if (o2 = true, Ns(e))
            return e.abort();
          if (typeof e.destroy == "function")
            return e.destroy();
          n(a3 || new Fs("pipe"));
        }
      };
    }
    function ii2(e) {
      e();
    }
    function Ps(e, t) {
      return e.pipe(t);
    }
    function qs(e) {
      return !e.length || typeof e[e.length - 1] != "function" ? ni : e.pop();
    }
    function Ds() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      var n = qs(t);
      if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
        throw new Os("streams");
      var i, o2 = t.map(function(a3, s2) {
        var u3 = s2 < t.length - 1, l3 = s2 > 0;
        return Us2(a3, u3, l3, function(h5) {
          i || (i = h5), h5 && o2.forEach(ii2), !u3 && (o2.forEach(ii2), n(i));
        });
      });
      return t.reduce(Ps);
    }
    ai2.exports = Ds;
  });
  dr3 = b5((q3, fi2) => {
    q3 = fi2.exports = Xt();
    q3.Stream = q3;
    q3.Readable = q3;
    q3.Writable = Kt2();
    q3.Duplex = ue2();
    q3.Transform = hr2();
    q3.PassThrough = ri2();
    q3.finished = it2();
    q3.pipeline = si();
  });
  gr3 = b5((yr2) => {
    var ui = xt(), ks = Q4(), li2 = dr3(), ct3 = yr2.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, pr2 = yr2.IncomingMessage = function(e, t, r, n) {
      var i = this;
      if (li2.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
        process.nextTick(function() {
          i.emit("close");
        });
      }), r === "fetch") {
        let c2 = function() {
          a3.read().then(function(d4) {
            if (!i._destroyed) {
              if (n(d4.done), d4.done) {
                i.push(null);
                return;
              }
              i.push(Buffer.from(d4.value)), c2();
            }
          }).catch(function(d4) {
            n(true), i._destroyed || i.emit("error", d4);
          });
        };
        var h5 = c2;
        if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(d4, p3) {
          i.headers[p3.toLowerCase()] = d4, i.rawHeaders.push(p3, d4);
        }), ui.writableStream) {
          var o2 = new WritableStream({ write: function(d4) {
            return n(false), new Promise(function(p3, g5) {
              i._destroyed ? g5() : i.push(Buffer.from(d4)) ? p3() : i._resumeFetch = p3;
            });
          }, close: function() {
            n(true), i._destroyed || i.push(null);
          }, abort: function(d4) {
            n(true), i._destroyed || i.emit("error", d4);
          } });
          try {
            t.body.pipeTo(o2).catch(function(d4) {
              n(true), i._destroyed || i.emit("error", d4);
            });
            return;
          } catch {
          }
        }
        var a3 = t.body.getReader();
        c2();
      } else {
        i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
        var s2 = e.getAllResponseHeaders().split(/\r?\n/);
        if (s2.forEach(function(c2) {
          var d4 = c2.match(/^([^:]+):\s*(.*)/);
          if (d4) {
            var p3 = d4[1].toLowerCase();
            p3 === "set-cookie" ? (i.headers[p3] === undefined && (i.headers[p3] = []), i.headers[p3].push(d4[2])) : i.headers[p3] !== undefined ? i.headers[p3] += ", " + d4[2] : i.headers[p3] = d4[2], i.rawHeaders.push(d4[1], d4[2]);
          }
        }), i._charset = "x-user-defined", !ui.overrideMimeType) {
          var u3 = i.rawHeaders["mime-type"];
          if (u3) {
            var l3 = u3.match(/;\s*charset=([^;])(;|$)/);
            l3 && (i._charset = l3[1].toLowerCase());
          }
          i._charset || (i._charset = "utf-8");
        }
      }
    };
    ks(pr2, li2.Readable);
    pr2.prototype._read = function() {
      var e = this, t = e._resumeFetch;
      t && (e._resumeFetch = null, t());
    };
    pr2.prototype._onXHRProgress = function(e) {
      var t = this, r = t._xhr, n = null;
      switch (t._mode) {
        case "text":
          if (n = r.responseText, n.length > t._pos) {
            var i = n.substr(t._pos);
            if (t._charset === "x-user-defined") {
              for (var o2 = Buffer.alloc(i.length), a3 = 0;a3 < i.length; a3++)
                o2[a3] = i.charCodeAt(a3) & 255;
              t.push(o2);
            } else
              t.push(i, t._charset);
            t._pos = n.length;
          }
          break;
        case "arraybuffer":
          if (r.readyState !== ct3.DONE || !r.response)
            break;
          n = r.response, t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "moz-chunked-arraybuffer":
          if (n = r.response, r.readyState !== ct3.LOADING || !n)
            break;
          t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "ms-stream":
          if (n = r.response, r.readyState !== ct3.LOADING)
            break;
          var s2 = new global.MSStreamReader;
          s2.onprogress = function() {
            s2.result.byteLength > t._pos && (t.push(Buffer.from(new Uint8Array(s2.result.slice(t._pos)))), t._pos = s2.result.byteLength);
          }, s2.onload = function() {
            e(true), t.push(null);
          }, s2.readAsArrayBuffer(n);
          break;
      }
      t._xhr.readyState === ct3.DONE && t._mode !== "ms-stream" && (e(true), t.push(null));
    };
  });
  pi2 = b5((ou2, di2) => {
    var pe = xt(), js2 = Q4(), ci2 = gr3(), wr = dr3(), Ws2 = ci2.IncomingMessage, hi = ci2.readyStates;
    function Hs2(e, t) {
      return pe.fetch && t ? "fetch" : pe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : pe.msstream ? "ms-stream" : pe.arraybuffer && e ? "arraybuffer" : "text";
    }
    var M3 = di2.exports = function(e) {
      var t = this;
      wr.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
        t.setHeader(i, e.headers[i]);
      });
      var r, n = true;
      if (e.mode === "disable-fetch" || "requestTimeout" in e && !pe.abortController)
        n = false, r = true;
      else if (e.mode === "prefer-streaming")
        r = false;
      else if (e.mode === "allow-wrong-content-type")
        r = !pe.overrideMimeType;
      else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
        r = true;
      else
        throw new Error("Invalid value for opts.mode");
      t._mode = Hs2(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
        t._onFinish();
      });
    };
    js2(M3, wr.Writable);
    M3.prototype.setHeader = function(e, t) {
      var r = this, n = e.toLowerCase();
      Gs2.indexOf(n) === -1 && (r._headers[n] = { name: e, value: t });
    };
    M3.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null;
    };
    M3.prototype.removeHeader = function(e) {
      var t = this;
      delete t._headers[e.toLowerCase()];
    };
    M3.prototype._onFinish = function() {
      var e = this;
      if (!e._destroyed) {
        var t = e._opts;
        "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
        var r = e._headers, n = null;
        t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, { type: (r["content-type"] || {}).value || "" }));
        var i = [];
        if (Object.keys(r).forEach(function(u3) {
          var l3 = r[u3].name, h5 = r[u3].value;
          Array.isArray(h5) ? h5.forEach(function(c2) {
            i.push([l3, c2]);
          }) : i.push([l3, h5]);
        }), e._mode === "fetch") {
          var o2 = null;
          if (pe.abortController) {
            var a3 = new AbortController;
            o2 = a3.signal, e._fetchAbortController = a3, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = global.setTimeout(function() {
              e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
            }, t.requestTimeout));
          }
          global.fetch(e._opts.url, { method: e._opts.method, headers: i, body: n || undefined, mode: "cors", credentials: t.withCredentials ? "include" : "same-origin", signal: o2 }).then(function(u3) {
            e._fetchResponse = u3, e._resetTimers(false), e._connect();
          }, function(u3) {
            e._resetTimers(true), e._destroyed || e.emit("error", u3);
          });
        } else {
          var s2 = e._xhr = new global.XMLHttpRequest;
          try {
            s2.open(e._opts.method, e._opts.url, true);
          } catch (u3) {
            process.nextTick(function() {
              e.emit("error", u3);
            });
            return;
          }
          "responseType" in s2 && (s2.responseType = e._mode), "withCredentials" in s2 && (s2.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in s2 && s2.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (s2.timeout = t.requestTimeout, s2.ontimeout = function() {
            e.emit("requestTimeout");
          }), i.forEach(function(u3) {
            s2.setRequestHeader(u3[0], u3[1]);
          }), e._response = null, s2.onreadystatechange = function() {
            switch (s2.readyState) {
              case hi.LOADING:
              case hi.DONE:
                e._onXHRProgress();
                break;
            }
          }, e._mode === "moz-chunked-arraybuffer" && (s2.onprogress = function() {
            e._onXHRProgress();
          }), s2.onerror = function() {
            e._destroyed || (e._resetTimers(true), e.emit("error", new Error("XHR error")));
          };
          try {
            s2.send(n);
          } catch (u3) {
            process.nextTick(function() {
              e.emit("error", u3);
            });
            return;
          }
        }
      }
    };
    function $s2(e) {
      try {
        var t = e.status;
        return t !== null && t !== 0;
      } catch {
        return false;
      }
    }
    M3.prototype._onXHRProgress = function() {
      var e = this;
      e._resetTimers(false), !(!$s2(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
    };
    M3.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new Ws2(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
        e.emit("error", t);
      }), e.emit("response", e._response));
    };
    M3.prototype._write = function(e, t, r) {
      var n = this;
      n._body.push(e), r();
    };
    M3.prototype._resetTimers = function(e) {
      var t = this;
      global.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (global.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = global.setTimeout(function() {
        t.emit("timeout");
      }, t._socketTimeout));
    };
    M3.prototype.abort = M3.prototype.destroy = function(e) {
      var t = this;
      t._destroyed = true, t._resetTimers(true), t._response && (t._response._destroyed = true), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
    };
    M3.prototype.end = function(e, t, r) {
      var n = this;
      typeof e == "function" && (r = e, e = undefined), wr.Writable.prototype.end.call(n, e, t, r);
    };
    M3.prototype.setTimeout = function(e, t) {
      var r = this;
      t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(false);
    };
    M3.prototype.flushHeaders = function() {
    };
    M3.prototype.setNoDelay = function() {
    };
    M3.prototype.setSocketKeepAlive = function() {
    };
    var Gs2 = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  gi3 = b5((au2, yi2) => {
    yi2.exports = Vs2;
    var Ks2 = Object.prototype.hasOwnProperty;
    function Vs2() {
      for (var e = {}, t = 0;t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Ks2.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }
  });
  mi2 = b5((su2, wi3) => {
    wi3.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
  });
  Ti = {};
  mt3(Ti, { decode: () => vr2, default: () => tf, encode: () => Er3, toASCII: () => Si3, toUnicode: () => Ri, ucs2decode: () => _r2, ucs2encode: () => Ei });
  Ai2 = Cr(() => {
    _i2 = "-", Ys2 = /^xn--/, Xs = /[^\0-\x7F]/, zs = /[\x2E\u3002\uFF0E\uFF61]/g, Zs = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, mr2 = 36 - 1, K4 = Math.floor, br3 = String.fromCharCode;
    Ei = (e) => String.fromCodePoint(...e), Qs = function(e) {
      return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36;
    }, bi2 = function(e, t) {
      return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
    }, xi2 = function(e, t, r) {
      let n = 0;
      for (e = r ? K4(e / 700) : e >> 1, e += K4(e / t);e > mr2 * 26 >> 1; n += 36)
        e = K4(e / mr2);
      return K4(n + (mr2 + 1) * e / (e + 38));
    }, vr2 = function(e) {
      let t = [], r = e.length, n = 0, i = 128, o2 = 72, a3 = e.lastIndexOf(_i2);
      a3 < 0 && (a3 = 0);
      for (let s2 = 0;s2 < a3; ++s2)
        e.charCodeAt(s2) >= 128 && oe2("not-basic"), t.push(e.charCodeAt(s2));
      for (let s2 = a3 > 0 ? a3 + 1 : 0;s2 < r; ) {
        let u3 = n;
        for (let h5 = 1, c2 = 36;; c2 += 36) {
          s2 >= r && oe2("invalid-input");
          let d4 = Qs(e.charCodeAt(s2++));
          d4 >= 36 && oe2("invalid-input"), d4 > K4((2147483647 - n) / h5) && oe2("overflow"), n += d4 * h5;
          let p3 = c2 <= o2 ? 1 : c2 >= o2 + 26 ? 26 : c2 - o2;
          if (d4 < p3)
            break;
          let g5 = 36 - p3;
          h5 > K4(2147483647 / g5) && oe2("overflow"), h5 *= g5;
        }
        let l3 = t.length + 1;
        o2 = xi2(n - u3, l3, u3 == 0), K4(n / l3) > 2147483647 - i && oe2("overflow"), i += K4(n / l3), n %= l3, t.splice(n++, 0, i);
      }
      return String.fromCodePoint(...t);
    }, Er3 = function(e) {
      let t = [];
      e = _r2(e);
      let r = e.length, n = 128, i = 0, o2 = 72;
      for (let u3 of e)
        u3 < 128 && t.push(br3(u3));
      let a3 = t.length, s2 = a3;
      for (a3 && t.push(_i2);s2 < r; ) {
        let u3 = 2147483647;
        for (let h5 of e)
          h5 >= n && h5 < u3 && (u3 = h5);
        let l3 = s2 + 1;
        u3 - n > K4((2147483647 - i) / l3) && oe2("overflow"), i += (u3 - n) * l3, n = u3;
        for (let h5 of e)
          if (h5 < n && ++i > 2147483647 && oe2("overflow"), h5 === n) {
            let c2 = i;
            for (let d4 = 36;; d4 += 36) {
              let p3 = d4 <= o2 ? 1 : d4 >= o2 + 26 ? 26 : d4 - o2;
              if (c2 < p3)
                break;
              let g5 = c2 - p3, E5 = 36 - p3;
              t.push(br3(bi2(p3 + g5 % E5, 0))), c2 = K4(g5 / E5);
            }
            t.push(br3(bi2(c2, 0))), o2 = xi2(i, l3, s2 === a3), i = 0, ++s2;
          }
        ++i, ++n;
      }
      return t.join("");
    }, Ri = function(e) {
      return vi2(e, function(t) {
        return Ys2.test(t) ? vr2(t.slice(4).toLowerCase()) : t;
      });
    }, Si3 = function(e) {
      return vi2(e, function(t) {
        return Xs.test(t) ? "xn--" + Er3(t) : t;
      });
    }, ef = { version: "2.1.0", ucs2: { decode: _r2, encode: Ei }, decode: vr2, encode: Er3, toASCII: Si3, toUnicode: Ri }, tf = ef;
  });
  Ii = b5((fu2, Bi) => {
    Bi.exports = { isString: function(e) {
      return typeof e == "string";
    }, isObject: function(e) {
      return typeof e == "object" && e !== null;
    }, isNull: function(e) {
      return e === null;
    }, isNullOrUndefined: function(e) {
      return e == null;
    } };
  });
  Li = b5((uu2, Ci) => {
    var rf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, nf = Object.keys || function() {
      var e = Object.prototype.hasOwnProperty, t = !{ toString: null }.propertyIsEnumerable("toString"), r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], n = r.length;
      return function(i) {
        if (typeof i != "function" && ((typeof i > "u" ? "undefined" : rf(i)) !== "object" || i === null))
          throw new TypeError("Object.keys called on non-object");
        var o2 = [], a3, s2;
        for (a3 in i)
          e.call(i, a3) && o2.push(a3);
        if (t)
          for (s2 = 0;s2 < n; s2++)
            e.call(i, r[s2]) && o2.push(r[s2]);
        return o2;
      };
    }();
    Ci.exports = nf;
  });
  ji = b5((lu2, ki) => {
    var Pi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, pt3 = ki.exports = { unescapeBuffer: ff2, unescape: Di2, escape: lf, stringify: Fi, encode: Fi, parse: Ui, decode: Ui }, of = _e2().Buffer, af = Li(), sf = function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    }, Mi = function(t, r, n) {
      var i;
      if (t == null)
        throw new TypeError('"arr" is null or not defined');
      var o2 = Object(t), a3 = o2.length >>> 0;
      if (a3 === 0)
        return -1;
      var s2 = n | 0;
      if (s2 >= a3)
        return -1;
      for (i = Math.max(s2 >= 0 ? s2 : a3 - Math.abs(s2), 0);i < a3; ) {
        if (i in o2 && o2[i] === r)
          return i;
        i++;
      }
      return -1;
    };
    function qi() {
    }
    qi.prototype = Object.create ? Object.create(null) : {};
    var Oi = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    function ff2(e, t) {
      for (var r = of.allocUnsafe(e.length), n = 0, i, o2, a3, s2, u3 = 0, l3 = 0;; u3++) {
        if (u3 < e.length)
          s2 = e.charCodeAt(u3);
        else {
          n > 0 && (r[l3++] = 37, n === 2 && (r[l3++] = a3));
          break;
        }
        switch (n) {
          case 0:
            switch (s2) {
              case 37:
                i = 0, o2 = 0, n = 1;
                break;
              case 43:
                t && (s2 = 32);
              default:
                r[l3++] = s2;
                break;
            }
            break;
          case 1:
            if (a3 = s2, i = Oi[s2], !(i >= 0)) {
              r[l3++] = 37, r[l3++] = s2, n = 0;
              break;
            }
            n = 2;
            break;
          case 2:
            if (n = 0, o2 = Oi[s2], !(o2 >= 0)) {
              r[l3++] = 37, r[l3++] = a3, r[l3++] = s2;
              break;
            }
            r[l3++] = 16 * i + o2;
            break;
        }
      }
      return r.slice(0, l3);
    }
    function Di2(e, t) {
      try {
        return decodeURIComponent(e);
      } catch {
        return pt3.unescapeBuffer(e, t).toString();
      }
    }
    var k3 = [];
    for (Se2 = 0;Se2 < 256; ++Se2)
      k3[Se2] = "%" + ((Se2 < 16 ? "0" : "") + Se2.toString(16)).toUpperCase();
    var Se2, uf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0];
    function lf(e) {
      typeof e != "string" && ((typeof e > "u" ? "undefined" : Pi(e)) === "object" ? e = String(e) : e += "");
      for (var t = "", r = 0, n = 0;n < e.length; ++n) {
        var i = e.charCodeAt(n);
        if (i < 128) {
          if (uf[i] === 1)
            continue;
          r < n && (t += e.slice(r, n)), r = n + 1, t += k3[i];
          continue;
        }
        if (r < n && (t += e.slice(r, n)), i < 2048) {
          r = n + 1, t += k3[192 | i >> 6] + k3[128 | i & 63];
          continue;
        }
        if (i < 55296 || i >= 57344) {
          r = n + 1, t += k3[224 | i >> 12] + k3[128 | i >> 6 & 63] + k3[128 | i & 63];
          continue;
        }
        ++n;
        var o2;
        if (n < e.length)
          o2 = e.charCodeAt(n) & 1023;
        else
          throw new URIError("URI malformed");
        r = n + 1, i = 65536 + ((i & 1023) << 10 | o2), t += k3[240 | i >> 18] + k3[128 | i >> 12 & 63] + k3[128 | i >> 6 & 63] + k3[128 | i & 63];
      }
      return r === 0 ? e : r < e.length ? t + e.slice(r) : t;
    }
    function xr2(e) {
      return typeof e == "string" ? e : typeof e == "number" && isFinite(e) ? "" + e : typeof e == "boolean" ? e ? "true" : "false" : "";
    }
    function Fi(e, t, r, n) {
      t = t || "&", r = r || "=";
      var i = pt3.escape;
      if (n && typeof n.encodeURIComponent == "function" && (i = n.encodeURIComponent), e !== null && (typeof e > "u" ? "undefined" : Pi(e)) === "object") {
        for (var o2 = af(e), a3 = o2.length, s2 = a3 - 1, u3 = "", l3 = 0;l3 < a3; ++l3) {
          var h5 = o2[l3], c2 = e[h5], d4 = i(xr2(h5)) + r;
          if (sf(c2)) {
            for (var p3 = c2.length, g5 = p3 - 1, E5 = 0;E5 < p3; ++E5)
              u3 += d4 + i(xr2(c2[E5])), E5 < g5 && (u3 += t);
            p3 && l3 < s2 && (u3 += t);
          } else
            u3 += d4 + i(xr2(c2)), l3 < s2 && (u3 += t);
        }
        return u3;
      }
      return "";
    }
    function Ni2(e) {
      if (e.length === 0)
        return [];
      if (e.length === 1)
        return [e.charCodeAt(0)];
      for (var t = [], r = 0;r < e.length; ++r)
        t[t.length] = e.charCodeAt(r);
      return t;
    }
    var hf = [38], cf2 = [61];
    function Ui(e, t, r, n) {
      var i = new qi;
      if (typeof e != "string" || e.length === 0)
        return i;
      var o2 = t ? Ni2(t + "") : hf, a3 = r ? Ni2(r + "") : cf2, s2 = o2.length, u3 = a3.length, l3 = 1000;
      n && typeof n.maxKeys == "number" && (l3 = n.maxKeys > 0 ? n.maxKeys : -1);
      var h5 = pt3.unescape;
      n && typeof n.decodeURIComponent == "function" && (h5 = n.decodeURIComponent);
      for (var c2 = h5 !== Di2, d4 = [], p3 = 0, g5 = 0, E5 = 0, v4 = 0, m3 = "", y5 = "", R4 = c2, C3 = c2, T3 = 0, S3 = 0;S3 < e.length; ++S3) {
        var B3 = e.charCodeAt(S3);
        if (B3 === o2[E5]) {
          if (++E5 === s2) {
            var F2 = S3 - E5 + 1;
            if (v4 < u3 ? g5 < F2 && (m3 += e.slice(g5, F2)) : g5 < F2 && (y5 += e.slice(g5, F2)), R4 && (m3 = dt3(m3, h5)), C3 && (y5 = dt3(y5, h5)), m3 || y5 || g5 - p3 > s2 || S3 === 0)
              if (Mi(d4, m3) === -1)
                i[m3] = y5, d4[d4.length] = m3;
              else {
                var L4 = i[m3] || "";
                L4.pop ? L4[L4.length] = y5 : L4 && (i[m3] = [L4, y5]);
              }
            else
              S3 === 1 && delete i[m3];
            if (--l3 === 0)
              break;
            R4 = C3 = c2, T3 = 0, m3 = y5 = "", p3 = g5, g5 = S3 + 1, E5 = v4 = 0;
          }
          continue;
        } else
          E5 = 0, C3 || (B3 === 37 ? T3 = 1 : T3 > 0 && (B3 >= 48 && B3 <= 57 || B3 >= 65 && B3 <= 70 || B3 >= 97 && B3 <= 102) ? ++T3 === 3 && (C3 = true) : T3 = 0);
        if (v4 < u3)
          if (B3 === a3[v4]) {
            if (++v4 === u3) {
              var Y3 = S3 - v4 + 1;
              g5 < Y3 && (m3 += e.slice(g5, Y3)), T3 = 0, g5 = S3 + 1;
            }
            continue;
          } else
            v4 = 0, R4 || (B3 === 37 ? T3 = 1 : T3 > 0 && (B3 >= 48 && B3 <= 57 || B3 >= 65 && B3 <= 70 || B3 >= 97 && B3 <= 102) ? ++T3 === 3 && (R4 = true) : T3 = 0);
        B3 === 43 && (v4 < u3 ? (g5 < S3 && (m3 += e.slice(g5, S3)), m3 += "%20", R4 = true) : (g5 < S3 && (y5 += e.slice(g5, S3)), y5 += "%20", C3 = true), g5 = S3 + 1);
      }
      if (l3 !== 0 && (g5 < e.length || v4 > 0))
        if (g5 < e.length && (v4 < u3 ? m3 += e.slice(g5) : E5 < s2 && (y5 += e.slice(g5))), R4 && (m3 = dt3(m3, h5)), C3 && (y5 = dt3(y5, h5)), Mi(d4, m3) === -1)
          i[m3] = y5, d4[d4.length] = m3;
        else {
          var Z3 = i[m3];
          Z3.pop ? Z3[Z3.length] = y5 : i[m3] = [Z3, y5];
        }
      return i;
    }
    function dt3(e, t) {
      try {
        return t(e);
      } catch {
        return pt3.unescape(e, true);
      }
    }
  });
  Ar2 = b5((Ae2) => {
    var df = (Ai2(), _t3(Ti)), V5 = Ii();
    Ae2.parse = qe2;
    Ae2.resolve = xf;
    Ae2.resolveObject = Rf;
    Ae2.format = Ef2;
    Ae2.Url = D3;
    function D3() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var pf = /^([a-z0-9.+-]+:)/i, yf2 = /:[0-9]*$/, gf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, wf = ["<", ">", '"', "`", " ", "\r", `
`, "\t"], mf2 = ["{", "}", "|", "\\", "^", "`"].concat(wf), Rr3 = ["'"].concat(mf2), Wi = ["%", "/", "?", ";", "#"].concat(Rr3), Hi2 = ["/", "?", "#"], bf = 255, $i = /^[+a-z0-9A-Z_-]{0,63}$/, _f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, vf2 = { javascript: true, "javascript:": true }, Sr = { javascript: true, "javascript:": true }, Te = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, Tr = ji();
    function qe2(e, t, r) {
      if (e && V5.isObject(e) && e instanceof D3)
        return e;
      var n = new D3;
      return n.parse(e, t, r), n;
    }
    D3.prototype.parse = function(e, t, r) {
      if (!V5.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
      var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o2 = e.split(i), a3 = /\\/g;
      o2[0] = o2[0].replace(a3, "/"), e = o2.join(i);
      var s2 = e;
      if (s2 = s2.trim(), !r && e.split("#").length === 1) {
        var u3 = gf.exec(s2);
        if (u3)
          return this.path = s2, this.href = s2, this.pathname = u3[1], u3[2] ? (this.search = u3[2], t ? this.query = Tr.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
      }
      var l3 = pf.exec(s2);
      if (l3) {
        l3 = l3[0];
        var h5 = l3.toLowerCase();
        this.protocol = h5, s2 = s2.substr(l3.length);
      }
      if (r || l3 || s2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var c2 = s2.substr(0, 2) === "//";
        c2 && !(l3 && Sr[l3]) && (s2 = s2.substr(2), this.slashes = true);
      }
      if (!Sr[l3] && (c2 || l3 && !Te[l3])) {
        for (var d4 = -1, p3 = 0;p3 < Hi2.length; p3++) {
          var g5 = s2.indexOf(Hi2[p3]);
          g5 !== -1 && (d4 === -1 || g5 < d4) && (d4 = g5);
        }
        var E5, v4;
        d4 === -1 ? v4 = s2.lastIndexOf("@") : v4 = s2.lastIndexOf("@", d4), v4 !== -1 && (E5 = s2.slice(0, v4), s2 = s2.slice(v4 + 1), this.auth = decodeURIComponent(E5)), d4 = -1;
        for (var p3 = 0;p3 < Wi.length; p3++) {
          var g5 = s2.indexOf(Wi[p3]);
          g5 !== -1 && (d4 === -1 || g5 < d4) && (d4 = g5);
        }
        d4 === -1 && (d4 = s2.length), this.host = s2.slice(0, d4), s2 = s2.slice(d4), this.parseHost(), this.hostname = this.hostname || "";
        var m3 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!m3)
          for (var y5 = this.hostname.split(/\./), p3 = 0, R4 = y5.length;p3 < R4; p3++) {
            var C3 = y5[p3];
            if (!!C3 && !C3.match($i)) {
              for (var T3 = "", S3 = 0, B3 = C3.length;S3 < B3; S3++)
                C3.charCodeAt(S3) > 127 ? T3 += "x" : T3 += C3[S3];
              if (!T3.match($i)) {
                var F2 = y5.slice(0, p3), L4 = y5.slice(p3 + 1), Y3 = C3.match(_f);
                Y3 && (F2.push(Y3[1]), L4.unshift(Y3[2])), L4.length && (s2 = "/" + L4.join(".") + s2), this.hostname = F2.join(".");
                break;
              }
            }
          }
        this.hostname.length > bf ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m3 || (this.hostname = df.toASCII(this.hostname));
        var Z3 = this.port ? ":" + this.port : "", zi = this.hostname || "";
        this.host = zi + Z3, this.href += this.host, m3 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s2[0] !== "/" && (s2 = "/" + s2));
      }
      if (!vf2[h5])
        for (var p3 = 0, R4 = Rr3.length;p3 < R4; p3++) {
          var Be = Rr3[p3];
          if (s2.indexOf(Be) !== -1) {
            var gt3 = encodeURIComponent(Be);
            gt3 === Be && (gt3 = escape(Be)), s2 = s2.split(Be).join(gt3);
          }
        }
      var wt = s2.indexOf("#");
      wt !== -1 && (this.hash = s2.substr(wt), s2 = s2.slice(0, wt));
      var je = s2.indexOf("?");
      if (je !== -1 ? (this.search = s2.substr(je), this.query = s2.substr(je + 1), t && (this.query = Tr.parse(this.query)), s2 = s2.slice(0, je)) : t && (this.search = "", this.query = {}), s2 && (this.pathname = s2), Te[h5] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Z3 = this.pathname || "", Zi = this.search || "";
        this.path = Z3 + Zi;
      }
      return this.href = this.format(), this;
    };
    function Ef2(e) {
      return V5.isString(e) && (e = qe2(e)), e instanceof D3 ? e.format() : D3.prototype.format.call(e);
    }
    D3.prototype.format = function() {
      var e = this.auth || "";
      e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
      var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = false, o2 = "";
      this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && V5.isObject(this.query) && Object.keys(this.query).length && (o2 = Tr.stringify(this.query));
      var a3 = this.search || o2 && "?" + o2 || "";
      return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Te[t]) && i !== false ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a3 && a3.charAt(0) !== "?" && (a3 = "?" + a3), r = r.replace(/[?#]/g, function(s2) {
        return encodeURIComponent(s2);
      }), a3 = a3.replace("#", "%23"), t + i + r + a3 + n;
    };
    function xf(e, t) {
      return qe2(e, false, true).resolve(t);
    }
    D3.prototype.resolve = function(e) {
      return this.resolveObject(qe2(e, false, true)).format();
    };
    function Rf(e, t) {
      return e ? qe2(e, false, true).resolveObject(t) : t;
    }
    D3.prototype.resolveObject = function(e) {
      if (V5.isString(e)) {
        var t = new D3;
        t.parse(e, false, true), e = t;
      }
      for (var r = new D3, n = Object.keys(this), i = 0;i < n.length; i++) {
        var o2 = n[i];
        r[o2] = this[o2];
      }
      if (r.hash = e.hash, e.href === "")
        return r.href = r.format(), r;
      if (e.slashes && !e.protocol) {
        for (var a3 = Object.keys(e), s2 = 0;s2 < a3.length; s2++) {
          var u3 = a3[s2];
          u3 !== "protocol" && (r[u3] = e[u3]);
        }
        return Te[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
      }
      if (e.protocol && e.protocol !== r.protocol) {
        if (!Te[e.protocol]) {
          for (var l3 = Object.keys(e), h5 = 0;h5 < l3.length; h5++) {
            var c2 = l3[h5];
            r[c2] = e[c2];
          }
          return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !Sr[e.protocol]) {
          for (var R4 = (e.pathname || "").split("/");R4.length && !(e.host = R4.shift()); )
            ;
          e.host || (e.host = ""), e.hostname || (e.hostname = ""), R4[0] !== "" && R4.unshift(""), R4.length < 2 && R4.unshift(""), r.pathname = R4.join("/");
        } else
          r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
          var d4 = r.pathname || "", p3 = r.search || "";
          r.path = d4 + p3;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }
      var g5 = r.pathname && r.pathname.charAt(0) === "/", E5 = e.host || e.pathname && e.pathname.charAt(0) === "/", v4 = E5 || g5 || r.host && e.pathname, m3 = v4, y5 = r.pathname && r.pathname.split("/") || [], R4 = e.pathname && e.pathname.split("/") || [], C3 = r.protocol && !Te[r.protocol];
      if (C3 && (r.hostname = "", r.port = null, r.host && (y5[0] === "" ? y5[0] = r.host : y5.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (R4[0] === "" ? R4[0] = e.host : R4.unshift(e.host)), e.host = null), v4 = v4 && (R4[0] === "" || y5[0] === "")), E5)
        r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, y5 = R4;
      else if (R4.length)
        y5 || (y5 = []), y5.pop(), y5 = y5.concat(R4), r.search = e.search, r.query = e.query;
      else if (!V5.isNullOrUndefined(e.search)) {
        if (C3) {
          r.hostname = r.host = y5.shift();
          var T3 = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
          T3 && (r.auth = T3.shift(), r.host = r.hostname = T3.shift());
        }
        return r.search = e.search, r.query = e.query, (!V5.isNull(r.pathname) || !V5.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
      }
      if (!y5.length)
        return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
      for (var S3 = y5.slice(-1)[0], B3 = (r.host || e.host || y5.length > 1) && (S3 === "." || S3 === "..") || S3 === "", F2 = 0, L4 = y5.length;L4 >= 0; L4--)
        S3 = y5[L4], S3 === "." ? y5.splice(L4, 1) : S3 === ".." ? (y5.splice(L4, 1), F2++) : F2 && (y5.splice(L4, 1), F2--);
      if (!v4 && !m3)
        for (;F2--; F2)
          y5.unshift("..");
      v4 && y5[0] !== "" && (!y5[0] || y5[0].charAt(0) !== "/") && y5.unshift(""), B3 && y5.join("/").substr(-1) !== "/" && y5.push("");
      var Y3 = y5[0] === "" || y5[0] && y5[0].charAt(0) === "/";
      if (C3) {
        r.hostname = r.host = Y3 ? "" : y5.length ? y5.shift() : "";
        var T3 = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
        T3 && (r.auth = T3.shift(), r.host = r.hostname = T3.shift());
      }
      return v4 = v4 || r.host && y5.length, v4 && !Y3 && y5.unshift(""), y5.length ? r.pathname = y5.join("/") : (r.pathname = null, r.path = null), (!V5.isNull(r.pathname) || !V5.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    };
    D3.prototype.parseHost = function() {
      var e = this.host, t = yf2.exec(e);
      t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
    };
  });
  Vi2 = b5((Ki2) => {
    var Gi2 = pi2(), Sf2 = gr3(), Tf = gi3(), Af2 = mi2(), Bf = Ar2(), j5 = Ki2;
    j5.request = function(e, t) {
      typeof e == "string" ? e = Bf.parse(e) : e = Tf(e);
      var r = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", n = e.protocol || r, i = e.hostname || e.host, o2 = e.port, a3 = e.path || "/";
      i && i.indexOf(":") !== -1 && (i = "[" + i + "]"), e.url = (i ? n + "//" + i : "") + (o2 ? ":" + o2 : "") + a3, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
      var s2 = new Gi2(e);
      return t && s2.on("response", t), s2;
    };
    j5.get = function(t, r) {
      var n = j5.request(t, r);
      return n.end(), n;
    };
    j5.ClientRequest = Gi2;
    j5.IncomingMessage = Sf2.IncomingMessage;
    j5.Agent = function() {
    };
    j5.Agent.defaultMaxSockets = 4;
    j5.globalAgent = new j5.Agent;
    j5.STATUS_CODES = Af2;
    j5.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  Ir3 = b5((du, Xi2) => {
    var De = Vi2(), If = Ar2(), Br3 = Xi2.exports;
    for (yt2 in De)
      De.hasOwnProperty(yt2) && (Br3[yt2] = De[yt2]);
    var yt2;
    Br3.request = function(e, t) {
      return e = Yi2(e), De.request.call(this, e, t);
    };
    Br3.get = function(e, t) {
      return e = Yi2(e), De.get.call(this, e, t);
    };
    function Yi2(e) {
      if (typeof e == "string" && (e = If.parse(e)), e.protocol || (e.protocol = "https:"), e.protocol !== "https:")
        throw new Error('Protocol "' + e.protocol + '" not supported. Expected "https:"');
      return e;
    }
  });
  ke2 = {};
  mt3(ke2, { default: () => Cf2 });
  $e(ke2, bt3(Ir3()));
  Cf2 = bt3(Ir3());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/winston/dist/winston/transports/http.js
var require_http = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r && (o2 = o2.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r = 1;r < arguments.length; r++) {
      var t = arguments[r] != null ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var http2 = (init_http(), __toCommonJS(exports_http));
  var https = (init_https(), __toCommonJS(exports_https));
  var _require = require_readable_browser();
  var Stream = _require.Stream;
  var TransportStream = require_dist();
  var _require2 = require_safe_stable_stringify();
  var configure = _require2.configure;
  module.exports = /* @__PURE__ */ function(_TransportStream) {
    function Http() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Http);
      _this = _callSuper(this, Http, [options]);
      _this.options = options;
      _this.name = options.name || "http";
      _this.ssl = !!options.ssl;
      _this.host = options.host || "localhost";
      _this.port = options.port;
      _this.auth = options.auth;
      _this.path = options.path || "";
      _this.maximumDepth = options.maximumDepth;
      _this.agent = options.agent;
      _this.headers = options.headers || {};
      _this.headers["content-type"] = "application/json";
      _this.batch = options.batch || false;
      _this.batchInterval = options.batchInterval || 5000;
      _this.batchCount = options.batchCount || 10;
      _this.batchOptions = [];
      _this.batchTimeoutID = -1;
      _this.batchCallback = {};
      if (!_this.port) {
        _this.port = _this.ssl ? 443 : 80;
      }
      return _this;
    }
    _inherits(Http, _TransportStream);
    return _createClass(Http, [{
      key: "log",
      value: function log(info, callback) {
        var _this2 = this;
        this._request(info, null, null, function(err, res) {
          if (res && res.statusCode !== 200) {
            err = new Error("Invalid HTTP Status Code: ".concat(res.statusCode));
          }
          if (err) {
            _this2.emit("warn", err);
          } else {
            _this2.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
    }, {
      key: "query",
      value: function query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        var auth = options.params.auth || null;
        delete options.params.auth;
        var path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, function(err, res, body) {
          if (res && res.statusCode !== 200) {
            err = new Error("Invalid HTTP Status Code: ".concat(res.statusCode));
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
    }, {
      key: "stream",
      value: function stream() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var stream = new Stream;
        options = {
          method: "stream",
          params: options
        };
        var path = options.params.path || null;
        delete options.params.path;
        var auth = options.params.auth || null;
        delete options.params.auth;
        var buff = "";
        var req = this._request(options, auth, path);
        stream.destroy = function() {
          return req.destroy();
        };
        req.on("data", function(data) {
          data = (buff + data).split(/\n+/);
          var l3 = data.length - 1;
          var i = 0;
          for (;i < l3; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l3];
        });
        req.on("error", function(err) {
          return stream.emit("error", err);
        });
        return stream;
      }
    }, {
      key: "_request",
      value: function _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
    }, {
      key: "_doBatch",
      value: function _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          var me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
    }, {
      key: "_doBatchRequest",
      value: function _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        var batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
    }, {
      key: "_doRequest",
      value: function _doRequest(options, callback, auth, path) {
        var headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = "Bearer ".concat(auth.bearer);
        }
        var req = (this.ssl ? https : http2).request(_objectSpread(_objectSpread({}, this.options), {}, {
          method: "POST",
          host: this.host,
          port: this.port,
          path: "/".concat(path.replace(/^\//, "")),
          headers,
          auth: auth && auth.username && auth.password ? "".concat(auth.username, ":").concat(auth.password) : "",
          agent: this.agent
        }));
        req.on("error", callback);
        req.on("response", function(res) {
          return res.on("end", function() {
            return callback(null, res);
          }).resume();
        });
        var jsonStringify = configure(_objectSpread({}, this.maximumDepth && {
          maximumDepth: this.maximumDepth
        }));
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    }]);
  }(TransportStream);
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/winston/dist/winston/transports/stream.js
var require_stream = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var isStream = require_is_stream();
  var _require = require_triple_beam();
  var MESSAGE = _require.MESSAGE;
  var os = (init_os(), __toCommonJS(exports_os));
  var TransportStream = require_dist();
  module.exports = /* @__PURE__ */ function(_TransportStream) {
    function Stream() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Stream);
      _this = _callSuper(this, Stream, [options]);
      if (!options.stream || !isStream(options.stream)) {
        throw new Error("options.stream is required.");
      }
      _this._stream = options.stream;
      _this._stream.setMaxListeners(Infinity);
      _this.isObjectMode = options.stream._writableState.objectMode;
      _this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      return _this;
    }
    _inherits(Stream, _TransportStream);
    return _createClass(Stream, [{
      key: "log",
      value: function log(info, callback) {
        var _this2 = this;
        setImmediate(function() {
          return _this2.emit("logged", info);
        });
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write("".concat(info[MESSAGE]).concat(this.eol));
        if (callback) {
          callback();
        }
        return;
      }
    }]);
  }(TransportStream);
});

// node_modules/winston/dist/winston/transports/index.js
var require_transports = __commonJS((exports) => {
  Object.defineProperty(exports, "Console", {
    configurable: true,
    enumerable: true,
    get: function get() {
      return require_console();
    }
  });
  Object.defineProperty(exports, "File", {
    configurable: true,
    enumerable: true,
    get: function get() {
      return require_file();
    }
  });
  Object.defineProperty(exports, "Http", {
    configurable: true,
    enumerable: true,
    get: function get() {
      return require_http();
    }
  });
  Object.defineProperty(exports, "Stream", {
    configurable: true,
    enumerable: true,
    get: function get() {
      return require_stream();
    }
  });
});

// node_modules/winston/dist/winston/config/index.js
var require_config2 = __commonJS((exports) => {
  var logform = require_browser();
  var _require = require_triple_beam();
  var configs = _require.configs;
  exports.cli = logform.levels(configs.cli);
  exports.npm = logform.levels(configs.npm);
  exports.syslog = logform.levels(configs.syslog);
  exports.addColors = logform.levels;
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index2 = 0, completed = 0, { length } = coll, canceled = false;
    if (length === 0) {
      callback(null);
    }
    function iteratorCallback(err, value) {
      if (err === false) {
        canceled = true;
      }
      if (canceled === true)
        return;
      if (err) {
        callback(err);
      } else if (++completed === length || value === _breakLoop2.default) {
        callback(null);
      }
    }
    for (;index2 < length; index2++) {
      iteratee(coll[index2], index2, (0, _onlyOnce2.default)(iteratorCallback));
    }
  }
  function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
  }
  function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  }
  exports.default = (0, _awaitify2.default)(eachOf, 3);
  module.exports = exports.default;
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _withoutIndex;
  function _withoutIndex(iteratee) {
    return (value, index2, callback) => iteratee(value, callback);
  }
  module.exports = exports.default;
});

// node_modules/async/forEach.js
var require_forEach = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOf = require_eachOf();
  var _eachOf2 = _interopRequireDefault(_eachOf);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachLimit(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  }
  exports.default = (0, _awaitify2.default)(eachLimit, 3);
  module.exports = exports.default;
});

// node_modules/fn.name/index.js
var require_fn = __commonJS((exports, module) => {
  var toString = Object.prototype.toString;
  module.exports = function name(fn) {
    if (typeof fn.displayName === "string" && fn.constructor.name) {
      return fn.displayName;
    } else if (typeof fn.name === "string" && fn.name) {
      return fn.name;
    }
    if (typeof fn === "object" && fn.constructor && typeof fn.constructor.name === "string")
      return fn.constructor.name;
    var named = fn.toString(), type = toString.call(fn).slice(8, -1);
    if (type === "Function") {
      named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
    } else {
      named = type;
    }
    return named || "anonymous";
  };
});

// node_modules/one-time/index.js
var require_one_time = __commonJS((exports, module) => {
  var name = require_fn();
  module.exports = function one(fn) {
    var called = 0, value;
    function onetime() {
      if (called)
        return value;
      called = 1;
      value = fn.apply(this, arguments);
      fn = null;
      return value;
    }
    onetime.displayName = name(fn);
    return onetime;
  };
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS((exports) => {
  exports.get = function(belowFn) {
    var oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    var dummyObject = {};
    var v8Handler = Error.prepareStackTrace;
    Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
      return v8StackTrace2;
    };
    Error.captureStackTrace(dummyObject, belowFn || exports.get);
    var v8StackTrace = dummyObject.stack;
    Error.prepareStackTrace = v8Handler;
    Error.stackTraceLimit = oldLimit;
    return v8StackTrace;
  };
  exports.parse = function(err) {
    if (!err.stack) {
      return [];
    }
    var self2 = this;
    var lines = err.stack.split(`
`).slice(1);
    return lines.map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self2._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          native: null
        });
      }
      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }
      var object = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = lineMatch[5] === "native";
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] == ".")
          methodStart--;
        if (methodStart > 0) {
          object = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object = object.substr(0, objectEnd);
          }
        }
        typeName = null;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = null;
        functionName = null;
      }
      var properties = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName,
        typeName,
        methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        native: isNative
      };
      return self2._createParsedCallSite(properties);
    }).filter(function(callSite) {
      return !!callSite;
    });
  };
  function CallSite(properties) {
    for (var property in properties) {
      this[property] = properties[property];
    }
  }
  var strProperties = [
    "this",
    "typeName",
    "functionName",
    "methodName",
    "fileName",
    "lineNumber",
    "columnNumber",
    "function",
    "evalOrigin"
  ];
  var boolProperties = [
    "topLevel",
    "eval",
    "native",
    "constructor"
  ];
  strProperties.forEach(function(property) {
    CallSite.prototype[property] = null;
    CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  boolProperties.forEach(function(property) {
    CallSite.prototype[property] = false;
    CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  exports._createParsedCallSite = function(properties) {
    return new CallSite(properties);
  };
});

// node_modules/winston/dist/winston/exception-stream.js
var require_exception_stream = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var _require = require_readable_browser();
  var Writable = _require.Writable;
  module.exports = /* @__PURE__ */ function(_Writable) {
    function ExceptionStream(transport) {
      var _this;
      _classCallCheck(this, ExceptionStream);
      _this = _callSuper(this, ExceptionStream, [{
        objectMode: true
      }]);
      if (!transport) {
        throw new Error("ExceptionStream requires a TransportStream instance.");
      }
      _this.handleExceptions = true;
      _this.transport = transport;
      return _this;
    }
    _inherits(ExceptionStream, _Writable);
    return _createClass(ExceptionStream, [{
      key: "_write",
      value: function _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    }]);
  }(Writable);
});

// node_modules/winston/dist/winston/exception-handler.js
var require_exception_handler = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var os = (init_os(), __toCommonJS(exports_os));
  var asyncForEach = require_forEach();
  var debug = require_browser3()("winston:exception");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var ExceptionStream = require_exception_stream();
  module.exports = /* @__PURE__ */ function() {
    function ExceptionHandler(logger) {
      _classCallCheck(this, ExceptionHandler);
      if (!logger) {
        throw new Error("Logger is required to handle exceptions");
      }
      this.logger = logger;
      this.handlers = new Map;
    }
    return _createClass(ExceptionHandler, [{
      key: "handle",
      value: function handle() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        args.forEach(function(arg) {
          if (Array.isArray(arg)) {
            return arg.forEach(function(handler) {
              return _this._addHandler(handler);
            });
          }
          _this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
    }, {
      key: "unhandle",
      value: function unhandle() {
        var _this2 = this;
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(function(wrapper) {
            return _this2.logger.unpipe(wrapper);
          });
        }
      }
    }, {
      key: "getAllInfo",
      value: function getAllInfo(err) {
        var message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          level: "error",
          message: ["uncaughtException: ".concat(message || "(no error message)"), err && err.stack || "  No stack trace"].join(`
`),
          stack: err && err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
    }, {
      key: "getProcessInfo",
      value: function getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
    }, {
      key: "getOsInfo",
      value: function getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
    }, {
      key: "getTrace",
      value: function getTrace(err) {
        var trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map(function(site) {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
    }, {
      key: "_addHandler",
      value: function _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          var wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
    }, {
      key: "_uncaughtException",
      value: function _uncaughtException(err) {
        var info = this.getAllInfo(err);
        var handlers = this._getExceptionHandlers();
        var doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        var timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, function(handler, next) {
          var done = once(next);
          var transport = handler.transport || handler;
          function onDone(event) {
            return function() {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, function() {
          return doExit && gracefulExit();
        });
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3000);
        }
      }
    }, {
      key: "_getExceptionHandlers",
      value: function _getExceptionHandlers() {
        return this.logger.transports.filter(function(wrap) {
          var transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    }]);
  }();
});

// node_modules/winston/dist/winston/rejection-stream.js
var require_rejection_stream = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var _require = require_readable_browser();
  var Writable = _require.Writable;
  module.exports = /* @__PURE__ */ function(_Writable) {
    function RejectionStream(transport) {
      var _this;
      _classCallCheck(this, RejectionStream);
      _this = _callSuper(this, RejectionStream, [{
        objectMode: true
      }]);
      if (!transport) {
        throw new Error("RejectionStream requires a TransportStream instance.");
      }
      _this.handleRejections = true;
      _this.transport = transport;
      return _this;
    }
    _inherits(RejectionStream, _Writable);
    return _createClass(RejectionStream, [{
      key: "_write",
      value: function _write(info, enc, callback) {
        if (info.rejection) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    }]);
  }(Writable);
});

// node_modules/winston/dist/winston/rejection-handler.js
var require_rejection_handler = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var os = (init_os(), __toCommonJS(exports_os));
  var asyncForEach = require_forEach();
  var debug = require_browser3()("winston:rejection");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var RejectionStream = require_rejection_stream();
  module.exports = /* @__PURE__ */ function() {
    function RejectionHandler(logger) {
      _classCallCheck(this, RejectionHandler);
      if (!logger) {
        throw new Error("Logger is required to handle rejections");
      }
      this.logger = logger;
      this.handlers = new Map;
    }
    return _createClass(RejectionHandler, [{
      key: "handle",
      value: function handle() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        args.forEach(function(arg) {
          if (Array.isArray(arg)) {
            return arg.forEach(function(handler) {
              return _this._addHandler(handler);
            });
          }
          _this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
    }, {
      key: "unhandle",
      value: function unhandle() {
        var _this2 = this;
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(function(wrapper) {
            return _this2.logger.unpipe(wrapper);
          });
        }
      }
    }, {
      key: "getAllInfo",
      value: function getAllInfo(err) {
        var message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          level: "error",
          message: ["unhandledRejection: ".concat(message || "(no error message)"), err && err.stack || "  No stack trace"].join(`
`),
          stack: err && err.stack,
          rejection: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
    }, {
      key: "getProcessInfo",
      value: function getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
    }, {
      key: "getOsInfo",
      value: function getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
    }, {
      key: "getTrace",
      value: function getTrace(err) {
        var trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map(function(site) {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
    }, {
      key: "_addHandler",
      value: function _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          var wrapper = new RejectionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
    }, {
      key: "_unhandledRejection",
      value: function _unhandledRejection(err) {
        var info = this.getAllInfo(err);
        var handlers = this._getRejectionHandlers();
        var doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        var timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, function(handler, next) {
          var done = once(next);
          var transport = handler.transport || handler;
          function onDone(event) {
            return function() {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, function() {
          return doExit && gracefulExit();
        });
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3000);
        }
      }
    }, {
      key: "_getRejectionHandlers",
      value: function _getRejectionHandlers() {
        return this.logger.transports.filter(function(wrap) {
          var transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    }]);
  }();
});

// node_modules/winston-transport/modern.js
var require_modern2 = __commonJS((exports, module) => {
  var util = (init_util(), __toCommonJS(exports_util));
  var Writable = require__stream_writable();
  var { LEVEL } = require_triple_beam();
  var TransportStream = module.exports = function TransportStream(options = {}) {
    Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log)
      this.log = options.log;
    if (options.logv)
      this.logv = options.logv;
    if (options.close)
      this.close = options.close;
    this.once("pipe", (logger) => {
      this.levels = logger.levels;
      this.parent = logger;
    });
    this.once("unpipe", (src) => {
      if (src === this.parent) {
        this.parent = null;
        if (this.close) {
          this.close();
        }
      }
    });
  };
  util.inherits(TransportStream, Writable);
  TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    const level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (info && !this.format) {
        return this.log(info, callback);
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, info), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        callback();
        if (errState)
          throw errState;
        return;
      }
      return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
  };
  TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
      const infos = chunks.filter(this._accept, this);
      if (!infos.length) {
        return callback(null);
      }
      return this.logv(infos, callback);
    }
    for (let i = 0;i < chunks.length; i++) {
      if (!this._accept(chunks[i]))
        continue;
      if (chunks[i].chunk && !this.format) {
        this.log(chunks[i].chunk, chunks[i].callback);
        continue;
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        chunks[i].callback();
        if (errState) {
          callback(null);
          throw errState;
        }
      } else {
        this.log(transformed, chunks[i].callback);
      }
    }
    return callback(null);
  };
  TransportStream.prototype._accept = function _accept(write) {
    const info = write.chunk;
    if (this.silent) {
      return false;
    }
    const level = this.level || this.parent && this.parent.level;
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (this.handleExceptions || info.exception !== true) {
        return true;
      }
    }
    return false;
  };
  TransportStream.prototype._nop = function _nop() {
    return;
  };
});

// node_modules/winston-transport/legacy.js
var require_legacy2 = __commonJS((exports, module) => {
  var util = (init_util(), __toCommonJS(exports_util));
  var { LEVEL } = require_triple_beam();
  var TransportStream = require_modern2();
  var LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
      throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    this._deprecated();
    function transportError(err) {
      this.emit("error", err, this.transport);
    }
    if (!this.transport.__winstonError) {
      this.transport.__winstonError = transportError.bind(this);
      this.transport.on("error", this.transport.__winstonError);
    }
  };
  util.inherits(LegacyTransportStream, TransportStream);
  LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
      this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
  };
  LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for (let i = 0;i < chunks.length; i++) {
      if (this._accept(chunks[i])) {
        this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
        chunks[i].callback();
      }
    }
    return callback(null);
  };
  LegacyTransportStream.prototype._deprecated = function _deprecated() {
    console.error([
      `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
      "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
    ].join(`
`));
  };
  LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
      this.transport.close();
    }
    if (this.transport.__winstonError) {
      this.transport.removeListener("error", this.transport.__winstonError);
      this.transport.__winstonError = null;
    }
  };
});

// node_modules/winston/dist/winston/profiler.js
var require_profiler = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var Profiler = /* @__PURE__ */ function() {
    function Profiler2(logger) {
      _classCallCheck(this, Profiler2);
      var Logger = require_logger();
      if (_typeof(logger) !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
        throw new Error("Logger is required for profiling");
      } else {
        this.logger = logger;
        this.start = Date.now();
      }
    }
    return _createClass(Profiler2, [{
      key: "done",
      value: function done() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        var info = _typeof(args[args.length - 1]) === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    }]);
  }();
  module.exports = Profiler;
});

// node_modules/logform/format.js
var require_format2 = __commonJS((exports, module) => {
  class InvalidFormatError extends Error {
    constructor(formatFn) {
      super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split(`
`)[0]}
`);
      Error.captureStackTrace(this, InvalidFormatError);
    }
  }
  module.exports = (formatFn) => {
    if (formatFn.length > 2) {
      throw new InvalidFormatError(formatFn);
    }
    function Format(options = {}) {
      this.options = options;
    }
    Format.prototype.transform = formatFn;
    function createFormatWrap(opts) {
      return new Format(opts);
    }
    createFormatWrap.Format = Format;
    return createFormatWrap;
  };
});

// node_modules/logform/json.js
var require_json2 = __commonJS((exports, module) => {
  var format = require_format2();
  var { MESSAGE } = require_triple_beam();
  var stringify2 = require_safe_stable_stringify();
  function replacer(key, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  }
  module.exports = format((info, opts) => {
    const jsonStringify = stringify2.configure(opts);
    info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
    return info;
  });
});

// node_modules/winston/dist/winston/logger.js
var require_logger = __commonJS((exports, module) => {
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var _require = require_readable_browser();
  var Stream = _require.Stream;
  var Transform = _require.Transform;
  var asyncForEach = require_forEach();
  var _require2 = require_triple_beam();
  var LEVEL = _require2.LEVEL;
  var SPLAT = _require2.SPLAT;
  var isStream = require_is_stream();
  var ExceptionHandler = require_exception_handler();
  var RejectionHandler = require_rejection_handler();
  var LegacyTransportStream = require_legacy2();
  var Profiler = require_profiler();
  var _require3 = require_common();
  var warn = _require3.warn;
  var config = require_config2();
  var formatRegExp = /%[scdjifoO%]/g;
  var Logger = /* @__PURE__ */ function(_Transform) {
    function Logger2(options) {
      var _this;
      _classCallCheck(this, Logger2);
      _this = _callSuper(this, Logger2, [{
        objectMode: true
      }]);
      _this.configure(options);
      return _this;
    }
    _inherits(Logger2, _Transform);
    return _createClass(Logger2, [{
      key: "child",
      value: function child(defaultRequestMetadata) {
        var logger = this;
        return Object.create(logger, {
          write: {
            value: function value(info) {
              var infoClone = Object.assign({}, defaultRequestMetadata, info);
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
    }, {
      key: "configure",
      value: function configure() {
        var _this2 = this;
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, silent = _ref.silent, format = _ref.format, defaultMeta = _ref.defaultMeta, levels = _ref.levels, _ref$level = _ref.level, level = _ref$level === undefined ? "info" : _ref$level, _ref$exitOnError = _ref.exitOnError, exitOnError = _ref$exitOnError === undefined ? true : _ref$exitOnError, transports = _ref.transports, colors = _ref.colors, emitErrs = _ref.emitErrs, formatters2 = _ref.formatters, padLevels = _ref.padLevels, rewriters = _ref.rewriters, stripColors = _ref.stripColors, exceptionHandlers = _ref.exceptionHandlers, rejectionHandlers = _ref.rejectionHandlers;
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format || this.format || require_json2()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach(function(transport) {
            return _this2.add(transport);
          });
        }
        if (colors || emitErrs || formatters2 || padLevels || rewriters || stripColors) {
          throw new Error(["{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.", "Use a custom winston.format(function) instead.", "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"].join(`
`));
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
    }, {
      key: "isLevelEnabled",
      value: function isLevelEnabled(level) {
        var _this3 = this;
        var givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        var configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        var index2 = this.transports.findIndex(function(transport) {
          var transportLevelValue = getLevelValue(_this3.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index2 !== -1;
      }
    }, {
      key: "log",
      value: function log(level, msg) {
        for (var _len = arguments.length, splat = new Array(_len > 2 ? _len - 2 : 0), _key = 2;_key < _len; _key++) {
          splat[_key - 2] = arguments[_key];
        }
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && _typeof(msg) === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = _defineProperty(_defineProperty(_defineProperty({}, LEVEL, level), "level", level), "message", msg);
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        var meta = splat[0];
        if (_typeof(meta) === "object" && meta !== null) {
          var tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            var info = Object.assign({}, this.defaultMeta, meta, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEVEL, level), SPLAT, splat), "level", level), "message", msg));
            if (meta.message)
              info.message = "".concat(info.message, " ").concat(meta.message);
            if (meta.stack)
              info.stack = meta.stack;
            if (meta.cause)
              info.cause = meta.cause;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEVEL, level), SPLAT, splat), "level", level), "message", msg)));
        return this;
      }
    }, {
      key: "_transform",
      value: function _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", info);
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
    }, {
      key: "_final",
      value: function _final(callback) {
        var transports = this.transports.slice();
        asyncForEach(transports, function(transport, next) {
          if (!transport || transport.finished)
            return setImmediate(next);
          transport.once("finish", next);
          transport.end();
        }, callback);
      }
    }, {
      key: "add",
      value: function add(transport) {
        var target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({
          transport
        }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
    }, {
      key: "remove",
      value: function remove(transport) {
        if (!transport)
          return this;
        var target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(function(match) {
            return match.transport === transport;
          })[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.unpipe();
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
    }, {
      key: "setLevels",
      value: function setLevels() {
        warn.deprecated("setLevels");
      }
    }, {
      key: "query",
      value: function query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var results = {};
        var queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, function(err, res) {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, function(err, result) {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(this.transports.filter(function(transport) {
          return !!transport.query;
        }), addResults, function() {
          return callback(null, results);
        });
      }
    }, {
      key: "stream",
      value: function stream() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var out = new Stream;
        var streams = [];
        out._streams = streams;
        out.destroy = function() {
          var i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter(function(transport) {
          return !!transport.stream;
        }).forEach(function(transport) {
          var str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", function(log) {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", function(err) {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
    }, {
      key: "startTimer",
      value: function startTimer() {
        return new Profiler(this);
      }
    }, {
      key: "profile",
      value: function profile(id) {
        var time = Date.now();
        if (this.profilers[id]) {
          var timeEnd = this.profilers[id];
          delete this.profilers[id];
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          if (typeof args[args.length - 2] === "function") {
            console.warn("Callback function no longer supported as of winston@3.0.0");
            args.pop();
          }
          var info = _typeof(args[args.length - 1]) === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
    }, {
      key: "handleExceptions",
      value: function handleExceptions() {
        var _this$exceptions;
        console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
        (_this$exceptions = this.exceptions).handle.apply(_this$exceptions, arguments);
      }
    }, {
      key: "unhandleExceptions",
      value: function unhandleExceptions() {
        var _this$exceptions2;
        console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
        (_this$exceptions2 = this.exceptions).unhandle.apply(_this$exceptions2, arguments);
      }
    }, {
      key: "cli",
      value: function cli() {
        throw new Error(["Logger.cli() was removed in winston@3.0.0", "Use a custom winston.formats.cli() instead.", "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"].join(`
`));
      }
    }, {
      key: "_onEvent",
      value: function _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
    }, {
      key: "_addDefaultMeta",
      value: function _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    }]);
  }(Transform);
  function getLevelValue(levels, level) {
    var value = levels[level];
    if (!value && value !== 0) {
      return null;
    }
    return value;
  }
  Object.defineProperty(Logger.prototype, "transports", {
    configurable: false,
    enumerable: true,
    get: function get() {
      var pipes = this._readableState.pipes;
      return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
    }
  });
  module.exports = Logger;
});

// node_modules/winston/dist/winston/create-logger.js
var require_create_logger = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _callSuper(t, o2, e) {
    return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o2, e || [], _getPrototypeOf(t).constructor) : o2.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var config = require_config2();
  var Logger = require_logger();
  var debug = require_browser3()("winston:create-logger");
  function isLevelEnabledFunctionName(level) {
    return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
  }
  module.exports = function() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    opts.levels = opts.levels || config.npm.levels;
    var DerivedLogger = /* @__PURE__ */ function(_Logger) {
      function DerivedLogger2(options) {
        _classCallCheck(this, DerivedLogger2);
        return _callSuper(this, DerivedLogger2, [options]);
      }
      _inherits(DerivedLogger2, _Logger);
      return _createClass(DerivedLogger2);
    }(Logger);
    var logger = new DerivedLogger(opts);
    Object.keys(opts.levels).forEach(function(level) {
      debug('Define prototype method for "%s"', level);
      if (level === "log") {
        console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
        return;
      }
      DerivedLogger.prototype[level] = function() {
        var self2 = this || logger;
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (args.length === 1) {
          var msg = args[0];
          var info = msg && msg.message && msg || {
            message: msg
          };
          info.level = info[LEVEL] = level;
          self2._addDefaultMeta(info);
          self2.write(info);
          return this || logger;
        }
        if (args.length === 0) {
          self2.log(level, "");
          return self2;
        }
        return self2.log.apply(self2, [level].concat(args));
      };
      DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
        return (this || logger).isLevelEnabled(level);
      };
    });
    return logger;
  };
});

// node_modules/winston/dist/winston/container.js
var require_container = __commonJS((exports, module) => {
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _classCallCheck(a3, n) {
    if (!(a3 instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o2 = r[t];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  var createLogger = require_create_logger();
  module.exports = /* @__PURE__ */ function() {
    function Container() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Container);
      this.loggers = new Map;
      this.options = options;
    }
    return _createClass(Container, [{
      key: "add",
      value: function add(id, options) {
        var _this = this;
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          var existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          var logger = createLogger(options);
          logger.on("close", function() {
            return _this._delete(id);
          });
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
    }, {
      key: "get",
      value: function get(id, options) {
        return this.add(id, options);
      }
    }, {
      key: "has",
      value: function has(id) {
        return !!this.loggers.has(id);
      }
    }, {
      key: "close",
      value: function close(id) {
        var _this2 = this;
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach(function(val, key) {
          return _this2._removeLogger(key);
        });
      }
    }, {
      key: "_removeLogger",
      value: function _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        var logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
    }, {
      key: "_delete",
      value: function _delete(id) {
        this.loggers["delete"](id);
      }
    }]);
  }();
});

// node_modules/winston/dist/winston.js
var require_winston = __commonJS((exports) => {
  var logform = require_browser();
  var _require = require_common();
  var warn = _require.warn;
  exports.version = require_package().version;
  exports.transports = require_transports();
  exports.config = require_config2();
  exports.addColors = logform.levels;
  exports.format = logform.format;
  exports.createLogger = require_create_logger();
  exports.Logger = require_logger();
  exports.ExceptionHandler = require_exception_handler();
  exports.RejectionHandler = require_rejection_handler();
  exports.Container = require_container();
  exports.Transport = require_dist();
  exports.loggers = new exports.Container;
  var defaultLogger = exports.createLogger();
  Object.keys(exports.config.npm.levels).concat(["log", "query", "stream", "add", "remove", "clear", "profile", "startTimer", "handleExceptions", "unhandleExceptions", "handleRejections", "unhandleRejections", "configure", "child"]).forEach(function(method) {
    return exports[method] = function() {
      return defaultLogger[method].apply(defaultLogger, arguments);
    };
  });
  Object.defineProperty(exports, "level", {
    get: function get() {
      return defaultLogger.level;
    },
    set: function set(val) {
      defaultLogger.level = val;
    }
  });
  Object.defineProperty(exports, "exceptions", {
    get: function get() {
      return defaultLogger.exceptions;
    }
  });
  Object.defineProperty(exports, "rejections", {
    get: function get() {
      return defaultLogger.rejections;
    }
  });
  ["exitOnError"].forEach(function(prop) {
    Object.defineProperty(exports, prop, {
      get: function get() {
        return defaultLogger[prop];
      },
      set: function set(val) {
        defaultLogger[prop] = val;
      }
    });
  });
  Object.defineProperty(exports, "default", {
    get: function get() {
      return {
        exceptionHandlers: defaultLogger.exceptionHandlers,
        rejectionHandlers: defaultLogger.rejectionHandlers,
        transports: defaultLogger.transports
      };
    }
  });
  warn.deprecated(exports, "setLevels");
  warn.forFunctions(exports, "useFormat", ["cli"]);
  warn.forProperties(exports, "useFormat", ["padLevels", "stripColors"]);
  warn.forFunctions(exports, "deprecated", ["addRewriter", "addFilter", "clone", "extend"]);
  warn.forProperties(exports, "deprecated", ["emitErrs", "levelLength"]);
});

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS((exports, module) => {
  (function(e) {
    var t;
    typeof exports == "object" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (typeof window != "undefined" ? t = window : typeof global != "undefined" ? t = global : typeof self != "undefined" && (t = self), t.objectHash = e());
  })(function() {
    return function r(o2, i, u3) {
      function s2(n, e2) {
        if (!i[n]) {
          if (!o2[n]) {
            var t = __require;
            if (!e2 && t)
              return t(n, true);
            if (a3)
              return a3(n, true);
            throw new Error("Cannot find module '" + n + "'");
          }
          e2 = i[n] = { exports: {} };
          o2[n][0].call(e2.exports, function(e3) {
            var t2 = o2[n][1][e3];
            return s2(t2 || e3);
          }, e2, e2.exports, r, o2, i, u3);
        }
        return i[n].exports;
      }
      for (var a3 = __require, e = 0;e < u3.length; e++)
        s2(u3[e]);
      return s2;
    }({ 1: [function(w3, b6, m3) {
      (function(e, n, s2, c2, d4, h5, p3, g5, y5) {
        var r = w3("crypto");
        function t(e2, t2) {
          t2 = u3(e2, t2);
          var n2;
          return (n2 = t2.algorithm !== "passthrough" ? r.createHash(t2.algorithm) : new l3).write === undefined && (n2.write = n2.update, n2.end = n2.update), f3(t2, n2).dispatch(e2), n2.update || n2.end(""), n2.digest ? n2.digest(t2.encoding === "buffer" ? undefined : t2.encoding) : (e2 = n2.read(), t2.encoding !== "buffer" ? e2.toString(t2.encoding) : e2);
        }
        (m3 = b6.exports = t).sha1 = function(e2) {
          return t(e2);
        }, m3.keys = function(e2) {
          return t(e2, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, m3.MD5 = function(e2) {
          return t(e2, { algorithm: "md5", encoding: "hex" });
        }, m3.keysMD5 = function(e2) {
          return t(e2, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var o2 = r.getHashes ? r.getHashes().slice() : ["sha1", "md5"], i = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function u3(e2, t2) {
          var n2 = {};
          if (n2.algorithm = (t2 = t2 || {}).algorithm || "sha1", n2.encoding = t2.encoding || "hex", n2.excludeValues = !!t2.excludeValues, n2.algorithm = n2.algorithm.toLowerCase(), n2.encoding = n2.encoding.toLowerCase(), n2.ignoreUnknown = t2.ignoreUnknown === true, n2.respectType = t2.respectType !== false, n2.respectFunctionNames = t2.respectFunctionNames !== false, n2.respectFunctionProperties = t2.respectFunctionProperties !== false, n2.unorderedArrays = t2.unorderedArrays === true, n2.unorderedSets = t2.unorderedSets !== false, n2.unorderedObjects = t2.unorderedObjects !== false, n2.replacer = t2.replacer || undefined, n2.excludeKeys = t2.excludeKeys || undefined, e2 === undefined)
            throw new Error("Object argument required.");
          for (var r2 = 0;r2 < o2.length; ++r2)
            o2[r2].toLowerCase() === n2.algorithm.toLowerCase() && (n2.algorithm = o2[r2]);
          if (o2.indexOf(n2.algorithm) === -1)
            throw new Error('Algorithm "' + n2.algorithm + '"  not supported. supported values: ' + o2.join(", "));
          if (i.indexOf(n2.encoding) === -1 && n2.algorithm !== "passthrough")
            throw new Error('Encoding "' + n2.encoding + '"  not supported. supported values: ' + i.join(", "));
          return n2;
        }
        function a3(e2) {
          if (typeof e2 == "function")
            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e2)) != null;
        }
        function f3(o3, t2, i2) {
          i2 = i2 || [];
          function u4(e2) {
            return t2.update ? t2.update(e2, "utf8") : t2.write(e2, "utf8");
          }
          return { dispatch: function(e2) {
            return this["_" + ((e2 = o3.replacer ? o3.replacer(e2) : e2) === null ? "null" : typeof e2)](e2);
          }, _object: function(t3) {
            var n2, e2 = Object.prototype.toString.call(t3), r2 = /\[object (.*)\]/i.exec(e2);
            r2 = (r2 = r2 ? r2[1] : "unknown:[" + e2 + "]").toLowerCase();
            if (0 <= (e2 = i2.indexOf(t3)))
              return this.dispatch("[CIRCULAR:" + e2 + "]");
            if (i2.push(t3), s2 !== undefined && s2.isBuffer && s2.isBuffer(t3))
              return u4("buffer:"), u4(t3);
            if (r2 === "object" || r2 === "function" || r2 === "asyncfunction")
              return e2 = Object.keys(t3), o3.unorderedObjects && (e2 = e2.sort()), o3.respectType === false || a3(t3) || e2.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e2 = e2.filter(function(e3) {
                return !o3.excludeKeys(e3);
              })), u4("object:" + e2.length + ":"), n2 = this, e2.forEach(function(e3) {
                n2.dispatch(e3), u4(":"), o3.excludeValues || n2.dispatch(t3[e3]), u4(",");
              });
            if (!this["_" + r2]) {
              if (o3.ignoreUnknown)
                return u4("[" + r2 + "]");
              throw new Error('Unknown object type "' + r2 + '"');
            }
            this["_" + r2](t3);
          }, _array: function(e2, t3) {
            t3 = t3 !== undefined ? t3 : o3.unorderedArrays !== false;
            var n2 = this;
            if (u4("array:" + e2.length + ":"), !t3 || e2.length <= 1)
              return e2.forEach(function(e3) {
                return n2.dispatch(e3);
              });
            var r2 = [], t3 = e2.map(function(e3) {
              var t4 = new l3, n3 = i2.slice();
              return f3(o3, t4, n3).dispatch(e3), r2 = r2.concat(n3.slice(i2.length)), t4.read().toString();
            });
            return i2 = i2.concat(r2), t3.sort(), this._array(t3, false);
          }, _date: function(e2) {
            return u4("date:" + e2.toJSON());
          }, _symbol: function(e2) {
            return u4("symbol:" + e2.toString());
          }, _error: function(e2) {
            return u4("error:" + e2.toString());
          }, _boolean: function(e2) {
            return u4("bool:" + e2.toString());
          }, _string: function(e2) {
            u4("string:" + e2.length + ":"), u4(e2.toString());
          }, _function: function(e2) {
            u4("fn:"), a3(e2) ? this.dispatch("[native]") : this.dispatch(e2.toString()), o3.respectFunctionNames !== false && this.dispatch("function-name:" + String(e2.name)), o3.respectFunctionProperties && this._object(e2);
          }, _number: function(e2) {
            return u4("number:" + e2.toString());
          }, _xml: function(e2) {
            return u4("xml:" + e2.toString());
          }, _null: function() {
            return u4("Null");
          }, _undefined: function() {
            return u4("Undefined");
          }, _regexp: function(e2) {
            return u4("regex:" + e2.toString());
          }, _uint8array: function(e2) {
            return u4("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _uint8clampedarray: function(e2) {
            return u4("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _int8array: function(e2) {
            return u4("int8array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _uint16array: function(e2) {
            return u4("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _int16array: function(e2) {
            return u4("int16array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _uint32array: function(e2) {
            return u4("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _int32array: function(e2) {
            return u4("int32array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _float32array: function(e2) {
            return u4("float32array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _float64array: function(e2) {
            return u4("float64array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _arraybuffer: function(e2) {
            return u4("arraybuffer:"), this.dispatch(new Uint8Array(e2));
          }, _url: function(e2) {
            return u4("url:" + e2.toString());
          }, _map: function(e2) {
            u4("map:");
            e2 = Array.from(e2);
            return this._array(e2, o3.unorderedSets !== false);
          }, _set: function(e2) {
            u4("set:");
            e2 = Array.from(e2);
            return this._array(e2, o3.unorderedSets !== false);
          }, _file: function(e2) {
            return u4("file:"), this.dispatch([e2.name, e2.size, e2.type, e2.lastModfied]);
          }, _blob: function() {
            if (o3.ignoreUnknown)
              return u4("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return u4("domwindow");
          }, _bigint: function(e2) {
            return u4("bigint:" + e2.toString());
          }, _process: function() {
            return u4("process");
          }, _timer: function() {
            return u4("timer");
          }, _pipe: function() {
            return u4("pipe");
          }, _tcp: function() {
            return u4("tcp");
          }, _udp: function() {
            return u4("udp");
          }, _tty: function() {
            return u4("tty");
          }, _statwatcher: function() {
            return u4("statwatcher");
          }, _securecontext: function() {
            return u4("securecontext");
          }, _connection: function() {
            return u4("connection");
          }, _zlib: function() {
            return u4("zlib");
          }, _context: function() {
            return u4("context");
          }, _nodescript: function() {
            return u4("nodescript");
          }, _httpparser: function() {
            return u4("httpparser");
          }, _dataview: function() {
            return u4("dataview");
          }, _signal: function() {
            return u4("signal");
          }, _fsevent: function() {
            return u4("fsevent");
          }, _tlswrap: function() {
            return u4("tlswrap");
          } };
        }
        function l3() {
          return { buf: "", write: function(e2) {
            this.buf += e2;
          }, end: function(e2) {
            this.buf += e2;
          }, read: function() {
            return this.buf;
          } };
        }
        m3.writeToStream = function(e2, t2, n2) {
          return n2 === undefined && (n2 = t2, t2 = {}), f3(t2 = u3(e2, t2), n2).dispatch(e2);
        };
      }).call(this, w3("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, w3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e, t, f3) {
      (function(e2, t2, n, r, o2, i, u3, s2, a3) {
        (function(e3) {
          var a4 = typeof Uint8Array != "undefined" ? Uint8Array : Array, t3 = 43, n2 = 47, r2 = 48, o3 = 97, i2 = 65, u4 = 45, s3 = 95;
          function f4(e4) {
            e4 = e4.charCodeAt(0);
            return e4 === t3 || e4 === u4 ? 62 : e4 === n2 || e4 === s3 ? 63 : e4 < r2 ? -1 : e4 < r2 + 10 ? e4 - r2 + 26 + 26 : e4 < i2 + 26 ? e4 - i2 : e4 < o3 + 26 ? e4 - o3 + 26 : undefined;
          }
          e3.toByteArray = function(e4) {
            var t4, n3;
            if (0 < e4.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r3 = e4.length, r3 = e4.charAt(r3 - 2) === "=" ? 2 : e4.charAt(r3 - 1) === "=" ? 1 : 0, o4 = new a4(3 * e4.length / 4 - r3), i3 = 0 < r3 ? e4.length - 4 : e4.length, u5 = 0;
            function s4(e5) {
              o4[u5++] = e5;
            }
            for (t4 = 0;t4 < i3; t4 += 4, 0)
              s4((16711680 & (n3 = f4(e4.charAt(t4)) << 18 | f4(e4.charAt(t4 + 1)) << 12 | f4(e4.charAt(t4 + 2)) << 6 | f4(e4.charAt(t4 + 3)))) >> 16), s4((65280 & n3) >> 8), s4(255 & n3);
            return r3 == 2 ? s4(255 & (n3 = f4(e4.charAt(t4)) << 2 | f4(e4.charAt(t4 + 1)) >> 4)) : r3 == 1 && (s4((n3 = f4(e4.charAt(t4)) << 10 | f4(e4.charAt(t4 + 1)) << 4 | f4(e4.charAt(t4 + 2)) >> 2) >> 8 & 255), s4(255 & n3)), o4;
          }, e3.fromByteArray = function(e4) {
            var t4, n3, r3, o4, i3 = e4.length % 3, u5 = "";
            function s4(e5) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
            }
            for (t4 = 0, r3 = e4.length - i3;t4 < r3; t4 += 3)
              n3 = (e4[t4] << 16) + (e4[t4 + 1] << 8) + e4[t4 + 2], u5 += s4((o4 = n3) >> 18 & 63) + s4(o4 >> 12 & 63) + s4(o4 >> 6 & 63) + s4(63 & o4);
            switch (i3) {
              case 1:
                u5 = (u5 += s4((n3 = e4[e4.length - 1]) >> 2)) + s4(n3 << 4 & 63) + "==";
                break;
              case 2:
                u5 = (u5 = (u5 += s4((n3 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10)) + s4(n3 >> 4 & 63)) + s4(n3 << 2 & 63) + "=";
            }
            return u5;
          };
        })(f3 === undefined ? this.base64js = {} : f3);
      }).call(this, e("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(O4, e, H3) {
      (function(e2, n, f3, r, h5, p3, g5, y5, w3) {
        var a3 = O4("base64-js"), i = O4("ieee754");
        function f3(e3, t2, n2) {
          if (!(this instanceof f3))
            return new f3(e3, t2, n2);
          var r2, o3, i2, u4, s3 = typeof e3;
          if (t2 === "base64" && s3 == "string")
            for (e3 = (u4 = e3).trim ? u4.trim() : u4.replace(/^\s+|\s+$/g, "");e3.length % 4 != 0; )
              e3 += "=";
          if (s3 == "number")
            r2 = j5(e3);
          else if (s3 == "string")
            r2 = f3.byteLength(e3, t2);
          else {
            if (s3 != "object")
              throw new Error("First argument needs to be a number, array or string.");
            r2 = j5(e3.length);
          }
          if (f3._useTypedArrays ? o3 = f3._augment(new Uint8Array(r2)) : ((o3 = this).length = r2, o3._isBuffer = true), f3._useTypedArrays && typeof e3.byteLength == "number")
            o3._set(e3);
          else if (C3(u4 = e3) || f3.isBuffer(u4) || u4 && typeof u4 == "object" && typeof u4.length == "number")
            for (i2 = 0;i2 < r2; i2++)
              f3.isBuffer(e3) ? o3[i2] = e3.readUInt8(i2) : o3[i2] = e3[i2];
          else if (s3 == "string")
            o3.write(e3, 0, t2);
          else if (s3 == "number" && !f3._useTypedArrays && !n2)
            for (i2 = 0;i2 < r2; i2++)
              o3[i2] = 0;
          return o3;
        }
        function b6(e3, t2, n2, r2) {
          return f3._charsWritten = c2(function(e4) {
            for (var t3 = [], n3 = 0;n3 < e4.length; n3++)
              t3.push(255 & e4.charCodeAt(n3));
            return t3;
          }(t2), e3, n2, r2);
        }
        function m3(e3, t2, n2, r2) {
          return f3._charsWritten = c2(function(e4) {
            for (var t3, n3, r3 = [], o3 = 0;o3 < e4.length; o3++)
              n3 = e4.charCodeAt(o3), t3 = n3 >> 8, n3 = n3 % 256, r3.push(n3), r3.push(t3);
            return r3;
          }(t2), e3, n2, r2);
        }
        function v4(e3, t2, n2) {
          var r2 = "";
          n2 = Math.min(e3.length, n2);
          for (var o3 = t2;o3 < n2; o3++)
            r2 += String.fromCharCode(e3[o3]);
          return r2;
        }
        function o2(e3, t2, n2, r2) {
          r2 || (d4(typeof n2 == "boolean", "missing or invalid endian"), d4(t2 != null, "missing offset"), d4(t2 + 1 < e3.length, "Trying to read beyond buffer length"));
          var o3, r2 = e3.length;
          if (!(r2 <= t2))
            return n2 ? (o3 = e3[t2], t2 + 1 < r2 && (o3 |= e3[t2 + 1] << 8)) : (o3 = e3[t2] << 8, t2 + 1 < r2 && (o3 |= e3[t2 + 1])), o3;
        }
        function u3(e3, t2, n2, r2) {
          r2 || (d4(typeof n2 == "boolean", "missing or invalid endian"), d4(t2 != null, "missing offset"), d4(t2 + 3 < e3.length, "Trying to read beyond buffer length"));
          var o3, r2 = e3.length;
          if (!(r2 <= t2))
            return n2 ? (t2 + 2 < r2 && (o3 = e3[t2 + 2] << 16), t2 + 1 < r2 && (o3 |= e3[t2 + 1] << 8), o3 |= e3[t2], t2 + 3 < r2 && (o3 += e3[t2 + 3] << 24 >>> 0)) : (t2 + 1 < r2 && (o3 = e3[t2 + 1] << 16), t2 + 2 < r2 && (o3 |= e3[t2 + 2] << 8), t2 + 3 < r2 && (o3 |= e3[t2 + 3]), o3 += e3[t2] << 24 >>> 0), o3;
        }
        function _4(e3, t2, n2, r2) {
          if (r2 || (d4(typeof n2 == "boolean", "missing or invalid endian"), d4(t2 != null, "missing offset"), d4(t2 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2))
            return r2 = o2(e3, t2, n2, true), 32768 & r2 ? -1 * (65535 - r2 + 1) : r2;
        }
        function E5(e3, t2, n2, r2) {
          if (r2 || (d4(typeof n2 == "boolean", "missing or invalid endian"), d4(t2 != null, "missing offset"), d4(t2 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2))
            return r2 = u3(e3, t2, n2, true), 2147483648 & r2 ? -1 * (4294967295 - r2 + 1) : r2;
        }
        function I4(e3, t2, n2, r2) {
          return r2 || (d4(typeof n2 == "boolean", "missing or invalid endian"), d4(t2 + 3 < e3.length, "Trying to read beyond buffer length")), i.read(e3, t2, n2, 23, 4);
        }
        function A4(e3, t2, n2, r2) {
          return r2 || (d4(typeof n2 == "boolean", "missing or invalid endian"), d4(t2 + 7 < e3.length, "Trying to read beyond buffer length")), i.read(e3, t2, n2, 52, 8);
        }
        function s2(e3, t2, n2, r2, o3) {
          o3 || (d4(t2 != null, "missing value"), d4(typeof r2 == "boolean", "missing or invalid endian"), d4(n2 != null, "missing offset"), d4(n2 + 1 < e3.length, "trying to write beyond buffer length"), Y3(t2, 65535));
          o3 = e3.length;
          if (!(o3 <= n2))
            for (var i2 = 0, u4 = Math.min(o3 - n2, 2);i2 < u4; i2++)
              e3[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
        }
        function l3(e3, t2, n2, r2, o3) {
          o3 || (d4(t2 != null, "missing value"), d4(typeof r2 == "boolean", "missing or invalid endian"), d4(n2 != null, "missing offset"), d4(n2 + 3 < e3.length, "trying to write beyond buffer length"), Y3(t2, 4294967295));
          o3 = e3.length;
          if (!(o3 <= n2))
            for (var i2 = 0, u4 = Math.min(o3 - n2, 4);i2 < u4; i2++)
              e3[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
        }
        function B3(e3, t2, n2, r2, o3) {
          o3 || (d4(t2 != null, "missing value"), d4(typeof r2 == "boolean", "missing or invalid endian"), d4(n2 != null, "missing offset"), d4(n2 + 1 < e3.length, "Trying to write beyond buffer length"), F2(t2, 32767, -32768)), e3.length <= n2 || s2(e3, 0 <= t2 ? t2 : 65535 + t2 + 1, n2, r2, o3);
        }
        function L4(e3, t2, n2, r2, o3) {
          o3 || (d4(t2 != null, "missing value"), d4(typeof r2 == "boolean", "missing or invalid endian"), d4(n2 != null, "missing offset"), d4(n2 + 3 < e3.length, "Trying to write beyond buffer length"), F2(t2, 2147483647, -2147483648)), e3.length <= n2 || l3(e3, 0 <= t2 ? t2 : 4294967295 + t2 + 1, n2, r2, o3);
        }
        function U3(e3, t2, n2, r2, o3) {
          o3 || (d4(t2 != null, "missing value"), d4(typeof r2 == "boolean", "missing or invalid endian"), d4(n2 != null, "missing offset"), d4(n2 + 3 < e3.length, "Trying to write beyond buffer length"), D3(t2, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000)), e3.length <= n2 || i.write(e3, t2, n2, r2, 23, 4);
        }
        function x5(e3, t2, n2, r2, o3) {
          o3 || (d4(t2 != null, "missing value"), d4(typeof r2 == "boolean", "missing or invalid endian"), d4(n2 != null, "missing offset"), d4(n2 + 7 < e3.length, "Trying to write beyond buffer length"), D3(t2, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)), e3.length <= n2 || i.write(e3, t2, n2, r2, 52, 8);
        }
        H3.Buffer = f3, H3.SlowBuffer = f3, H3.INSPECT_MAX_BYTES = 50, f3.poolSize = 8192, f3._useTypedArrays = function() {
          try {
            var e3 = new ArrayBuffer(0), t2 = new Uint8Array(e3);
            return t2.foo = function() {
              return 42;
            }, t2.foo() === 42 && typeof t2.subarray == "function";
          } catch (e4) {
            return false;
          }
        }(), f3.isEncoding = function(e3) {
          switch (String(e3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, f3.isBuffer = function(e3) {
          return !(e3 == null || !e3._isBuffer);
        }, f3.byteLength = function(e3, t2) {
          var n2;
          switch (e3 += "", t2 || "utf8") {
            case "hex":
              n2 = e3.length / 2;
              break;
            case "utf8":
            case "utf-8":
              n2 = T3(e3).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              n2 = e3.length;
              break;
            case "base64":
              n2 = M3(e3).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              n2 = 2 * e3.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return n2;
        }, f3.concat = function(e3, t2) {
          if (d4(C3(e3), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), e3.length === 0)
            return new f3(0);
          if (e3.length === 1)
            return e3[0];
          if (typeof t2 != "number")
            for (o3 = t2 = 0;o3 < e3.length; o3++)
              t2 += e3[o3].length;
          for (var n2 = new f3(t2), r2 = 0, o3 = 0;o3 < e3.length; o3++) {
            var i2 = e3[o3];
            i2.copy(n2, r2), r2 += i2.length;
          }
          return n2;
        }, f3.prototype.write = function(e3, t2, n2, r2) {
          isFinite(t2) ? isFinite(n2) || (r2 = n2, n2 = undefined) : (a4 = r2, r2 = t2, t2 = n2, n2 = a4), t2 = Number(t2) || 0;
          var o3, i2, u4, s3, a4 = this.length - t2;
          switch ((!n2 || a4 < (n2 = Number(n2))) && (n2 = a4), r2 = String(r2 || "utf8").toLowerCase()) {
            case "hex":
              o3 = function(e4, t3, n3, r3) {
                n3 = Number(n3) || 0;
                var o4 = e4.length - n3;
                (!r3 || o4 < (r3 = Number(r3))) && (r3 = o4), d4((o4 = t3.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r3 && (r3 = o4 / 2);
                for (var i3 = 0;i3 < r3; i3++) {
                  var u5 = parseInt(t3.substr(2 * i3, 2), 16);
                  d4(!isNaN(u5), "Invalid hex string"), e4[n3 + i3] = u5;
                }
                return f3._charsWritten = 2 * i3, i3;
              }(this, e3, t2, n2);
              break;
            case "utf8":
            case "utf-8":
              i2 = this, u4 = t2, s3 = n2, o3 = f3._charsWritten = c2(T3(e3), i2, u4, s3);
              break;
            case "ascii":
            case "binary":
              o3 = b6(this, e3, t2, n2);
              break;
            case "base64":
              i2 = this, u4 = t2, s3 = n2, o3 = f3._charsWritten = c2(M3(e3), i2, u4, s3);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              o3 = m3(this, e3, t2, n2);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return o3;
        }, f3.prototype.toString = function(e3, t2, n2) {
          var r2, o3, i2, u4, s3 = this;
          if (e3 = String(e3 || "utf8").toLowerCase(), t2 = Number(t2) || 0, (n2 = n2 !== undefined ? Number(n2) : s3.length) === t2)
            return "";
          switch (e3) {
            case "hex":
              r2 = function(e4, t3, n3) {
                var r3 = e4.length;
                (!t3 || t3 < 0) && (t3 = 0);
                (!n3 || n3 < 0 || r3 < n3) && (n3 = r3);
                for (var o4 = "", i3 = t3;i3 < n3; i3++)
                  o4 += k3(e4[i3]);
                return o4;
              }(s3, t2, n2);
              break;
            case "utf8":
            case "utf-8":
              r2 = function(e4, t3, n3) {
                var r3 = "", o4 = "";
                n3 = Math.min(e4.length, n3);
                for (var i3 = t3;i3 < n3; i3++)
                  e4[i3] <= 127 ? (r3 += N6(o4) + String.fromCharCode(e4[i3]), o4 = "") : o4 += "%" + e4[i3].toString(16);
                return r3 + N6(o4);
              }(s3, t2, n2);
              break;
            case "ascii":
            case "binary":
              r2 = v4(s3, t2, n2);
              break;
            case "base64":
              o3 = s3, u4 = n2, r2 = (i2 = t2) === 0 && u4 === o3.length ? a3.fromByteArray(o3) : a3.fromByteArray(o3.slice(i2, u4));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              r2 = function(e4, t3, n3) {
                for (var r3 = e4.slice(t3, n3), o4 = "", i3 = 0;i3 < r3.length; i3 += 2)
                  o4 += String.fromCharCode(r3[i3] + 256 * r3[i3 + 1]);
                return o4;
              }(s3, t2, n2);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return r2;
        }, f3.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, f3.prototype.copy = function(e3, t2, n2, r2) {
          if (t2 = t2 || 0, (r2 = r2 || r2 === 0 ? r2 : this.length) !== (n2 = n2 || 0) && e3.length !== 0 && this.length !== 0) {
            d4(n2 <= r2, "sourceEnd < sourceStart"), d4(0 <= t2 && t2 < e3.length, "targetStart out of bounds"), d4(0 <= n2 && n2 < this.length, "sourceStart out of bounds"), d4(0 <= r2 && r2 <= this.length, "sourceEnd out of bounds"), r2 > this.length && (r2 = this.length);
            var o3 = (r2 = e3.length - t2 < r2 - n2 ? e3.length - t2 + n2 : r2) - n2;
            if (o3 < 100 || !f3._useTypedArrays)
              for (var i2 = 0;i2 < o3; i2++)
                e3[i2 + t2] = this[i2 + n2];
            else
              e3._set(this.subarray(n2, n2 + o3), t2);
          }
        }, f3.prototype.slice = function(e3, t2) {
          var n2 = this.length;
          if (e3 = S3(e3, n2, 0), t2 = S3(t2, n2, n2), f3._useTypedArrays)
            return f3._augment(this.subarray(e3, t2));
          for (var r2 = t2 - e3, o3 = new f3(r2, undefined, true), i2 = 0;i2 < r2; i2++)
            o3[i2] = this[i2 + e3];
          return o3;
        }, f3.prototype.get = function(e3) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
        }, f3.prototype.set = function(e3, t2) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t2);
        }, f3.prototype.readUInt8 = function(e3, t2) {
          if (t2 || (d4(e3 != null, "missing offset"), d4(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
            return this[e3];
        }, f3.prototype.readUInt16LE = function(e3, t2) {
          return o2(this, e3, true, t2);
        }, f3.prototype.readUInt16BE = function(e3, t2) {
          return o2(this, e3, false, t2);
        }, f3.prototype.readUInt32LE = function(e3, t2) {
          return u3(this, e3, true, t2);
        }, f3.prototype.readUInt32BE = function(e3, t2) {
          return u3(this, e3, false, t2);
        }, f3.prototype.readInt8 = function(e3, t2) {
          if (t2 || (d4(e3 != null, "missing offset"), d4(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
            return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
        }, f3.prototype.readInt16LE = function(e3, t2) {
          return _4(this, e3, true, t2);
        }, f3.prototype.readInt16BE = function(e3, t2) {
          return _4(this, e3, false, t2);
        }, f3.prototype.readInt32LE = function(e3, t2) {
          return E5(this, e3, true, t2);
        }, f3.prototype.readInt32BE = function(e3, t2) {
          return E5(this, e3, false, t2);
        }, f3.prototype.readFloatLE = function(e3, t2) {
          return I4(this, e3, true, t2);
        }, f3.prototype.readFloatBE = function(e3, t2) {
          return I4(this, e3, false, t2);
        }, f3.prototype.readDoubleLE = function(e3, t2) {
          return A4(this, e3, true, t2);
        }, f3.prototype.readDoubleBE = function(e3, t2) {
          return A4(this, e3, false, t2);
        }, f3.prototype.writeUInt8 = function(e3, t2, n2) {
          n2 || (d4(e3 != null, "missing value"), d4(t2 != null, "missing offset"), d4(t2 < this.length, "trying to write beyond buffer length"), Y3(e3, 255)), t2 >= this.length || (this[t2] = e3);
        }, f3.prototype.writeUInt16LE = function(e3, t2, n2) {
          s2(this, e3, t2, true, n2);
        }, f3.prototype.writeUInt16BE = function(e3, t2, n2) {
          s2(this, e3, t2, false, n2);
        }, f3.prototype.writeUInt32LE = function(e3, t2, n2) {
          l3(this, e3, t2, true, n2);
        }, f3.prototype.writeUInt32BE = function(e3, t2, n2) {
          l3(this, e3, t2, false, n2);
        }, f3.prototype.writeInt8 = function(e3, t2, n2) {
          n2 || (d4(e3 != null, "missing value"), d4(t2 != null, "missing offset"), d4(t2 < this.length, "Trying to write beyond buffer length"), F2(e3, 127, -128)), t2 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t2, n2) : this.writeUInt8(255 + e3 + 1, t2, n2));
        }, f3.prototype.writeInt16LE = function(e3, t2, n2) {
          B3(this, e3, t2, true, n2);
        }, f3.prototype.writeInt16BE = function(e3, t2, n2) {
          B3(this, e3, t2, false, n2);
        }, f3.prototype.writeInt32LE = function(e3, t2, n2) {
          L4(this, e3, t2, true, n2);
        }, f3.prototype.writeInt32BE = function(e3, t2, n2) {
          L4(this, e3, t2, false, n2);
        }, f3.prototype.writeFloatLE = function(e3, t2, n2) {
          U3(this, e3, t2, true, n2);
        }, f3.prototype.writeFloatBE = function(e3, t2, n2) {
          U3(this, e3, t2, false, n2);
        }, f3.prototype.writeDoubleLE = function(e3, t2, n2) {
          x5(this, e3, t2, true, n2);
        }, f3.prototype.writeDoubleBE = function(e3, t2, n2) {
          x5(this, e3, t2, false, n2);
        }, f3.prototype.fill = function(e3, t2, n2) {
          if (t2 = t2 || 0, n2 = n2 || this.length, d4(typeof (e3 = typeof (e3 = e3 || 0) == "string" ? e3.charCodeAt(0) : e3) == "number" && !isNaN(e3), "value is not a number"), d4(t2 <= n2, "end < start"), n2 !== t2 && this.length !== 0) {
            d4(0 <= t2 && t2 < this.length, "start out of bounds"), d4(0 <= n2 && n2 <= this.length, "end out of bounds");
            for (var r2 = t2;r2 < n2; r2++)
              this[r2] = e3;
          }
        }, f3.prototype.inspect = function() {
          for (var e3 = [], t2 = this.length, n2 = 0;n2 < t2; n2++)
            if (e3[n2] = k3(this[n2]), n2 === H3.INSPECT_MAX_BYTES) {
              e3[n2 + 1] = "...";
              break;
            }
          return "<Buffer " + e3.join(" ") + ">";
        }, f3.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array == "undefined")
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (f3._useTypedArrays)
            return new f3(this).buffer;
          for (var e3 = new Uint8Array(this.length), t2 = 0, n2 = e3.length;t2 < n2; t2 += 1)
            e3[t2] = this[t2];
          return e3.buffer;
        };
        var t = f3.prototype;
        function S3(e3, t2, n2) {
          return typeof e3 != "number" ? n2 : t2 <= (e3 = ~~e3) ? t2 : 0 <= e3 || 0 <= (e3 += t2) ? e3 : 0;
        }
        function j5(e3) {
          return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
        }
        function C3(e3) {
          return (Array.isArray || function(e4) {
            return Object.prototype.toString.call(e4) === "[object Array]";
          })(e3);
        }
        function k3(e3) {
          return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
        }
        function T3(e3) {
          for (var t2 = [], n2 = 0;n2 < e3.length; n2++) {
            var r2 = e3.charCodeAt(n2);
            if (r2 <= 127)
              t2.push(e3.charCodeAt(n2));
            else
              for (var o3 = n2, i2 = (55296 <= r2 && r2 <= 57343 && n2++, encodeURIComponent(e3.slice(o3, n2 + 1)).substr(1).split("%")), u4 = 0;u4 < i2.length; u4++)
                t2.push(parseInt(i2[u4], 16));
          }
          return t2;
        }
        function M3(e3) {
          return a3.toByteArray(e3);
        }
        function c2(e3, t2, n2, r2) {
          for (var o3 = 0;o3 < r2 && !(o3 + n2 >= t2.length || o3 >= e3.length); o3++)
            t2[o3 + n2] = e3[o3];
          return o3;
        }
        function N6(e3) {
          try {
            return decodeURIComponent(e3);
          } catch (e4) {
            return String.fromCharCode(65533);
          }
        }
        function Y3(e3, t2) {
          d4(typeof e3 == "number", "cannot write a non-number as a number"), d4(0 <= e3, "specified a negative value for writing an unsigned value"), d4(e3 <= t2, "value is larger than maximum value for type"), d4(Math.floor(e3) === e3, "value has a fractional component");
        }
        function F2(e3, t2, n2) {
          d4(typeof e3 == "number", "cannot write a non-number as a number"), d4(e3 <= t2, "value larger than maximum allowed value"), d4(n2 <= e3, "value smaller than minimum allowed value"), d4(Math.floor(e3) === e3, "value has a fractional component");
        }
        function D3(e3, t2, n2) {
          d4(typeof e3 == "number", "cannot write a non-number as a number"), d4(e3 <= t2, "value larger than maximum allowed value"), d4(n2 <= e3, "value smaller than minimum allowed value");
        }
        function d4(e3, t2) {
          if (!e3)
            throw new Error(t2 || "Failed assertion");
        }
        f3._augment = function(e3) {
          return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = t.get, e3.set = t.set, e3.write = t.write, e3.toString = t.toString, e3.toLocaleString = t.toString, e3.toJSON = t.toJSON, e3.copy = t.copy, e3.slice = t.slice, e3.readUInt8 = t.readUInt8, e3.readUInt16LE = t.readUInt16LE, e3.readUInt16BE = t.readUInt16BE, e3.readUInt32LE = t.readUInt32LE, e3.readUInt32BE = t.readUInt32BE, e3.readInt8 = t.readInt8, e3.readInt16LE = t.readInt16LE, e3.readInt16BE = t.readInt16BE, e3.readInt32LE = t.readInt32LE, e3.readInt32BE = t.readInt32BE, e3.readFloatLE = t.readFloatLE, e3.readFloatBE = t.readFloatBE, e3.readDoubleLE = t.readDoubleLE, e3.readDoubleBE = t.readDoubleBE, e3.writeUInt8 = t.writeUInt8, e3.writeUInt16LE = t.writeUInt16LE, e3.writeUInt16BE = t.writeUInt16BE, e3.writeUInt32LE = t.writeUInt32LE, e3.writeUInt32BE = t.writeUInt32BE, e3.writeInt8 = t.writeInt8, e3.writeInt16LE = t.writeInt16LE, e3.writeInt16BE = t.writeInt16BE, e3.writeInt32LE = t.writeInt32LE, e3.writeInt32BE = t.writeInt32BE, e3.writeFloatLE = t.writeFloatLE, e3.writeFloatBE = t.writeFloatBE, e3.writeDoubleLE = t.writeDoubleLE, e3.writeDoubleBE = t.writeDoubleBE, e3.fill = t.fill, e3.inspect = t.inspect, e3.toArrayBuffer = t.toArrayBuffer, e3;
        };
      }).call(this, O4("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, O4("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c2, d4, e) {
      (function(e2, t, a3, n, r, o2, i, u3, s2) {
        var a3 = c2("buffer").Buffer, f3 = 4, l3 = new a3(f3);
        l3.fill(0);
        d4.exports = { hash: function(e3, t2, n2, r2) {
          for (var o3 = t2(function(e4, t3) {
            e4.length % f3 != 0 && (n3 = e4.length + (f3 - e4.length % f3), e4 = a3.concat([e4, l3], n3));
            for (var n3, r3 = [], o4 = t3 ? e4.readInt32BE : e4.readInt32LE, i3 = 0;i3 < e4.length; i3 += f3)
              r3.push(o4.call(e4, i3));
            return r3;
          }(e3 = a3.isBuffer(e3) ? e3 : new a3(e3), r2), 8 * e3.length), t2 = r2, i2 = new a3(n2), u4 = t2 ? i2.writeInt32BE : i2.writeInt32LE, s3 = 0;s3 < o3.length; s3++)
            u4.call(i2, o3[s3], 4 * s3, true);
          return i2;
        } };
      }).call(this, c2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(v4, e, _4) {
      (function(l3, c2, u3, d4, h5, p3, g5, y5, w3) {
        var u3 = v4("buffer").Buffer, e2 = v4("./sha"), t = v4("./sha256"), n = v4("./rng"), b6 = { sha1: e2, sha256: t, md5: v4("./md5") }, s2 = 64, a3 = new u3(s2);
        function r(e3, n2) {
          var r2 = b6[e3 = e3 || "sha1"], o3 = [];
          return r2 || i("algorithm:", e3, "is not yet supported"), { update: function(e4) {
            return u3.isBuffer(e4) || (e4 = new u3(e4)), o3.push(e4), e4.length, this;
          }, digest: function(e4) {
            var t2 = u3.concat(o3), t2 = n2 ? function(e5, t3, n3) {
              u3.isBuffer(t3) || (t3 = new u3(t3)), u3.isBuffer(n3) || (n3 = new u3(n3)), t3.length > s2 ? t3 = e5(t3) : t3.length < s2 && (t3 = u3.concat([t3, a3], s2));
              for (var r3 = new u3(s2), o4 = new u3(s2), i2 = 0;i2 < s2; i2++)
                r3[i2] = 54 ^ t3[i2], o4[i2] = 92 ^ t3[i2];
              return n3 = e5(u3.concat([r3, n3])), e5(u3.concat([o4, n3]));
            }(r2, n2, t2) : r2(t2);
            return o3 = null, e4 ? t2.toString(e4) : t2;
          } };
        }
        function i() {
          var e3 = [].slice.call(arguments).join(" ");
          throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        a3.fill(0), _4.createHash = function(e3) {
          return r(e3);
        }, _4.createHmac = r, _4.randomBytes = function(e3, t2) {
          if (!t2 || !t2.call)
            return new u3(n(e3));
          try {
            t2.call(this, undefined, new u3(n(e3)));
          } catch (e4) {
            t2(e4);
          }
        };
        var o2, f3 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m3 = function(e3) {
          _4[e3] = function() {
            i("sorry,", e3, "is not implemented yet");
          };
        };
        for (o2 in f3)
          m3(f3[o2], o2);
      }).call(this, v4("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, v4("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w3, b6, e) {
      (function(e2, r, o2, i, u3, a3, f3, l3, y5) {
        var t = w3("./helpers");
        function n(e3, t2) {
          e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
          for (var n2 = 1732584193, r2 = -271733879, o3 = -1732584194, i2 = 271733878, u4 = 0;u4 < e3.length; u4 += 16) {
            var s3 = n2, a4 = r2, f4 = o3, l4 = i2, n2 = c2(n2, r2, o3, i2, e3[u4 + 0], 7, -680876936), i2 = c2(i2, n2, r2, o3, e3[u4 + 1], 12, -389564586), o3 = c2(o3, i2, n2, r2, e3[u4 + 2], 17, 606105819), r2 = c2(r2, o3, i2, n2, e3[u4 + 3], 22, -1044525330);
            n2 = c2(n2, r2, o3, i2, e3[u4 + 4], 7, -176418897), i2 = c2(i2, n2, r2, o3, e3[u4 + 5], 12, 1200080426), o3 = c2(o3, i2, n2, r2, e3[u4 + 6], 17, -1473231341), r2 = c2(r2, o3, i2, n2, e3[u4 + 7], 22, -45705983), n2 = c2(n2, r2, o3, i2, e3[u4 + 8], 7, 1770035416), i2 = c2(i2, n2, r2, o3, e3[u4 + 9], 12, -1958414417), o3 = c2(o3, i2, n2, r2, e3[u4 + 10], 17, -42063), r2 = c2(r2, o3, i2, n2, e3[u4 + 11], 22, -1990404162), n2 = c2(n2, r2, o3, i2, e3[u4 + 12], 7, 1804603682), i2 = c2(i2, n2, r2, o3, e3[u4 + 13], 12, -40341101), o3 = c2(o3, i2, n2, r2, e3[u4 + 14], 17, -1502002290), n2 = d4(n2, r2 = c2(r2, o3, i2, n2, e3[u4 + 15], 22, 1236535329), o3, i2, e3[u4 + 1], 5, -165796510), i2 = d4(i2, n2, r2, o3, e3[u4 + 6], 9, -1069501632), o3 = d4(o3, i2, n2, r2, e3[u4 + 11], 14, 643717713), r2 = d4(r2, o3, i2, n2, e3[u4 + 0], 20, -373897302), n2 = d4(n2, r2, o3, i2, e3[u4 + 5], 5, -701558691), i2 = d4(i2, n2, r2, o3, e3[u4 + 10], 9, 38016083), o3 = d4(o3, i2, n2, r2, e3[u4 + 15], 14, -660478335), r2 = d4(r2, o3, i2, n2, e3[u4 + 4], 20, -405537848), n2 = d4(n2, r2, o3, i2, e3[u4 + 9], 5, 568446438), i2 = d4(i2, n2, r2, o3, e3[u4 + 14], 9, -1019803690), o3 = d4(o3, i2, n2, r2, e3[u4 + 3], 14, -187363961), r2 = d4(r2, o3, i2, n2, e3[u4 + 8], 20, 1163531501), n2 = d4(n2, r2, o3, i2, e3[u4 + 13], 5, -1444681467), i2 = d4(i2, n2, r2, o3, e3[u4 + 2], 9, -51403784), o3 = d4(o3, i2, n2, r2, e3[u4 + 7], 14, 1735328473), n2 = h5(n2, r2 = d4(r2, o3, i2, n2, e3[u4 + 12], 20, -1926607734), o3, i2, e3[u4 + 5], 4, -378558), i2 = h5(i2, n2, r2, o3, e3[u4 + 8], 11, -2022574463), o3 = h5(o3, i2, n2, r2, e3[u4 + 11], 16, 1839030562), r2 = h5(r2, o3, i2, n2, e3[u4 + 14], 23, -35309556), n2 = h5(n2, r2, o3, i2, e3[u4 + 1], 4, -1530992060), i2 = h5(i2, n2, r2, o3, e3[u4 + 4], 11, 1272893353), o3 = h5(o3, i2, n2, r2, e3[u4 + 7], 16, -155497632), r2 = h5(r2, o3, i2, n2, e3[u4 + 10], 23, -1094730640), n2 = h5(n2, r2, o3, i2, e3[u4 + 13], 4, 681279174), i2 = h5(i2, n2, r2, o3, e3[u4 + 0], 11, -358537222), o3 = h5(o3, i2, n2, r2, e3[u4 + 3], 16, -722521979), r2 = h5(r2, o3, i2, n2, e3[u4 + 6], 23, 76029189), n2 = h5(n2, r2, o3, i2, e3[u4 + 9], 4, -640364487), i2 = h5(i2, n2, r2, o3, e3[u4 + 12], 11, -421815835), o3 = h5(o3, i2, n2, r2, e3[u4 + 15], 16, 530742520), n2 = p3(n2, r2 = h5(r2, o3, i2, n2, e3[u4 + 2], 23, -995338651), o3, i2, e3[u4 + 0], 6, -198630844), i2 = p3(i2, n2, r2, o3, e3[u4 + 7], 10, 1126891415), o3 = p3(o3, i2, n2, r2, e3[u4 + 14], 15, -1416354905), r2 = p3(r2, o3, i2, n2, e3[u4 + 5], 21, -57434055), n2 = p3(n2, r2, o3, i2, e3[u4 + 12], 6, 1700485571), i2 = p3(i2, n2, r2, o3, e3[u4 + 3], 10, -1894986606), o3 = p3(o3, i2, n2, r2, e3[u4 + 10], 15, -1051523), r2 = p3(r2, o3, i2, n2, e3[u4 + 1], 21, -2054922799), n2 = p3(n2, r2, o3, i2, e3[u4 + 8], 6, 1873313359), i2 = p3(i2, n2, r2, o3, e3[u4 + 15], 10, -30611744), o3 = p3(o3, i2, n2, r2, e3[u4 + 6], 15, -1560198380), r2 = p3(r2, o3, i2, n2, e3[u4 + 13], 21, 1309151649), n2 = p3(n2, r2, o3, i2, e3[u4 + 4], 6, -145523070), i2 = p3(i2, n2, r2, o3, e3[u4 + 11], 10, -1120210379), o3 = p3(o3, i2, n2, r2, e3[u4 + 2], 15, 718787259), r2 = p3(r2, o3, i2, n2, e3[u4 + 9], 21, -343485551), n2 = g5(n2, s3), r2 = g5(r2, a4), o3 = g5(o3, f4), i2 = g5(i2, l4);
          }
          return Array(n2, r2, o3, i2);
        }
        function s2(e3, t2, n2, r2, o3, i2) {
          return g5((t2 = g5(g5(t2, e3), g5(r2, i2))) << o3 | t2 >>> 32 - o3, n2);
        }
        function c2(e3, t2, n2, r2, o3, i2, u4) {
          return s2(t2 & n2 | ~t2 & r2, e3, t2, o3, i2, u4);
        }
        function d4(e3, t2, n2, r2, o3, i2, u4) {
          return s2(t2 & r2 | n2 & ~r2, e3, t2, o3, i2, u4);
        }
        function h5(e3, t2, n2, r2, o3, i2, u4) {
          return s2(t2 ^ n2 ^ r2, e3, t2, o3, i2, u4);
        }
        function p3(e3, t2, n2, r2, o3, i2, u4) {
          return s2(n2 ^ (t2 | ~r2), e3, t2, o3, i2, u4);
        }
        function g5(e3, t2) {
          var n2 = (65535 & e3) + (65535 & t2);
          return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
        }
        b6.exports = function(e3) {
          return t.hash(e3, n, 16);
        };
      }).call(this, w3("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, w3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e, l3, t) {
      (function(e2, t2, n, r, o2, i, u3, s2, f3) {
        var a3;
        l3.exports = a3 || function(e3) {
          for (var t3, n2 = new Array(e3), r2 = 0;r2 < e3; r2++)
            (3 & r2) == 0 && (t3 = 4294967296 * Math.random()), n2[r2] = t3 >>> ((3 & r2) << 3) & 255;
          return n2;
        };
      }).call(this, e("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(c2, d4, e) {
      (function(e2, t, n, r, o2, s2, a3, f3, l3) {
        var i = c2("./helpers");
        function u3(l4, c3) {
          l4[c3 >> 5] |= 128 << 24 - c3 % 32, l4[15 + (c3 + 64 >> 9 << 4)] = c3;
          for (var e3, t2, n2, r2 = Array(80), o3 = 1732584193, i2 = -271733879, u4 = -1732584194, s3 = 271733878, d5 = -1009589776, h5 = 0;h5 < l4.length; h5 += 16) {
            for (var p3 = o3, g5 = i2, y5 = u4, w3 = s3, b6 = d5, a4 = 0;a4 < 80; a4++) {
              r2[a4] = a4 < 16 ? l4[h5 + a4] : v4(r2[a4 - 3] ^ r2[a4 - 8] ^ r2[a4 - 14] ^ r2[a4 - 16], 1);
              var f4 = m3(m3(v4(o3, 5), (f4 = i2, t2 = u4, n2 = s3, (e3 = a4) < 20 ? f4 & t2 | ~f4 & n2 : !(e3 < 40) && e3 < 60 ? f4 & t2 | f4 & n2 | t2 & n2 : f4 ^ t2 ^ n2)), m3(m3(d5, r2[a4]), (e3 = a4) < 20 ? 1518500249 : e3 < 40 ? 1859775393 : e3 < 60 ? -1894007588 : -899497514)), d5 = s3, s3 = u4, u4 = v4(i2, 30), i2 = o3, o3 = f4;
            }
            o3 = m3(o3, p3), i2 = m3(i2, g5), u4 = m3(u4, y5), s3 = m3(s3, w3), d5 = m3(d5, b6);
          }
          return Array(o3, i2, u4, s3, d5);
        }
        function m3(e3, t2) {
          var n2 = (65535 & e3) + (65535 & t2);
          return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
        }
        function v4(e3, t2) {
          return e3 << t2 | e3 >>> 32 - t2;
        }
        d4.exports = function(e3) {
          return i.hash(e3, u3, 20, true);
        };
      }).call(this, c2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c2, d4, e) {
      (function(e2, t, n, r, u3, s2, a3, f3, l3) {
        function b6(e3, t2) {
          var n2 = (65535 & e3) + (65535 & t2);
          return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
        }
        function o2(e3, l4) {
          var c3, d5 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n2 = new Array(64);
          e3[l4 >> 5] |= 128 << 24 - l4 % 32, e3[15 + (l4 + 64 >> 9 << 4)] = l4;
          for (var r2, o3, h5 = 0;h5 < e3.length; h5 += 16) {
            for (var i2 = t2[0], u4 = t2[1], s3 = t2[2], p3 = t2[3], a4 = t2[4], g5 = t2[5], y5 = t2[6], w3 = t2[7], f4 = 0;f4 < 64; f4++)
              n2[f4] = f4 < 16 ? e3[f4 + h5] : b6(b6(b6((o3 = n2[f4 - 2], m3(o3, 17) ^ m3(o3, 19) ^ v4(o3, 10)), n2[f4 - 7]), (o3 = n2[f4 - 15], m3(o3, 7) ^ m3(o3, 18) ^ v4(o3, 3))), n2[f4 - 16]), c3 = b6(b6(b6(b6(w3, m3(o3 = a4, 6) ^ m3(o3, 11) ^ m3(o3, 25)), a4 & g5 ^ ~a4 & y5), d5[f4]), n2[f4]), r2 = b6(m3(r2 = i2, 2) ^ m3(r2, 13) ^ m3(r2, 22), i2 & u4 ^ i2 & s3 ^ u4 & s3), w3 = y5, y5 = g5, g5 = a4, a4 = b6(p3, c3), p3 = s3, s3 = u4, u4 = i2, i2 = b6(c3, r2);
            t2[0] = b6(i2, t2[0]), t2[1] = b6(u4, t2[1]), t2[2] = b6(s3, t2[2]), t2[3] = b6(p3, t2[3]), t2[4] = b6(a4, t2[4]), t2[5] = b6(g5, t2[5]), t2[6] = b6(y5, t2[6]), t2[7] = b6(w3, t2[7]);
          }
          return t2;
        }
        var i = c2("./helpers"), m3 = function(e3, t2) {
          return e3 >>> t2 | e3 << 32 - t2;
        }, v4 = function(e3, t2) {
          return e3 >>> t2;
        };
        d4.exports = function(e3) {
          return i.hash(e3, o2, 32, true);
        };
      }).call(this, c2("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e, t, f3) {
      (function(e2, t2, n, r, o2, i, u3, s2, a3) {
        f3.read = function(e3, t3, n2, r2, o3) {
          var i2, u4, l3 = 8 * o3 - r2 - 1, c2 = (1 << l3) - 1, d4 = c2 >> 1, s3 = -7, a4 = n2 ? o3 - 1 : 0, f4 = n2 ? -1 : 1, o3 = e3[t3 + a4];
          for (a4 += f4, i2 = o3 & (1 << -s3) - 1, o3 >>= -s3, s3 += l3;0 < s3; i2 = 256 * i2 + e3[t3 + a4], a4 += f4, s3 -= 8)
            ;
          for (u4 = i2 & (1 << -s3) - 1, i2 >>= -s3, s3 += r2;0 < s3; u4 = 256 * u4 + e3[t3 + a4], a4 += f4, s3 -= 8)
            ;
          if (i2 === 0)
            i2 = 1 - d4;
          else {
            if (i2 === c2)
              return u4 ? NaN : 1 / 0 * (o3 ? -1 : 1);
            u4 += Math.pow(2, r2), i2 -= d4;
          }
          return (o3 ? -1 : 1) * u4 * Math.pow(2, i2 - r2);
        }, f3.write = function(e3, t3, l3, n2, r2, c2) {
          var o3, i2, u4 = 8 * c2 - r2 - 1, s3 = (1 << u4) - 1, a4 = s3 >> 1, d4 = r2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n2 ? 0 : c2 - 1, h5 = n2 ? 1 : -1, c2 = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (i2 = isNaN(t3) ? 1 : 0, o3 = s3) : (o3 = Math.floor(Math.log(t3) / Math.LN2), t3 * (n2 = Math.pow(2, -o3)) < 1 && (o3--, n2 *= 2), 2 <= (t3 += 1 <= o3 + a4 ? d4 / n2 : d4 * Math.pow(2, 1 - a4)) * n2 && (o3++, n2 /= 2), s3 <= o3 + a4 ? (i2 = 0, o3 = s3) : 1 <= o3 + a4 ? (i2 = (t3 * n2 - 1) * Math.pow(2, r2), o3 += a4) : (i2 = t3 * Math.pow(2, a4 - 1) * Math.pow(2, r2), o3 = 0));8 <= r2; e3[l3 + f4] = 255 & i2, f4 += h5, i2 /= 256, r2 -= 8)
            ;
          for (o3 = o3 << r2 | i2, u4 += r2;0 < u4; e3[l3 + f4] = 255 & o3, f4 += h5, o3 /= 256, u4 -= 8)
            ;
          e3[l3 + f4 - h5] |= 128 * c2;
        };
      }).call(this, e("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(e, h5, t) {
      (function(e2, t2, n, r, o2, f3, l3, c2, d4) {
        var i, u3, s2;
        function a3() {
        }
        (e2 = h5.exports = {}).nextTick = (u3 = typeof window != "undefined" && window.setImmediate, s2 = typeof window != "undefined" && window.postMessage && window.addEventListener, u3 ? function(e3) {
          return window.setImmediate(e3);
        } : s2 ? (i = [], window.addEventListener("message", function(e3) {
          var t3 = e3.source;
          t3 !== window && t3 !== null || e3.data !== "process-tick" || (e3.stopPropagation(), 0 < i.length && i.shift()());
        }, true), function(e3) {
          i.push(e3), window.postMessage("process-tick", "*");
        }) : function(e3) {
          setTimeout(e3, 0);
        }), e2.title = "browser", e2.browser = true, e2.env = {}, e2.argv = [], e2.on = a3, e2.addListener = a3, e2.once = a3, e2.off = a3, e2.removeListener = a3, e2.removeAllListeners = a3, e2.emit = a3, e2.binding = function(e3) {
          throw new Error("process.binding is not supported");
        }, e2.cwd = function() {
          return "/";
        }, e2.chdir = function(e3) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, e("lYpoI2"), typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
});

// node:stream
var exports_stream = {};
__export(exports_stream, {
  default: () => Uc
});
var al, tt3, cl2, dl, hl, pl, yl = (e, t) => () => (e && (t = e(e = 0)), t), E5 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Qr = (e, t) => {
  for (var r in t)
    tt3(e, r, { get: t[r], enumerable: true });
}, et2 = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of dl(t))
      !pl.call(e, i) && i !== r && tt3(e, i, { get: () => t[i], enumerable: !(n = cl2(t, i)) || n.enumerable });
  return e;
}, ue3 = (e, t, r) => (et2(e, t, "default"), r && et2(r, t, "default")), rt3 = (e, t, r) => (r = e != null ? al(hl(e)) : {}, et2(t || !e || !e.__esModule ? tt3(r, "default", { value: e, enumerable: true }) : r, e)), pe = (e) => et2(tt3({}, "__esModule", { value: true }), e), tn2, rn, te, I4, V5, ut2, C3, He2, ir2, k3, Gu, se2, ae, ce2, di2, Se2, Et, xt2, At4, Pi, Tt4, Wi, Gi2, Er4, Ke, Cr2, Mo2, J2, qr2, $r2, Ut2, Jo, Kr2, fl, Jr, Ze, Uc;
var init_stream = __esm(() => {
  al = Object.create;
  tt3 = Object.defineProperty;
  cl2 = Object.getOwnPropertyDescriptor;
  dl = Object.getOwnPropertyNames;
  hl = Object.getPrototypeOf;
  pl = Object.prototype.hasOwnProperty;
  tn2 = E5((nt4) => {
    nt4.byteLength = bl;
    nt4.toByteArray = _l;
    nt4.fromByteArray = ml;
    var G2 = [], P4 = [], wl = typeof Uint8Array < "u" ? Uint8Array : Array, Wt2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ye2 = 0, Zr2 = Wt2.length;ye2 < Zr2; ++ye2)
      G2[ye2] = Wt2[ye2], P4[Wt2.charCodeAt(ye2)] = ye2;
    var ye2, Zr2;
    P4[45] = 62;
    P4[95] = 63;
    function en(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function bl(e) {
      var t = en(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function gl(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function _l(e) {
      var t, r = en(e), n = r[0], i = r[1], o2 = new wl(gl(e, n, i)), l3 = 0, u3 = i > 0 ? n - 4 : n, f3;
      for (f3 = 0;f3 < u3; f3 += 4)
        t = P4[e.charCodeAt(f3)] << 18 | P4[e.charCodeAt(f3 + 1)] << 12 | P4[e.charCodeAt(f3 + 2)] << 6 | P4[e.charCodeAt(f3 + 3)], o2[l3++] = t >> 16 & 255, o2[l3++] = t >> 8 & 255, o2[l3++] = t & 255;
      return i === 2 && (t = P4[e.charCodeAt(f3)] << 2 | P4[e.charCodeAt(f3 + 1)] >> 4, o2[l3++] = t & 255), i === 1 && (t = P4[e.charCodeAt(f3)] << 10 | P4[e.charCodeAt(f3 + 1)] << 4 | P4[e.charCodeAt(f3 + 2)] >> 2, o2[l3++] = t >> 8 & 255, o2[l3++] = t & 255), o2;
    }
    function El(e) {
      return G2[e >> 18 & 63] + G2[e >> 12 & 63] + G2[e >> 6 & 63] + G2[e & 63];
    }
    function Sl(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(El(n));
      return i.join("");
    }
    function ml(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, l3 = 0, u3 = r - n;l3 < u3; l3 += o2)
        i.push(Sl(e, l3, l3 + o2 > u3 ? u3 : l3 + o2));
      return n === 1 ? (t = e[r - 1], i.push(G2[t >> 2] + G2[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(G2[t >> 10] + G2[t >> 4 & 63] + G2[t << 2 & 63] + "=")), i.join("");
    }
  });
  rn = E5(($t) => {
    $t.read = function(e, t, r, n, i) {
      var o2, l3, u3 = i * 8 - n - 1, f3 = (1 << u3) - 1, s2 = f3 >> 1, d4 = -7, c2 = r ? i - 1 : 0, y5 = r ? -1 : 1, h5 = e[t + c2];
      for (c2 += y5, o2 = h5 & (1 << -d4) - 1, h5 >>= -d4, d4 += u3;d4 > 0; o2 = o2 * 256 + e[t + c2], c2 += y5, d4 -= 8)
        ;
      for (l3 = o2 & (1 << -d4) - 1, o2 >>= -d4, d4 += n;d4 > 0; l3 = l3 * 256 + e[t + c2], c2 += y5, d4 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - s2;
      else {
        if (o2 === f3)
          return l3 ? NaN : (h5 ? -1 : 1) * (1 / 0);
        l3 = l3 + Math.pow(2, n), o2 = o2 - s2;
      }
      return (h5 ? -1 : 1) * l3 * Math.pow(2, o2 - n);
    };
    $t.write = function(e, t, r, n, i, o2) {
      var l3, u3, f3, s2 = o2 * 8 - i - 1, d4 = (1 << s2) - 1, c2 = d4 >> 1, y5 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h5 = n ? 0 : o2 - 1, p3 = n ? 1 : -1, B3 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u3 = isNaN(t) ? 1 : 0, l3 = d4) : (l3 = Math.floor(Math.log(t) / Math.LN2), t * (f3 = Math.pow(2, -l3)) < 1 && (l3--, f3 *= 2), l3 + c2 >= 1 ? t += y5 / f3 : t += y5 * Math.pow(2, 1 - c2), t * f3 >= 2 && (l3++, f3 /= 2), l3 + c2 >= d4 ? (u3 = 0, l3 = d4) : l3 + c2 >= 1 ? (u3 = (t * f3 - 1) * Math.pow(2, i), l3 = l3 + c2) : (u3 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), l3 = 0));i >= 8; e[r + h5] = u3 & 255, h5 += p3, u3 /= 256, i -= 8)
        ;
      for (l3 = l3 << i | u3, s2 += i;s2 > 0; e[r + h5] = l3 & 255, h5 += p3, l3 /= 256, s2 -= 8)
        ;
      e[r + h5 - p3] |= B3 * 128;
    };
  });
  te = E5((Fe) => {
    var jt2 = tn2(), Le = rn(), nn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Fe.Buffer = a3;
    Fe.SlowBuffer = Bl;
    Fe.INSPECT_MAX_BYTES = 50;
    var it3 = 2147483647;
    Fe.kMaxLength = it3;
    a3.TYPED_ARRAY_SUPPORT = xl();
    !a3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function xl() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a3.prototype, "parent", { enumerable: true, get: function() {
      if (!!a3.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(a3.prototype, "offset", { enumerable: true, get: function() {
      if (!!a3.isBuffer(this))
        return this.byteOffset;
    } });
    function ee(e) {
      if (e > it3)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, a3.prototype), t;
    }
    function a3(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Yt(e);
      }
      return fn(e, t, r);
    }
    a3.poolSize = 8192;
    function fn(e, t, r) {
      if (typeof e == "string")
        return Al(e, t);
      if (ArrayBuffer.isView(e))
        return Il(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H3(e, ArrayBuffer) || e && H3(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H3(e, SharedArrayBuffer) || e && H3(e.buffer, SharedArrayBuffer)))
        return Ht2(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return a3.from(n, t, r);
      let i = Tl(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return a3.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    a3.from = function(e, t, r) {
      return fn(e, t, r);
    };
    Object.setPrototypeOf(a3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(a3, Uint8Array);
    function sn(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Rl(e, t, r) {
      return sn(e), e <= 0 ? ee(e) : t !== undefined ? typeof r == "string" ? ee(e).fill(t, r) : ee(e).fill(t) : ee(e);
    }
    a3.alloc = function(e, t, r) {
      return Rl(e, t, r);
    };
    function Yt(e) {
      return sn(e), ee(e < 0 ? 0 : Kt3(e) | 0);
    }
    a3.allocUnsafe = function(e) {
      return Yt(e);
    };
    a3.allocUnsafeSlow = function(e) {
      return Yt(e);
    };
    function Al(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !a3.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = an2(e, t) | 0, n = ee(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Gt(e) {
      let t = e.length < 0 ? 0 : Kt3(e.length) | 0, r = ee(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function Il(e) {
      if (H3(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Ht2(t.buffer, t.byteOffset, t.byteLength);
      }
      return Gt(e);
    }
    function Ht2(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, a3.prototype), n;
    }
    function Tl(e) {
      if (a3.isBuffer(e)) {
        let t = Kt3(e.length) | 0, r = ee(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Xt2(e.length) ? ee(0) : Gt(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Gt(e.data);
    }
    function Kt3(e) {
      if (e >= it3)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + it3.toString(16) + " bytes");
      return e | 0;
    }
    function Bl(e) {
      return +e != e && (e = 0), a3.alloc(+e);
    }
    a3.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== a3.prototype;
    };
    a3.compare = function(t, r) {
      if (H3(t, Uint8Array) && (t = a3.from(t, t.offset, t.byteLength)), H3(r, Uint8Array) && (r = a3.from(r, r.offset, r.byteLength)), !a3.isBuffer(t) || !a3.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, l3 = Math.min(n, i);o2 < l3; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    a3.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    a3.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return a3.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = a3.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let l3 = t[n];
        if (H3(l3, Uint8Array))
          o2 + l3.length > i.length ? (a3.isBuffer(l3) || (l3 = a3.from(l3)), l3.copy(i, o2)) : Uint8Array.prototype.set.call(i, l3, o2);
        else if (a3.isBuffer(l3))
          l3.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += l3.length;
      }
      return i;
    };
    function an2(e, t) {
      if (a3.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H3(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Vt2(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return _n2(e).length;
          default:
            if (i)
              return n ? -1 : Vt2(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    a3.byteLength = an2;
    function Ll(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return vl(this, t, r);
          case "utf8":
          case "utf-8":
            return dn(this, t, r);
          case "ascii":
            return kl(this, t, r);
          case "latin1":
          case "binary":
            return Ul(this, t, r);
          case "base64":
            return Dl(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ql(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    a3.prototype._isBuffer = true;
    function we(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    a3.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        we(this, r, r + 1);
      return this;
    };
    a3.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        we(this, r, r + 3), we(this, r + 1, r + 2);
      return this;
    };
    a3.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        we(this, r, r + 7), we(this, r + 1, r + 6), we(this, r + 2, r + 5), we(this, r + 3, r + 4);
      return this;
    };
    a3.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? dn(this, 0, t) : Ll.apply(this, arguments);
    };
    a3.prototype.toLocaleString = a3.prototype.toString;
    a3.prototype.equals = function(t) {
      if (!a3.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : a3.compare(this, t) === 0;
    };
    a3.prototype.inspect = function() {
      let t = "", r = Fe.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    nn && (a3.prototype[nn] = a3.prototype.inspect);
    a3.prototype.compare = function(t, r, n, i, o2) {
      if (H3(t, Uint8Array) && (t = a3.from(t, t.offset, t.byteLength)), !a3.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let l3 = o2 - i, u3 = n - r, f3 = Math.min(l3, u3), s2 = this.slice(i, o2), d4 = t.slice(r, n);
      for (let c2 = 0;c2 < f3; ++c2)
        if (s2[c2] !== d4[c2]) {
          l3 = s2[c2], u3 = d4[c2];
          break;
        }
      return l3 < u3 ? -1 : u3 < l3 ? 1 : 0;
    };
    function cn2(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Xt2(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = a3.from(t, n)), a3.isBuffer(t))
        return t.length === 0 ? -1 : on(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : on(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function on(e, t, r, n, i) {
      let o2 = 1, l3 = e.length, u3 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, l3 /= 2, u3 /= 2, r /= 2;
      }
      function f3(d4, c2) {
        return o2 === 1 ? d4[c2] : d4.readUInt16BE(c2 * o2);
      }
      let s2;
      if (i) {
        let d4 = -1;
        for (s2 = r;s2 < l3; s2++)
          if (f3(e, s2) === f3(t, d4 === -1 ? 0 : s2 - d4)) {
            if (d4 === -1 && (d4 = s2), s2 - d4 + 1 === u3)
              return d4 * o2;
          } else
            d4 !== -1 && (s2 -= s2 - d4), d4 = -1;
      } else
        for (r + u3 > l3 && (r = l3 - u3), s2 = r;s2 >= 0; s2--) {
          let d4 = true;
          for (let c2 = 0;c2 < u3; c2++)
            if (f3(e, s2 + c2) !== f3(t, c2)) {
              d4 = false;
              break;
            }
          if (d4)
            return s2;
        }
      return -1;
    }
    a3.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    a3.prototype.indexOf = function(t, r, n) {
      return cn2(this, t, r, n, true);
    };
    a3.prototype.lastIndexOf = function(t, r, n) {
      return cn2(this, t, r, n, false);
    };
    function Nl(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let l3;
      for (l3 = 0;l3 < n; ++l3) {
        let u3 = parseInt(t.substr(l3 * 2, 2), 16);
        if (Xt2(u3))
          return l3;
        e[r + l3] = u3;
      }
      return l3;
    }
    function Fl(e, t, r, n) {
      return ot3(Vt2(t, e.length - r), e, r, n);
    }
    function Ml(e, t, r, n) {
      return ot3(Gl(t), e, r, n);
    }
    function Cl(e, t, r, n) {
      return ot3(_n2(t), e, r, n);
    }
    function Ol(e, t, r, n) {
      return ot3(Hl(t, e.length - r), e, r, n);
    }
    a3.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let l3 = false;
      for (;; )
        switch (i) {
          case "hex":
            return Nl(this, t, r, n);
          case "utf8":
          case "utf-8":
            return Fl(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return Ml(this, t, r, n);
          case "base64":
            return Cl(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ol(this, t, r, n);
          default:
            if (l3)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), l3 = true;
        }
    };
    a3.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Dl(e, t, r) {
      return t === 0 && r === e.length ? jt2.fromByteArray(e) : jt2.fromByteArray(e.slice(t, r));
    }
    function dn(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], l3 = null, u3 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + u3 <= r) {
          let f3, s2, d4, c2;
          switch (u3) {
            case 1:
              o2 < 128 && (l3 = o2);
              break;
            case 2:
              f3 = e[i + 1], (f3 & 192) === 128 && (c2 = (o2 & 31) << 6 | f3 & 63, c2 > 127 && (l3 = c2));
              break;
            case 3:
              f3 = e[i + 1], s2 = e[i + 2], (f3 & 192) === 128 && (s2 & 192) === 128 && (c2 = (o2 & 15) << 12 | (f3 & 63) << 6 | s2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (l3 = c2));
              break;
            case 4:
              f3 = e[i + 1], s2 = e[i + 2], d4 = e[i + 3], (f3 & 192) === 128 && (s2 & 192) === 128 && (d4 & 192) === 128 && (c2 = (o2 & 15) << 18 | (f3 & 63) << 12 | (s2 & 63) << 6 | d4 & 63, c2 > 65535 && c2 < 1114112 && (l3 = c2));
          }
        }
        l3 === null ? (l3 = 65533, u3 = 1) : l3 > 65535 && (l3 -= 65536, n.push(l3 >>> 10 & 1023 | 55296), l3 = 56320 | l3 & 1023), n.push(l3), i += u3;
      }
      return Pl(n);
    }
    var ln = 4096;
    function Pl(e) {
      let t = e.length;
      if (t <= ln)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += ln));
      return r;
    }
    function kl(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function Ul(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function vl(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += Vl[e[o2]];
      return i;
    }
    function ql(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    a3.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, a3.prototype), i;
    };
    function F2(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a3.prototype.readUintLE = a3.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = this[t], o2 = 1, l3 = 0;
      for (;++l3 < r && (o2 *= 256); )
        i += this[t + l3] * o2;
      return i;
    };
    a3.prototype.readUintBE = a3.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    a3.prototype.readUint8 = a3.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || F2(t, 1, this.length), this[t];
    };
    a3.prototype.readUint16LE = a3.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || F2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    a3.prototype.readUint16BE = a3.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || F2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    a3.prototype.readUint32LE = a3.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    a3.prototype.readUint32BE = a3.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    a3.prototype.readBigUInt64LE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    a3.prototype.readBigUInt64BE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    a3.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = this[t], o2 = 1, l3 = 0;
      for (;++l3 < r && (o2 *= 256); )
        i += this[t + l3] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    a3.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = r, o2 = 1, l3 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        l3 += this[t + --i] * o2;
      return o2 *= 128, l3 >= o2 && (l3 -= Math.pow(2, 8 * r)), l3;
    };
    a3.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || F2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    a3.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || F2(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a3.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || F2(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a3.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    a3.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    a3.prototype.readBigInt64LE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    a3.prototype.readBigInt64BE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    a3.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), Le.read(this, t, true, 23, 4);
    };
    a3.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), Le.read(this, t, false, 23, 4);
    };
    a3.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || F2(t, 8, this.length), Le.read(this, t, true, 52, 8);
    };
    a3.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || F2(t, 8, this.length), Le.read(this, t, false, 52, 8);
    };
    function O4(e, t, r, n, i, o2) {
      if (!a3.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    a3.prototype.writeUintLE = a3.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n) - 1;
        O4(this, t, r, n, u3, 0);
      }
      let o2 = 1, l3 = 0;
      for (this[r] = t & 255;++l3 < n && (o2 *= 256); )
        this[r + l3] = t / o2 & 255;
      return r + n;
    };
    a3.prototype.writeUintBE = a3.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n) - 1;
        O4(this, t, r, n, u3, 0);
      }
      let o2 = n - 1, l3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (l3 *= 256); )
        this[r + o2] = t / l3 & 255;
      return r + n;
    };
    a3.prototype.writeUint8 = a3.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    a3.prototype.writeUint16LE = a3.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    a3.prototype.writeUint16BE = a3.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    a3.prototype.writeUint32LE = a3.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    a3.prototype.writeUint32BE = a3.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function hn(e, t, r, n, i) {
      gn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let l3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, r;
    }
    function pn2(e, t, r, n, i) {
      gn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let l3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = l3, l3 = l3 >> 8, e[r + 2] = l3, l3 = l3 >> 8, e[r + 1] = l3, l3 = l3 >> 8, e[r] = l3, r + 8;
    }
    a3.prototype.writeBigUInt64LE = fe3(function(t, r = 0) {
      return hn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a3.prototype.writeBigUInt64BE = fe3(function(t, r = 0) {
      return pn2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a3.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let f3 = Math.pow(2, 8 * n - 1);
        O4(this, t, r, n, f3 - 1, -f3);
      }
      let o2 = 0, l3 = 1, u3 = 0;
      for (this[r] = t & 255;++o2 < n && (l3 *= 256); )
        t < 0 && u3 === 0 && this[r + o2 - 1] !== 0 && (u3 = 1), this[r + o2] = (t / l3 >> 0) - u3 & 255;
      return r + n;
    };
    a3.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let f3 = Math.pow(2, 8 * n - 1);
        O4(this, t, r, n, f3 - 1, -f3);
      }
      let o2 = n - 1, l3 = 1, u3 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (l3 *= 256); )
        t < 0 && u3 === 0 && this[r + o2 + 1] !== 0 && (u3 = 1), this[r + o2] = (t / l3 >> 0) - u3 & 255;
      return r + n;
    };
    a3.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    a3.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    a3.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    a3.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    a3.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O4(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    a3.prototype.writeBigInt64LE = fe3(function(t, r = 0) {
      return hn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    a3.prototype.writeBigInt64BE = fe3(function(t, r = 0) {
      return pn2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function yn2(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function wn(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || yn2(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Le.write(e, t, r, n, 23, 4), r + 4;
    }
    a3.prototype.writeFloatLE = function(t, r, n) {
      return wn(this, t, r, true, n);
    };
    a3.prototype.writeFloatBE = function(t, r, n) {
      return wn(this, t, r, false, n);
    };
    function bn(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || yn2(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Le.write(e, t, r, n, 52, 8), r + 8;
    }
    a3.prototype.writeDoubleLE = function(t, r, n) {
      return bn(this, t, r, true, n);
    };
    a3.prototype.writeDoubleBE = function(t, r, n) {
      return bn(this, t, r, false, n);
    };
    a3.prototype.copy = function(t, r, n, i) {
      if (!a3.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    a3.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !a3.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let l3 = t.charCodeAt(0);
          (i === "utf8" && l3 < 128 || i === "latin1") && (t = l3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let l3 = a3.isBuffer(t) ? t : a3.from(t, i), u3 = l3.length;
        if (u3 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = l3[o2 % u3];
      }
      return this;
    };
    var Be = {};
    function zt(e, t, r) {
      Be[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    zt("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    zt("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = un2(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = un2(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function un2(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function Wl(e, t, r) {
      Ne(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ge(t, e.length - (r + 1));
    }
    function gn(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let l3 = typeof t == "bigint" ? "n" : "", u3;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? u3 = `>= 0${l3} and < 2${l3} ** ${(o2 + 1) * 8}${l3}` : u3 = `>= -(2${l3} ** ${(o2 + 1) * 8 - 1}${l3}) and < 2 ** ${(o2 + 1) * 8 - 1}${l3}` : u3 = `>= ${t}${l3} and <= ${r}${l3}`, new Be.ERR_OUT_OF_RANGE("value", u3, e);
      }
      Wl(n, i, o2);
    }
    function Ne(e, t) {
      if (typeof e != "number")
        throw new Be.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ge(e, t, r) {
      throw Math.floor(e) !== e ? (Ne(e, r), new Be.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new Be.ERR_BUFFER_OUT_OF_BOUNDS : new Be.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var $l = /[^+/0-9A-Za-z-_]/g;
    function jl(e) {
      if (e = e.split("=")[0], e = e.trim().replace($l, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Vt2(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let l3 = 0;l3 < n; ++l3) {
        if (r = e.charCodeAt(l3), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (l3 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function Gl(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Hl(e, t) {
      let r, n, i, o2 = [];
      for (let l3 = 0;l3 < e.length && !((t -= 2) < 0); ++l3)
        r = e.charCodeAt(l3), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function _n2(e) {
      return jt2.toByteArray(jl(e));
    }
    function ot3(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function H3(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Xt2(e) {
      return e !== e;
    }
    var Vl = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function fe3(e) {
      return typeof BigInt > "u" ? Yl : e;
    }
    function Yl() {
      throw new Error("BigInt not supported");
    }
  });
  I4 = E5((Gc, En) => {
    En.exports = { ArrayIsArray(e) {
      return Array.isArray(e);
    }, ArrayPrototypeIncludes(e, t) {
      return e.includes(t);
    }, ArrayPrototypeIndexOf(e, t) {
      return e.indexOf(t);
    }, ArrayPrototypeJoin(e, t) {
      return e.join(t);
    }, ArrayPrototypeMap(e, t) {
      return e.map(t);
    }, ArrayPrototypePop(e, t) {
      return e.pop(t);
    }, ArrayPrototypePush(e, t) {
      return e.push(t);
    }, ArrayPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, Error, FunctionPrototypeCall(e, t, ...r) {
      return e.call(t, ...r);
    }, FunctionPrototypeSymbolHasInstance(e, t) {
      return Function.prototype[Symbol.hasInstance].call(e, t);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(e, t) {
      return Object.defineProperties(e, t);
    }, ObjectDefineProperty(e, t, r) {
      return Object.defineProperty(e, t, r);
    }, ObjectGetOwnPropertyDescriptor(e, t) {
      return Object.getOwnPropertyDescriptor(e, t);
    }, ObjectKeys(e) {
      return Object.keys(e);
    }, ObjectSetPrototypeOf(e, t) {
      return Object.setPrototypeOf(e, t);
    }, Promise, PromisePrototypeCatch(e, t) {
      return e.catch(t);
    }, PromisePrototypeThen(e, t, r) {
      return e.then(t, r);
    }, PromiseReject(e) {
      return Promise.reject(e);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(e, t) {
      return e.test(t);
    }, SafeSet: Set, String, StringPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, StringPrototypeToLowerCase(e) {
      return e.toLowerCase();
    }, StringPrototypeToUpperCase(e) {
      return e.toUpperCase();
    }, StringPrototypeTrim(e) {
      return e.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(e, t, r) {
      return e.set(t, r);
    }, Uint8Array };
  });
  V5 = E5((Hc, Qt2) => {
    var Kl = te(), zl = Object.getPrototypeOf(async function() {
    }).constructor, Sn2 = globalThis.Blob || Kl.Blob, Xl = typeof Sn2 < "u" ? function(t) {
      return t instanceof Sn2;
    } : function(t) {
      return false;
    }, Jt = class extends Error {
      constructor(t) {
        if (!Array.isArray(t))
          throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
        let r = "";
        for (let n = 0;n < t.length; n++)
          r += `    ${t[n].stack}
`;
        super(r), this.name = "AggregateError", this.errors = t;
      }
    };
    Qt2.exports = { AggregateError: Jt, kEmptyObject: Object.freeze({}), once(e) {
      let t = false;
      return function(...r) {
        t || (t = true, e.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let e, t;
      return { promise: new Promise((n, i) => {
        e = n, t = i;
      }), resolve: e, reject: t };
    }, promisify(e) {
      return new Promise((t, r) => {
        e((n, ...i) => n ? r(n) : t(...i));
      });
    }, debuglog() {
      return function() {
      };
    }, format(e, ...t) {
      return e.replace(/%([sdifj])/g, function(...[r, n]) {
        let i = t.shift();
        return n === "f" ? i.toFixed(6) : n === "j" ? JSON.stringify(i) : n === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
      });
    }, inspect(e) {
      switch (typeof e) {
        case "string":
          if (e.includes("'"))
            if (e.includes('"')) {
              if (!e.includes("`") && !e.includes("${"))
                return `\`${e}\``;
            } else
              return `"${e}"`;
          return `'${e}'`;
        case "number":
          return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
        case "bigint":
          return `${String(e)}n`;
        case "boolean":
        case "undefined":
          return String(e);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(e) {
      return e instanceof zl;
    }, isArrayBufferView(e) {
      return ArrayBuffer.isView(e);
    } }, isBlob: Xl };
    Qt2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  ut2 = E5((Vc, lt3) => {
    var { AbortController: mn, AbortSignal: Jl } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    lt3.exports = mn;
    lt3.exports.AbortSignal = Jl;
    lt3.exports.default = mn;
  });
  C3 = E5((Yc2, An) => {
    var { format: Ql, inspect: ft2, AggregateError: Zl } = V5(), eu = globalThis.AggregateError || Zl, tu = Symbol("kIsNodeError"), ru = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], nu = /^([A-Z][a-z0-9]*)+$/, iu2 = "__node_internal_", st3 = {};
    function be2(e, t) {
      if (!e)
        throw new st3.ERR_INTERNAL_ASSERTION(t);
    }
    function xn(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function ou2(e, t, r) {
      if (typeof t == "function")
        return be2(t.length <= r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`), t(...r);
      let n = (t.match(/%[dfijoOs]/g) || []).length;
      return be2(n === r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`), r.length === 0 ? t : Ql(t, ...r);
    }
    function M3(e, t, r) {
      r || (r = Error);

      class n extends r {
        constructor(...o2) {
          super(ou2(e, t, o2));
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      }
      Object.defineProperties(n.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${e}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), n.prototype.code = e, n.prototype[tu] = true, st3[e] = n;
    }
    function Rn(e) {
      let t = iu2 + e.name;
      return Object.defineProperty(e, "name", { value: t }), e;
    }
    function lu2(e, t) {
      if (e && t && e !== t) {
        if (Array.isArray(t.errors))
          return t.errors.push(e), t;
        let r = new eu([t, e], t.message);
        return r.code = t.code, r;
      }
      return e || t;
    }
    var Zt = class extends Error {
      constructor(t = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new st3.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    M3("ERR_ASSERTION", "%s", Error);
    M3("ERR_INVALID_ARG_TYPE", (e, t, r) => {
      be2(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
      let n = "The ";
      e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
      let i = [], o2 = [], l3 = [];
      for (let f3 of t)
        be2(typeof f3 == "string", "All expected entries have to be of type string"), ru.includes(f3) ? i.push(f3.toLowerCase()) : nu.test(f3) ? o2.push(f3) : (be2(f3 !== "object", 'The value "object" should be written as "Object"'), l3.push(f3));
      if (o2.length > 0) {
        let f3 = i.indexOf("object");
        f3 !== -1 && (i.splice(i, f3, 1), o2.push("Object"));
      }
      if (i.length > 0) {
        switch (i.length) {
          case 1:
            n += `of type ${i[0]}`;
            break;
          case 2:
            n += `one of type ${i[0]} or ${i[1]}`;
            break;
          default: {
            let f3 = i.pop();
            n += `one of type ${i.join(", ")}, or ${f3}`;
          }
        }
        (o2.length > 0 || l3.length > 0) && (n += " or ");
      }
      if (o2.length > 0) {
        switch (o2.length) {
          case 1:
            n += `an instance of ${o2[0]}`;
            break;
          case 2:
            n += `an instance of ${o2[0]} or ${o2[1]}`;
            break;
          default: {
            let f3 = o2.pop();
            n += `an instance of ${o2.join(", ")}, or ${f3}`;
          }
        }
        l3.length > 0 && (n += " or ");
      }
      switch (l3.length) {
        case 0:
          break;
        case 1:
          l3[0].toLowerCase() !== l3[0] && (n += "an "), n += `${l3[0]}`;
          break;
        case 2:
          n += `one of ${l3[0]} or ${l3[1]}`;
          break;
        default: {
          let f3 = l3.pop();
          n += `one of ${l3.join(", ")}, or ${f3}`;
        }
      }
      if (r == null)
        n += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        n += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var u3;
        (u3 = r.constructor) !== null && u3 !== undefined && u3.name ? n += `. Received an instance of ${r.constructor.name}` : n += `. Received ${ft2(r, { depth: -1 })}`;
      } else {
        let f3 = ft2(r, { colors: false });
        f3.length > 25 && (f3 = `${f3.slice(0, 25)}...`), n += `. Received type ${typeof r} (${f3})`;
      }
      return n;
    }, TypeError);
    M3("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
      let n = ft2(t);
      return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
    }, TypeError);
    M3("ERR_INVALID_RETURN_VALUE", (e, t, r) => {
      var n;
      let i = r != null && (n = r.constructor) !== null && n !== undefined && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    M3("ERR_MISSING_ARGS", (...e) => {
      be2(e.length > 0, "At least one arg needs to be specified");
      let t, r = e.length;
      switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
        case 1:
          t += `The ${e[0]} argument`;
          break;
        case 2:
          t += `The ${e[0]} and ${e[1]} arguments`;
          break;
        default:
          {
            let n = e.pop();
            t += `The ${e.join(", ")}, and ${n} arguments`;
          }
          break;
      }
      return `${t} must be specified`;
    }, TypeError);
    M3("ERR_OUT_OF_RANGE", (e, t, r) => {
      be2(t, 'Missing "range" argument');
      let n;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = xn(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = xn(n)), n += "n") : n = ft2(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
    }, RangeError);
    M3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    M3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    M3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    M3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    M3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    M3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    M3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    M3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    M3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    M3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    M3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    An.exports = { AbortError: Zt, aggregateTwoErrors: Rn(lu2), hideStackFrames: Rn, codes: st3 };
  });
  He2 = E5((Kc, Cn) => {
    var { ArrayIsArray: Bn3, ArrayPrototypeIncludes: Ln3, ArrayPrototypeJoin: Nn2, ArrayPrototypeMap: uu2, NumberIsInteger: tr, NumberIsNaN: fu2, NumberMAX_SAFE_INTEGER: su2, NumberMIN_SAFE_INTEGER: au2, NumberParseInt: cu2, ObjectPrototypeHasOwnProperty: du, RegExpPrototypeExec: hu2, String: pu, StringPrototypeToUpperCase: yu, StringPrototypeTrim: wu } = I4(), { hideStackFrames: W, codes: { ERR_SOCKET_BAD_PORT: bu, ERR_INVALID_ARG_TYPE: D3, ERR_INVALID_ARG_VALUE: at3, ERR_OUT_OF_RANGE: ge, ERR_UNKNOWN_SIGNAL: In } } = C3(), { normalizeEncoding: gu } = V5(), { isAsyncFunction: _u, isArrayBufferView: Eu2 } = V5().types, Tn2 = {};
    function Su(e) {
      return e === (e | 0);
    }
    function mu(e) {
      return e === e >>> 0;
    }
    var xu = /^[0-7]+$/, Ru = "must be a 32-bit unsigned integer or an octal string";
    function Au(e, t, r) {
      if (typeof e > "u" && (e = r), typeof e == "string") {
        if (hu2(xu, e) === null)
          throw new at3(t, e, Ru);
        e = cu2(e, 8);
      }
      return Fn2(e, t), e;
    }
    var Iu = W((e, t, r = au2, n = su2) => {
      if (typeof e != "number")
        throw new D3(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      if (e < r || e > n)
        throw new ge(t, `>= ${r} && <= ${n}`, e);
    }), Tu = W((e, t, r = -2147483648, n = 2147483647) => {
      if (typeof e != "number")
        throw new D3(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      if (e < r || e > n)
        throw new ge(t, `>= ${r} && <= ${n}`, e);
    }), Fn2 = W((e, t, r = false) => {
      if (typeof e != "number")
        throw new D3(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      let n = r ? 1 : 0, i = 4294967295;
      if (e < n || e > i)
        throw new ge(t, `>= ${n} && <= ${i}`, e);
    });
    function Mn(e, t) {
      if (typeof e != "string")
        throw new D3(t, "string", e);
    }
    function Bu(e, t, r = undefined, n) {
      if (typeof e != "number")
        throw new D3(t, "number", e);
      if (r != null && e < r || n != null && e > n || (r != null || n != null) && fu2(e))
        throw new ge(t, `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`, e);
    }
    var Lu = W((e, t, r) => {
      if (!Ln3(r, e)) {
        let n = Nn2(uu2(r, (o2) => typeof o2 == "string" ? `'${o2}'` : pu(o2)), ", "), i = "must be one of: " + n;
        throw new at3(t, e, i);
      }
    });
    function Nu(e, t) {
      if (typeof e != "boolean")
        throw new D3(t, "boolean", e);
    }
    function er2(e, t, r) {
      return e == null || !du(e, t) ? r : e[t];
    }
    var Fu = W((e, t, r = null) => {
      let n = er2(r, "allowArray", false), i = er2(r, "allowFunction", false);
      if (!er2(r, "nullable", false) && e === null || !n && Bn3(e) || typeof e != "object" && (!i || typeof e != "function"))
        throw new D3(t, "Object", e);
    }), Mu = W((e, t, r = 0) => {
      if (!Bn3(e))
        throw new D3(t, "Array", e);
      if (e.length < r) {
        let n = `must be longer than ${r}`;
        throw new at3(t, e, n);
      }
    });
    function Cu(e, t = "signal") {
      if (Mn(e, t), Tn2[e] === undefined)
        throw Tn2[yu(e)] !== undefined ? new In(e + " (signals must use all capital letters)") : new In(e);
    }
    var Ou = W((e, t = "buffer") => {
      if (!Eu2(e))
        throw new D3(t, ["Buffer", "TypedArray", "DataView"], e);
    });
    function Du(e, t) {
      let r = gu(t), n = e.length;
      if (r === "hex" && n % 2 !== 0)
        throw new at3("encoding", t, `is invalid for data of length ${n}`);
    }
    function Pu(e, t = "Port", r = true) {
      if (typeof e != "number" && typeof e != "string" || typeof e == "string" && wu(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
        throw new bu(t, e, r);
      return e | 0;
    }
    var ku = W((e, t) => {
      if (e !== undefined && (e === null || typeof e != "object" || !("aborted" in e)))
        throw new D3(t, "AbortSignal", e);
    }), Uu = W((e, t) => {
      if (typeof e != "function")
        throw new D3(t, "Function", e);
    }), vu = W((e, t) => {
      if (typeof e != "function" || _u(e))
        throw new D3(t, "Function", e);
    }), qu = W((e, t) => {
      if (e !== undefined)
        throw new D3(t, "undefined", e);
    });
    function Wu(e, t, r) {
      if (!Ln3(r, e))
        throw new D3(t, `('${Nn2(r, "|")}')`, e);
    }
    Cn.exports = { isInt32: Su, isUint32: mu, parseFileMode: Au, validateArray: Mu, validateBoolean: Nu, validateBuffer: Ou, validateEncoding: Du, validateFunction: Uu, validateInt32: Tu, validateInteger: Iu, validateNumber: Bu, validateObject: Fu, validateOneOf: Lu, validatePlainFunction: vu, validatePort: Pu, validateSignalName: Cu, validateString: Mn, validateUint32: Fn2, validateUndefined: qu, validateUnion: Wu, validateAbortSignal: ku };
  });
  ir2 = E5((zc2, kn) => {
    var x5 = kn.exports = {}, Y3, K5;
    function rr2() {
      throw new Error("setTimeout has not been defined");
    }
    function nr() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Y3 = setTimeout : Y3 = rr2;
      } catch {
        Y3 = rr2;
      }
      try {
        typeof clearTimeout == "function" ? K5 = clearTimeout : K5 = nr;
      } catch {
        K5 = nr;
      }
    })();
    function On2(e) {
      if (Y3 === setTimeout)
        return setTimeout(e, 0);
      if ((Y3 === rr2 || !Y3) && setTimeout)
        return Y3 = setTimeout, setTimeout(e, 0);
      try {
        return Y3(e, 0);
      } catch {
        try {
          return Y3.call(null, e, 0);
        } catch {
          return Y3.call(this, e, 0);
        }
      }
    }
    function $u(e) {
      if (K5 === clearTimeout)
        return clearTimeout(e);
      if ((K5 === nr || !K5) && clearTimeout)
        return K5 = clearTimeout, clearTimeout(e);
      try {
        return K5(e);
      } catch {
        try {
          return K5.call(null, e);
        } catch {
          return K5.call(this, e);
        }
      }
    }
    var re2 = [], Me = false, _e3, ct3 = -1;
    function ju() {
      !Me || !_e3 || (Me = false, _e3.length ? re2 = _e3.concat(re2) : ct3 = -1, re2.length && Dn3());
    }
    function Dn3() {
      if (!Me) {
        var e = On2(ju);
        Me = true;
        for (var t = re2.length;t; ) {
          for (_e3 = re2, re2 = [];++ct3 < t; )
            _e3 && _e3[ct3].run();
          ct3 = -1, t = re2.length;
        }
        _e3 = null, Me = false, $u(e);
      }
    }
    x5.nextTick = function(e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          t[r - 1] = arguments[r];
      re2.push(new Pn(e, t)), re2.length === 1 && !Me && On2(Dn3);
    };
    function Pn(e, t) {
      this.fun = e, this.array = t;
    }
    Pn.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    x5.title = "browser";
    x5.browser = true;
    x5.env = {};
    x5.argv = [];
    x5.version = "";
    x5.versions = {};
    function ne2() {
    }
    x5.on = ne2;
    x5.addListener = ne2;
    x5.once = ne2;
    x5.off = ne2;
    x5.removeListener = ne2;
    x5.removeAllListeners = ne2;
    x5.emit = ne2;
    x5.prependListener = ne2;
    x5.prependOnceListener = ne2;
    x5.listeners = function(e) {
      return [];
    };
    x5.binding = function(e) {
      throw new Error("process.binding is not supported");
    };
    x5.cwd = function() {
      return "/";
    };
    x5.chdir = function(e) {
      throw new Error("process.chdir is not supported");
    };
    x5.umask = function() {
      return 0;
    };
  });
  k3 = {};
  Qr(k3, { default: () => Gu });
  se2 = yl(() => {
    ue3(k3, rt3(ir2()));
    Gu = rt3(ir2());
  });
  ae = E5((Jc, zn2) => {
    var { Symbol: dt3, SymbolAsyncIterator: Un, SymbolIterator: vn } = I4(), qn2 = dt3("kDestroyed"), Wn = dt3("kIsErrored"), or = dt3("kIsReadable"), $n = dt3("kIsDisturbed");
    function ht2(e, t = false) {
      var r;
      return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!e._writableState || e._readableState));
    }
    function pt3(e) {
      var t;
      return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === undefined ? undefined : t.writable) !== false));
    }
    function Hu(e) {
      return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Ee(e) {
      return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function Vu(e, t) {
      return e == null ? false : t === true ? typeof e[Un] == "function" : t === false ? typeof e[vn] == "function" : typeof e[Un] == "function" || typeof e[vn] == "function";
    }
    function yt2(e) {
      if (!Ee(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !!(e.destroyed || e[qn2] || n != null && n.destroyed);
    }
    function jn2(e) {
      if (!pt3(e))
        return null;
      if (e.writableEnded === true)
        return true;
      let t = e._writableState;
      return t != null && t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Yu2(e, t) {
      if (!pt3(e))
        return null;
      if (e.writableFinished === true)
        return true;
      let r = e._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || t === false && r.ended === true && r.length === 0);
    }
    function Ku(e) {
      if (!ht2(e))
        return null;
      if (e.readableEnded === true)
        return true;
      let t = e._readableState;
      return !t || t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Gn(e, t) {
      if (!ht2(e))
        return null;
      let r = e._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || t === false && r.ended === true && r.length === 0);
    }
    function Hn(e) {
      return e && e[or] != null ? e[or] : typeof e?.readable != "boolean" ? null : yt2(e) ? false : ht2(e) && e.readable && !Gn(e);
    }
    function Vn(e) {
      return typeof e?.writable != "boolean" ? null : yt2(e) ? false : pt3(e) && e.writable && !jn2(e);
    }
    function zu(e, t) {
      return Ee(e) ? yt2(e) ? true : !(t?.readable !== false && Hn(e) || t?.writable !== false && Vn(e)) : null;
    }
    function Xu(e) {
      var t, r;
      return Ee(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function Ju2(e) {
      var t, r;
      return Ee(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function Qu(e) {
      if (!Ee(e))
        return null;
      if (typeof e.closed == "boolean")
        return e.closed;
      let { _writableState: t, _readableState: r } = e;
      return typeof t?.closed == "boolean" || typeof r?.closed == "boolean" ? t?.closed || r?.closed : typeof e._closed == "boolean" && Yn(e) ? e._closed : null;
    }
    function Yn(e) {
      return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function Kn(e) {
      return typeof e._sent100 == "boolean" && Yn(e);
    }
    function Zu2(e) {
      var t;
      return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === undefined ? undefined : t.upgradeOrConnect) === undefined;
    }
    function ef2(e) {
      if (!Ee(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !n && Kn(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === false);
    }
    function tf2(e) {
      var t;
      return !!(e && ((t = e[$n]) !== null && t !== undefined ? t : e.readableDidRead || e.readableAborted));
    }
    function rf(e) {
      var t, r, n, i, o2, l3, u3, f3, s2, d4;
      return !!(e && ((t = (r = (n = (i = (o2 = (l3 = e[Wn]) !== null && l3 !== undefined ? l3 : e.readableErrored) !== null && o2 !== undefined ? o2 : e.writableErrored) !== null && i !== undefined ? i : (u3 = e._readableState) === null || u3 === undefined ? undefined : u3.errorEmitted) !== null && n !== undefined ? n : (f3 = e._writableState) === null || f3 === undefined ? undefined : f3.errorEmitted) !== null && r !== undefined ? r : (s2 = e._readableState) === null || s2 === undefined ? undefined : s2.errored) !== null && t !== undefined ? t : (d4 = e._writableState) === null || d4 === undefined ? undefined : d4.errored));
    }
    zn2.exports = { kDestroyed: qn2, isDisturbed: tf2, kIsDisturbed: $n, isErrored: rf, kIsErrored: Wn, isReadable: Hn, kIsReadable: or, isClosed: Qu, isDestroyed: yt2, isDuplexNodeStream: Hu, isFinished: zu, isIterable: Vu, isReadableNodeStream: ht2, isReadableEnded: Ku, isReadableFinished: Gn, isReadableErrored: Ju2, isNodeStream: Ee, isWritable: Vn, isWritableNodeStream: pt3, isWritableEnded: jn2, isWritableFinished: Yu2, isWritableErrored: Xu, isServerRequest: Zu2, isServerResponse: Kn, willEmitClose: ef2 };
  });
  ce2 = E5((Qc, ur2) => {
    var Ce2 = (se2(), pe(k3)), { AbortError: nf, codes: of } = C3(), { ERR_INVALID_ARG_TYPE: lf, ERR_STREAM_PREMATURE_CLOSE: Xn } = of, { kEmptyObject: Jn, once: Qn2 } = V5(), { validateAbortSignal: uf, validateFunction: ff2, validateObject: sf } = He2(), { Promise: af } = I4(), { isClosed: cf2, isReadable: Zn, isReadableNodeStream: lr, isReadableFinished: ei, isReadableErrored: df, isWritable: ti2, isWritableNodeStream: ri3, isWritableFinished: ni, isWritableErrored: hf, isNodeStream: pf, willEmitClose: yf2 } = ae();
    function wf(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    var bf = () => {
    };
    function ii2(e, t, r) {
      var n, i;
      arguments.length === 2 ? (r = t, t = Jn) : t == null ? t = Jn : sf(t, "options"), ff2(r, "callback"), uf(t.signal, "options.signal"), r = Qn2(r);
      let o2 = (n = t.readable) !== null && n !== undefined ? n : lr(e), l3 = (i = t.writable) !== null && i !== undefined ? i : ri3(e);
      if (!pf(e))
        throw new lf("stream", "Stream", e);
      let { _writableState: u3, _readableState: f3 } = e, s2 = () => {
        e.writable || y5();
      }, d4 = yf2(e) && lr(e) === o2 && ri3(e) === l3, c2 = ni(e, false), y5 = () => {
        c2 = true, e.destroyed && (d4 = false), !(d4 && (!e.readable || o2)) && (!o2 || h5) && r.call(e);
      }, h5 = ei(e, false), p3 = () => {
        h5 = true, e.destroyed && (d4 = false), !(d4 && (!e.writable || l3)) && (!l3 || c2) && r.call(e);
      }, B3 = (N6) => {
        r.call(e, N6);
      }, v4 = cf2(e), w3 = () => {
        v4 = true;
        let N6 = hf(e) || df(e);
        if (N6 && typeof N6 != "boolean")
          return r.call(e, N6);
        if (o2 && !h5 && lr(e, true) && !ei(e, false))
          return r.call(e, new Xn);
        if (l3 && !c2 && !ni(e, false))
          return r.call(e, new Xn);
        r.call(e);
      }, b6 = () => {
        e.req.on("finish", y5);
      };
      wf(e) ? (e.on("complete", y5), d4 || e.on("abort", w3), e.req ? b6() : e.on("request", b6)) : l3 && !u3 && (e.on("end", s2), e.on("close", s2)), !d4 && typeof e.aborted == "boolean" && e.on("aborted", w3), e.on("end", p3), e.on("finish", y5), t.error !== false && e.on("error", B3), e.on("close", w3), v4 ? Ce2.nextTick(w3) : u3 != null && u3.errorEmitted || f3 != null && f3.errorEmitted ? d4 || Ce2.nextTick(w3) : (!o2 && (!d4 || Zn(e)) && (c2 || ti2(e) === false) || !l3 && (!d4 || ti2(e)) && (h5 || Zn(e) === false) || f3 && e.req && e.aborted) && Ce2.nextTick(w3);
      let L4 = () => {
        r = bf, e.removeListener("aborted", w3), e.removeListener("complete", y5), e.removeListener("abort", w3), e.removeListener("request", b6), e.req && e.req.removeListener("finish", y5), e.removeListener("end", s2), e.removeListener("close", s2), e.removeListener("finish", y5), e.removeListener("end", p3), e.removeListener("error", B3), e.removeListener("close", w3);
      };
      if (t.signal && !v4) {
        let N6 = () => {
          let Q5 = r;
          L4(), Q5.call(e, new nf(undefined, { cause: t.signal.reason }));
        };
        if (t.signal.aborted)
          Ce2.nextTick(N6);
        else {
          let Q5 = r;
          r = Qn2((...Ie) => {
            t.signal.removeEventListener("abort", N6), Q5.apply(e, Ie);
          }), t.signal.addEventListener("abort", N6);
        }
      }
      return L4;
    }
    function gf(e, t) {
      return new af((r, n) => {
        ii2(e, t, (i) => {
          i ? n(i) : r();
        });
      });
    }
    ur2.exports = ii2;
    ur2.exports.finished = gf;
  });
  di2 = E5((Zc, ar2) => {
    var fi2 = globalThis.AbortController || ut2().AbortController, { codes: { ERR_INVALID_ARG_TYPE: Ve, ERR_MISSING_ARGS: _f, ERR_OUT_OF_RANGE: Ef2 }, AbortError: z } = C3(), { validateAbortSignal: Oe, validateInteger: Sf2, validateObject: De } = He2(), mf2 = I4().Symbol("kWeak"), { finished: xf } = ce2(), { ArrayPrototypePush: Rf, MathFloor: Af2, Number: If, NumberIsNaN: Tf, Promise: oi, PromiseReject: li2, PromisePrototypeThen: Bf, Symbol: si2 } = I4(), wt = si2("kEmpty"), ui = si2("kEof");
    function bt4(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal");
      let r = 1;
      return t?.concurrency != null && (r = Af2(t.concurrency)), Sf2(r, "concurrency", 1), async function* () {
        var i, o2;
        let l3 = new fi2, u3 = this, f3 = [], s2 = l3.signal, d4 = { signal: s2 }, c2 = () => l3.abort();
        t != null && (i = t.signal) !== null && i !== undefined && i.aborted && c2(), t == null || (o2 = t.signal) === null || o2 === undefined || o2.addEventListener("abort", c2);
        let y5, h5, p3 = false;
        function B3() {
          p3 = true;
        }
        async function v4() {
          try {
            for await (let L4 of u3) {
              var w3;
              if (p3)
                return;
              if (s2.aborted)
                throw new z;
              try {
                L4 = e(L4, d4);
              } catch (N6) {
                L4 = li2(N6);
              }
              L4 !== wt && (typeof ((w3 = L4) === null || w3 === undefined ? undefined : w3.catch) == "function" && L4.catch(B3), f3.push(L4), y5 && (y5(), y5 = null), !p3 && f3.length && f3.length >= r && await new oi((N6) => {
                h5 = N6;
              }));
            }
            f3.push(ui);
          } catch (L4) {
            let N6 = li2(L4);
            Bf(N6, undefined, B3), f3.push(N6);
          } finally {
            var b6;
            p3 = true, y5 && (y5(), y5 = null), t == null || (b6 = t.signal) === null || b6 === undefined || b6.removeEventListener("abort", c2);
          }
        }
        v4();
        try {
          for (;; ) {
            for (;f3.length > 0; ) {
              let w3 = await f3[0];
              if (w3 === ui)
                return;
              if (s2.aborted)
                throw new z;
              w3 !== wt && (yield w3), f3.shift(), h5 && (h5(), h5 = null);
            }
            await new oi((w3) => {
              y5 = w3;
            });
          }
        } finally {
          l3.abort(), p3 = true, h5 && (h5(), h5 = null);
        }
      }.call(this);
    }
    function Lf(e = undefined) {
      return e != null && De(e, "options"), e?.signal != null && Oe(e.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let i of this) {
          var n;
          if (e != null && (n = e.signal) !== null && n !== undefined && n.aborted)
            throw new z({ cause: e.signal.reason });
          yield [r++, i];
        }
      }.call(this);
    }
    async function ai2(e, t = undefined) {
      for await (let r of sr.call(this, e, t))
        return true;
      return false;
    }
    async function Nf(e, t = undefined) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      return !await ai2.call(this, async (...r) => !await e(...r), t);
    }
    async function Ff(e, t) {
      for await (let r of sr.call(this, e, t))
        return r;
    }
    async function Mf(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i), wt;
      }
      for await (let n of bt4.call(this, r, t))
        ;
    }
    function sr(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i) ? n : wt;
      }
      return bt4.call(this, r, t);
    }
    var fr = class extends _f {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function Cf3(e, t, r) {
      var n;
      if (typeof e != "function")
        throw new Ve("reducer", ["Function", "AsyncFunction"], e);
      r != null && De(r, "options"), r?.signal != null && Oe(r.signal, "options.signal");
      let i = arguments.length > 1;
      if (r != null && (n = r.signal) !== null && n !== undefined && n.aborted) {
        let s2 = new z(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await xf(this.destroy(s2)), s2;
      }
      let o2 = new fi2, l3 = o2.signal;
      if (r != null && r.signal) {
        let s2 = { once: true, [mf2]: this };
        r.signal.addEventListener("abort", () => o2.abort(), s2);
      }
      let u3 = false;
      try {
        for await (let s2 of this) {
          var f3;
          if (u3 = true, r != null && (f3 = r.signal) !== null && f3 !== undefined && f3.aborted)
            throw new z;
          i ? t = await e(t, s2, { signal: l3 }) : (t = s2, i = true);
        }
        if (!u3 && !i)
          throw new fr;
      } finally {
        o2.abort();
      }
      return t;
    }
    async function Of(e) {
      e != null && De(e, "options"), e?.signal != null && Oe(e.signal, "options.signal");
      let t = [];
      for await (let n of this) {
        var r;
        if (e != null && (r = e.signal) !== null && r !== undefined && r.aborted)
          throw new z(undefined, { cause: e.signal.reason });
        Rf(t, n);
      }
      return t;
    }
    function Df(e, t) {
      let r = bt4.call(this, e, t);
      return async function* () {
        for await (let i of r)
          yield* i;
      }.call(this);
    }
    function ci2(e) {
      if (e = If(e), Tf(e))
        return 0;
      if (e < 0)
        throw new Ef2("number", ">= 0", e);
      return e;
    }
    function Pf(e, t = undefined) {
      return t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal"), e = ci2(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new z;
          e-- <= 0 && (yield o2);
        }
      }.call(this);
    }
    function kf(e, t = undefined) {
      return t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal"), e = ci2(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new z;
          if (e-- > 0)
            yield o2;
          else
            return;
        }
      }.call(this);
    }
    ar2.exports.streamReturningOperators = { asIndexedPairs: Lf, drop: Pf, filter: sr, flatMap: Df, map: bt4, take: kf };
    ar2.exports.promiseReturningOperators = { every: Nf, forEach: Mf, reduce: Cf3, toArray: Of, some: ai2, find: Ff };
  });
  Se2 = E5((ed, Ei2) => {
    var de = (se2(), pe(k3)), { aggregateTwoErrors: Uf, codes: { ERR_MULTIPLE_CALLBACK: vf2 }, AbortError: qf } = C3(), { Symbol: yi2 } = I4(), { kDestroyed: Wf, isDestroyed: $f, isFinished: jf, isServerRequest: Gf } = ae(), wi3 = yi2("kDestroy"), cr2 = yi2("kConstruct");
    function bi3(e, t, r) {
      e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
    }
    function Hf(e, t) {
      let r = this._readableState, n = this._writableState, i = n || r;
      return n && n.destroyed || r && r.destroyed ? (typeof t == "function" && t(), this) : (bi3(e, n, r), n && (n.destroyed = true), r && (r.destroyed = true), i.constructed ? hi(this, e, t) : this.once(wi3, function(o2) {
        hi(this, Uf(o2, e), t);
      }), this);
    }
    function hi(e, t, r) {
      let n = false;
      function i(o2) {
        if (n)
          return;
        n = true;
        let { _readableState: l3, _writableState: u3 } = e;
        bi3(o2, u3, l3), u3 && (u3.closed = true), l3 && (l3.closed = true), typeof r == "function" && r(o2), o2 ? de.nextTick(Vf, e, o2) : de.nextTick(gi4, e);
      }
      try {
        e._destroy(t || null, i);
      } catch (o2) {
        i(o2);
      }
    }
    function Vf(e, t) {
      dr4(e, t), gi4(e);
    }
    function gi4(e) {
      let { _readableState: t, _writableState: r } = e;
      r && (r.closeEmitted = true), t && (t.closeEmitted = true), (r && r.emitClose || t && t.emitClose) && e.emit("close");
    }
    function dr4(e, t) {
      let { _readableState: r, _writableState: n } = e;
      n && n.errorEmitted || r && r.errorEmitted || (n && (n.errorEmitted = true), r && (r.errorEmitted = true), e.emit("error", t));
    }
    function Yf() {
      let e = this._readableState, t = this._writableState;
      e && (e.constructed = true, e.closed = false, e.closeEmitted = false, e.destroyed = false, e.errored = null, e.errorEmitted = false, e.reading = false, e.ended = e.readable === false, e.endEmitted = e.readable === false), t && (t.constructed = true, t.destroyed = false, t.closed = false, t.closeEmitted = false, t.errored = null, t.errorEmitted = false, t.finalCalled = false, t.prefinished = false, t.ended = t.writable === false, t.ending = t.writable === false, t.finished = t.writable === false);
    }
    function hr3(e, t, r) {
      let { _readableState: n, _writableState: i } = e;
      if (i && i.destroyed || n && n.destroyed)
        return this;
      n && n.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), n && !n.errored && (n.errored = t), r ? de.nextTick(dr4, e, t) : dr4(e, t));
    }
    function Kf(e, t) {
      if (typeof e._construct != "function")
        return;
      let { _readableState: r, _writableState: n } = e;
      r && (r.constructed = false), n && (n.constructed = false), e.once(cr2, t), !(e.listenerCount(cr2) > 1) && de.nextTick(zf2, e);
    }
    function zf2(e) {
      let t = false;
      function r(n) {
        if (t) {
          hr3(e, n ?? new vf2);
          return;
        }
        t = true;
        let { _readableState: i, _writableState: o2 } = e, l3 = o2 || i;
        i && (i.constructed = true), o2 && (o2.constructed = true), l3.destroyed ? e.emit(wi3, n) : n ? hr3(e, n, true) : de.nextTick(Xf, e);
      }
      try {
        e._construct(r);
      } catch (n) {
        r(n);
      }
    }
    function Xf(e) {
      e.emit(cr2);
    }
    function pi3(e) {
      return e && e.setHeader && typeof e.abort == "function";
    }
    function _i3(e) {
      e.emit("close");
    }
    function Jf(e, t) {
      e.emit("error", t), de.nextTick(_i3, e);
    }
    function Qf(e, t) {
      !e || $f(e) || (!t && !jf(e) && (t = new qf), Gf(e) ? (e.socket = null, e.destroy(t)) : pi3(e) ? e.abort() : pi3(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? de.nextTick(Jf, e, t) : de.nextTick(_i3, e), e.destroyed || (e[Wf] = true));
    }
    Ei2.exports = { construct: Kf, destroyer: Qf, destroy: Hf, undestroy: Yf, errorOrDestroy: hr3 };
  });
  Et = E5((td, pr2) => {
    var Pe3 = typeof Reflect == "object" ? Reflect : null, Si4 = Pe3 && typeof Pe3.apply == "function" ? Pe3.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, gt3;
    Pe3 && typeof Pe3.ownKeys == "function" ? gt3 = Pe3.ownKeys : Object.getOwnPropertySymbols ? gt3 = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : gt3 = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function Zf(e) {
      console && console.warn && console.warn(e);
    }
    var xi3 = Number.isNaN || function(t) {
      return t !== t;
    };
    function S3() {
      S3.init.call(this);
    }
    pr2.exports = S3;
    pr2.exports.once = ns;
    S3.EventEmitter = S3;
    S3.prototype._events = undefined;
    S3.prototype._eventsCount = 0;
    S3.prototype._maxListeners = undefined;
    var mi3 = 10;
    function _t4(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(S3, "defaultMaxListeners", { enumerable: true, get: function() {
      return mi3;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || xi3(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      mi3 = e;
    } });
    S3.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    S3.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || xi3(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Ri2(e) {
      return e._maxListeners === undefined ? S3.defaultMaxListeners : e._maxListeners;
    }
    S3.prototype.getMaxListeners = function() {
      return Ri2(this);
    };
    S3.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var l3;
        if (r.length > 0 && (l3 = r[0]), l3 instanceof Error)
          throw l3;
        var u3 = new Error("Unhandled error." + (l3 ? " (" + l3.message + ")" : ""));
        throw u3.context = l3, u3;
      }
      var f3 = o2[t];
      if (f3 === undefined)
        return false;
      if (typeof f3 == "function")
        Si4(f3, this, r);
      else
        for (var s2 = f3.length, d4 = Li2(f3, s2), n = 0;n < s2; ++n)
          Si4(d4[n], this, r);
      return true;
    };
    function Ai3(e, t, r, n) {
      var i, o2, l3;
      if (_t4(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), l3 = o2[t]), l3 === undefined)
        l3 = o2[t] = r, ++e._eventsCount;
      else if (typeof l3 == "function" ? l3 = o2[t] = n ? [r, l3] : [l3, r] : n ? l3.unshift(r) : l3.push(r), i = Ri2(e), i > 0 && l3.length > i && !l3.warned) {
        l3.warned = true;
        var u3 = new Error("Possible EventEmitter memory leak detected. " + l3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        u3.name = "MaxListenersExceededWarning", u3.emitter = e, u3.type = t, u3.count = l3.length, Zf(u3);
      }
      return e;
    }
    S3.prototype.addListener = function(t, r) {
      return Ai3(this, t, r, false);
    };
    S3.prototype.on = S3.prototype.addListener;
    S3.prototype.prependListener = function(t, r) {
      return Ai3(this, t, r, true);
    };
    function es() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ii2(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = es.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    S3.prototype.once = function(t, r) {
      return _t4(r), this.on(t, Ii2(this, t, r)), this;
    };
    S3.prototype.prependOnceListener = function(t, r) {
      return _t4(r), this.prependListener(t, Ii2(this, t, r)), this;
    };
    S3.prototype.removeListener = function(t, r) {
      var n, i, o2, l3, u3;
      if (_t4(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, l3 = n.length - 1;l3 >= 0; l3--)
          if (n[l3] === r || n[l3].listener === r) {
            u3 = n[l3].listener, o2 = l3;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : ts(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, u3 || r);
      }
      return this;
    };
    S3.prototype.off = S3.prototype.removeListener;
    S3.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), l3;
        for (i = 0;i < o2.length; ++i)
          l3 = o2[i], l3 !== "removeListener" && this.removeAllListeners(l3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Ti2(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? rs(i) : Li2(i, i.length);
    }
    S3.prototype.listeners = function(t) {
      return Ti2(this, t, true);
    };
    S3.prototype.rawListeners = function(t) {
      return Ti2(this, t, false);
    };
    S3.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Bi.call(e, t);
    };
    S3.prototype.listenerCount = Bi;
    function Bi(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    S3.prototype.eventNames = function() {
      return this._eventsCount > 0 ? gt3(this._events) : [];
    };
    function Li2(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function ts(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function rs(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function ns(e, t) {
      return new Promise(function(r, n) {
        function i(l3) {
          e.removeListener(t, o2), n(l3);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        Ni2(e, t, o2, { once: true }), t !== "error" && is(e, i, { once: true });
      });
    }
    function is(e, t, r) {
      typeof e.on == "function" && Ni2(e, "error", t, r);
    }
    function Ni2(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  xt2 = E5((rd, Mi) => {
    var { ArrayIsArray: os, ObjectSetPrototypeOf: Fi } = I4(), { EventEmitter: St2 } = Et();
    function mt4(e) {
      St2.call(this, e);
    }
    Fi(mt4.prototype, St2.prototype);
    Fi(mt4, St2);
    mt4.prototype.pipe = function(e, t) {
      let r = this;
      function n(d4) {
        e.writable && e.write(d4) === false && r.pause && r.pause();
      }
      r.on("data", n);
      function i() {
        r.readable && r.resume && r.resume();
      }
      e.on("drain", i), !e._isStdio && (!t || t.end !== false) && (r.on("end", l3), r.on("close", u3));
      let o2 = false;
      function l3() {
        o2 || (o2 = true, e.end());
      }
      function u3() {
        o2 || (o2 = true, typeof e.destroy == "function" && e.destroy());
      }
      function f3(d4) {
        s2(), St2.listenerCount(this, "error") === 0 && this.emit("error", d4);
      }
      yr2(r, "error", f3), yr2(e, "error", f3);
      function s2() {
        r.removeListener("data", n), e.removeListener("drain", i), r.removeListener("end", l3), r.removeListener("close", u3), r.removeListener("error", f3), e.removeListener("error", f3), r.removeListener("end", s2), r.removeListener("close", s2), e.removeListener("close", s2);
      }
      return r.on("end", s2), r.on("close", s2), e.on("close", s2), e.emit("pipe", r), e;
    };
    function yr2(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : os(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    Mi.exports = { Stream: mt4, prependListener: yr2 };
  });
  At4 = E5((nd, Rt2) => {
    var { AbortError: ls, codes: us } = C3(), fs = ce2(), { ERR_INVALID_ARG_TYPE: Ci } = us, ss = (e, t) => {
      if (typeof e != "object" || !("aborted" in e))
        throw new Ci(t, "AbortSignal", e);
    };
    function as(e) {
      return !!(e && typeof e.pipe == "function");
    }
    Rt2.exports.addAbortSignal = function(t, r) {
      if (ss(t, "signal"), !as(r))
        throw new Ci("stream", "stream.Stream", r);
      return Rt2.exports.addAbortSignalNoValidate(t, r);
    };
    Rt2.exports.addAbortSignalNoValidate = function(e, t) {
      if (typeof e != "object" || !("aborted" in e))
        return t;
      let r = () => {
        t.destroy(new ls(undefined, { cause: e.reason }));
      };
      return e.aborted ? r() : (e.addEventListener("abort", r), fs(t, () => e.removeEventListener("abort", r))), t;
    };
  });
  Pi = E5((od, Di2) => {
    var { StringPrototypeSlice: Oi, SymbolIterator: cs, TypedArrayPrototypeSet: It, Uint8Array: ds } = I4(), { Buffer: wr } = te(), { inspect: hs } = V5();
    Di2.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(t) {
        let r = { data: t, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(t) {
        let r = { data: t, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let t = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(t) {
        if (this.length === 0)
          return "";
        let r = this.head, n = "" + r.data;
        for (;(r = r.next) !== null; )
          n += t + r.data;
        return n;
      }
      concat(t) {
        if (this.length === 0)
          return wr.alloc(0);
        let r = wr.allocUnsafe(t >>> 0), n = this.head, i = 0;
        for (;n; )
          It(r, n.data, i), i += n.data.length, n = n.next;
        return r;
      }
      consume(t, r) {
        let n = this.head.data;
        if (t < n.length) {
          let i = n.slice(0, t);
          return this.head.data = n.slice(t), i;
        }
        return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
      }
      first() {
        return this.head.data;
      }
      *[cs]() {
        for (let t = this.head;t; t = t.next)
          yield t.data;
      }
      _getString(t) {
        let r = "", n = this.head, i = 0;
        do {
          let o2 = n.data;
          if (t > o2.length)
            r += o2, t -= o2.length;
          else {
            t === o2.length ? (r += o2, ++i, n.next ? this.head = n.next : this.head = this.tail = null) : (r += Oi(o2, 0, t), this.head = n, n.data = Oi(o2, t));
            break;
          }
          ++i;
        } while ((n = n.next) !== null);
        return this.length -= i, r;
      }
      _getBuffer(t) {
        let r = wr.allocUnsafe(t), n = t, i = this.head, o2 = 0;
        do {
          let l3 = i.data;
          if (t > l3.length)
            It(r, l3, n - t), t -= l3.length;
          else {
            t === l3.length ? (It(r, l3, n - t), ++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (It(r, new ds(l3.buffer, l3.byteOffset, t), n - t), this.head = i, i.data = l3.slice(t));
            break;
          }
          ++o2;
        } while ((i = i.next) !== null);
        return this.length -= o2, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](t, r) {
        return hs(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Tt4 = E5((ld, Ui) => {
    var { MathFloor: ps, NumberIsInteger: ys } = I4(), { ERR_INVALID_ARG_VALUE: ws } = C3().codes;
    function bs(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function ki(e) {
      return e ? 16 : 16 * 1024;
    }
    function gs(e, t, r, n) {
      let i = bs(t, n, r);
      if (i != null) {
        if (!ys(i) || i < 0) {
          let o2 = n ? `options.${r}` : "options.highWaterMark";
          throw new ws(o2, i);
        }
        return ps(i);
      }
      return ki(e.objectMode);
    }
    Ui.exports = { getHighWaterMark: gs, getDefaultHighWaterMark: ki };
  });
  Wi = E5((br4, qi) => {
    var Bt2 = te(), X4 = Bt2.Buffer;
    function vi3(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    X4.from && X4.alloc && X4.allocUnsafe && X4.allocUnsafeSlow ? qi.exports = Bt2 : (vi3(Bt2, br4), br4.Buffer = me);
    function me(e, t, r) {
      return X4(e, t, r);
    }
    me.prototype = Object.create(X4.prototype);
    vi3(X4, me);
    me.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return X4(e, t, r);
    };
    me.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = X4(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    me.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return X4(e);
    };
    me.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Bt2.SlowBuffer(e);
    };
  });
  Gi2 = E5((ji2) => {
    var _r3 = Wi().Buffer, $i = _r3.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _s(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function Es(e) {
      var t = _s(e);
      if (typeof t != "string" && (_r3.isEncoding === $i || !$i(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    ji2.StringDecoder = Ye;
    function Ye(e) {
      this.encoding = Es(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Is, this.end = Ts, t = 4;
          break;
        case "utf8":
          this.fillLast = xs, t = 4;
          break;
        case "base64":
          this.text = Bs, this.end = Ls, t = 3;
          break;
        default:
          this.write = Ns, this.end = Fs;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = _r3.allocUnsafe(t);
    }
    Ye.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Ye.prototype.end = As;
    Ye.prototype.text = Rs;
    Ye.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function gr4(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ss(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = gr4(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = gr4(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = gr4(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ms(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function xs(e) {
      var t = this.lastTotal - this.lastNeed, r = ms(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Rs(e, t) {
      var r = Ss(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function As(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function Is(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ts(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Bs(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Ls(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ns(e) {
      return e.toString(this.encoding);
    }
    function Fs(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Er4 = E5((fd, Ki2) => {
    var Hi2 = (se2(), pe(k3)), { PromisePrototypeThen: Ms, SymbolAsyncIterator: Vi3, SymbolIterator: Yi2 } = I4(), { Buffer: Cs } = te(), { ERR_INVALID_ARG_TYPE: Os, ERR_STREAM_NULL_VALUES: Ds } = C3().codes;
    function Ps(e, t, r) {
      let n;
      if (typeof t == "string" || t instanceof Cs)
        return new e({ objectMode: true, ...r, read() {
          this.push(t), this.push(null);
        } });
      let i;
      if (t && t[Vi3])
        i = true, n = t[Vi3]();
      else if (t && t[Yi2])
        i = false, n = t[Yi2]();
      else
        throw new Os("iterable", ["Iterable"], t);
      let o2 = new e({ objectMode: true, highWaterMark: 1, ...r }), l3 = false;
      o2._read = function() {
        l3 || (l3 = true, f3());
      }, o2._destroy = function(s2, d4) {
        Ms(u3(s2), () => Hi2.nextTick(d4, s2), (c2) => Hi2.nextTick(d4, c2 || s2));
      };
      async function u3(s2) {
        let d4 = s2 != null, c2 = typeof n.throw == "function";
        if (d4 && c2) {
          let { value: y5, done: h5 } = await n.throw(s2);
          if (await y5, h5)
            return;
        }
        if (typeof n.return == "function") {
          let { value: y5 } = await n.return();
          await y5;
        }
      }
      async function f3() {
        for (;; ) {
          try {
            let { value: s2, done: d4 } = i ? await n.next() : n.next();
            if (d4)
              o2.push(null);
            else {
              let c2 = s2 && typeof s2.then == "function" ? await s2 : s2;
              if (c2 === null)
                throw l3 = false, new Ds;
              if (o2.push(c2))
                continue;
              l3 = false;
            }
          } catch (s2) {
            o2.destroy(s2);
          }
          break;
        }
      }
      return o2;
    }
    Ki2.exports = Ps;
  });
  Ke = E5((sd, uo) => {
    var $3 = (se2(), pe(k3)), { ArrayPrototypeIndexOf: ks, NumberIsInteger: Us2, NumberIsNaN: vs, NumberParseInt: qs, ObjectDefineProperties: Ji2, ObjectKeys: Ws2, ObjectSetPrototypeOf: Qi2, Promise: $s2, SafeSet: js2, SymbolAsyncIterator: Gs2, Symbol: Hs2 } = I4();
    uo.exports = g5;
    g5.ReadableState = Ir4;
    var { EventEmitter: Vs2 } = Et(), { Stream: he, prependListener: Ys3 } = xt2(), { Buffer: Sr } = te(), { addAbortSignal: Ks2 } = At4(), zs2 = ce2(), _4 = V5().debuglog("stream", (e) => {
      _4 = e;
    }), Xs2 = Pi(), Ue = Se2(), { getHighWaterMark: Js2, getDefaultHighWaterMark: Qs2 } = Tt4(), { aggregateTwoErrors: zi, codes: { ERR_INVALID_ARG_TYPE: Zs2, ERR_METHOD_NOT_IMPLEMENTED: ea, ERR_OUT_OF_RANGE: ta, ERR_STREAM_PUSH_AFTER_EOF: ra, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: na } } = C3(), { validateObject: ia } = He2(), xe2 = Hs2("kPaused"), { StringDecoder: Zi } = Gi2(), oa = Er4();
    Qi2(g5.prototype, he.prototype);
    Qi2(g5, he);
    var mr3 = () => {
    }, { errorOrDestroy: ke3 } = Ue;
    function Ir4(e, t, r) {
      typeof r != "boolean" && (r = t instanceof J2()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? Js2(this, e, "readableHighWaterMark", r) : Qs2(false), this.buffer = new Xs2, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[xe2] = null, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new Zi(e.encoding), this.encoding = e.encoding);
    }
    function g5(e) {
      if (!(this instanceof g5))
        return new g5(e);
      let t = this instanceof J2();
      this._readableState = new Ir4(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && Ks2(e.signal, this)), he.call(this, e), Ue.construct(this, () => {
        this._readableState.needReadable && Lt3(this, this._readableState);
      });
    }
    g5.prototype.destroy = Ue.destroy;
    g5.prototype._undestroy = Ue.undestroy;
    g5.prototype._destroy = function(e, t) {
      t(e);
    };
    g5.prototype[Vs2.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    g5.prototype.push = function(e, t) {
      return eo2(this, e, t, false);
    };
    g5.prototype.unshift = function(e, t) {
      return eo2(this, e, t, true);
    };
    function eo2(e, t, r, n) {
      _4("readableAddChunk", t);
      let i = e._readableState, o2;
      if (i.objectMode || (typeof t == "string" ? (r = r || i.defaultEncoding, i.encoding !== r && (n && i.encoding ? t = Sr.from(t, r).toString(i.encoding) : (t = Sr.from(t, r), r = ""))) : t instanceof Sr ? r = "" : he._isUint8Array(t) ? (t = he._uint8ArrayToBuffer(t), r = "") : t != null && (o2 = new Zs2("chunk", ["string", "Buffer", "Uint8Array"], t))), o2)
        ke3(e, o2);
      else if (t === null)
        i.reading = false, fa(e, i);
      else if (i.objectMode || t && t.length > 0)
        if (n)
          if (i.endEmitted)
            ke3(e, new na);
          else {
            if (i.destroyed || i.errored)
              return false;
            xr2(e, i, t, true);
          }
        else if (i.ended)
          ke3(e, new ra);
        else {
          if (i.destroyed || i.errored)
            return false;
          i.reading = false, i.decoder && !r ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? xr2(e, i, t, false) : Lt3(e, i)) : xr2(e, i, t, false);
        }
      else
        n || (i.reading = false, Lt3(e, i));
      return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function xr2(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = true, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && Nt3(e)), Lt3(e, t);
    }
    g5.prototype.isPaused = function() {
      let e = this._readableState;
      return e[xe2] === true || e.flowing === false;
    };
    g5.prototype.setEncoding = function(e) {
      let t = new Zi(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, n = "";
      for (let i of r)
        n += t.write(i);
      return r.clear(), n !== "" && r.push(n), this._readableState.length = n.length, this;
    };
    var la = 1073741824;
    function ua(e) {
      if (e > la)
        throw new ta("size", "<= 1GiB", e);
      return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function Xi2(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : vs(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    g5.prototype.read = function(e) {
      _4("read", e), e === undefined ? e = NaN : Us2(e) || (e = qs(e, 10));
      let t = this._readableState, r = e;
      if (e > t.highWaterMark && (t.highWaterMark = ua(e)), e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return _4("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Rr3(this) : Nt3(this), null;
      if (e = Xi2(e, t), e === 0 && t.ended)
        return t.length === 0 && Rr3(this), null;
      let n = t.needReadable;
      if (_4("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, _4("length less than watermark", n)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
        n = false, _4("reading, ended or constructing", n);
      else if (n) {
        _4("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true);
        try {
          this._read(t.highWaterMark);
        } catch (o2) {
          ke3(this, o2);
        }
        t.sync = false, t.reading || (e = Xi2(r, t));
      }
      let i;
      return e > 0 ? i = oo(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && Rr3(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = true, this.emit("data", i)), i;
    };
    function fa(e, t) {
      if (_4("onEofChunk"), !t.ended) {
        if (t.decoder) {
          let r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? Nt3(e) : (t.needReadable = false, t.emittedReadable = true, to2(e));
      }
    }
    function Nt3(e) {
      let t = e._readableState;
      _4("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (_4("emitReadable", t.flowing), t.emittedReadable = true, $3.nextTick(to2, e));
    }
    function to2(e) {
      let t = e._readableState;
      _4("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, no(e);
    }
    function Lt3(e, t) {
      !t.readingMore && t.constructed && (t.readingMore = true, $3.nextTick(sa, e, t));
    }
    function sa(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        let r = t.length;
        if (_4("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    g5.prototype._read = function(e) {
      throw new ea("_read()");
    };
    g5.prototype.pipe = function(e, t) {
      let r = this, n = this._readableState;
      n.pipes.length === 1 && (n.multiAwaitDrain || (n.multiAwaitDrain = true, n.awaitDrainWriters = new js2(n.awaitDrainWriters ? [n.awaitDrainWriters] : []))), n.pipes.push(e), _4("pipe count=%d opts=%j", n.pipes.length, t);
      let o2 = (!t || t.end !== false) && e !== $3.stdout && e !== $3.stderr ? u3 : v4;
      n.endEmitted ? $3.nextTick(o2) : r.once("end", o2), e.on("unpipe", l3);
      function l3(w3, b6) {
        _4("onunpipe"), w3 === r && b6 && b6.hasUnpiped === false && (b6.hasUnpiped = true, d4());
      }
      function u3() {
        _4("onend"), e.end();
      }
      let f3, s2 = false;
      function d4() {
        _4("cleanup"), e.removeListener("close", p3), e.removeListener("finish", B3), f3 && e.removeListener("drain", f3), e.removeListener("error", h5), e.removeListener("unpipe", l3), r.removeListener("end", u3), r.removeListener("end", v4), r.removeListener("data", y5), s2 = true, f3 && n.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f3();
      }
      function c2() {
        s2 || (n.pipes.length === 1 && n.pipes[0] === e ? (_4("false write response, pause", 0), n.awaitDrainWriters = e, n.multiAwaitDrain = false) : n.pipes.length > 1 && n.pipes.includes(e) && (_4("false write response, pause", n.awaitDrainWriters.size), n.awaitDrainWriters.add(e)), r.pause()), f3 || (f3 = aa(r, e), e.on("drain", f3));
      }
      r.on("data", y5);
      function y5(w3) {
        _4("ondata");
        let b6 = e.write(w3);
        _4("dest.write", b6), b6 === false && c2();
      }
      function h5(w3) {
        if (_4("onerror", w3), v4(), e.removeListener("error", h5), e.listenerCount("error") === 0) {
          let b6 = e._writableState || e._readableState;
          b6 && !b6.errorEmitted ? ke3(e, w3) : e.emit("error", w3);
        }
      }
      Ys3(e, "error", h5);
      function p3() {
        e.removeListener("finish", B3), v4();
      }
      e.once("close", p3);
      function B3() {
        _4("onfinish"), e.removeListener("close", p3), v4();
      }
      e.once("finish", B3);
      function v4() {
        _4("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), e.writableNeedDrain === true ? n.flowing && c2() : n.flowing || (_4("pipe resume"), r.resume()), e;
    };
    function aa(e, t) {
      return function() {
        let n = e._readableState;
        n.awaitDrainWriters === t ? (_4("pipeOnDrain", 1), n.awaitDrainWriters = null) : n.multiAwaitDrain && (_4("pipeOnDrain", n.awaitDrainWriters.size), n.awaitDrainWriters.delete(t)), (!n.awaitDrainWriters || n.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
      };
    }
    g5.prototype.unpipe = function(e) {
      let t = this._readableState, r = { hasUnpiped: false };
      if (t.pipes.length === 0)
        return this;
      if (!e) {
        let i = t.pipes;
        t.pipes = [], this.pause();
        for (let o2 = 0;o2 < i.length; o2++)
          i[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let n = ks(t.pipes, e);
      return n === -1 ? this : (t.pipes.splice(n, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, r), this);
    };
    g5.prototype.on = function(e, t) {
      let r = he.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, _4("on readable", n.length, n.reading), n.length ? Nt3(this) : n.reading || $3.nextTick(ca, this)), r;
    };
    g5.prototype.addListener = g5.prototype.on;
    g5.prototype.removeListener = function(e, t) {
      let r = he.prototype.removeListener.call(this, e, t);
      return e === "readable" && $3.nextTick(ro2, this), r;
    };
    g5.prototype.off = g5.prototype.removeListener;
    g5.prototype.removeAllListeners = function(e) {
      let t = he.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && $3.nextTick(ro2, this), t;
    };
    function ro2(e) {
      let t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[xe2] === false ? t.flowing = true : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function ca(e) {
      _4("readable nexttick read 0"), e.read(0);
    }
    g5.prototype.resume = function() {
      let e = this._readableState;
      return e.flowing || (_4("resume"), e.flowing = !e.readableListening, da2(this, e)), e[xe2] = false, this;
    };
    function da2(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, $3.nextTick(ha, e, t));
    }
    function ha(e, t) {
      _4("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), no(e), t.flowing && !t.reading && e.read(0);
    }
    g5.prototype.pause = function() {
      return _4("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (_4("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[xe2] = true, this;
    };
    function no(e) {
      let t = e._readableState;
      for (_4("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    g5.prototype.wrap = function(e) {
      let t = false;
      e.on("data", (n) => {
        !this.push(n) && e.pause && (t = true, e.pause());
      }), e.on("end", () => {
        this.push(null);
      }), e.on("error", (n) => {
        ke3(this, n);
      }), e.on("close", () => {
        this.destroy();
      }), e.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        t && e.resume && (t = false, e.resume());
      };
      let r = Ws2(e);
      for (let n = 1;n < r.length; n++) {
        let i = r[n];
        this[i] === undefined && typeof e[i] == "function" && (this[i] = e[i].bind(e));
      }
      return this;
    };
    g5.prototype[Gs2] = function() {
      return io(this);
    };
    g5.prototype.iterator = function(e) {
      return e !== undefined && ia(e, "options"), io(this, e);
    };
    function io(e, t) {
      typeof e.read != "function" && (e = g5.wrap(e, { objectMode: true }));
      let r = pa(e, t);
      return r.stream = e, r;
    }
    async function* pa(e, t) {
      let r = mr3;
      function n(l3) {
        this === e ? (r(), r = mr3) : r = l3;
      }
      e.on("readable", n);
      let i, o2 = zs2(e, { writable: false }, (l3) => {
        i = l3 ? zi(i, l3) : null, r(), r = mr3;
      });
      try {
        for (;; ) {
          let l3 = e.destroyed ? null : e.read();
          if (l3 !== null)
            yield l3;
          else {
            if (i)
              throw i;
            if (i === null)
              return;
            await new $s2(n);
          }
        }
      } catch (l3) {
        throw i = zi(i, l3), i;
      } finally {
        (i || t?.destroyOnReturn !== false) && (i === undefined || e._readableState.autoDestroy) ? Ue.destroyer(e, null) : (e.off("readable", n), o2());
      }
    }
    Ji2(g5.prototype, { readable: { __proto__: null, get() {
      let e = this._readableState;
      return !!e && e.readable !== false && !e.destroyed && !e.errorEmitted && !e.endEmitted;
    }, set(e) {
      this._readableState && (this._readableState.readable = !!e);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    Ji2(Ir4.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[xe2] !== false;
    }, set(e) {
      this[xe2] = !!e;
    } } });
    g5._fromList = oo;
    function oo(e, t) {
      if (t.length === 0)
        return null;
      let r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function Rr3(e) {
      let t = e._readableState;
      _4("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, $3.nextTick(ya, t, e));
    }
    function ya(e, t) {
      if (_4("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
        if (e.endEmitted = true, t.emit("end"), t.writable && t.allowHalfOpen === false)
          $3.nextTick(wa2, t);
        else if (e.autoDestroy) {
          let r = t._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && t.destroy();
        }
      }
    }
    function wa2(e) {
      e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    g5.from = function(e, t) {
      return oa(g5, e, t);
    };
    var Ar3;
    function lo() {
      return Ar3 === undefined && (Ar3 = {}), Ar3;
    }
    g5.fromWeb = function(e, t) {
      return lo().newStreamReadableFromReadableStream(e, t);
    };
    g5.toWeb = function(e, t) {
      return lo().newReadableStreamFromStreamReadable(e, t);
    };
    g5.wrap = function(e, t) {
      var r, n;
      return new g5({ objectMode: (r = (n = e.readableObjectMode) !== null && n !== undefined ? n : e.objectMode) !== null && r !== undefined ? r : true, ...t, destroy(i, o2) {
        Ue.destroyer(e, i), o2(i);
      } }).wrap(e);
    };
  });
  Cr2 = E5((ad, Eo) => {
    var Re = (se2(), pe(k3)), { ArrayPrototypeSlice: ao, Error: ba, FunctionPrototypeSymbolHasInstance: co, ObjectDefineProperty: ho, ObjectDefineProperties: ga, ObjectSetPrototypeOf: po, StringPrototypeToLowerCase: _a, Symbol: Ea, SymbolHasInstance: Sa } = I4();
    Eo.exports = m3;
    m3.WritableState = Je;
    var { EventEmitter: ma } = Et(), ze = xt2().Stream, { Buffer: Ft2 } = te(), Ot = Se2(), { addAbortSignal: xa } = At4(), { getHighWaterMark: Ra, getDefaultHighWaterMark: Aa } = Tt4(), { ERR_INVALID_ARG_TYPE: Ia2, ERR_METHOD_NOT_IMPLEMENTED: Ta, ERR_MULTIPLE_CALLBACK: yo, ERR_STREAM_CANNOT_PIPE: Ba, ERR_STREAM_DESTROYED: Xe, ERR_STREAM_ALREADY_FINISHED: La, ERR_STREAM_NULL_VALUES: Na2, ERR_STREAM_WRITE_AFTER_END: Fa, ERR_UNKNOWN_ENCODING: wo2 } = C3().codes, { errorOrDestroy: ve } = Ot;
    po(m3.prototype, ze.prototype);
    po(m3, ze);
    function Lr() {
    }
    var qe2 = Ea("kOnFinished");
    function Je(e, t, r) {
      typeof r != "boolean" && (r = t instanceof J2()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Ra(this, e, "writableHighWaterMark", r) : Aa(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let n = !!(e && e.decodeStrings === false);
      this.decodeStrings = !n, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = Ca.bind(undefined, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ct(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[qe2] = [];
    }
    function Ct(e) {
      e.buffered = [], e.bufferedIndex = 0, e.allBuffers = true, e.allNoop = true;
    }
    Je.prototype.getBuffer = function() {
      return ao(this.buffered, this.bufferedIndex);
    };
    ho(Je.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function m3(e) {
      let t = this instanceof J2();
      if (!t && !co(m3, this))
        return new m3(e);
      this._writableState = new Je(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && xa(e.signal, this)), ze.call(this, e), Ot.construct(this, () => {
        let r = this._writableState;
        r.writing || Fr3(this, r), Mr(this, r);
      });
    }
    ho(m3, Sa, { __proto__: null, value: function(e) {
      return co(this, e) ? true : this !== m3 ? false : e && e._writableState instanceof Je;
    } });
    m3.prototype.pipe = function() {
      ve(this, new Ba);
    };
    function bo(e, t, r, n) {
      let i = e._writableState;
      if (typeof r == "function")
        n = r, r = i.defaultEncoding;
      else {
        if (!r)
          r = i.defaultEncoding;
        else if (r !== "buffer" && !Ft2.isEncoding(r))
          throw new wo2(r);
        typeof n != "function" && (n = Lr);
      }
      if (t === null)
        throw new Na2;
      if (!i.objectMode)
        if (typeof t == "string")
          i.decodeStrings !== false && (t = Ft2.from(t, r), r = "buffer");
        else if (t instanceof Ft2)
          r = "buffer";
        else if (ze._isUint8Array(t))
          t = ze._uint8ArrayToBuffer(t), r = "buffer";
        else
          throw new Ia2("chunk", ["string", "Buffer", "Uint8Array"], t);
      let o2;
      return i.ending ? o2 = new Fa : i.destroyed && (o2 = new Xe("write")), o2 ? (Re.nextTick(n, o2), ve(e, o2, true), o2) : (i.pendingcb++, Ma(e, i, t, r, n));
    }
    m3.prototype.write = function(e, t, r) {
      return bo(this, e, t, r) === true;
    };
    m3.prototype.cork = function() {
      this._writableState.corked++;
    };
    m3.prototype.uncork = function() {
      let e = this._writableState;
      e.corked && (e.corked--, e.writing || Fr3(this, e));
    };
    m3.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = _a(t)), !Ft2.isEncoding(t))
        throw new wo2(t);
      return this._writableState.defaultEncoding = t, this;
    };
    function Ma(e, t, r, n, i) {
      let o2 = t.objectMode ? 1 : r.length;
      t.length += o2;
      let l3 = t.length < t.highWaterMark;
      return l3 || (t.needDrain = true), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({ chunk: r, encoding: n, callback: i }), t.allBuffers && n !== "buffer" && (t.allBuffers = false), t.allNoop && i !== Lr && (t.allNoop = false)) : (t.writelen = o2, t.writecb = i, t.writing = true, t.sync = true, e._write(r, n, t.onwrite), t.sync = false), l3 && !t.errored && !t.destroyed;
    }
    function fo(e, t, r, n, i, o2, l3) {
      t.writelen = n, t.writecb = l3, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new Xe("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function so2(e, t, r, n) {
      --t.pendingcb, n(r), Nr(t), ve(e, r);
    }
    function Ca(e, t) {
      let r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function") {
        ve(e, new yo);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, t ? (t.stack, r.errored || (r.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), n ? Re.nextTick(so2, e, r, t, i) : so2(e, r, t, i)) : (r.buffered.length > r.bufferedIndex && Fr3(e, r), n ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === i ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: i, stream: e, state: r }, Re.nextTick(Oa, r.afterWriteTickInfo)) : go(e, r, 1, i));
    }
    function Oa({ stream: e, state: t, count: r, cb: n }) {
      return t.afterWriteTickInfo = null, go(e, t, r, n);
    }
    function go(e, t, r, n) {
      for (!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));r-- > 0; )
        t.pendingcb--, n();
      t.destroyed && Nr(t), Mr(e, t);
    }
    function Nr(e) {
      if (e.writing)
        return;
      for (let i = e.bufferedIndex;i < e.buffered.length; ++i) {
        var t;
        let { chunk: o2, callback: l3 } = e.buffered[i], u3 = e.objectMode ? 1 : o2.length;
        e.length -= u3, l3((t = e.errored) !== null && t !== undefined ? t : new Xe("write"));
      }
      let r = e[qe2].splice(0);
      for (let i = 0;i < r.length; i++) {
        var n;
        r[i]((n = e.errored) !== null && n !== undefined ? n : new Xe("end"));
      }
      Ct(e);
    }
    function Fr3(e, t) {
      if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
        return;
      let { buffered: r, bufferedIndex: n, objectMode: i } = t, o2 = r.length - n;
      if (!o2)
        return;
      let l3 = n;
      if (t.bufferProcessing = true, o2 > 1 && e._writev) {
        t.pendingcb -= o2 - 1;
        let u3 = t.allNoop ? Lr : (s2) => {
          for (let d4 = l3;d4 < r.length; ++d4)
            r[d4].callback(s2);
        }, f3 = t.allNoop && l3 === 0 ? r : ao(r, l3);
        f3.allBuffers = t.allBuffers, fo(e, t, true, t.length, f3, "", u3), Ct(t);
      } else {
        do {
          let { chunk: u3, encoding: f3, callback: s2 } = r[l3];
          r[l3++] = null;
          let d4 = i ? 1 : u3.length;
          fo(e, t, false, d4, u3, f3, s2);
        } while (l3 < r.length && !t.writing);
        l3 === r.length ? Ct(t) : l3 > 256 ? (r.splice(0, l3), t.bufferedIndex = 0) : t.bufferedIndex = l3;
      }
      t.bufferProcessing = false;
    }
    m3.prototype._write = function(e, t, r) {
      if (this._writev)
        this._writev([{ chunk: e, encoding: t }], r);
      else
        throw new Ta("_write()");
    };
    m3.prototype._writev = null;
    m3.prototype.end = function(e, t, r) {
      let n = this._writableState;
      typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null);
      let i;
      if (e != null) {
        let o2 = bo(this, e, t);
        o2 instanceof ba && (i = o2);
      }
      return n.corked && (n.corked = 1, this.uncork()), i || (!n.errored && !n.ending ? (n.ending = true, Mr(this, n, true), n.ended = true) : n.finished ? i = new La("end") : n.destroyed && (i = new Xe("end"))), typeof r == "function" && (i || n.finished ? Re.nextTick(r, i) : n[qe2].push(r)), this;
    };
    function Mt(e) {
      return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Da(e, t) {
      let r = false;
      function n(i) {
        if (r) {
          ve(e, i ?? yo());
          return;
        }
        if (r = true, t.pendingcb--, i) {
          let o2 = t[qe2].splice(0);
          for (let l3 = 0;l3 < o2.length; l3++)
            o2[l3](i);
          ve(e, i, t.sync);
        } else
          Mt(t) && (t.prefinished = true, e.emit("prefinish"), t.pendingcb++, Re.nextTick(Br3, e, t));
      }
      t.sync = true, t.pendingcb++;
      try {
        e._final(n);
      } catch (i) {
        n(i);
      }
      t.sync = false;
    }
    function Pa(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = true, Da(e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Mr(e, t, r) {
      Mt(t) && (Pa(e, t), t.pendingcb === 0 && (r ? (t.pendingcb++, Re.nextTick((n, i) => {
        Mt(i) ? Br3(n, i) : i.pendingcb--;
      }, e, t)) : Mt(t) && (t.pendingcb++, Br3(e, t))));
    }
    function Br3(e, t) {
      t.pendingcb--, t.finished = true;
      let r = t[qe2].splice(0);
      for (let n = 0;n < r.length; n++)
        r[n]();
      if (e.emit("finish"), t.autoDestroy) {
        let n = e._readableState;
        (!n || n.autoDestroy && (n.endEmitted || n.readable === false)) && e.destroy();
      }
    }
    ga(m3.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(e) {
      this._writableState && (this._writableState.destroyed = e);
    } }, writable: { __proto__: null, get() {
      let e = this._writableState;
      return !!e && e.writable !== false && !e.destroyed && !e.errored && !e.ending && !e.ended;
    }, set(e) {
      this._writableState && (this._writableState.writable = !!e);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let e = this._writableState;
      return e ? !e.destroyed && !e.ending && e.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var ka2 = Ot.destroy;
    m3.prototype.destroy = function(e, t) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[qe2].length) && Re.nextTick(Nr, r), ka2.call(this, e, t), this;
    };
    m3.prototype._undestroy = Ot.undestroy;
    m3.prototype._destroy = function(e, t) {
      t(e);
    };
    m3.prototype[ma.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    var Tr;
    function _o() {
      return Tr === undefined && (Tr = {}), Tr;
    }
    m3.fromWeb = function(e, t) {
      return _o().newStreamWritableFromWritableStream(e, t);
    };
    m3.toWeb = function(e) {
      return _o().newWritableStreamFromStreamWritable(e);
    };
  });
  Mo2 = E5((cd2, Fo) => {
    var Or = (se2(), pe(k3)), Ua = te(), { isReadable: va2, isWritable: qa, isIterable: So, isNodeStream: Wa2, isReadableNodeStream: mo, isWritableNodeStream: xo, isDuplexNodeStream: $a2 } = ae(), Ro = ce2(), { AbortError: No, codes: { ERR_INVALID_ARG_TYPE: ja, ERR_INVALID_RETURN_VALUE: Ao } } = C3(), { destroyer: We2 } = Se2(), Ga2 = J2(), Ha = Ke(), { createDeferredPromise: Io } = V5(), To = Er4(), Bo = globalThis.Blob || Ua.Blob, Va = typeof Bo < "u" ? function(t) {
      return t instanceof Bo;
    } : function(t) {
      return false;
    }, Ya2 = globalThis.AbortController || ut2().AbortController, { FunctionPrototypeCall: Lo } = I4(), Ae2 = class extends Ga2 {
      constructor(t) {
        super(t), t?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Fo.exports = function e(t, r) {
      if ($a2(t))
        return t;
      if (mo(t))
        return Dt2({ readable: t });
      if (xo(t))
        return Dt2({ writable: t });
      if (Wa2(t))
        return Dt2({ writable: false, readable: false });
      if (typeof t == "function") {
        let { value: i, write: o2, final: l3, destroy: u3 } = Ka(t);
        if (So(i))
          return To(Ae2, i, { objectMode: true, write: o2, final: l3, destroy: u3 });
        let f3 = i?.then;
        if (typeof f3 == "function") {
          let s2, d4 = Lo(f3, i, (c2) => {
            if (c2 != null)
              throw new Ao("nully", "body", c2);
          }, (c2) => {
            We2(s2, c2);
          });
          return s2 = new Ae2({ objectMode: true, readable: false, write: o2, final(c2) {
            l3(async () => {
              try {
                await d4, Or.nextTick(c2, null);
              } catch (y5) {
                Or.nextTick(c2, y5);
              }
            });
          }, destroy: u3 });
        }
        throw new Ao("Iterable, AsyncIterable or AsyncFunction", r, i);
      }
      if (Va(t))
        return e(t.arrayBuffer());
      if (So(t))
        return To(Ae2, t, { objectMode: true, writable: false });
      if (typeof t?.writable == "object" || typeof t?.readable == "object") {
        let i = t != null && t.readable ? mo(t?.readable) ? t?.readable : e(t.readable) : undefined, o2 = t != null && t.writable ? xo(t?.writable) ? t?.writable : e(t.writable) : undefined;
        return Dt2({ readable: i, writable: o2 });
      }
      let n = t?.then;
      if (typeof n == "function") {
        let i;
        return Lo(n, t, (o2) => {
          o2 != null && i.push(o2), i.push(null);
        }, (o2) => {
          We2(i, o2);
        }), i = new Ae2({ objectMode: true, writable: false, read() {
        } });
      }
      throw new ja(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t);
    };
    function Ka(e) {
      let { promise: t, resolve: r } = Io(), n = new Ya2, i = n.signal;
      return { value: e(async function* () {
        for (;; ) {
          let l3 = t;
          t = null;
          let { chunk: u3, done: f3, cb: s2 } = await l3;
          if (Or.nextTick(s2), f3)
            return;
          if (i.aborted)
            throw new No(undefined, { cause: i.reason });
          ({ promise: t, resolve: r } = Io()), yield u3;
        }
      }(), { signal: i }), write(l3, u3, f3) {
        let s2 = r;
        r = null, s2({ chunk: l3, done: false, cb: f3 });
      }, final(l3) {
        let u3 = r;
        r = null, u3({ done: true, cb: l3 });
      }, destroy(l3, u3) {
        n.abort(), u3(l3);
      } };
    }
    function Dt2(e) {
      let t = e.readable && typeof e.readable.read != "function" ? Ha.wrap(e.readable) : e.readable, r = e.writable, n = !!va2(t), i = !!qa(r), o2, l3, u3, f3, s2;
      function d4(c2) {
        let y5 = f3;
        f3 = null, y5 ? y5(c2) : c2 ? s2.destroy(c2) : !n && !i && s2.destroy();
      }
      return s2 = new Ae2({ readableObjectMode: !!(t != null && t.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: n, writable: i }), i && (Ro(r, (c2) => {
        i = false, c2 && We2(t, c2), d4(c2);
      }), s2._write = function(c2, y5, h5) {
        r.write(c2, y5) ? h5() : o2 = h5;
      }, s2._final = function(c2) {
        r.end(), l3 = c2;
      }, r.on("drain", function() {
        if (o2) {
          let c2 = o2;
          o2 = null, c2();
        }
      }), r.on("finish", function() {
        if (l3) {
          let c2 = l3;
          l3 = null, c2();
        }
      })), n && (Ro(t, (c2) => {
        n = false, c2 && We2(t, c2), d4(c2);
      }), t.on("readable", function() {
        if (u3) {
          let c2 = u3;
          u3 = null, c2();
        }
      }), t.on("end", function() {
        s2.push(null);
      }), s2._read = function() {
        for (;; ) {
          let c2 = t.read();
          if (c2 === null) {
            u3 = s2._read;
            return;
          }
          if (!s2.push(c2))
            return;
        }
      }), s2._destroy = function(c2, y5) {
        !c2 && f3 !== null && (c2 = new No), u3 = null, o2 = null, l3 = null, f3 === null ? y5(c2) : (f3 = y5, We2(r, c2), We2(t, c2));
      }, s2;
    }
  });
  J2 = E5((dd, Do) => {
    var { ObjectDefineProperties: za, ObjectGetOwnPropertyDescriptor: ie, ObjectKeys: Xa, ObjectSetPrototypeOf: Co } = I4();
    Do.exports = j5;
    var kr = Ke(), U3 = Cr2();
    Co(j5.prototype, kr.prototype);
    Co(j5, kr);
    {
      let e = Xa(U3.prototype);
      for (let t = 0;t < e.length; t++) {
        let r = e[t];
        j5.prototype[r] || (j5.prototype[r] = U3.prototype[r]);
      }
    }
    function j5(e) {
      if (!(this instanceof j5))
        return new j5(e);
      kr.call(this, e), U3.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== false, e.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    za(j5.prototype, { writable: { __proto__: null, ...ie(U3.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ie(U3.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ie(U3.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ie(U3.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ie(U3.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ie(U3.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ie(U3.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ie(U3.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ie(U3.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(e) {
      this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } } });
    var Dr2;
    function Oo() {
      return Dr2 === undefined && (Dr2 = {}), Dr2;
    }
    j5.fromWeb = function(e, t) {
      return Oo().newStreamDuplexFromReadableWritablePair(e, t);
    };
    j5.toWeb = function(e) {
      return Oo().newReadableWritablePairFromDuplex(e);
    };
    var Pr;
    j5.from = function(e) {
      return Pr || (Pr = Mo2()), Pr(e, "body");
    };
  });
  qr2 = E5((hd, ko) => {
    var { ObjectSetPrototypeOf: Po, Symbol: Ja } = I4();
    ko.exports = oe3;
    var { ERR_METHOD_NOT_IMPLEMENTED: Qa } = C3().codes, vr3 = J2(), { getHighWaterMark: Za } = Tt4();
    Po(oe3.prototype, vr3.prototype);
    Po(oe3, vr3);
    var Qe2 = Ja("kCallback");
    function oe3(e) {
      if (!(this instanceof oe3))
        return new oe3(e);
      let t = e ? Za(this, e, "readableHighWaterMark", true) : null;
      t === 0 && (e = { ...e, highWaterMark: null, readableHighWaterMark: t, writableHighWaterMark: e.writableHighWaterMark || 0 }), vr3.call(this, e), this._readableState.sync = false, this[Qe2] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ec);
    }
    function Ur4(e) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
        if (t) {
          e ? e(t) : this.destroy(t);
          return;
        }
        r != null && this.push(r), this.push(null), e && e();
      }) : (this.push(null), e && e());
    }
    function ec() {
      this._final !== Ur4 && Ur4.call(this);
    }
    oe3.prototype._final = Ur4;
    oe3.prototype._transform = function(e, t, r) {
      throw new Qa("_transform()");
    };
    oe3.prototype._write = function(e, t, r) {
      let n = this._readableState, i = this._writableState, o2 = n.length;
      this._transform(e, t, (l3, u3) => {
        if (l3) {
          r(l3);
          return;
        }
        u3 != null && this.push(u3), i.ended || o2 === n.length || n.length < n.highWaterMark ? r() : this[Qe2] = r;
      });
    };
    oe3.prototype._read = function() {
      if (this[Qe2]) {
        let e = this[Qe2];
        this[Qe2] = null, e();
      }
    };
  });
  $r2 = E5((pd, vo) => {
    var { ObjectSetPrototypeOf: Uo } = I4();
    vo.exports = $e2;
    var Wr = qr2();
    Uo($e2.prototype, Wr.prototype);
    Uo($e2, Wr);
    function $e2(e) {
      if (!(this instanceof $e2))
        return new $e2(e);
      Wr.call(this, e);
    }
    $e2.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  Ut2 = E5((yd, Vo) => {
    var Pt = (se2(), pe(k3)), { ArrayIsArray: tc, Promise: rc, SymbolAsyncIterator: nc } = I4(), kt2 = ce2(), { once: ic2 } = V5(), oc = Se2(), qo = J2(), { aggregateTwoErrors: lc, codes: { ERR_INVALID_ARG_TYPE: Go, ERR_INVALID_RETURN_VALUE: jr, ERR_MISSING_ARGS: uc, ERR_STREAM_DESTROYED: fc, ERR_STREAM_PREMATURE_CLOSE: sc }, AbortError: ac } = C3(), { validateFunction: cc, validateAbortSignal: dc } = He2(), { isIterable: je, isReadable: Gr2, isReadableNodeStream: Yr2, isNodeStream: Wo } = ae(), hc = globalThis.AbortController || ut2().AbortController, Hr2, Vr;
    function $o(e, t, r) {
      let n = false;
      e.on("close", () => {
        n = true;
      });
      let i = kt2(e, { readable: t, writable: r }, (o2) => {
        n = !o2;
      });
      return { destroy: (o2) => {
        n || (n = true, oc.destroyer(e, o2 || new fc("pipe")));
      }, cleanup: i };
    }
    function pc(e) {
      return cc(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function yc2(e) {
      if (je(e))
        return e;
      if (Yr2(e))
        return wc(e);
      throw new Go("val", ["Readable", "Iterable", "AsyncIterable"], e);
    }
    async function* wc(e) {
      Vr || (Vr = Ke()), yield* Vr.prototype[nc].call(e);
    }
    async function jo(e, t, r, { end: n }) {
      let i, o2 = null, l3 = (s2) => {
        if (s2 && (i = s2), o2) {
          let d4 = o2;
          o2 = null, d4();
        }
      }, u3 = () => new rc((s2, d4) => {
        i ? d4(i) : o2 = () => {
          i ? d4(i) : s2();
        };
      });
      t.on("drain", l3);
      let f3 = kt2(t, { readable: false }, l3);
      try {
        t.writableNeedDrain && await u3();
        for await (let s2 of e)
          t.write(s2) || await u3();
        n && t.end(), await u3(), r();
      } catch (s2) {
        r(i !== s2 ? lc(i, s2) : s2);
      } finally {
        f3(), t.off("drain", l3);
      }
    }
    function bc(...e) {
      return Ho(e, ic2(pc(e)));
    }
    function Ho(e, t, r) {
      if (e.length === 1 && tc(e[0]) && (e = e[0]), e.length < 2)
        throw new uc("streams");
      let n = new hc, i = n.signal, o2 = r?.signal, l3 = [];
      dc(o2, "options.signal");
      function u3() {
        h5(new ac);
      }
      o2?.addEventListener("abort", u3);
      let f3, s2, d4 = [], c2 = 0;
      function y5(w3) {
        h5(w3, --c2 === 0);
      }
      function h5(w3, b6) {
        if (w3 && (!f3 || f3.code === "ERR_STREAM_PREMATURE_CLOSE") && (f3 = w3), !(!f3 && !b6)) {
          for (;d4.length; )
            d4.shift()(f3);
          o2?.removeEventListener("abort", u3), n.abort(), b6 && (f3 || l3.forEach((L4) => L4()), Pt.nextTick(t, f3, s2));
        }
      }
      let p3;
      for (let w3 = 0;w3 < e.length; w3++) {
        let b6 = e[w3], L4 = w3 < e.length - 1, N6 = w3 > 0, Q5 = L4 || r?.end !== false, Ie = w3 === e.length - 1;
        if (Wo(b6)) {
          let q3 = function(Z3) {
            Z3 && Z3.name !== "AbortError" && Z3.code !== "ERR_STREAM_PREMATURE_CLOSE" && y5(Z3);
          };
          var v4 = q3;
          if (Q5) {
            let { destroy: Z3, cleanup: qt2 } = $o(b6, L4, N6);
            d4.push(Z3), Gr2(b6) && Ie && l3.push(qt2);
          }
          b6.on("error", q3), Gr2(b6) && Ie && l3.push(() => {
            b6.removeListener("error", q3);
          });
        }
        if (w3 === 0)
          if (typeof b6 == "function") {
            if (p3 = b6({ signal: i }), !je(p3))
              throw new jr("Iterable, AsyncIterable or Stream", "source", p3);
          } else
            je(b6) || Yr2(b6) ? p3 = b6 : p3 = qo.from(b6);
        else if (typeof b6 == "function")
          if (p3 = yc2(p3), p3 = b6(p3, { signal: i }), L4) {
            if (!je(p3, true))
              throw new jr("AsyncIterable", `transform[${w3 - 1}]`, p3);
          } else {
            var B3;
            Hr2 || (Hr2 = $r2());
            let q3 = new Hr2({ objectMode: true }), Z3 = (B3 = p3) === null || B3 === undefined ? undefined : B3.then;
            if (typeof Z3 == "function")
              c2++, Z3.call(p3, (Te) => {
                s2 = Te, Te != null && q3.write(Te), Q5 && q3.end(), Pt.nextTick(y5);
              }, (Te) => {
                q3.destroy(Te), Pt.nextTick(y5, Te);
              });
            else if (je(p3, true))
              c2++, jo(p3, q3, y5, { end: Q5 });
            else
              throw new jr("AsyncIterable or Promise", "destination", p3);
            p3 = q3;
            let { destroy: qt2, cleanup: sl2 } = $o(p3, false, true);
            d4.push(qt2), Ie && l3.push(sl2);
          }
        else if (Wo(b6)) {
          if (Yr2(p3)) {
            c2 += 2;
            let q3 = gc(p3, b6, y5, { end: Q5 });
            Gr2(b6) && Ie && l3.push(q3);
          } else if (je(p3))
            c2++, jo(p3, b6, y5, { end: Q5 });
          else
            throw new Go("val", ["Readable", "Iterable", "AsyncIterable"], p3);
          p3 = b6;
        } else
          p3 = qo.from(b6);
      }
      return (i != null && i.aborted || o2 != null && o2.aborted) && Pt.nextTick(u3), p3;
    }
    function gc(e, t, r, { end: n }) {
      let i = false;
      return t.on("close", () => {
        i || r(new sc);
      }), e.pipe(t, { end: n }), n ? e.once("end", () => {
        i = true, t.end();
      }) : r(), kt2(e, { readable: true, writable: false }, (o2) => {
        let l3 = e._readableState;
        o2 && o2.code === "ERR_STREAM_PREMATURE_CLOSE" && l3 && l3.ended && !l3.errored && !l3.errorEmitted ? e.once("end", r).once("error", r) : r(o2);
      }), kt2(t, { readable: false, writable: true }, r);
    }
    Vo.exports = { pipelineImpl: Ho, pipeline: bc };
  });
  Jo = E5((wd, Xo) => {
    var { pipeline: _c2 } = Ut2(), vt2 = J2(), { destroyer: Ec } = Se2(), { isNodeStream: Sc2, isReadable: Yo, isWritable: Ko } = ae(), { AbortError: mc, codes: { ERR_INVALID_ARG_VALUE: zo, ERR_MISSING_ARGS: xc } } = C3();
    Xo.exports = function(...t) {
      if (t.length === 0)
        throw new xc("streams");
      if (t.length === 1)
        return vt2.from(t[0]);
      let r = [...t];
      if (typeof t[0] == "function" && (t[0] = vt2.from(t[0])), typeof t[t.length - 1] == "function") {
        let h5 = t.length - 1;
        t[h5] = vt2.from(t[h5]);
      }
      for (let h5 = 0;h5 < t.length; ++h5)
        if (!!Sc2(t[h5])) {
          if (h5 < t.length - 1 && !Yo(t[h5]))
            throw new zo(`streams[${h5}]`, r[h5], "must be readable");
          if (h5 > 0 && !Ko(t[h5]))
            throw new zo(`streams[${h5}]`, r[h5], "must be writable");
        }
      let n, i, o2, l3, u3;
      function f3(h5) {
        let p3 = l3;
        l3 = null, p3 ? p3(h5) : h5 ? u3.destroy(h5) : !y5 && !c2 && u3.destroy();
      }
      let s2 = t[0], d4 = _c2(t, f3), c2 = !!Ko(s2), y5 = !!Yo(d4);
      return u3 = new vt2({ writableObjectMode: !!(s2 != null && s2.writableObjectMode), readableObjectMode: !!(d4 != null && d4.writableObjectMode), writable: c2, readable: y5 }), c2 && (u3._write = function(h5, p3, B3) {
        s2.write(h5, p3) ? B3() : n = B3;
      }, u3._final = function(h5) {
        s2.end(), i = h5;
      }, s2.on("drain", function() {
        if (n) {
          let h5 = n;
          n = null, h5();
        }
      }), d4.on("finish", function() {
        if (i) {
          let h5 = i;
          i = null, h5();
        }
      })), y5 && (d4.on("readable", function() {
        if (o2) {
          let h5 = o2;
          o2 = null, h5();
        }
      }), d4.on("end", function() {
        u3.push(null);
      }), u3._read = function() {
        for (;; ) {
          let h5 = d4.read();
          if (h5 === null) {
            o2 = u3._read;
            return;
          }
          if (!u3.push(h5))
            return;
        }
      }), u3._destroy = function(h5, p3) {
        !h5 && l3 !== null && (h5 = new mc), o2 = null, n = null, i = null, l3 === null ? p3(h5) : (l3 = p3, Ec(d4, h5));
      }, u3;
    };
  });
  Kr2 = E5((bd, Qo2) => {
    var { ArrayPrototypePop: Rc2, Promise: Ac } = I4(), { isIterable: Ic, isNodeStream: Tc } = ae(), { pipelineImpl: Bc } = Ut2(), { finished: Lc } = ce2();
    function Nc(...e) {
      return new Ac((t, r) => {
        let n, i, o2 = e[e.length - 1];
        if (o2 && typeof o2 == "object" && !Tc(o2) && !Ic(o2)) {
          let l3 = Rc2(e);
          n = l3.signal, i = l3.end;
        }
        Bc(e, (l3, u3) => {
          l3 ? r(l3) : t(u3);
        }, { signal: n, end: i });
      });
    }
    Qo2.exports = { finished: Lc, pipeline: Nc };
  });
  fl = E5((gd, ul) => {
    var { Buffer: Fc } = te(), { ObjectDefineProperty: le, ObjectKeys: tl, ReflectApply: rl } = I4(), { promisify: { custom: nl } } = V5(), { streamReturningOperators: Zo, promiseReturningOperators: el } = di2(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: il } } = C3(), Mc = Jo(), { pipeline: ol2 } = Ut2(), { destroyer: Cc } = Se2(), ll = ce2(), zr2 = Kr2(), Xr = ae(), R4 = ul.exports = xt2().Stream;
    R4.isDisturbed = Xr.isDisturbed;
    R4.isErrored = Xr.isErrored;
    R4.isReadable = Xr.isReadable;
    R4.Readable = Ke();
    for (let e of tl(Zo)) {
      let r = function(...n) {
        if (new.target)
          throw il();
        return R4.Readable.from(rl(t, this, n));
      };
      Dc = r;
      let t = Zo[e];
      le(r, "name", { __proto__: null, value: t.name }), le(r, "length", { __proto__: null, value: t.length }), le(R4.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    for (let e of tl(el)) {
      let r = function(...i) {
        if (new.target)
          throw il();
        return rl(t, this, i);
      };
      Dc = r;
      let t = el[e];
      le(r, "name", { __proto__: null, value: t.name }), le(r, "length", { __proto__: null, value: t.length }), le(R4.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    R4.Writable = Cr2();
    R4.Duplex = J2();
    R4.Transform = qr2();
    R4.PassThrough = $r2();
    R4.pipeline = ol2;
    var { addAbortSignal: Oc } = At4();
    R4.addAbortSignal = Oc;
    R4.finished = ll;
    R4.destroy = Cc;
    R4.compose = Mc;
    le(R4, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return zr2;
    } });
    le(ol2, nl, { __proto__: null, enumerable: true, get() {
      return zr2.pipeline;
    } });
    le(ll, nl, { __proto__: null, enumerable: true, get() {
      return zr2.finished;
    } });
    R4.Stream = R4;
    R4._isUint8Array = function(t) {
      return t instanceof Uint8Array;
    };
    R4._uint8ArrayToBuffer = function(t) {
      return Fc.from(t.buffer, t.byteOffset, t.byteLength);
    };
  });
  Jr = E5((_d, A4) => {
    var T3 = fl(), Pc = Kr2(), kc = T3.Readable.destroy;
    A4.exports = T3.Readable;
    A4.exports._uint8ArrayToBuffer = T3._uint8ArrayToBuffer;
    A4.exports._isUint8Array = T3._isUint8Array;
    A4.exports.isDisturbed = T3.isDisturbed;
    A4.exports.isErrored = T3.isErrored;
    A4.exports.isReadable = T3.isReadable;
    A4.exports.Readable = T3.Readable;
    A4.exports.Writable = T3.Writable;
    A4.exports.Duplex = T3.Duplex;
    A4.exports.Transform = T3.Transform;
    A4.exports.PassThrough = T3.PassThrough;
    A4.exports.addAbortSignal = T3.addAbortSignal;
    A4.exports.finished = T3.finished;
    A4.exports.destroy = T3.destroy;
    A4.exports.destroy = kc;
    A4.exports.pipeline = T3.pipeline;
    A4.exports.compose = T3.compose;
    Object.defineProperty(T3, "promises", { configurable: true, enumerable: true, get() {
      return Pc;
    } });
    A4.exports.Stream = T3.Stream;
    A4.exports.default = A4.exports;
  });
  Ze = {};
  Qr(Ze, { default: () => Uc });
  ue3(Ze, rt3(Jr()));
  Uc = rt3(Jr());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS((exports, module) => {
  module.exports = {
    ArrayIsArray(self2) {
      return Array.isArray(self2);
    },
    ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    },
    ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    },
    ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    },
    ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    },
    ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    },
    ArrayPrototypePush(self2, el) {
      return self2.push(el);
    },
    ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    Error,
    FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    },
    FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    },
    ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    },
    ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    },
    ObjectKeys(obj) {
      return Object.keys(obj);
    },
    ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    },
    Promise,
    PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    },
    PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    },
    PromiseReject(err) {
      return Promise.reject(err);
    },
    PromiseResolve(val) {
      return Promise.resolve(val);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    },
    StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    },
    StringPrototypeTrim(self2) {
      return self2.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(self2, buf, len) {
      return self2.set(buf, len);
    },
    Boolean,
    Uint8Array
  };
});

// node_modules/abort-controller/browser.js
var require_browser4 = __commonJS((exports, module) => {
  var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : undefined;
  module.exports = AbortController2;
  module.exports.AbortSignal = AbortSignal;
  module.exports.default = AbortController2;
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS((exports, module) => {
  var bufferModule = (init_buffer(), __toCommonJS(exports_buffer));
  var { kResistStopPropagation, SymbolDispose } = require_primordials();
  var AbortSignal = globalThis.AbortSignal || require_browser4().AbortSignal;
  var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
  var AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  var Blob2 = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob2 !== "undefined" ? function isBlob(b6) {
    return b6 instanceof Blob2;
  } : function isBlob(b6) {
    return false;
  };
  var validateAbortSignal = (signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  };
  var validateFunction = (value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  };

  class AggregateError2 extends Error {
    constructor(errors) {
      if (!Array.isArray(errors)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      }
      let message = "";
      for (let i = 0;i < errors.length; i++) {
        message += `    ${errors[i].stack}
`;
      }
      super(message);
      this.name = "AggregateError";
      this.errors = errors;
    }
  }
  module.exports = {
    AggregateError: AggregateError2,
    kEmptyObject: Object.freeze({}),
    once(callback) {
      let called = false;
      return function(...args) {
        if (called) {
          return;
        }
        called = true;
        callback.apply(this, args);
      };
    },
    createDeferredPromise: function() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return {
        promise,
        resolve,
        reject
      };
    },
    promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err) {
            return reject(err);
          }
          return resolve(...args);
        });
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(format, ...args) {
      return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
        const replacement = args.shift();
        if (type === "f") {
          return replacement.toFixed(6);
        } else if (type === "j") {
          return JSON.stringify(replacement);
        } else if (type === "s" && typeof replacement === "object") {
          const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
          return `${ctor} {}`.trim();
        } else {
          return replacement.toString();
        }
      });
    },
    inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"')) {
              return `"${value}"`;
            } else if (!value.includes("`") && !value.includes("${")) {
              return `\`${value}\``;
            }
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value)) {
            return "NaN";
          } else if (Object.is(value, -0)) {
            return String(value);
          }
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(fn) {
        return fn instanceof AsyncFunction;
      },
      isArrayBufferView(arr) {
        return ArrayBuffer.isView(arr);
      }
    },
    isBlob,
    deprecate(fn, message) {
      return fn;
    },
    addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined) {
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
      }
      validateAbortSignal(signal, "signal");
      validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted) {
        queueMicrotask(() => listener());
      } else {
        signal.addEventListener("abort", listener, {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        });
        removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      }
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener;
          (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
        }
      };
    },
    AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
      if (signals.length === 1) {
        return signals[0];
      }
      const ac = new AbortController2;
      const abort = () => ac.abort();
      signals.forEach((signal) => {
        validateAbortSignal(signal, "signals");
        signal.addEventListener("abort", abort, {
          once: true
        });
      });
      ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, {
        once: true
      });
      return ac.signal;
    }
  };
  module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var { format, inspect, AggregateError: CustomAggregateError } = require_util();
  var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
  var kIsNodeError = Symbol("kIsNodeError");
  var kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ];
  var classRegExp = /^([A-Z][a-z0-9]*)+$/;
  var nodeInternalPrefix = "__node_internal_";
  var codes = {};
  function assert(value, message) {
    if (!value) {
      throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
  }
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (;i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function getMessage(key, msg, args) {
    if (typeof msg === "function") {
      assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
      return msg(...args);
    }
    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
    assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
    if (args.length === 0) {
      return msg;
    }
    return format(msg, ...args);
  }
  function E6(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    class NodeError extends Base {
      constructor(...args) {
        super(getMessage(code, message, args));
      }
      toString() {
        return `${this.name} [${code}]: ${this.message}`;
      }
    }
    Object.defineProperties(NodeError.prototype, {
      name: {
        value: Base.name,
        writable: true,
        enumerable: false,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${code}]: ${this.message}`;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    NodeError.prototype.code = code;
    NodeError.prototype[kIsNodeError] = true;
    codes[code] = NodeError;
  }
  function hideStackFrames(fn) {
    const hidden = nodeInternalPrefix + fn.name;
    Object.defineProperty(fn, "name", {
      value: hidden
    });
    return fn;
  }
  function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
      if (Array.isArray(outerError.errors)) {
        outerError.errors.push(innerError);
        return outerError;
      }
      const err = new AggregateError2([outerError, innerError], outerError.message);
      err.code = outerError.code;
      return err;
    }
    return innerError || outerError;
  }

  class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  }
  E6("ERR_ASSERTION", "%s", Error);
  E6("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
    assert(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let msg = "The ";
    if (name.endsWith(" argument")) {
      msg += `${name} `;
    } else {
      msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      assert(typeof value === "string", "All expected entries have to be of type string");
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.test(value)) {
        instances.push(value);
      } else {
        assert(value !== "object", 'The value "object" should be written as "Object"');
        other.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.splice(types, pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`;
          break;
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`;
          break;
        default: {
          const last = types.pop();
          msg += `one of type ${types.join(", ")}, or ${last}`;
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += " or ";
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`;
          break;
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`;
          break;
        default: {
          const last = instances.pop();
          msg += `an instance of ${instances.join(", ")}, or ${last}`;
        }
      }
      if (other.length > 0) {
        msg += " or ";
      }
    }
    switch (other.length) {
      case 0:
        break;
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += "an ";
        }
        msg += `${other[0]}`;
        break;
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`;
        break;
      default: {
        const last = other.pop();
        msg += `one of ${other.join(", ")}, or ${last}`;
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`;
    } else if (typeof actual === "function" && actual.name) {
      msg += `. Received function ${actual.name}`;
    } else if (typeof actual === "object") {
      var _actual$constructor;
      if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) {
        msg += `. Received an instance of ${actual.constructor.name}`;
      } else {
        const inspected = inspect(actual, {
          depth: -1
        });
        msg += `. Received ${inspected}`;
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      });
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      msg += `. Received type ${typeof actual} (${inspected})`;
    }
    return msg;
  }, TypeError);
  E6("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + "...";
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  }, TypeError);
  E6("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
    var _value$constructor;
    const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`;
  }, TypeError);
  E6("ERR_MISSING_ARGS", (...args) => {
    assert(args.length > 0, "At least one arg needs to be specified");
    let msg;
    const len = args.length;
    args = (Array.isArray(args) ? args : [args]).map((a3) => `"${a3}"`).join(" or ");
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`;
        break;
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`;
        break;
      default:
        {
          const last = args.pop();
          msg += `The ${args.join(", ")}, and ${last} arguments`;
        }
        break;
    }
    return `${msg} must be specified`;
  }, TypeError);
  E6("ERR_OUT_OF_RANGE", (str, range, input) => {
    assert(range, 'Missing "range" argument');
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input);
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
  }, RangeError);
  E6("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  E6("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  E6("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  E6("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  E6("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  E6("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  E6("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  E6("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  E6("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  E6("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  E6("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  module.exports = {
    AbortError,
    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
    hideStackFrames,
    codes
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS((exports, module) => {
  var {
    ArrayIsArray,
    ArrayPrototypeIncludes,
    ArrayPrototypeJoin,
    ArrayPrototypeMap,
    NumberIsInteger,
    NumberIsNaN,
    NumberMAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER,
    NumberParseInt,
    ObjectPrototypeHasOwnProperty,
    RegExpPrototypeExec,
    String: String2,
    StringPrototypeToUpperCase,
    StringPrototypeTrim
  } = require_primordials();
  var {
    hideStackFrames,
    codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
  } = require_errors2();
  var { normalizeEncoding } = require_util();
  var { isAsyncFunction, isArrayBufferView } = require_util().types;
  var signals = {};
  function isInt32(value) {
    return value === (value | 0);
  }
  function isUint32(value) {
    return value === value >>> 0;
  }
  var octalReg = /^[0-7]+$/;
  var modeDesc = "must be a 32-bit unsigned integer or an octal string";
  function parseFileMode(value, name, def) {
    if (typeof value === "undefined") {
      value = def;
    }
    if (typeof value === "string") {
      if (RegExpPrototypeExec(octalReg, value) === null) {
        throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
      }
      value = NumberParseInt(value, 8);
    }
    validateUint32(value, name);
    return value;
  }
  var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  });
  var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  var validateUint32 = hideStackFrames((value, name, positive = false) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min = positive ? 1 : 0;
    const max = 4294967295;
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  function validateString(value, name) {
    if (typeof value !== "string")
      throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
  }
  function validateNumber(value, name, min = undefined, max) {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
      throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
    }
  }
  var validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!ArrayPrototypeIncludes(oneOf, value)) {
      const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v4) => typeof v4 === "string" ? `'${v4}'` : String2(v4)), ", ");
      const reason = "must be one of: " + allowed;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateBoolean(value, name) {
    if (typeof value !== "boolean")
      throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
  }
  function getOwnPropertyValueOrDefault(options, key, defaultValue) {
    return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
  }
  var validateObject2 = hideStackFrames((value, name, options = null) => {
    const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
    const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
    const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
    if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
      throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
    }
  });
  var validateDictionary = hideStackFrames((value, name) => {
    if (value != null && typeof value !== "object" && typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
    }
  });
  var validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!ArrayIsArray(value)) {
      throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
    }
    if (value.length < minLength) {
      const reason = `must be longer than ${minLength}`;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateStringArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateString(value[i], `${name}[${i}]`);
    }
  }
  function validateBooleanArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateBoolean(value[i], `${name}[${i}]`);
    }
  }
  function validateAbortSignalArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      const signal = value[i];
      const indexedName = `${name}[${i}]`;
      if (signal == null) {
        throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
      }
      validateAbortSignal(signal, indexedName);
    }
  }
  function validateSignalName(signal, name = "signal") {
    validateString(signal, name);
    if (signals[signal] === undefined) {
      if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
        throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
  }
  var validateBuffer = hideStackFrames((buffer2, name = "buffer") => {
    if (!isArrayBufferView(buffer2)) {
      throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer2);
    }
  });
  function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
      throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
  }
  function validatePort(port, name = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
      throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }
    return port | 0;
  }
  var validateAbortSignal = hideStackFrames((signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
    }
  });
  var validateFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  });
  var validatePlainFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function" || isAsyncFunction(value))
      throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  });
  var validateUndefined = hideStackFrames((value, name) => {
    if (value !== undefined)
      throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
  });
  function validateUnion(value, name, union) {
    if (!ArrayPrototypeIncludes(union, value)) {
      throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
  }
  var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function validateLinkHeaderFormat(value, name) {
    if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
      throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
  }
  function validateLinkHeaderValue(hints) {
    if (typeof hints === "string") {
      validateLinkHeaderFormat(hints, "hints");
      return hints;
    } else if (ArrayIsArray(hints)) {
      const hintsLength = hints.length;
      let result = "";
      if (hintsLength === 0) {
        return result;
      }
      for (let i = 0;i < hintsLength; i++) {
        const link = hints[i];
        validateLinkHeaderFormat(link, "hints");
        result += link;
        if (i !== hintsLength - 1) {
          result += ", ";
        }
      }
      return result;
    }
    throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
  module.exports = {
    isInt32,
    isUint32,
    parseFileMode,
    validateArray,
    validateStringArray,
    validateBooleanArray,
    validateAbortSignalArray,
    validateBoolean,
    validateBuffer,
    validateDictionary,
    validateEncoding,
    validateFunction,
    validateInt32,
    validateInteger,
    validateNumber,
    validateObject: validateObject2,
    validateOneOf,
    validatePlainFunction,
    validatePort,
    validateSignalName,
    validateString,
    validateUint32,
    validateUndefined,
    validateUnion,
    validateAbortSignal,
    validateLinkHeaderValue
  };
});

// node_modules/process/browser.js
var require_browser5 = __commonJS((exports, module) => {
  var process2 = module.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process2.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1;i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process2.title = "browser";
  process2.browser = true;
  process2.env = {};
  process2.argv = [];
  process2.version = "";
  process2.versions = {};
  function noop() {
  }
  process2.on = noop;
  process2.addListener = noop;
  process2.once = noop;
  process2.off = noop;
  process2.removeListener = noop;
  process2.removeAllListeners = noop;
  process2.emit = noop;
  process2.prependListener = noop;
  process2.prependOnceListener = noop;
  process2.listeners = function(name) {
    return [];
  };
  process2.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process2.cwd = function() {
    return "/";
  };
  process2.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process2.umask = function() {
    return 0;
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS((exports, module) => {
  var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
  var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
  var kIsErrored = SymbolFor("nodejs.stream.errored");
  var kIsReadable = SymbolFor("nodejs.stream.readable");
  var kIsWritable = SymbolFor("nodejs.stream.writable");
  var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
  var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
  var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
  function isReadableNodeStream(obj, strict = false) {
    var _obj$_readableState;
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
  }
  function isWritableNodeStream(obj) {
    var _obj$_writableState;
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
  }
  function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
  }
  function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
  }
  function isReadableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
  }
  function isWritableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
  }
  function isTransformStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
  }
  function isWebStream(obj) {
    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
  }
  function isIterable(obj, isAsync) {
    if (obj == null)
      return false;
    if (isAsync === true)
      return typeof obj[SymbolAsyncIterator] === "function";
    if (isAsync === false)
      return typeof obj[SymbolIterator] === "function";
    return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
  }
  function isDestroyed(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
  }
  function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableEnded === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
      return null;
    return wState.ended;
  }
  function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableFinished === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
      return null;
    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
  }
  function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream))
      return null;
    if (stream.readableEnded === true)
      return true;
    const rState = stream._readableState;
    if (!rState || rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
      return null;
    return rState.ended;
  }
  function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream))
      return null;
    const rState = stream._readableState;
    if (rState !== null && rState !== undefined && rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
      return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
  }
  function isReadable(stream) {
    if (stream && stream[kIsReadable] != null)
      return stream[kIsReadable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
  }
  function isWritable(stream) {
    if (stream && stream[kIsWritable] != null)
      return stream[kIsWritable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
  }
  function isFinished(stream, opts) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (isDestroyed(stream)) {
      return true;
    }
    if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
      return false;
    }
    if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
      return false;
    }
    return true;
  }
  function isWritableErrored(stream) {
    var _stream$_writableStat, _stream$_writableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.writableErrored) {
      return stream.writableErrored;
    }
    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
  }
  function isReadableErrored(stream) {
    var _stream$_readableStat, _stream$_readableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.readableErrored) {
      return stream.readableErrored;
    }
    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
  }
  function isClosed(stream) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (typeof stream.closed === "boolean") {
      return stream.closed;
    }
    const wState = stream._writableState;
    const rState = stream._readableState;
    if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean") {
      return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
    }
    if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
      return stream._closed;
    }
    return null;
  }
  function isOutgoingMessage(stream) {
    return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
  }
  function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
  }
  function isServerRequest(stream) {
    var _stream$req;
    return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
  }
  function willEmitClose(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
  }
  function isDisturbed(stream) {
    var _stream$kIsDisturbed;
    return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
  }
  function isErrored(stream) {
    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
  }
  module.exports = {
    isDestroyed,
    kIsDestroyed,
    isDisturbed,
    kIsDisturbed,
    isErrored,
    kIsErrored,
    isReadable,
    kIsReadable,
    kIsClosedPromise,
    kControllerErrorFunction,
    kIsWritable,
    isClosed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadableNodeStream,
    isReadableStream,
    isReadableEnded,
    isReadableFinished,
    isReadableErrored,
    isNodeStream,
    isWebStream,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableEnded,
    isWritableFinished,
    isWritableErrored,
    isServerRequest,
    isServerResponse,
    willEmitClose,
    isTransformStream
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var { AbortError, codes } = require_errors2();
  var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
  var { kEmptyObject, once } = require_util();
  var { validateAbortSignal, validateFunction, validateObject: validateObject2, validateBoolean } = require_validators();
  var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
  var {
    isClosed,
    isReadable,
    isReadableNodeStream,
    isReadableStream,
    isReadableFinished,
    isReadableErrored,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableFinished,
    isWritableErrored,
    isNodeStream,
    willEmitClose: _willEmitClose,
    kIsClosedPromise
  } = require_utils();
  var addAbortListener;
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  var nop = () => {
  };
  function eos(stream, options, callback) {
    var _options$readable, _options$writable;
    if (arguments.length === 2) {
      callback = options;
      options = kEmptyObject;
    } else if (options == null) {
      options = kEmptyObject;
    } else {
      validateObject2(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    if (isReadableStream(stream) || isWritableStream(stream)) {
      return eosWeb(stream, options, callback);
    }
    if (!isNodeStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);
    const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const onlegacyfinish = () => {
      if (!stream.writable) {
        onfinish();
      }
    };
    let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
    let writableFinished = isWritableFinished(stream, false);
    const onfinish = () => {
      writableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.readable || readable)) {
        return;
      }
      if (!readable || readableFinished) {
        callback.call(stream);
      }
    };
    let readableFinished = isReadableFinished(stream, false);
    const onend = () => {
      readableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.writable || writable)) {
        return;
      }
      if (!writable || writableFinished) {
        callback.call(stream);
      }
    };
    const onerror = (err) => {
      callback.call(stream, err);
    };
    let closed = isClosed(stream);
    const onclose = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
        if (!isReadableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      if (writable && !writableFinished) {
        if (!isWritableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      callback.call(stream);
    };
    const onclosed = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      callback.call(stream);
    };
    const onrequest = () => {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      if (!willEmitClose) {
        stream.on("abort", onclose);
      }
      if (stream.req) {
        onrequest();
      } else {
        stream.on("request", onrequest);
      }
    } else if (writable && !wState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
      stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) {
      stream.on("error", onerror);
    }
    stream.on("close", onclose);
    if (closed) {
      process2.nextTick(onclose);
    } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
      if (!willEmitClose) {
        process2.nextTick(onclosed);
      }
    } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
      process2.nextTick(onclosed);
    } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
      process2.nextTick(onclosed);
    } else if (rState && stream.req && stream.aborted) {
      process2.nextTick(onclosed);
    }
    const cleanup = () => {
      callback = nop;
      stream.removeListener("aborted", onclose);
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
      const abort = () => {
        const endCallback = callback;
        cleanup();
        endCallback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    return cleanup;
  }
  function eosWeb(stream, options, callback) {
    let isAborted = false;
    let abort = nop;
    if (options.signal) {
      abort = () => {
        isAborted = true;
        callback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    const resolverFn = (...args) => {
      if (!isAborted) {
        process2.nextTick(() => callback.apply(stream, args));
      }
    };
    PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
    return nop;
  }
  function finished(stream, opts) {
    var _opts;
    let autoCleanup = false;
    if (opts === null) {
      opts = kEmptyObject;
    }
    if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
      validateBoolean(opts.cleanup, "cleanup");
      autoCleanup = opts.cleanup;
    }
    return new Promise2((resolve, reject) => {
      const cleanup = eos(stream, opts, (err) => {
        if (autoCleanup) {
          cleanup();
        }
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  module.exports = eos;
  module.exports.finished = finished;
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var {
    aggregateTwoErrors,
    codes: { ERR_MULTIPLE_CALLBACK },
    AbortError
  } = require_errors2();
  var { Symbol: Symbol2 } = require_primordials();
  var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
  var kDestroy = Symbol2("kDestroy");
  var kConstruct = Symbol2("kConstruct");
  function checkError(err, w3, r) {
    if (err) {
      err.stack;
      if (w3 && !w3.errored) {
        w3.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
    }
  }
  function destroy(err, cb) {
    const r = this._readableState;
    const w3 = this._writableState;
    const s2 = w3 || r;
    if (w3 !== null && w3 !== undefined && w3.destroyed || r !== null && r !== undefined && r.destroyed) {
      if (typeof cb === "function") {
        cb();
      }
      return this;
    }
    checkError(err, w3, r);
    if (w3) {
      w3.destroyed = true;
    }
    if (r) {
      r.destroyed = true;
    }
    if (!s2.constructed) {
      this.once(kDestroy, function(er2) {
        _destroy(this, aggregateTwoErrors(er2, err), cb);
      });
    } else {
      _destroy(this, err, cb);
    }
    return this;
  }
  function _destroy(self2, err, cb) {
    let called = false;
    function onDestroy(err2) {
      if (called) {
        return;
      }
      called = true;
      const r = self2._readableState;
      const w3 = self2._writableState;
      checkError(err2, w3, r);
      if (w3) {
        w3.closed = true;
      }
      if (r) {
        r.closed = true;
      }
      if (typeof cb === "function") {
        cb(err2);
      }
      if (err2) {
        process2.nextTick(emitErrorCloseNT, self2, err2);
      } else {
        process2.nextTick(emitCloseNT, self2);
      }
    }
    try {
      self2._destroy(err || null, onDestroy);
    } catch (err2) {
      onDestroy(err2);
    }
  }
  function emitErrorCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    const r = self2._readableState;
    const w3 = self2._writableState;
    if (w3) {
      w3.closeEmitted = true;
    }
    if (r) {
      r.closeEmitted = true;
    }
    if (w3 !== null && w3 !== undefined && w3.emitClose || r !== null && r !== undefined && r.emitClose) {
      self2.emit("close");
    }
  }
  function emitErrorNT(self2, err) {
    const r = self2._readableState;
    const w3 = self2._writableState;
    if (w3 !== null && w3 !== undefined && w3.errorEmitted || r !== null && r !== undefined && r.errorEmitted) {
      return;
    }
    if (w3) {
      w3.errorEmitted = true;
    }
    if (r) {
      r.errorEmitted = true;
    }
    self2.emit("error", err);
  }
  function undestroy() {
    const r = this._readableState;
    const w3 = this._writableState;
    if (r) {
      r.constructed = true;
      r.closed = false;
      r.closeEmitted = false;
      r.destroyed = false;
      r.errored = null;
      r.errorEmitted = false;
      r.reading = false;
      r.ended = r.readable === false;
      r.endEmitted = r.readable === false;
    }
    if (w3) {
      w3.constructed = true;
      w3.destroyed = false;
      w3.closed = false;
      w3.closeEmitted = false;
      w3.errored = null;
      w3.errorEmitted = false;
      w3.finalCalled = false;
      w3.prefinished = false;
      w3.ended = w3.writable === false;
      w3.ending = w3.writable === false;
      w3.finished = w3.writable === false;
    }
  }
  function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w3 = stream._writableState;
    if (w3 !== null && w3 !== undefined && w3.destroyed || r !== null && r !== undefined && r.destroyed) {
      return this;
    }
    if (r !== null && r !== undefined && r.autoDestroy || w3 !== null && w3 !== undefined && w3.autoDestroy)
      stream.destroy(err);
    else if (err) {
      err.stack;
      if (w3 && !w3.errored) {
        w3.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
      if (sync) {
        process2.nextTick(emitErrorNT, stream, err);
      } else {
        emitErrorNT(stream, err);
      }
    }
  }
  function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
      return;
    }
    const r = stream._readableState;
    const w3 = stream._writableState;
    if (r) {
      r.constructed = false;
    }
    if (w3) {
      w3.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
      return;
    }
    process2.nextTick(constructNT, stream);
  }
  function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
        return;
      }
      called = true;
      const r = stream._readableState;
      const w3 = stream._writableState;
      const s2 = w3 || r;
      if (r) {
        r.constructed = true;
      }
      if (w3) {
        w3.constructed = true;
      }
      if (s2.destroyed) {
        stream.emit(kDestroy, err);
      } else if (err) {
        errorOrDestroy(stream, err, true);
      } else {
        process2.nextTick(emitConstructNT, stream);
      }
    }
    try {
      stream._construct((err) => {
        process2.nextTick(onConstruct, err);
      });
    } catch (err) {
      process2.nextTick(onConstruct, err);
    }
  }
  function emitConstructNT(stream) {
    stream.emit(kConstruct);
  }
  function isRequest(stream) {
    return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
  }
  function emitCloseLegacy(stream) {
    stream.emit("close");
  }
  function emitErrorCloseLegacy(stream, err) {
    stream.emit("error", err);
    process2.nextTick(emitCloseLegacy, stream);
  }
  function destroyer(stream, err) {
    if (!stream || isDestroyed(stream)) {
      return;
    }
    if (!err && !isFinished(stream)) {
      err = new AbortError;
    }
    if (isServerRequest(stream)) {
      stream.socket = null;
      stream.destroy(err);
    } else if (isRequest(stream)) {
      stream.abort();
    } else if (isRequest(stream.req)) {
      stream.req.abort();
    } else if (typeof stream.destroy === "function") {
      stream.destroy(err);
    } else if (typeof stream.close === "function") {
      stream.close();
    } else if (err) {
      process2.nextTick(emitErrorCloseLegacy, stream, err);
    } else {
      process2.nextTick(emitCloseLegacy, stream);
    }
    if (!stream.destroyed) {
      stream[kIsDestroyed] = true;
    }
  }
  module.exports = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy3 = __commonJS((exports, module) => {
  var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
  var { EventEmitter: EE2 } = (init_events(), __toCommonJS(exports_events));
  function Stream(opts) {
    EE2.call(this, opts);
  }
  ObjectSetPrototypeOf(Stream.prototype, EE2.prototype);
  ObjectSetPrototypeOf(Stream, EE2);
  Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
      if (dest.writable && dest.write(chunk) === false && source.pause) {
        source.pause();
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er2) {
      cleanup();
      if (EE2.listenerCount(this, "error") === 0) {
        this.emit("error", er2);
      }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (ArrayIsArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  module.exports = {
    Stream,
    prependListener
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS((exports, module) => {
  var { SymbolDispose } = require_primordials();
  var { AbortError, codes } = require_errors2();
  var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
  var eos = require_end_of_stream2();
  var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
  var addAbortListener;
  var validateAbortSignal = (signal, name) => {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
    }
  };
  exports.addAbortSignal = function addAbortSignal(signal, stream) {
    validateAbortSignal(signal, "signal");
    if (!isNodeStream(stream) && !isWebStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    return exports.addAbortSignalNoValidate(signal, stream);
  };
  exports.addAbortSignalNoValidate = function(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      return stream;
    }
    const onAbort = isNodeStream(stream) ? () => {
      stream.destroy(new AbortError(undefined, {
        cause: signal.reason
      }));
    } : () => {
      stream[kControllerErrorFunction](new AbortError(undefined, {
        cause: signal.reason
      }));
    };
    if (signal.aborted) {
      onAbort();
    } else {
      addAbortListener = addAbortListener || require_util().addAbortListener;
      const disposable = addAbortListener(signal, onAbort);
      eos(stream, disposable[SymbolDispose]);
    }
    return stream;
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS((exports, module) => {
  var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { inspect } = require_util();
  module.exports = class BufferList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    push(v4) {
      const entry = {
        data: v4,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    }
    unshift(v4) {
      const entry = {
        data: v4,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      const ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    }
    clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
    join(s2) {
      if (this.length === 0)
        return "";
      let p3 = this.head;
      let ret = "" + p3.data;
      while ((p3 = p3.next) !== null)
        ret += s2 + p3.data;
      return ret;
    }
    concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      const ret = Buffer2.allocUnsafe(n >>> 0);
      let p3 = this.head;
      let i = 0;
      while (p3) {
        TypedArrayPrototypeSet(ret, p3.data, i);
        i += p3.data.length;
        p3 = p3.next;
      }
      return ret;
    }
    consume(n, hasStrings) {
      const data = this.head.data;
      if (n < data.length) {
        const slice2 = data.slice(0, n);
        this.head.data = data.slice(n);
        return slice2;
      }
      if (n === data.length) {
        return this.shift();
      }
      return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
      return this.head.data;
    }
    *[SymbolIterator]() {
      for (let p3 = this.head;p3; p3 = p3.next) {
        yield p3.data;
      }
    }
    _getString(n) {
      let ret = "";
      let p3 = this.head;
      let c2 = 0;
      do {
        const str = p3.data;
        if (n > str.length) {
          ret += str;
          n -= str.length;
        } else {
          if (n === str.length) {
            ret += str;
            ++c2;
            if (p3.next)
              this.head = p3.next;
            else
              this.head = this.tail = null;
          } else {
            ret += StringPrototypeSlice(str, 0, n);
            this.head = p3;
            p3.data = StringPrototypeSlice(str, n);
          }
          break;
        }
        ++c2;
      } while ((p3 = p3.next) !== null);
      this.length -= c2;
      return ret;
    }
    _getBuffer(n) {
      const ret = Buffer2.allocUnsafe(n);
      const retLen = n;
      let p3 = this.head;
      let c2 = 0;
      do {
        const buf = p3.data;
        if (n > buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n);
          n -= buf.length;
        } else {
          if (n === buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            ++c2;
            if (p3.next)
              this.head = p3.next;
            else
              this.head = this.tail = null;
          } else {
            TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
            this.head = p3;
            p3.data = buf.slice(n);
          }
          break;
        }
        ++c2;
      } while ((p3 = p3.next) !== null);
      this.length -= c2;
      return ret;
    }
    [Symbol.for("nodejs.util.inspect.custom")](_4, options) {
      return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false
      });
    }
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS((exports, module) => {
  var { MathFloor, NumberIsInteger } = require_primordials();
  var { validateInteger } = require_validators();
  var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
  var defaultHighWaterMarkBytes = 16 * 1024;
  var defaultHighWaterMarkObjectMode = 16;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getDefaultHighWaterMark(objectMode) {
    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
  }
  function setDefaultHighWaterMark(objectMode, value) {
    validateInteger(value, "value", 0);
    if (objectMode) {
      defaultHighWaterMarkObjectMode = value;
    } else {
      defaultHighWaterMarkBytes = value;
    }
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!NumberIsInteger(hwm) || hwm < 0) {
        const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
        throw new ERR_INVALID_ARG_VALUE(name, hwm);
      }
      return MathFloor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
  }
  module.exports = {
    getHighWaterMark,
    getDefaultHighWaterMark,
    setDefaultHighWaterMark
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
  function from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer2) {
      return new Readable({
        objectMode: true,
        ...opts,
        read() {
          this.push(iterable);
          this.push(null);
        }
      });
    }
    let isAsync;
    if (iterable && iterable[SymbolAsyncIterator]) {
      isAsync = true;
      iterator = iterable[SymbolAsyncIterator]();
    } else if (iterable && iterable[SymbolIterator]) {
      isAsync = false;
      iterator = iterable[SymbolIterator]();
    } else {
      throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
    }
    const readable = new Readable({
      objectMode: true,
      highWaterMark: 1,
      ...opts
    });
    let reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    readable._destroy = function(error, cb) {
      PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
    };
    async function close(error) {
      const hadError = error !== undefined && error !== null;
      const hasThrow = typeof iterator.throw === "function";
      if (hadError && hasThrow) {
        const { value, done } = await iterator.throw(error);
        await value;
        if (done) {
          return;
        }
      }
      if (typeof iterator.return === "function") {
        const { value } = await iterator.return();
        await value;
      }
    }
    async function next() {
      for (;; ) {
        try {
          const { value, done } = isAsync ? await iterator.next() : iterator.next();
          if (done) {
            readable.push(null);
          } else {
            const res = value && typeof value.then === "function" ? await value : value;
            if (res === null) {
              reading = false;
              throw new ERR_STREAM_NULL_VALUES;
            } else if (readable.push(res)) {
              continue;
            } else {
              reading = false;
            }
          }
        } catch (err) {
          readable.destroy(err);
        }
        break;
      }
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var {
    ArrayPrototypeIndexOf,
    NumberIsInteger,
    NumberIsNaN,
    NumberParseInt,
    ObjectDefineProperties,
    ObjectKeys,
    ObjectSetPrototypeOf,
    Promise: Promise2,
    SafeSet,
    SymbolAsyncDispose,
    SymbolAsyncIterator,
    Symbol: Symbol2
  } = require_primordials();
  module.exports = Readable;
  Readable.ReadableState = ReadableState;
  var { EventEmitter: EE2 } = (init_events(), __toCommonJS(exports_events));
  var { Stream, prependListener } = require_legacy3();
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { addAbortSignal } = require_add_abort_signal();
  var eos = require_end_of_stream2();
  var debug = require_util().debuglog("stream", (fn) => {
    debug = fn;
  });
  var BufferList = require_buffer_list2();
  var destroyImpl = require_destroy2();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_OUT_OF_RANGE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT
    },
    AbortError
  } = require_errors2();
  var { validateObject: validateObject2 } = require_validators();
  var kPaused = Symbol2("kPaused");
  var { StringDecoder } = (init_string_decoder(), __toCommonJS(exports_string_decoder));
  var from = require_from();
  ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Readable, Stream);
  var nop = () => {
  };
  var { errorOrDestroy } = destroyImpl;
  var kObjectMode = 1 << 0;
  var kEnded = 1 << 1;
  var kEndEmitted = 1 << 2;
  var kReading = 1 << 3;
  var kConstructed = 1 << 4;
  var kSync = 1 << 5;
  var kNeedReadable = 1 << 6;
  var kEmittedReadable = 1 << 7;
  var kReadableListening = 1 << 8;
  var kResumeScheduled = 1 << 9;
  var kErrorEmitted = 1 << 10;
  var kEmitClose = 1 << 11;
  var kAutoDestroy = 1 << 12;
  var kDestroyed = 1 << 13;
  var kClosed = 1 << 14;
  var kCloseEmitted = 1 << 15;
  var kMultiAwaitDrain = 1 << 16;
  var kReadingMore = 1 << 17;
  var kDataEmitted = 1 << 18;
  function makeBitMapDescriptor(bit) {
    return {
      enumerable: false,
      get() {
        return (this.state & bit) !== 0;
      },
      set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      }
    };
  }
  ObjectDefineProperties(ReadableState.prototype, {
    objectMode: makeBitMapDescriptor(kObjectMode),
    ended: makeBitMapDescriptor(kEnded),
    endEmitted: makeBitMapDescriptor(kEndEmitted),
    reading: makeBitMapDescriptor(kReading),
    constructed: makeBitMapDescriptor(kConstructed),
    sync: makeBitMapDescriptor(kSync),
    needReadable: makeBitMapDescriptor(kNeedReadable),
    emittedReadable: makeBitMapDescriptor(kEmittedReadable),
    readableListening: makeBitMapDescriptor(kReadableListening),
    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
    errorEmitted: makeBitMapDescriptor(kErrorEmitted),
    emitClose: makeBitMapDescriptor(kEmitClose),
    autoDestroy: makeBitMapDescriptor(kAutoDestroy),
    destroyed: makeBitMapDescriptor(kDestroyed),
    closed: makeBitMapDescriptor(kClosed),
    closeEmitted: makeBitMapDescriptor(kCloseEmitted),
    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
    readingMore: makeBitMapDescriptor(kReadingMore),
    dataEmitted: makeBitMapDescriptor(kDataEmitted)
  });
  function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
    if (options && options.objectMode)
      this.state |= kObjectMode;
    if (isDuplex && options && options.readableObjectMode)
      this.state |= kObjectMode;
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this[kPaused] = null;
    if (options && options.emitClose === false)
      this.state &= ~kEmitClose;
    if (options && options.autoDestroy === false)
      this.state &= ~kAutoDestroy;
    this.errored = null;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    const isDuplex = this instanceof require_duplex();
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal && !isDuplex)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      if (this._readableState.needReadable) {
        maybeReadMore(this, this._readableState);
      }
    });
  }
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype[EE2.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  Readable.prototype[SymbolAsyncDispose] = function() {
    let error;
    if (!this.destroyed) {
      error = this.readableEnded ? null : new AbortError;
      this.destroy(error);
    }
    return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
  };
  Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if ((state.state & kObjectMode) === 0) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (state.encoding !== encoding) {
          if (addToFront && state.encoding) {
            chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
          } else {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "";
      } else if (chunk != null) {
        err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    if (err) {
      errorOrDestroy(stream, err);
    } else if (chunk === null) {
      state.state &= ~kReading;
      onEofChunk(stream, state);
    } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
      if (addToFront) {
        if ((state.state & kEndEmitted) !== 0)
          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
        else if (state.destroyed || state.errored)
          return false;
        else
          addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
      } else if (state.destroyed || state.errored) {
        return false;
      } else {
        state.state &= ~kReading;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.state &= ~kReading;
      maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
      if ((state.state & kMultiAwaitDrain) !== 0) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
      state.dataEmitted = true;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if ((state.state & kNeedReadable) !== 0)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer2 = this._readableState.buffer;
    let content = "";
    for (const data of buffer2) {
      content += decoder.write(data);
    }
    buffer2.clear();
    if (content !== "")
      buffer2.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n > MAX_HWM) {
      throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if ((state.state & kObjectMode) !== 0)
      return 1;
    if (NumberIsNaN(n)) {
      if (state.flowing && state.length)
        return state.buffer.first().length;
      return state.length;
    }
    if (n <= state.length)
      return n;
    return state.ended ? state.length : 0;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
      n = NaN;
    } else if (!NumberIsInteger(n)) {
      n = NumberParseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n !== 0)
      state.state &= ~kEmittedReadable;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    let doRead = (state.state & kNeedReadable) !== 0;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
      doRead = false;
      debug("reading, ended or constructing", doRead);
    } else if (doRead) {
      debug("do read");
      state.state |= kReading | kSync;
      if (state.length === 0)
        state.state |= kNeedReadable;
      try {
        this._read(state.highWaterMark);
      } catch (err) {
        errorOrDestroy(this, err);
      }
      state.state &= ~kSync;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    let ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      if (state.multiAwaitDrain) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
      state.dataEmitted = true;
      this.emit("data", ret);
    }
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      const chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
  function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process2.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
      state.readingMore = true;
      process2.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      const len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
      if (!state.multiAwaitDrain) {
        state.multiAwaitDrain = true;
        state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process2.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      if (ondrain) {
        dest.removeListener("drain", ondrain);
      }
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    function pause() {
      if (!cleanedUp) {
        if (state.pipes.length === 1 && state.pipes[0] === dest) {
          debug("false write response, pause", 0);
          state.awaitDrainWriters = dest;
          state.multiAwaitDrain = false;
        } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
          debug("false write response, pause", state.awaitDrainWriters.size);
          state.awaitDrainWriters.add(dest);
        }
        src.pause();
      }
      if (!ondrain) {
        ondrain = pipeOnDrain(src, dest);
        dest.on("drain", ondrain);
      }
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      const ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        pause();
      }
    }
    function onerror(er2) {
      debug("onerror", er2);
      unpipe();
      dest.removeListener("error", onerror);
      if (dest.listenerCount("error") === 0) {
        const s2 = dest._writableState || dest._readableState;
        if (s2 && !s2.errorEmitted) {
          errorOrDestroy(dest, er2);
        } else {
          dest.emit("error", er2);
        }
      }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
      pause();
    } else if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
      const state = src._readableState;
      if (state.awaitDrainWriters === dest) {
        debug("pipeOnDrain", 1);
        state.awaitDrainWriters = null;
      } else if (state.multiAwaitDrain) {
        debug("pipeOnDrain", state.awaitDrainWriters.size);
        state.awaitDrainWriters.delete(dest);
      }
      if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
        src.resume();
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipes.length === 0)
      return this;
    if (!dest) {
      const dests = state.pipes;
      state.pipes = [];
      this.pause();
      for (let i = 0;i < dests.length; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    const index2 = ArrayPrototypeIndexOf(state.pipes, dest);
    if (index2 === -1)
      return this;
    state.pipes.splice(index2, 1);
    if (state.pipes.length === 0)
      this.pause();
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process2.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.off = Readable.prototype.removeListener;
  Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    const state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    } else if (!state.readableListening) {
      state.flowing = null;
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state[kPaused] = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process2.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
  };
  function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk) => {
      if (!this.push(chunk) && stream.pause) {
        paused = true;
        stream.pause();
      }
    });
    stream.on("end", () => {
      this.push(null);
    });
    stream.on("error", (err) => {
      errorOrDestroy(this, err);
    });
    stream.on("close", () => {
      this.destroy();
    });
    stream.on("destroy", () => {
      this.destroy();
    });
    this._read = () => {
      if (paused && stream.resume) {
        paused = false;
        stream.resume();
      }
    };
    const streamKeys = ObjectKeys(stream);
    for (let j5 = 1;j5 < streamKeys.length; j5++) {
      const i = streamKeys[j5];
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = stream[i].bind(stream);
      }
    }
    return this;
  };
  Readable.prototype[SymbolAsyncIterator] = function() {
    return streamToAsyncIterator(this);
  };
  Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
      validateObject2(options, "options");
    }
    return streamToAsyncIterator(this, options);
  };
  function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
      stream = Readable.wrap(stream, {
        objectMode: true
      });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
  }
  async function* createAsyncIterator(stream, options) {
    let callback = nop;
    function next(resolve) {
      if (this === stream) {
        callback();
        callback = nop;
      } else {
        callback = resolve;
      }
    }
    stream.on("readable", next);
    let error;
    const cleanup = eos(stream, {
      writable: false
    }, (err) => {
      error = err ? aggregateTwoErrors(error, err) : null;
      callback();
      callback = nop;
    });
    try {
      while (true) {
        const chunk = stream.destroyed ? null : stream.read();
        if (chunk !== null) {
          yield chunk;
        } else if (error) {
          throw error;
        } else if (error === null) {
          return;
        } else {
          await new Promise2(next);
        }
      }
    } catch (err) {
      error = aggregateTwoErrors(error, err);
      throw error;
    } finally {
      if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {
        destroyImpl.destroyer(stream, null);
      } else {
        stream.off("readable", next);
        cleanup();
      }
    }
  }
  ObjectDefineProperties(Readable.prototype, {
    readable: {
      __proto__: null,
      get() {
        const r = this._readableState;
        return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      },
      set(val) {
        if (this._readableState) {
          this._readableState.readable = !!val;
        }
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.objectMode : false;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.destroyed : false;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.endEmitted : false;
      }
    }
  });
  ObjectDefineProperties(ReadableState.prototype, {
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    paused: {
      __proto__: null,
      get() {
        return this[kPaused] !== false;
      },
      set(value) {
        this[kPaused] = !!value;
      }
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    let ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process2.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.emit("end");
      if (stream.writable && stream.allowHalfOpen === false) {
        process2.nextTick(endWritableNT, stream);
      } else if (state.autoDestroy) {
        const wState = stream._writableState;
        const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
  }
  function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
      stream.end();
    }
  }
  Readable.from = function(iterable, opts) {
    return from(Readable, iterable, opts);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Readable.fromWeb = function(readableStream, options) {
    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
  };
  Readable.toWeb = function(streamReadable, options) {
    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
  };
  Readable.wrap = function(src, options) {
    var _ref, _src$readableObjectMo;
    return new Readable({
      objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,
      ...options,
      destroy(err, callback) {
        destroyImpl.destroyer(src, err);
        callback(err);
      }
    }).wrap(src);
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var {
    ArrayPrototypeSlice,
    Error: Error2,
    FunctionPrototypeSymbolHasInstance,
    ObjectDefineProperty,
    ObjectDefineProperties,
    ObjectSetPrototypeOf,
    StringPrototypeToLowerCase,
    Symbol: Symbol2,
    SymbolHasInstance
  } = require_primordials();
  module.exports = Writable;
  Writable.WritableState = WritableState;
  var { EventEmitter: EE2 } = (init_events(), __toCommonJS(exports_events));
  var Stream = require_legacy3().Stream;
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var destroyImpl = require_destroy2();
  var { addAbortSignal } = require_add_abort_signal();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
  var {
    ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING
  } = require_errors2().codes;
  var { errorOrDestroy } = destroyImpl;
  ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Writable, Stream);
  function nop() {
  }
  var kOnFinished = Symbol2("kOnFinished");
  function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex)
      this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
  }
  function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
  };
  ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Writable(options) {
    const isDuplex = this instanceof require_duplex();
    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      const state = this._writableState;
      if (!state.writing) {
        clearBuffer(this, state);
      }
      finishMaybe(this, state);
    });
  }
  ObjectDefineProperty(Writable, SymbolHasInstance, {
    __proto__: null,
    value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    }
  });
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = state.defaultEncoding;
    } else {
      if (!encoding)
        encoding = state.defaultEncoding;
      else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      if (typeof cb !== "function")
        cb = nop;
    }
    if (chunk === null) {
      throw new ERR_STREAM_NULL_VALUES;
    } else if (!state.objectMode) {
      if (typeof chunk === "string") {
        if (state.decodeStrings !== false) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "buffer";
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "buffer";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "buffer";
      } else {
        throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    let err;
    if (state.ending) {
      err = new ERR_STREAM_WRITE_AFTER_END;
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
      process2.nextTick(cb, err);
      errorOrDestroy(stream, err, true);
      return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = StringPrototypeToLowerCase(encoding);
    if (!Buffer2.isEncoding(encoding))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked || state.errored || !state.constructed) {
      state.buffered.push({
        chunk,
        encoding,
        callback
      });
      if (state.allBuffers && encoding !== "buffer") {
        state.allBuffers = false;
      }
      if (state.allNoop && callback !== nop) {
        state.allNoop = false;
      }
    } else {
      state.writelen = len;
      state.writecb = callback;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, er2, cb) {
    --state.pendingcb;
    cb(er2);
    errorBuffer(state);
    errorOrDestroy(stream, er2);
  }
  function onwrite(stream, er2) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
      errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
      return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er2) {
      er2.stack;
      if (!state.errored) {
        state.errored = er2;
      }
      if (stream._readableState && !stream._readableState.errored) {
        stream._readableState.errored = er2;
      }
      if (sync) {
        process2.nextTick(onwriteError, stream, state, er2, cb);
      } else {
        onwriteError(stream, state, er2, cb);
      }
    } else {
      if (state.buffered.length > state.bufferedIndex) {
        clearBuffer(stream, state);
      }
      if (sync) {
        if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
          state.afterWriteTickInfo.count++;
        } else {
          state.afterWriteTickInfo = {
            count: 1,
            cb,
            stream,
            state
          };
          process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        }
      } else {
        afterWrite(stream, state, 1, cb);
      }
    }
  }
  function afterWriteTick({ stream, state, count, cb }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
  }
  function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
    while (count-- > 0) {
      state.pendingcb--;
      cb();
    }
    if (state.destroyed) {
      errorBuffer(state);
    }
    finishMaybe(stream, state);
  }
  function errorBuffer(state) {
    if (state.writing) {
      return;
    }
    for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
      var _state$errored;
      const { chunk, callback } = state.buffered[n];
      const len = state.objectMode ? 1 : chunk.length;
      state.length -= len;
      callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      var _state$errored2;
      onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
  }
  function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
      return;
    }
    const { buffered, bufferedIndex, objectMode } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
      return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
      state.pendingcb -= bufferedLength - 1;
      const callback = state.allNoop ? nop : (err) => {
        for (let n = i;n < buffered.length; ++n) {
          buffered[n].callback(err);
        }
      };
      const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
      chunks.allBuffers = state.allBuffers;
      doWrite(stream, state, true, state.length, chunks, "", callback);
      resetBuffer(state);
    } else {
      do {
        const { chunk, encoding, callback } = buffered[i];
        buffered[i++] = null;
        const len = objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, callback);
      } while (i < buffered.length && !state.writing);
      if (i === buffered.length) {
        resetBuffer(state);
      } else if (i > 256) {
        buffered.splice(0, i);
        state.bufferedIndex = 0;
      } else {
        state.bufferedIndex = i;
      }
    }
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
      this._writev([
        {
          chunk,
          encoding
        }
      ], cb);
    } else {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
      const ret = _write(this, chunk, encoding);
      if (ret instanceof Error2) {
        err = ret;
      }
    }
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (err) {
    } else if (!state.errored && !state.ending) {
      state.ending = true;
      finishMaybe(this, state, true);
      state.ended = true;
    } else if (state.finished) {
      err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
      if (err || state.finished) {
        process2.nextTick(cb, err);
      } else {
        state[kOnFinished].push(cb);
      }
    }
    return this;
  };
  function needFinish(state) {
    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
  }
  function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
        return;
      }
      called = true;
      state.pendingcb--;
      if (err) {
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0;i < onfinishCallbacks.length; i++) {
          onfinishCallbacks[i](err);
        }
        errorOrDestroy(stream, err, state.sync);
      } else if (needFinish(state)) {
        state.prefinished = true;
        stream.emit("prefinish");
        state.pendingcb++;
        process2.nextTick(finish, stream, state);
      }
    }
    state.sync = true;
    state.pendingcb++;
    try {
      stream._final(onFinish);
    } catch (err) {
      onFinish(err);
    }
    state.sync = false;
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.finalCalled = true;
        callFinal(stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        if (sync) {
          state.pendingcb++;
          process2.nextTick((stream2, state2) => {
            if (needFinish(state2)) {
              finish(stream2, state2);
            } else {
              state2.pendingcb--;
            }
          }, stream, state);
        } else if (needFinish(state)) {
          state.pendingcb++;
          finish(stream, state);
        }
      }
    }
  }
  function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
      const rState = stream._readableState;
      const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
  ObjectDefineProperties(Writable.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : false;
      },
      set(value) {
        if (this._writableState) {
          this._writableState.destroyed = value;
        }
      }
    },
    writable: {
      __proto__: null,
      get() {
        const w3 = this._writableState;
        return !!w3 && w3.writable !== false && !w3.destroyed && !w3.errored && !w3.ending && !w3.ended;
      },
      set(val) {
        if (this._writableState) {
          this._writableState.writable = !!val;
        }
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : false;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : false;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : false;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const wState = this._writableState;
        if (!wState)
          return false;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  var destroy = destroyImpl.destroy;
  Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
      process2.nextTick(errorBuffer, state);
    }
    destroy.call(this, err, cb);
    return this;
  };
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Writable.prototype[EE2.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Writable.fromWeb = function(writableStream, options) {
    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
  };
  Writable.toWeb = function(streamWritable) {
    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var bufferModule = (init_buffer(), __toCommonJS(exports_buffer));
  var {
    isReadable,
    isWritable,
    isIterable,
    isNodeStream,
    isReadableNodeStream,
    isWritableNodeStream,
    isDuplexNodeStream,
    isReadableStream,
    isWritableStream
  } = require_utils();
  var eos = require_end_of_stream2();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
  } = require_errors2();
  var { destroyer } = require_destroy2();
  var Duplex = require_duplex();
  var Readable = require_readable();
  var Writable = require_writable();
  var { createDeferredPromise } = require_util();
  var from = require_from();
  var Blob2 = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob2 !== "undefined" ? function isBlob(b6) {
    return b6 instanceof Blob2;
  } : function isBlob(b6) {
    return false;
  };
  var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
  var { FunctionPrototypeCall } = require_primordials();

  class Duplexify extends Duplex {
    constructor(options) {
      super(options);
      if ((options === null || options === undefined ? undefined : options.readable) === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if ((options === null || options === undefined ? undefined : options.writable) === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    }
  }
  module.exports = function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
      return body;
    }
    if (isReadableNodeStream(body)) {
      return _duplexify({
        readable: body
      });
    }
    if (isWritableNodeStream(body)) {
      return _duplexify({
        writable: body
      });
    }
    if (isNodeStream(body)) {
      return _duplexify({
        writable: false,
        readable: false
      });
    }
    if (isReadableStream(body)) {
      return _duplexify({
        readable: Readable.fromWeb(body)
      });
    }
    if (isWritableStream(body)) {
      return _duplexify({
        writable: Writable.fromWeb(body)
      });
    }
    if (typeof body === "function") {
      const { value, write, final, destroy } = fromAsyncGen(body);
      if (isIterable(value)) {
        return from(Duplexify, value, {
          objectMode: true,
          write,
          final,
          destroy
        });
      }
      const then2 = value === null || value === undefined ? undefined : value.then;
      if (typeof then2 === "function") {
        let d4;
        const promise = FunctionPrototypeCall(then2, value, (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }
        }, (err) => {
          destroyer(d4, err);
        });
        return d4 = new Duplexify({
          objectMode: true,
          readable: false,
          write,
          final(cb) {
            final(async () => {
              try {
                await promise;
                process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          },
          destroy
        });
      }
      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body)) {
      return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
      return from(Duplexify, body, {
        objectMode: true,
        writable: false
      });
    }
    if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable)) {
      return Duplexify.fromWeb(body);
    }
    if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
      const readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;
      const writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
      return _duplexify({
        readable,
        writable
      });
    }
    const then = body === null || body === undefined ? undefined : body.then;
    if (typeof then === "function") {
      let d4;
      FunctionPrototypeCall(then, body, (val) => {
        if (val != null) {
          d4.push(val);
        }
        d4.push(null);
      }, (err) => {
        destroyer(d4, err);
      });
      return d4 = new Duplexify({
        objectMode: true,
        writable: false,
        read() {
        }
      });
    }
    throw new ERR_INVALID_ARG_TYPE2(name, [
      "Blob",
      "ReadableStream",
      "WritableStream",
      "Stream",
      "Iterable",
      "AsyncIterable",
      "Function",
      "{ readable, writable } pair",
      "Promise"
    ], body);
  };
  function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise();
    const ac = new AbortController2;
    const signal = ac.signal;
    const value = fn(async function* () {
      while (true) {
        const _promise = promise;
        promise = null;
        const { chunk, done, cb } = await _promise;
        process2.nextTick(cb);
        if (done)
          return;
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          });
        ({ promise, resolve } = createDeferredPromise());
        yield chunk;
      }
    }(), {
      signal
    });
    return {
      value,
      write(chunk, encoding, cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          chunk,
          done: false,
          cb
        });
      },
      final(cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          done: true,
          cb
        });
      },
      destroy(err, cb) {
        ac.abort();
        cb(err);
      }
    };
  }
  function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w3 = pair.writable;
    let readable = !!isReadable(r);
    let writable = !!isWritable(w3);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d4;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d4.destroy(err);
      }
    }
    d4 = new Duplexify({
      readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
      writableObjectMode: !!(w3 !== null && w3 !== undefined && w3.writableObjectMode),
      readable,
      writable
    });
    if (writable) {
      eos(w3, (err) => {
        writable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      d4._write = function(chunk, encoding, callback) {
        if (w3.write(chunk, encoding)) {
          callback();
        } else {
          ondrain = callback;
        }
      };
      d4._final = function(callback) {
        w3.end();
        onfinish = callback;
      };
      w3.on("drain", function() {
        if (ondrain) {
          const cb = ondrain;
          ondrain = null;
          cb();
        }
      });
      w3.on("finish", function() {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      eos(r, (err) => {
        readable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      r.on("readable", function() {
        if (onreadable) {
          const cb = onreadable;
          onreadable = null;
          cb();
        }
      });
      r.on("end", function() {
        d4.push(null);
      });
      d4._read = function() {
        while (true) {
          const buf = r.read();
          if (buf === null) {
            onreadable = d4._read;
            return;
          }
          if (!d4.push(buf)) {
            return;
          }
        }
      };
    }
    d4._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        destroyer(w3, err);
        destroyer(r, err);
      }
    };
    return d4;
  }
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS((exports, module) => {
  var {
    ObjectDefineProperties,
    ObjectGetOwnPropertyDescriptor,
    ObjectKeys,
    ObjectSetPrototypeOf
  } = require_primordials();
  module.exports = Duplex;
  var Readable = require_readable();
  var Writable = require_writable();
  ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
  ObjectSetPrototypeOf(Duplex, Readable);
  {
    const keys = ObjectKeys(Writable.prototype);
    for (let i = 0;i < keys.length; i++) {
      const method = keys[i];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options) {
      this.allowHalfOpen = options.allowHalfOpen !== false;
      if (options.readable === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if (options.writable === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    } else {
      this.allowHalfOpen = true;
    }
  }
  ObjectDefineProperties(Duplex.prototype, {
    writable: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState && this._writableState) {
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      }
    }
  });
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Duplex.fromWeb = function(pair, options) {
    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
  };
  Duplex.toWeb = function(duplex) {
    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
  };
  var duplexify;
  Duplex.from = function(body) {
    if (!duplexify) {
      duplexify = require_duplexify();
    }
    return duplexify(body, "body");
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
  module.exports = Transform;
  var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
  var Duplex = require_duplex();
  var { getHighWaterMark } = require_state2();
  ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
  ObjectSetPrototypeOf(Transform, Duplex);
  var kCallback = Symbol2("kCallback");
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
    if (readableHighWaterMark === 0) {
      options = {
        ...options,
        highWaterMark: null,
        readableHighWaterMark,
        writableHighWaterMark: options.writableHighWaterMark || 0
      };
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function final(cb) {
    if (typeof this._flush === "function" && !this.destroyed) {
      this._flush((er2, data) => {
        if (er2) {
          if (cb) {
            cb(er2);
          } else {
            this.destroy(er2);
          }
          return;
        }
        if (data != null) {
          this.push(data);
        }
        this.push(null);
        if (cb) {
          cb();
        }
      });
    } else {
      this.push(null);
      if (cb) {
        cb();
      }
    }
  }
  function prefinish() {
    if (this._final !== final) {
      final.call(this);
    }
  }
  Transform.prototype._final = final;
  Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
  };
  Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    this._transform(chunk, encoding, (err, val) => {
      if (err) {
        callback(err);
        return;
      }
      if (val != null) {
        this.push(val);
      }
      if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) {
        callback();
      } else {
        this[kCallback] = callback;
      }
    });
  };
  Transform.prototype._read = function() {
    if (this[kCallback]) {
      const callback = this[kCallback];
      this[kCallback] = null;
      callback();
    }
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf } = require_primordials();
  module.exports = PassThrough;
  var Transform = require_transform();
  ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
  ObjectSetPrototypeOf(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS((exports, module) => {
  var process2 = require_browser5();
  var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
  var eos = require_end_of_stream2();
  var { once } = require_util();
  var destroyImpl = require_destroy2();
  var Duplex = require_duplex();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_INVALID_RETURN_VALUE,
      ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_PREMATURE_CLOSE
    },
    AbortError
  } = require_errors2();
  var { validateFunction, validateAbortSignal } = require_validators();
  var {
    isIterable,
    isReadable,
    isReadableNodeStream,
    isNodeStream,
    isTransformStream,
    isWebStream,
    isReadableStream,
    isReadableFinished
  } = require_utils();
  var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
  var PassThrough;
  var Readable;
  var addAbortListener;
  function destroyer(stream, reading, writing) {
    let finished = false;
    stream.on("close", () => {
      finished = true;
    });
    const cleanup = eos(stream, {
      readable: reading,
      writable: writing
    }, (err) => {
      finished = !err;
    });
    return {
      destroy: (err) => {
        if (finished)
          return;
        finished = true;
        destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      },
      cleanup
    };
  }
  function popCallback(streams) {
    validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
    return streams.pop();
  }
  function makeAsyncIterable(val) {
    if (isIterable(val)) {
      return val;
    } else if (isReadableNodeStream(val)) {
      return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
  }
  async function* fromReadable(val) {
    if (!Readable) {
      Readable = require_readable();
    }
    yield* Readable.prototype[SymbolAsyncIterator].call(val);
  }
  async function pumpToNode(iterable, writable, finish, { end }) {
    let error;
    let onresolve = null;
    const resume = (err) => {
      if (err) {
        error = err;
      }
      if (onresolve) {
        const callback = onresolve;
        onresolve = null;
        callback();
      }
    };
    const wait2 = () => new Promise2((resolve, reject) => {
      if (error) {
        reject(error);
      } else {
        onresolve = () => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        };
      }
    });
    writable.on("drain", resume);
    const cleanup = eos(writable, {
      readable: false
    }, resume);
    try {
      if (writable.writableNeedDrain) {
        await wait2();
      }
      for await (const chunk of iterable) {
        if (!writable.write(chunk)) {
          await wait2();
        }
      }
      if (end) {
        writable.end();
        await wait2();
      }
      finish();
    } catch (err) {
      finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
      cleanup();
      writable.off("drain", resume);
    }
  }
  async function pumpToWeb(readable, writable, finish, { end }) {
    if (isTransformStream(writable)) {
      writable = writable.writable;
    }
    const writer = writable.getWriter();
    try {
      for await (const chunk of readable) {
        await writer.ready;
        writer.write(chunk).catch(() => {
        });
      }
      await writer.ready;
      if (end) {
        await writer.close();
      }
      finish();
    } catch (err) {
      try {
        await writer.abort(err);
        finish(err);
      } catch (err2) {
        finish(err2);
      }
    }
  }
  function pipeline(...streams) {
    return pipelineImpl(streams, once(popCallback(streams)));
  }
  function pipelineImpl(streams, callback, opts) {
    if (streams.length === 1 && ArrayIsArray(streams[0])) {
      streams = streams[0];
    }
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController2;
    const signal = ac.signal;
    const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;
    const lastStreamCleanup = [];
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
      finishImpl(new AbortError);
    }
    addAbortListener = addAbortListener || require_util().addAbortListener;
    let disposable;
    if (outerSignal) {
      disposable = addAbortListener(outerSignal, abort);
    }
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
      finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, final) {
      var _disposable;
      if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
        error = err;
      }
      if (!error && !final) {
        return;
      }
      while (destroys.length) {
        destroys.shift()(error);
      }
      (_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose]();
      ac.abort();
      if (final) {
        if (!error) {
          lastStreamCleanup.forEach((fn) => fn());
        }
        process2.nextTick(callback, error, value);
      }
    }
    let ret;
    for (let i = 0;i < streams.length; i++) {
      const stream = streams[i];
      const reading = i < streams.length - 1;
      const writing = i > 0;
      const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;
      const isLastStream = i === streams.length - 1;
      if (isNodeStream(stream)) {
        let onError2 = function(err) {
          if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            finish(err);
          }
        };
        var onError = onError2;
        if (end) {
          const { destroy, cleanup } = destroyer(stream, reading, writing);
          destroys.push(destroy);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
        stream.on("error", onError2);
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(() => {
            stream.removeListener("error", onError2);
          });
        }
      }
      if (i === 0) {
        if (typeof stream === "function") {
          ret = stream({
            signal
          });
          if (!isIterable(ret)) {
            throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          }
        } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      } else if (typeof stream === "function") {
        if (isTransformStream(ret)) {
          var _ret;
          ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
        } else {
          ret = makeAsyncIterable(ret);
        }
        ret = stream(ret, {
          signal
        });
        if (reading) {
          if (!isIterable(ret, true)) {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
          }
        } else {
          var _ret2;
          if (!PassThrough) {
            PassThrough = require_passthrough();
          }
          const pt3 = new PassThrough({
            objectMode: true
          });
          const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
          if (typeof then === "function") {
            finishCount++;
            then.call(ret, (val) => {
              value = val;
              if (val != null) {
                pt3.write(val);
              }
              if (end) {
                pt3.end();
              }
              process2.nextTick(finish);
            }, (err) => {
              pt3.destroy(err);
              process2.nextTick(finish, err);
            });
          } else if (isIterable(ret, true)) {
            finishCount++;
            pumpToNode(ret, pt3, finish, {
              end
            });
          } else if (isReadableStream(ret) || isTransformStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, pt3, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
          }
          ret = pt3;
          const { destroy, cleanup } = destroyer(ret, false, true);
          destroys.push(destroy);
          if (isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
      } else if (isNodeStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount += 2;
          const cleanup = pipe(ret, stream, finish, {
            end
          });
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        } else if (isTransformStream(ret) || isReadableStream(ret)) {
          const toRead = ret.readable || ret;
          finishCount++;
          pumpToNode(toRead, stream, finish, {
            end
          });
        } else if (isIterable(ret)) {
          finishCount++;
          pumpToNode(ret, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else if (isWebStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount++;
          pumpToWeb(makeAsyncIterable(ret), stream, finish, {
            end
          });
        } else if (isReadableStream(ret) || isIterable(ret)) {
          finishCount++;
          pumpToWeb(ret, stream, finish, {
            end
          });
        } else if (isTransformStream(ret)) {
          finishCount++;
          pumpToWeb(ret.readable, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else {
        ret = Duplex.from(stream);
      }
    }
    if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {
      process2.nextTick(abort);
    }
    return ret;
  }
  function pipe(src, dst, finish, { end }) {
    let ended = false;
    dst.on("close", () => {
      if (!ended) {
        finish(new ERR_STREAM_PREMATURE_CLOSE);
      }
    });
    src.pipe(dst, {
      end: false
    });
    if (end) {
      let endFn2 = function() {
        ended = true;
        dst.end();
      };
      var endFn = endFn2;
      if (isReadableFinished(src)) {
        process2.nextTick(endFn2);
      } else {
        src.once("end", endFn2);
      }
    } else {
      finish();
    }
    eos(src, {
      readable: true,
      writable: false
    }, (err) => {
      const rState = src._readableState;
      if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
        src.once("end", finish).once("error", finish);
      } else {
        finish(err);
      }
    });
    return eos(dst, {
      readable: false,
      writable: true
    }, finish);
  }
  module.exports = {
    pipelineImpl,
    pipeline
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS((exports, module) => {
  var { pipeline } = require_pipeline2();
  var Duplex = require_duplex();
  var { destroyer } = require_destroy2();
  var {
    isNodeStream,
    isReadable,
    isWritable,
    isWebStream,
    isTransformStream,
    isWritableStream,
    isReadableStream
  } = require_utils();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
  } = require_errors2();
  var eos = require_end_of_stream2();
  module.exports = function compose(...streams) {
    if (streams.length === 0) {
      throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
      return Duplex.from(streams[0]);
    }
    const orgStreams = [...streams];
    if (typeof streams[0] === "function") {
      streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
      const idx = streams.length - 1;
      streams[idx] = Duplex.from(streams[idx]);
    }
    for (let n = 0;n < streams.length; ++n) {
      if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
        continue;
      }
      if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
      }
      if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d4;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d4.destroy(err);
      } else if (!readable && !writable) {
        d4.destroy();
      }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
    const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
    d4 = new Duplex({
      writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
      readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
      writable,
      readable
    });
    if (writable) {
      if (isNodeStream(head)) {
        d4._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d4._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
      } else if (isWebStream(head)) {
        const writable2 = isTransformStream(head) ? head.writable : head;
        const writer = writable2.getWriter();
        d4._write = async function(chunk, encoding, callback) {
          try {
            await writer.ready;
            writer.write(chunk).catch(() => {
            });
            callback();
          } catch (err) {
            callback(err);
          }
        };
        d4._final = async function(callback) {
          try {
            await writer.ready;
            writer.close().catch(() => {
            });
            onfinish = callback;
          } catch (err) {
            callback(err);
          }
        };
      }
      const toRead = isTransformStream(tail) ? tail.readable : tail;
      eos(toRead, () => {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      if (isNodeStream(tail)) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d4.push(null);
        });
        d4._read = function() {
          while (true) {
            const buf = tail.read();
            if (buf === null) {
              onreadable = d4._read;
              return;
            }
            if (!d4.push(buf)) {
              return;
            }
          }
        };
      } else if (isWebStream(tail)) {
        const readable2 = isTransformStream(tail) ? tail.readable : tail;
        const reader = readable2.getReader();
        d4._read = async function() {
          while (true) {
            try {
              const { value, done } = await reader.read();
              if (!d4.push(value)) {
                return;
              }
              if (done) {
                d4.push(null);
                return;
              }
            } catch {
              return;
            }
          }
        };
      }
    }
    d4._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        if (isNodeStream(tail)) {
          destroyer(tail, err);
        }
      }
    };
    return d4;
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS((exports, module) => {
  var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
  var {
    codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
    AbortError
  } = require_errors2();
  var { validateAbortSignal, validateInteger, validateObject: validateObject2 } = require_validators();
  var kWeakHandler = require_primordials().Symbol("kWeak");
  var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
  var { finished } = require_end_of_stream2();
  var staticCompose = require_compose();
  var { addAbortSignalNoValidate } = require_add_abort_signal();
  var { isWritable, isNodeStream } = require_utils();
  var { deprecate } = require_util();
  var {
    ArrayPrototypePush,
    Boolean: Boolean2,
    MathFloor,
    Number: Number2,
    NumberIsNaN,
    Promise: Promise2,
    PromiseReject,
    PromiseResolve,
    PromisePrototypeThen,
    Symbol: Symbol2
  } = require_primordials();
  var kEmpty = Symbol2("kEmpty");
  var kEof = Symbol2("kEof");
  function compose(stream, options) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    if (isNodeStream(stream) && !isWritable(stream)) {
      throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
    }
    const composedStream = staticCompose(this, stream);
    if (options !== null && options !== undefined && options.signal) {
      addAbortSignalNoValidate(options.signal, composedStream);
    }
    return composedStream;
  }
  function map(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let concurrency = 1;
    if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
      concurrency = MathFloor(options.concurrency);
    }
    let highWaterMark = concurrency - 1;
    if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
      highWaterMark = MathFloor(options.highWaterMark);
    }
    validateInteger(concurrency, "options.concurrency", 1);
    validateInteger(highWaterMark, "options.highWaterMark", 0);
    highWaterMark += concurrency;
    return async function* map() {
      const signal = require_util().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2));
      const stream = this;
      const queue = [];
      const signalOpt = {
        signal
      };
      let next;
      let resume;
      let done = false;
      let cnt = 0;
      function onCatch() {
        done = true;
        afterItemProcessed();
      }
      function afterItemProcessed() {
        cnt -= 1;
        maybeResume();
      }
      function maybeResume() {
        if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
          resume();
          resume = null;
        }
      }
      async function pump() {
        try {
          for await (let val of stream) {
            if (done) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            try {
              val = fn(val, signalOpt);
              if (val === kEmpty) {
                continue;
              }
              val = PromiseResolve(val);
            } catch (err) {
              val = PromiseReject(err);
            }
            cnt += 1;
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
            if (next) {
              next();
              next = null;
            }
            if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
              await new Promise2((resolve) => {
                resume = resolve;
              });
            }
          }
          queue.push(kEof);
        } catch (err) {
          const val = PromiseReject(err);
          PromisePrototypeThen(val, afterItemProcessed, onCatch);
          queue.push(val);
        } finally {
          done = true;
          if (next) {
            next();
            next = null;
          }
        }
      }
      pump();
      try {
        while (true) {
          while (queue.length > 0) {
            const val = await queue[0];
            if (val === kEof) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            if (val !== kEmpty) {
              yield val;
            }
            queue.shift();
            maybeResume();
          }
          await new Promise2((resolve) => {
            next = resolve;
          });
        }
      } finally {
        done = true;
        if (resume) {
          resume();
          resume = null;
        }
      }
    }.call(this);
  }
  function asIndexedPairs(options = undefined) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    return async function* asIndexedPairs() {
      let index2 = 0;
      for await (const val of this) {
        var _options$signal;
        if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {
          throw new AbortError({
            cause: options.signal.reason
          });
        }
        yield [index2++, val];
      }
    }.call(this);
  }
  async function some(fn, options = undefined) {
    for await (const unused of filter.call(this, fn, options)) {
      return true;
    }
    return false;
  }
  async function every(fn, options = undefined) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    return !await some.call(this, async (...args) => {
      return !await fn(...args);
    }, options);
  }
  async function find(fn, options) {
    for await (const result of filter.call(this, fn, options)) {
      return result;
    }
    return;
  }
  async function forEach(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    async function forEachFn(value, options2) {
      await fn(value, options2);
      return kEmpty;
    }
    for await (const unused of map.call(this, forEachFn, options))
      ;
  }
  function filter(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    async function filterFn(value, options2) {
      if (await fn(value, options2)) {
        return value;
      }
      return kEmpty;
    }
    return map.call(this, filterFn, options);
  }

  class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
    constructor() {
      super("reduce");
      this.message = "Reduce of an empty stream requires an initial value";
    }
  }
  async function reduce(reducer, initialValue, options) {
    var _options$signal2;
    if (typeof reducer !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
    }
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let hasInitialValue = arguments.length > 1;
    if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
      const err = new AbortError(undefined, {
        cause: options.signal.reason
      });
      this.once("error", () => {
      });
      await finished(this.destroy(err));
      throw err;
    }
    const ac = new AbortController2;
    const signal = ac.signal;
    if (options !== null && options !== undefined && options.signal) {
      const opts = {
        once: true,
        [kWeakHandler]: this,
        [kResistStopPropagation]: true
      };
      options.signal.addEventListener("abort", () => ac.abort(), opts);
    }
    let gotAnyItemFromStream = false;
    try {
      for await (const value of this) {
        var _options$signal3;
        gotAnyItemFromStream = true;
        if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {
          throw new AbortError;
        }
        if (!hasInitialValue) {
          initialValue = value;
          hasInitialValue = true;
        } else {
          initialValue = await reducer(initialValue, value, {
            signal
          });
        }
      }
      if (!gotAnyItemFromStream && !hasInitialValue) {
        throw new ReduceAwareErrMissingArgs;
      }
    } finally {
      ac.abort();
    }
    return initialValue;
  }
  async function toArray(options) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    const result = [];
    for await (const val of this) {
      var _options$signal4;
      if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {
        throw new AbortError(undefined, {
          cause: options.signal.reason
        });
      }
      ArrayPrototypePush(result, val);
    }
    return result;
  }
  function flatMap(fn, options) {
    const values = map.call(this, fn, options);
    return async function* flatMap() {
      for await (const val of values) {
        yield* val;
      }
    }.call(this);
  }
  function toIntegerOrInfinity(number) {
    number = Number2(number);
    if (NumberIsNaN(number)) {
      return 0;
    }
    if (number < 0) {
      throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
    }
    return number;
  }
  function drop(number, options = undefined) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return async function* drop() {
      var _options$signal5;
      if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal6;
        if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {
          throw new AbortError;
        }
        if (number-- <= 0) {
          yield val;
        }
      }
    }.call(this);
  }
  function take(number, options = undefined) {
    if (options != null) {
      validateObject2(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return async function* take() {
      var _options$signal7;
      if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal8;
        if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {
          throw new AbortError;
        }
        if (number-- > 0) {
          yield val;
        }
        if (number <= 0) {
          return;
        }
      }
    }.call(this);
  }
  exports.streamReturningOperators = {
    asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
    drop,
    filter,
    flatMap,
    map,
    take,
    compose
  };
  exports.promiseReturningOperators = {
    every,
    forEach,
    reduce,
    toArray,
    some,
    find
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS((exports, module) => {
  var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
  var { isIterable, isNodeStream, isWebStream } = require_utils();
  var { pipelineImpl: pl2 } = require_pipeline2();
  var { finished } = require_end_of_stream2();
  require_stream2();
  function pipeline(...streams) {
    return new Promise2((resolve, reject) => {
      let signal;
      let end;
      const lastArg = streams[streams.length - 1];
      if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
        const options = ArrayPrototypePop(streams);
        signal = options.signal;
        end = options.end;
      }
      pl2(streams, (err, value) => {
        if (err) {
          reject(err);
        } else {
          resolve(value);
        }
      }, {
        signal,
        end
      });
    });
  }
  module.exports = {
    finished,
    pipeline
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/stream.js
var require_stream2 = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
  var {
    promisify: { custom: customPromisify }
  } = require_util();
  var { streamReturningOperators, promiseReturningOperators } = require_operators();
  var {
    codes: { ERR_ILLEGAL_CONSTRUCTOR }
  } = require_errors2();
  var compose = require_compose();
  var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state2();
  var { pipeline } = require_pipeline2();
  var { destroyer } = require_destroy2();
  var eos = require_end_of_stream2();
  var promises = require_promises();
  var utils = require_utils();
  var Stream = module.exports = require_legacy3().Stream;
  Stream.isDestroyed = utils.isDestroyed;
  Stream.isDisturbed = utils.isDisturbed;
  Stream.isErrored = utils.isErrored;
  Stream.isReadable = utils.isReadable;
  Stream.isWritable = utils.isWritable;
  Stream.Readable = require_readable();
  for (const key of ObjectKeys(streamReturningOperators)) {
    let fn2 = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return Stream.Readable.from(ReflectApply(op, this, args));
    };
    fn = fn2;
    const op = streamReturningOperators[key];
    ObjectDefineProperty(fn2, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn2, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn2,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  var fn;
  for (const key of ObjectKeys(promiseReturningOperators)) {
    let fn2 = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return ReflectApply(op, this, args);
    };
    fn = fn2;
    const op = promiseReturningOperators[key];
    ObjectDefineProperty(fn2, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn2, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn2,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  var fn;
  Stream.Writable = require_writable();
  Stream.Duplex = require_duplex();
  Stream.Transform = require_transform();
  Stream.PassThrough = require_passthrough();
  Stream.pipeline = pipeline;
  var { addAbortSignal } = require_add_abort_signal();
  Stream.addAbortSignal = addAbortSignal;
  Stream.finished = eos;
  Stream.destroy = destroyer;
  Stream.compose = compose;
  Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
  Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
  ObjectDefineProperty(Stream, "promises", {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get() {
      return promises;
    }
  });
  ObjectDefineProperty(pipeline, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.pipeline;
    }
  });
  ObjectDefineProperty(eos, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.finished;
    }
  });
  Stream.Stream = Stream;
  Stream._isUint8Array = function isUint8Array(value) {
    return value instanceof Uint8Array;
  };
  Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable2 = __commonJS((exports, module) => {
  module.exports = require_stream2().Writable;
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/dist/modern.js
var require_modern3 = __commonJS((exports, module) => {
  var util = (init_util(), __toCommonJS(exports_util));
  var Writable = require__stream_writable2();
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var TransportStream = module.exports = function TransportStream() {
    var _this = this;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log)
      this.log = options.log;
    if (options.logv)
      this.logv = options.logv;
    if (options.close)
      this.close = options.close;
    this.once("pipe", function(logger) {
      _this.levels = logger.levels;
      _this.parent = logger;
    });
    this.once("unpipe", function(src) {
      if (src === _this.parent) {
        _this.parent = null;
        if (_this.close) {
          _this.close();
        }
      }
    });
  };
  util.inherits(TransportStream, Writable);
  TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    var level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (info && !this.format) {
        return this.log(info, callback);
      }
      var errState = undefined;
      var transformed = undefined;
      try {
        transformed = this.format.transform(Object.assign({}, info), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        callback();
        if (errState)
          throw errState;
        return;
      }
      return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
  };
  TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
      var infos = chunks.filter(this._accept, this);
      if (!infos.length) {
        return callback(null);
      }
      return this.logv(infos, callback);
    }
    for (var i = 0;i < chunks.length; i++) {
      if (!this._accept(chunks[i]))
        continue;
      if (chunks[i].chunk && !this.format) {
        this.log(chunks[i].chunk, chunks[i].callback);
        continue;
      }
      var errState = undefined;
      var transformed = undefined;
      try {
        transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        chunks[i].callback();
        if (errState) {
          callback(null);
          throw errState;
        }
      } else {
        this.log(transformed, chunks[i].callback);
      }
    }
    return callback(null);
  };
  TransportStream.prototype._accept = function _accept(write) {
    var info = write.chunk;
    if (this.silent) {
      return false;
    }
    var level = this.level || this.parent && this.parent.level;
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (this.handleExceptions || info.exception !== true) {
        return true;
      }
    }
    return false;
  };
  TransportStream.prototype._nop = function _nop() {
    return;
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/dist/legacy.js
var require_legacy4 = __commonJS((exports, module) => {
  var util = (init_util(), __toCommonJS(exports_util));
  var _require = require_triple_beam();
  var LEVEL = _require.LEVEL;
  var TransportStream = require_modern3();
  var LegacyTransportStream = module.exports = function LegacyTransportStream() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
      throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    this._deprecated();
    function transportError(err) {
      this.emit("error", err, this.transport);
    }
    if (!this.transport.__winstonError) {
      this.transport.__winstonError = transportError.bind(this);
      this.transport.on("error", this.transport.__winstonError);
    }
  };
  util.inherits(LegacyTransportStream, TransportStream);
  LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
      this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
  };
  LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for (var i = 0;i < chunks.length; i++) {
      if (this._accept(chunks[i])) {
        this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
        chunks[i].callback();
      }
    }
    return callback(null);
  };
  LegacyTransportStream.prototype._deprecated = function _deprecated() {
    console.error([this.transport.name + " is a legacy winston transport. Consider upgrading: ", "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"].join(`
`));
  };
  LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
      this.transport.close();
    }
    if (this.transport.__winstonError) {
      this.transport.removeListener("error", this.transport.__winstonError);
      this.transport.__winstonError = null;
    }
  };
});

// node_modules/winston-daily-rotate-file/node_modules/winston-transport/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  module.exports = require_modern3();
  module.exports.LegacyTransportStream = require_legacy4();
});

// node_modules/moment/dist/moment.js
var exports_moment = {};
__export(exports_moment, {
  default: () => moment_default
});
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a3, b6) {
  return Object.prototype.hasOwnProperty.call(a3, b6);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k4;
    for (k4 in obj) {
      if (hasOwnProp(obj, k4)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === undefined;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0;i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend(a3, b6) {
  for (var i in b6) {
    if (hasOwnProp(b6, i)) {
      a3[i] = b6[i];
    }
  }
  if (hasOwnProp(b6, "toString")) {
    a3.toString = b6.toString;
  }
  if (hasOwnProp(b6, "valueOf")) {
    a3.valueOf = b6.valueOf;
  }
  return a3;
}
function createUTC(input, format, locale, strict) {
  return createLocalOrUTC(input, format, locale, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m3) {
  if (m3._pf == null) {
    m3._pf = defaultParsingFlags();
  }
  return m3._pf;
}
function isValid(m3) {
  var flags = null, parsedParts = false, isNowValid = m3._d && !isNaN(m3._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m3);
    parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m3._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m3)) {
    m3._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m3._isValid;
}
function createInvalid(flags) {
  var m3 = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m3), flags);
  } else {
    getParsingFlags(m3).userInvalidated = true;
  }
  return m3;
}
function copyConfig(to2, from) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from._isAMomentObject)) {
    to2._isAMomentObject = from._isAMomentObject;
  }
  if (!isUndefined(from._i)) {
    to2._i = from._i;
  }
  if (!isUndefined(from._f)) {
    to2._f = from._f;
  }
  if (!isUndefined(from._l)) {
    to2._l = from._l;
  }
  if (!isUndefined(from._strict)) {
    to2._strict = from._strict;
  }
  if (!isUndefined(from._tzm)) {
    to2._tzm = from._tzm;
  }
  if (!isUndefined(from._isUTC)) {
    to2._isUTC = from._isUTC;
  }
  if (!isUndefined(from._offset)) {
    to2._offset = from._offset;
  }
  if (!isUndefined(from._pf)) {
    to2._pf = getParsingFlags(from);
  }
  if (!isUndefined(from._locale)) {
    to2._locale = from._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0;i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0;i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += `
[` + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(msg + `
Arguments: ` + Array.prototype.slice.call(args).join("") + `
` + new Error().stack);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
function calendar(key, mom, now) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
  return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
function addFormatToken(token, padded, ordinal, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token) {
    formatTokenFunctions[token] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal) {
    formatTokenFunctions[ordinal] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format) {
  var array = format.match(formattingTokens), i, length;
  for (i = 0, length = array.length;i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0;i2 < length; i2++) {
      output += isFunction(array[i2]) ? array[i2].call(mom, format) : array[i2];
    }
    return output;
  };
}
function formatMoment(m3, format) {
  if (!m3.isValid()) {
    return m3.localeData().invalidDate();
  }
  format = expandFormat(format, m3.localeData());
  formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
  return formatFunctions[format](m3);
}
function expandFormat(format, locale) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format)) {
    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format;
}
function longDateFormat(key) {
  var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format || !formatUpper) {
    return format;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
function invalidDate() {
  return this._invalidDate;
}
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff, output) {
  var format = this._relativeTime[diff > 0 ? "future" : "past"];
  return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u3;
  for (u3 in unitsObj) {
    if (hasOwnProp(unitsObj, u3)) {
      units.push({ unit: u3, priority: priorities[u3] });
    }
  }
  units.sort(function(a3, b6) {
    return a3.priority - b6.priority;
  });
  return units;
}
function addRegexToken(token, regex, strictRegex) {
  regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token, config) {
  if (!hasOwnProp(regexes, token)) {
    return new RegExp(unescapeFormat(token));
  }
  return regexes[token](config._strict, config._locale);
}
function unescapeFormat(s2) {
  return regexEscape(s2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p22, p3, p4) {
    return p1 || p22 || p3 || p4;
  }));
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function addParseToken(token, callback) {
  var i, func = callback, tokenLen;
  if (typeof token === "string") {
    token = [token];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token.length;
  for (i = 0;i < tokenLen; i++) {
    tokens[token[i]] = func;
  }
}
function addWeekParseToken(token, callback) {
  addParseToken(token, function(input, array, config, token2) {
    config._w = config._w || {};
    callback(input, config._w, config, token2);
  });
}
function addTimeToArrayFromToken(token, input, config) {
  if (input != null && hasOwnProp(tokens, token)) {
    tokens[token](input, config._a, config, token);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var { _d: d4, _isUTC: isUTC } = mom;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d4.getUTCMilliseconds() : d4.getMilliseconds();
    case "Seconds":
      return isUTC ? d4.getUTCSeconds() : d4.getSeconds();
    case "Minutes":
      return isUTC ? d4.getUTCMinutes() : d4.getMinutes();
    case "Hours":
      return isUTC ? d4.getUTCHours() : d4.getHours();
    case "Date":
      return isUTC ? d4.getUTCDate() : d4.getDate();
    case "Day":
      return isUTC ? d4.getUTCDay() : d4.getDay();
    case "Month":
      return isUTC ? d4.getUTCMonth() : d4.getMonth();
    case "FullYear":
      return isUTC ? d4.getUTCFullYear() : d4.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d4, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d4 = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d4.setUTCMilliseconds(value) : d4.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d4.setUTCSeconds(value) : d4.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d4.setUTCMinutes(value) : d4.setMinutes(value));
    case "Hours":
      return void (isUTC ? d4.setUTCHours(value) : d4.setHours(value));
    case "Date":
      return void (isUTC ? d4.setUTCDate(value) : d4.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
  isUTC ? d4.setUTCFullYear(year, month, date) : d4.setFullYear(year, month, date);
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0;i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod2(n, x5) {
  return (n % x5 + x5) % x5;
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod2(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
function localeMonths(m3, format) {
  if (!m3) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m3.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m3.month()];
}
function localeMonthsShort(m3, format) {
  if (!m3) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m3.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m3.month()];
}
function handleStrictParse(monthName, format, strict) {
  var i, ii2, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0;i < 12; ++i) {
      mom = createUTC([2000, i]);
      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeMonthsParse(monthName, format, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0;i < 12; i++) {
    mom = createUTC([2000, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
  mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a3, b6) {
    return b6.length - a3.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0;i < 12; i++) {
    mom = createUTC([2000, i]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}
function createDate(y5, m3, d4, h5, M3, s2, ms) {
  var date;
  if (y5 < 100 && y5 >= 0) {
    date = new Date(y5 + 400, m3, d4, h5, M3, s2, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y5);
    }
  } else {
    date = new Date(y5, m3, d4, h5, M3, s2, ms);
  }
  return date;
}
function createUTCDate(y5) {
  var date, args;
  if (y5 < 100 && y5 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y5 + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y5);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
function parseWeekday(input, locale) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale) {
  if (typeof input === "string") {
    return locale.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
function localeWeekdays(m3, format) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m3 && m3 !== true && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
  return m3 === true ? shiftWeekdays(weekdays, this._week.dow) : m3 ? weekdays[m3.day()] : weekdays;
}
function localeWeekdaysShort(m3) {
  return m3 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m3 ? this._weekdaysShort[m3.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m3) {
  return m3 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m3 ? this._weekdaysMin[m3.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format, strict) {
  var i, ii2, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0;i < 7; ++i) {
      mom = createUTC([2000, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0;i < 7; i++) {
    mom = createUTC([2000, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a3, b6) {
    return b6.length - a3.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0;i < 7; i++) {
    mom = createUTC([2000, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
function meridiem(token, lowercase) {
  addFormatToken(token, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
function matchMeridiem(isStrict, locale) {
  return locale._meridiemParse;
}
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
function localeMeridiem(hours, minutes, isLower) {
  if (hours > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0;i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j5, next, locale, split2;
  while (i < names.length) {
    split2 = normalizeLocale(names[i]).split("-");
    j5 = split2.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j5 > 0) {
      locale = loadLocale(split2.slice(0, j5).join("-"));
      if (locale) {
        return locale;
      }
      if (next && next.length >= j5 && commonPrefix(split2, next) >= j5 - 1) {
        break;
      }
      j5--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === undefined && typeof module_moment !== "undefined" && module_moment && exports_moment && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data;
  if (key) {
    if (isUndefined(values)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("Locale " + key + " not found. Did you forget to load it?");
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale = loadLocale(config.parentLocale);
        if (locale != null) {
          parentConfig = locale._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x5) {
        defineLocale(x5.name, x5.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale = loadLocale(key);
    if (locale) {
      return locale;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m3) {
  var overflow, a3 = m3._a;
  if (a3 && getParsingFlags(m3).overflow === -2) {
    overflow = a3[MONTH] < 0 || a3[MONTH] > 11 ? MONTH : a3[DATE] < 1 || a3[DATE] > daysInMonth(a3[YEAR], a3[MONTH]) ? DATE : a3[HOUR] < 0 || a3[HOUR] > 24 || a3[HOUR] === 24 && (a3[MINUTE] !== 0 || a3[SECOND] !== 0 || a3[MILLISECOND] !== 0) ? HOUR : a3[MINUTE] < 0 || a3[MINUTE] > 59 ? MINUTE : a3[SECOND] < 0 || a3[SECOND] > 59 ? SECOND : a3[MILLISECOND] < 0 || a3[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m3)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m3)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m3)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m3).overflow = overflow;
  }
  return m3;
}
function configFromISO(config) {
  var i, l3, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i = 0, l3 = isoDatesLen;i < l3; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l3 = isoTimesLen;i < l3; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2000 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m3 = hm % 100, h5 = (hm - m3) / 100;
    return h5 * 60 + m3;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
function defaults(a3, b6, c2) {
  if (a3 != null) {
    return a3;
  }
  if (b6 != null) {
    return b6;
  }
  return c2;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0;i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (;i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w3, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w3 = config._w;
  if (w3.GG != null || w3.W != null || w3.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(w3.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w3.W, 1);
    weekday = defaults(w3.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w3.gg, config._a[YEAR], curWeek.year);
    week = defaults(w3.w, curWeek.week);
    if (w3.d != null) {
      weekday = w3.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w3.e != null) {
      weekday = w3.e + dow;
      if (w3.e < 0 || w3.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0;i < tokenLen; i++) {
    token = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token);
      }
      addTimeToArrayFromToken(token, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = undefined;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale.meridiemHour != null) {
    return locale.meridiemHour(hour, meridiem2);
  } else if (locale.isPM != null) {
    isPm = locale.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = new Date(NaN);
    return;
  }
  for (i = 0;i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;
  config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
    return obj && parseInt(obj, 10);
  });
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = undefined;
  }
  return res;
}
function prepareConfig(config) {
  var { _i: input, _f: format } = config;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format === undefined && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format)) {
    configFromStringAndArray(config);
  } else if (format) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format, locale, strict, isUTC) {
  var c2 = {};
  if (format === true || format === false) {
    strict = format;
    format = undefined;
  }
  if (locale === true || locale === false) {
    strict = locale;
    locale = undefined;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = undefined;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale;
  c2._i = input;
  c2._f = format;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input, format, locale, strict) {
  return createLocalOrUTC(input, format, locale, strict, false);
}
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1;i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
function isDurationValid(m3) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m3) {
    if (hasOwnProp(m3, key) && !(indexOf.call(ordering, key) !== -1 && (m3[key] == null || !isNaN(m3[key])))) {
      return false;
    }
  }
  for (i = 0;i < orderLen; ++i) {
    if (m3[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m3[ordering[i]]) !== toInt(m3[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds + seconds * 1000 + minutes * 60000 + hours * 1000 * 60 * 60;
  this._days = +days + weeks * 7;
  this._months = +months + quarters * 3 + years * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0;i < len; i++) {
    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token, separator) {
  addFormatToken(token, 0, 0, function() {
    var offset2 = this.utcOffset(), sign = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign = "-";
    }
    return sign + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk, parts, minutes;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes = +(parts[1] * 60) + toInt(parts[2]);
  return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
}
function cloneWithOffset(input, model) {
  var res, diff;
  if (model._isUTC) {
    res = model.clone();
    diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m3) {
  return -Math.round(m3._d.getTimezoneOffset());
}
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
function createDuration(input, key) {
  var duration = input, match = null, sign, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign,
      h: toInt(match[HOUR]) * sign,
      m: toInt(match[MINUTE]) * sign,
      s: toInt(match[SECOND]) * sign,
      ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign
    };
  } else if (match = isoRegex.exec(input)) {
    sign = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign),
      M: parseIso(match[3], sign),
      w: parseIso(match[4], sign),
      d: parseIso(match[5], sign),
      h: parseIso(match[6], sign),
      m: parseIso(match[7], sign),
      s: parseIso(match[8], sign)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && (("from" in duration) || ("to" in duration))) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
function parseIso(inp, sign) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign;
}
function positiveMomentsDifference(base2, other) {
  var res = {};
  res.months = other.month() - base2.month() + (other.year() - base2.year()) * 12;
  if (base2.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base2.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base2, other) {
  var res;
  if (!(base2.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base2);
  if (base2.isBefore(other)) {
    res = positiveMomentsDifference(base2, other);
  } else {
    res = positiveMomentsDifference(other, base2);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months) {
    setMonth(mom, get(mom, "Month") + months * isAdding);
  }
  if (days) {
    set$1(mom, "Date", get(mom, "Date") + days * isAdding);
  }
  if (milliseconds) {
    mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days || months);
  }
}
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property, propertyLen = properties.length;
  for (i = 0;i < propertyLen; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property;
  for (i = 0;i < properties.length; i += 1) {
    property = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff = myMoment.diff(now2, "days", true);
  return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = undefined;
      formats = undefined;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = undefined;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = undefined;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now2) : formats[format]);
  return this.format(output || this.localeData().calendar(format, this, createLocal(now2)));
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from, to2, units, inclusivity) {
  var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 60000;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1000;
      break;
    case "minute":
      output = (this - that) / 60000;
      break;
    case "hour":
      output = (this - that) / 3600000;
      break;
    case "day":
      output = (this - that - zoneDelta) / 86400000;
      break;
    case "week":
      output = (this - that - zoneDelta) / 604800000;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a3, b6) {
  if (a3.date() < b6.date()) {
    return -monthDiff(b6, a3);
  }
  var wholeMonthDiff = (b6.year() - a3.year()) * 12 + (b6.month() - a3.month()), anchor = a3.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b6 - anchor < 0) {
    anchor2 = a3.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b6 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a3.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b6 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m3 = utc ? this.clone().utc() : this;
  if (m3.year() < 0 || m3.year() > 9999) {
    return formatMoment(m3, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace("Z", formatMoment(m3, "Z"));
    }
  }
  return formatMoment(m3, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to2(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === undefined) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
function localeData() {
  return this._locale;
}
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y5, m3, d4) {
  if (y5 < 100 && y5 >= 0) {
    return new Date(y5 + 400, m3, d4) - MS_PER_400_YEARS;
  } else {
    return new Date(y5, m3, d4).valueOf();
  }
}
function utcStartOfDate(y5, m3, d4) {
  if (y5 < 100 && y5 >= 0) {
    return Date.UTC(y5 + 400, m3, d4) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y5, m3, d4);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === undefined || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === undefined || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 60000;
}
function unix() {
  return Math.floor(this.valueOf() / 1000);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m3 = this;
  return [
    m3.year(),
    m3.month(),
    m3.date(),
    m3.hour(),
    m3.minute(),
    m3.second(),
    m3.millisecond()
  ];
}
function toObject() {
  var m3 = this;
  return {
    years: m3.year(),
    months: m3.month(),
    date: m3.date(),
    hours: m3.hours(),
    minutes: m3.minutes(),
    seconds: m3.seconds(),
    milliseconds: m3.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
function localeEras(m3, format2) {
  var i, l3, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l3, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === undefined) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l3, val, eras = this.localeData().eras();
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l3, val, eras = this.localeData().eras();
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l3, val, eras = this.localeData().eras();
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l3, dir, val, eras = this.localeData().eras();
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l3, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l3 = eras.length;i < l3; ++i) {
    erasName = regexEscape(eras[i].name);
    erasAbbr = regexEscape(eras[i].abbr);
    erasNarrow = regexEscape(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
}
function addWeekYearFormatToken(token, getter) {
  addFormatToken(0, [token, token.length], 0, getter);
}
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 86400000) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1000);
}
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
function createUnix(input) {
  return createLocal(input * 1000);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
function get$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber(format2)) {
    index2 = format2;
    format2 = undefined;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1(format2, index2, field, "month");
  }
  var i, out = [];
  for (i = 0;i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index2 = format2;
      format2 = undefined;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index2 = format2;
      format2 = undefined;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index2 != null) {
    return get$1(format2, (index2 + shift) % 7, field, "day");
  }
  for (i = 0;i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;
  if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
    milliseconds += absCeil(monthsToDays(months) + days) * 86400000;
    days = 0;
    months = 0;
  }
  data.milliseconds = milliseconds % 1000;
  seconds = absFloor(milliseconds / 1000);
  data.seconds = seconds % 60;
  minutes = absFloor(seconds / 60);
  data.minutes = minutes % 60;
  hours = absFloor(minutes / 60);
  data.hours = hours % 24;
  days += absFloor(hours / 24);
  monthsFromDays = absFloor(daysToMonths(days));
  months += monthsFromDays;
  days -= absCeil(monthsToDays(monthsFromDays));
  years = absFloor(months / 12);
  months %= 12;
  data.days = days;
  data.months = months;
  data.years = years;
  return this;
}
function daysToMonths(days) {
  return days * 4800 / 146097;
}
function monthsToDays(months) {
  return months * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days, months, milliseconds = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days = this._days + milliseconds / 86400000;
    months = this._months + daysToMonths(days);
    switch (units) {
      case "month":
        return months;
      case "quarter":
        return months / 3;
      case "year":
        return months / 12;
    }
  } else {
    days = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days / 7 + milliseconds / 604800000;
      case "day":
        return days + milliseconds / 86400000;
      case "hour":
        return days * 24 + milliseconds / 3600000;
      case "minute":
        return days * 1440 + milliseconds / 60000;
      case "second":
        return days * 86400 + milliseconds / 1000;
      case "millisecond":
        return Math.floor(days * 86400000) + milliseconds;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
function weeks() {
  return absFloor(this.days() / 7);
}
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a3 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a3 = a3 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a3 = a3 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a3[2] = withoutSuffix;
  a3[3] = +posNegDuration > 0;
  a3[4] = locale2;
  return substituteTimeAgo.apply(null, a3);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === undefined) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === undefined) {
    return false;
  }
  if (limit === undefined) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
function sign(x5) {
  return (x5 > 0) - (x5 < 0) || +x5;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1000, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var hookCallback, some, momentProperties, updateInProgress = false, deprecations, keys, defaultCalendar, formattingTokens, localFormattingTokens, formatFunctions, formatTokenFunctions, defaultLongDateFormat, defaultInvalidDate = "Invalid date", defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse, defaultRelativeTime, aliases, priorities, match1, match2, match3, match4, match6, match1to2, match3to4, match5to6, match1to3, match1to4, match1to6, matchUnsigned, matchSigned, matchOffset, matchShortOffset, matchTimestamp, matchWord, match1to2NoLeadingZero, match1to2HasZero, regexes, tokens, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8, getSetYear, indexOf, defaultLocaleMonths, defaultLocaleMonthsShort, MONTHS_IN_FORMAT, defaultMonthsShortRegex, defaultMonthsRegex, defaultLocaleWeek, defaultLocaleWeekdays, defaultLocaleWeekdaysShort, defaultLocaleWeekdaysMin, defaultWeekdaysRegex, defaultWeekdaysShortRegex, defaultWeekdaysMinRegex, defaultLocaleMeridiemParse, getSetHour, baseConfig, locales, localeFamilies, globalLocale, extendedIsoRegex, basicIsoRegex, tzRegex, isoDates, isoTimes, aspNetJsonRegex, rfc2822, obsOffsets, prototypeMin, prototypeMax, now = function() {
  return Date.now ? Date.now() : +new Date;
}, ordering, chunkOffset, aspNetRegex, isoRegex, add, subtract, lang, MS_PER_SECOND = 1000, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_400_YEARS, getSetDayOfMonth, getSetMinute, getSetSecond, token, getSetMillisecond, proto, proto$1, mathAbs, asMilliseconds, asSeconds, asMinutes, asHours, asDays, asWeeks, asMonths, asQuarters, asYears, valueOf$1, milliseconds, seconds, minutes, hours, days, months, years, round, thresholds, abs$1, proto$2, moment_default;
var init_moment = __esm(() => {
  //! moment.js
  //! version : 2.30.1
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function(fun) {
      var t = Object(this), len = t.length >>> 0, i;
      for (i = 0;i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  momentProperties = hooks.momentProperties = [];
  deprecations = {};
  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function(obj) {
      var i, res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  defaultCalendar = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
  };
  formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  formatFunctions = {};
  formatTokenFunctions = {};
  defaultLongDateFormat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  };
  defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  defaultRelativeTime = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  };
  aliases = {
    D: "date",
    dates: "date",
    date: "date",
    d: "day",
    days: "day",
    day: "day",
    e: "weekday",
    weekdays: "weekday",
    weekday: "weekday",
    E: "isoWeekday",
    isoweekdays: "isoWeekday",
    isoweekday: "isoWeekday",
    DDD: "dayOfYear",
    dayofyears: "dayOfYear",
    dayofyear: "dayOfYear",
    h: "hour",
    hours: "hour",
    hour: "hour",
    ms: "millisecond",
    milliseconds: "millisecond",
    millisecond: "millisecond",
    m: "minute",
    minutes: "minute",
    minute: "minute",
    M: "month",
    months: "month",
    month: "month",
    Q: "quarter",
    quarters: "quarter",
    quarter: "quarter",
    s: "second",
    seconds: "second",
    second: "second",
    gg: "weekYear",
    weekyears: "weekYear",
    weekyear: "weekYear",
    GG: "isoWeekYear",
    isoweekyears: "isoWeekYear",
    isoweekyear: "isoWeekYear",
    w: "week",
    weeks: "week",
    week: "week",
    W: "isoWeek",
    isoweeks: "isoWeek",
    isoweek: "isoWeek",
    y: "year",
    years: "year",
    year: "year"
  };
  priorities = {
    date: 9,
    day: 11,
    weekday: 11,
    isoWeekday: 11,
    dayOfYear: 4,
    hour: 13,
    millisecond: 16,
    minute: 14,
    month: 8,
    quarter: 7,
    second: 15,
    weekYear: 1,
    isoWeekYear: 1,
    week: 5,
    isoWeek: 5,
    year: 1
  };
  match1 = /\d/;
  match2 = /\d\d/;
  match3 = /\d{3}/;
  match4 = /\d{4}/;
  match6 = /[+-]?\d{6}/;
  match1to2 = /\d\d?/;
  match3to4 = /\d\d\d\d?/;
  match5to6 = /\d\d\d\d\d\d?/;
  match1to3 = /\d{1,3}/;
  match1to4 = /\d{1,4}/;
  match1to6 = /[+-]?\d{1,6}/;
  matchUnsigned = /\d+/;
  matchSigned = /[+-]?\d+/;
  matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
  matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
  match1to2NoLeadingZero = /^[1-9]\d?/;
  match1to2HasZero = /^([1-9]\d|\d)/;
  regexes = {};
  tokens = {};
  addFormatToken("Y", 0, 0, function() {
    var y5 = this.year();
    return y5 <= 9999 ? zeroFill(y5, 4) : "+" + y5;
  });
  addFormatToken(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
  addRegexToken("Y", matchSigned);
  addRegexToken("YY", match1to2, match2);
  addRegexToken("YYYY", match1to4, match4);
  addRegexToken("YYYYY", match1to6, match6);
  addRegexToken("YYYYYY", match1to6, match6);
  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function(input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken("YY", function(input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken("Y", function(input, array) {
    array[YEAR] = parseInt(input, 10);
  });
  hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };
  getSetYear = makeGetSet("FullYear", true);
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function(o2) {
      var i;
      for (i = 0;i < this.length; ++i) {
        if (this[i] === o2) {
          return i;
        }
      }
      return -1;
    };
  }
  addFormatToken("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  });
  addFormatToken("MMM", 0, 0, function(format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken("MMMM", 0, 0, function(format) {
    return this.localeData().months(this, format);
  });
  addRegexToken("M", match1to2, match1to2NoLeadingZero);
  addRegexToken("MM", match1to2, match2);
  addRegexToken("MMM", function(isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken("MMMM", function(isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(["M", "MM"], function(input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(["MMM", "MMMM"], function(input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
  defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
  MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  defaultMonthsShortRegex = matchWord;
  defaultMonthsRegex = matchWord;
  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
  addRegexToken("w", match1to2, match1to2NoLeadingZero);
  addRegexToken("ww", match1to2, match2);
  addRegexToken("W", match1to2, match1to2NoLeadingZero);
  addRegexToken("WW", match1to2, match2);
  addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });
  defaultLocaleWeek = {
    dow: 0,
    doy: 6
  };
  addFormatToken("d", 0, "do", "day");
  addFormatToken("dd", 0, 0, function(format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken("ddd", 0, 0, function(format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken("dddd", 0, 0, function(format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");
  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", function(isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken("ddd", function(isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken("dddd", function(isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(["d", "e", "E"], function(input, week, config, token) {
    week[token] = toInt(input);
  });
  defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
  defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
  defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
  defaultWeekdaysRegex = matchWord;
  defaultWeekdaysShortRegex = matchWord;
  defaultWeekdaysMinRegex = matchWord;
  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, hFormat);
  addFormatToken("k", ["kk", 2], 0, kFormat);
  addFormatToken("hmm", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken("hmmss", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken("Hmm", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken("Hmmss", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  meridiem("a", true);
  meridiem("A", false);
  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2, match1to2HasZero);
  addRegexToken("h", match1to2, match1to2NoLeadingZero);
  addRegexToken("k", match1to2, match1to2NoLeadingZero);
  addRegexToken("HH", match1to2, match2);
  addRegexToken("hh", match1to2, match2);
  addRegexToken("kk", match1to2, match2);
  addRegexToken("hmm", match3to4);
  addRegexToken("hmmss", match5to6);
  addRegexToken("Hmm", match3to4);
  addRegexToken("Hmmss", match5to6);
  addParseToken(["H", "HH"], HOUR);
  addParseToken(["k", "kk"], function(input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(["a", "A"], function(input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(["h", "hh"], function(input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmm", function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmmss", function(input, array, config) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("Hmm", function(input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken("Hmmss", function(input, array, config) {
    var pos1 = input.length - 4, pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });
  defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  getSetHour = makeGetSet("Hours", true);
  baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };
  locales = {};
  localeFamilies = {};
  extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  isoDates = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
    ["YYYY-DDD", /\d{4}-\d{3}/],
    ["YYYY-MM", /\d{4}-\d\d/, false],
    ["YYYYYYMMDD", /[+-]\d{10}/],
    ["YYYYMMDD", /\d{8}/],
    ["GGGG[W]WWE", /\d{4}W\d{3}/],
    ["GGGG[W]WW", /\d{4}W\d{2}/, false],
    ["YYYYDDD", /\d{7}/],
    ["YYYYMM", /\d{6}/, false],
    ["YYYY", /\d{4}/, false]
  ];
  isoTimes = [
    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
    ["HH:mm", /\d\d:\d\d/],
    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
    ["HHmmss", /\d\d\d\d\d\d/],
    ["HHmm", /\d\d\d\d/],
    ["HH", /\d\d/]
  ];
  aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
  rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
  obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " + "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
  });
  hooks.ISO_8601 = function() {
  };
  hooks.RFC_2822 = function() {
  };
  prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  });
  prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  });
  ordering = [
    "year",
    "quarter",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  offset("Z", ":");
  offset("ZZ", "");
  addRegexToken("Z", matchShortOffset);
  addRegexToken("ZZ", matchShortOffset);
  addParseToken(["Z", "ZZ"], function(input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  chunkOffset = /([\+\-]|\d\d)/gi;
  hooks.updateOffset = function() {
  };
  aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
  isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;
  add = createAdder(1, "add");
  subtract = createAdder(-1, "subtract");
  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  MS_PER_MINUTE = 60 * MS_PER_SECOND;
  MS_PER_HOUR = 60 * MS_PER_MINUTE;
  MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
  addFormatToken("N", 0, 0, "eraAbbr");
  addFormatToken("NN", 0, 0, "eraAbbr");
  addFormatToken("NNN", 0, 0, "eraAbbr");
  addFormatToken("NNNN", 0, 0, "eraName");
  addFormatToken("NNNNN", 0, 0, "eraNarrow");
  addFormatToken("y", ["y", 1], "yo", "eraYear");
  addFormatToken("y", ["yy", 2], 0, "eraYear");
  addFormatToken("y", ["yyy", 3], 0, "eraYear");
  addFormatToken("y", ["yyyy", 4], 0, "eraYear");
  addRegexToken("N", matchEraAbbr);
  addRegexToken("NN", matchEraAbbr);
  addRegexToken("NNN", matchEraAbbr);
  addRegexToken("NNNN", matchEraName);
  addRegexToken("NNNNN", matchEraNarrow);
  addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token) {
    var era = config._locale.erasParse(input, token, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  });
  addRegexToken("y", matchUnsigned);
  addRegexToken("yy", matchUnsigned);
  addRegexToken("yyy", matchUnsigned);
  addRegexToken("yyyy", matchUnsigned);
  addRegexToken("yo", matchEraYearOrdinal);
  addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
  addParseToken(["yo"], function(input, array, config, token) {
    var match;
    if (config._locale._eraYearOrdinalRegex) {
      match = input.match(config._locale._eraYearOrdinalRegex);
    }
    if (config._locale.eraYearOrdinalParse) {
      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
    } else {
      array[YEAR] = parseInt(input, 10);
    }
  });
  addFormatToken(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");
  addRegexToken("G", matchSigned);
  addRegexToken("g", matchSigned);
  addRegexToken("GG", match1to2, match2);
  addRegexToken("gg", match1to2, match2);
  addRegexToken("GGGG", match1to4, match4);
  addRegexToken("gggg", match1to4, match4);
  addRegexToken("GGGGG", match1to6, match6);
  addRegexToken("ggggg", match1to6, match6);
  addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(["gg", "GG"], function(input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  });
  addFormatToken("Q", 0, "Qo", "quarter");
  addRegexToken("Q", match1);
  addParseToken("Q", function(input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  addFormatToken("D", ["DD", 2], "Do", "date");
  addRegexToken("D", match1to2, match1to2NoLeadingZero);
  addRegexToken("DD", match1to2, match2);
  addRegexToken("Do", function(isStrict, locale2) {
    return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });
  getSetDayOfMonth = makeGetSet("Date", true);
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  addRegexToken("DDD", match1to3);
  addRegexToken("DDDD", match3);
  addParseToken(["DDD", "DDDD"], function(input, array, config) {
    config._dayOfYear = toInt(input);
  });
  addFormatToken("m", ["mm", 2], 0, "minute");
  addRegexToken("m", match1to2, match1to2HasZero);
  addRegexToken("mm", match1to2, match2);
  addParseToken(["m", "mm"], MINUTE);
  getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second");
  addRegexToken("s", match1to2, match1to2HasZero);
  addRegexToken("ss", match1to2, match2);
  addParseToken(["s", "ss"], SECOND);
  getSetSecond = makeGetSet("Seconds", false);
  addFormatToken("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function() {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ["SSSSS", 5], 0, function() {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function() {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function() {
    return this.millisecond() * 1e4;
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
    return this.millisecond() * 1e5;
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
    return this.millisecond() * 1e6;
  });
  addRegexToken("S", match1to3, match1);
  addRegexToken("SS", match1to3, match2);
  addRegexToken("SSS", match1to3, match3);
  for (token = "SSSS";token.length <= 9; token += "S") {
    addRegexToken(token, matchUnsigned);
  }
  for (token = "S";token.length <= 9; token += "S") {
    addParseToken(token, parseMs);
  }
  getSetMillisecond = makeGetSet("Milliseconds", false);
  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");
  proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to2;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  if (typeof Symbol !== "undefined" && Symbol.for != null) {
    proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    };
  }
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
  proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
  proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
  proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
  proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
  proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;
  getSetGlobalLocale("en", {
    eras: [
      {
        since: "0001-01-01",
        until: Infinity,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
      },
      {
        since: "0000-12-31",
        until: -Infinity,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
      }
    ],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(number) {
      var b6 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b6 === 1 ? "st" : b6 === 2 ? "nd" : b6 === 3 ? "rd" : "th";
      return number + output;
    }
  });
  hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
  hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
  mathAbs = Math.abs;
  asMilliseconds = makeAs("ms");
  asSeconds = makeAs("s");
  asMinutes = makeAs("m");
  asHours = makeAs("h");
  asDays = makeAs("d");
  asWeeks = makeAs("w");
  asMonths = makeAs("M");
  asQuarters = makeAs("Q");
  asYears = makeAs("y");
  valueOf$1 = asMilliseconds;
  milliseconds = makeGetter("milliseconds");
  seconds = makeGetter("seconds");
  minutes = makeGetter("minutes");
  hours = makeGetter("hours");
  days = makeGetter("days");
  months = makeGetter("months");
  years = makeGetter("years");
  round = Math.round;
  thresholds = {
    ss: 44,
    s: 45,
    m: 45,
    h: 22,
    d: 26,
    w: null,
    M: 11
  };
  abs$1 = Math.abs;
  proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
  proto$2.lang = lang;
  addFormatToken("X", 0, 0, "unix");
  addFormatToken("x", 0, 0, "valueOf");
  addRegexToken("x", matchSigned);
  addRegexToken("X", matchTimestamp);
  addParseToken("X", function(input, array, config) {
    config._d = new Date(parseFloat(input) * 1000);
  });
  addParseToken("x", function(input, array, config) {
    config._d = new Date(toInt(input));
  });
  //! moment.js
  hooks.version = "2.30.1";
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    DATE: "YYYY-MM-DD",
    TIME: "HH:mm",
    TIME_SECONDS: "HH:mm:ss",
    TIME_MS: "HH:mm:ss.SSS",
    WEEK: "GGGG-[W]WW",
    MONTH: "YYYY-MM"
  };
  moment_default = hooks;
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id2,
  scrypt: () => Td2,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga2
});
function dw() {
  return Hq;
}
var pw, Xa, vw, bw, mw, gw, R0 = (t, e) => () => (t && (e = t(t = 0)), e), T3 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Ja = (t, e) => {
  for (var r in e)
    Xa(t, r, { get: e[r], enumerable: true });
}, Ya2 = (t, e, r, o2) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f3 of bw(e))
      !gw.call(t, f3) && f3 !== r && Xa(t, f3, { get: () => e[f3], enumerable: !(o2 = vw(e, f3)) || o2.enumerable });
  return t;
}, ot3 = (t, e, r) => (Ya2(t, e, "default"), r && Ya2(r, e, "default")), rn2 = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya2(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t)), ur2 = (t) => Ya2(Xa({}, "__esModule", { value: true }), t), Nd, Dd2, Ut3, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh2, Ao, Bo, pn2, _p, Ep, gh, qp, yh, Op, ko, Tt5, Gr2, No, Jt, pa, Rh, pr2, Y_, Oi, Fi, Ui, k1, yn2, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr2, fu2, ou2, os, eb, cu2, lb, bu, vf2, S7, db, yi2, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu2, Au, Ub, Iu, Tu, ar2, vs, ku, Yb, Qb, em, im, nm, yf2, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji2, Yu2, Ym, Xm, As, tl, ol2, rg, ag, hg, hl2, pg, dl2, kn, cl3, bl, Ln3, Ds, Lg, Dg, yl2, Il, Yg, t2, i2, Ws2, Ks2, s2, ri3, Nl, or, Oa, b22, y22, _22, Pl, Cr3, Tf, Cl, N22, Fl, F2, Wl, Z22, V22, Q22, ty, e0, ny2, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy2, dd, r3, n3, o3, cd2, d32, p3, v32, m3, Ha, bd, _32, A32, k32, N32, P32, _d, xd2, w0, Ed, j32, Y3, X32, ow, qd, Xt2, zq, Ga2 = "buffer", uw = (t) => crypto.getRandomValues(t), lw = () => crypto.randomUUID(), Hq, x0, Id2, Td2, cw, Wq;
var init_crypto2 = __esm(() => {
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  Nd = T3((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr[45] = 62;
    lr[95] = 63;
    function Ld(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o2 = r === e ? 0 : 4 - r % 4;
      return [r, o2];
    }
    function ww(t) {
      var e = Ld(t), r = e[0], o2 = e[1];
      return (r + o2) * 3 / 4 - o2;
    }
    function Mw(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e, r = Ld(t), o2 = r[0], f3 = r[1], p3 = new yw(Mw(t, o2, f3)), m3 = 0, y5 = f3 > 0 ? o2 - 4 : o2, M3;
      for (M3 = 0;M3 < y5; M3 += 4)
        e = lr[t.charCodeAt(M3)] << 18 | lr[t.charCodeAt(M3 + 1)] << 12 | lr[t.charCodeAt(M3 + 2)] << 6 | lr[t.charCodeAt(M3 + 3)], p3[m3++] = e >> 16 & 255, p3[m3++] = e >> 8 & 255, p3[m3++] = e & 255;
      return f3 === 2 && (e = lr[t.charCodeAt(M3)] << 2 | lr[t.charCodeAt(M3 + 1)] >> 4, p3[m3++] = e & 255), f3 === 1 && (e = lr[t.charCodeAt(M3)] << 10 | lr[t.charCodeAt(M3 + 1)] << 4 | lr[t.charCodeAt(M3 + 2)] >> 2, p3[m3++] = e >> 8 & 255, p3[m3++] = e & 255), p3;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e, r) {
      for (var o2, f3 = [], p3 = e;p3 < r; p3 += 3)
        o2 = (t[p3] << 16 & 16711680) + (t[p3 + 1] << 8 & 65280) + (t[p3 + 2] & 255), f3.push(xw(o2));
      return f3.join("");
    }
    function Ew(t) {
      for (var e, r = t.length, o2 = r % 3, f3 = [], p3 = 16383, m3 = 0, y5 = r - o2;m3 < y5; m3 += p3)
        f3.push(Sw(t, m3, m3 + p3 > y5 ? y5 : m3 + p3));
      return o2 === 1 ? (e = t[r - 1], f3.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o2 === 2 && (e = (t[r - 2] << 8) + t[r - 1], f3.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f3.join("");
    }
  });
  Dd2 = T3((q0) => {
    q0.read = function(t, e, r, o2, f3) {
      var p3, m3, y5 = f3 * 8 - o2 - 1, M3 = (1 << y5) - 1, x5 = M3 >> 1, S3 = -7, E6 = r ? f3 - 1 : 0, B3 = r ? -1 : 1, q3 = t[e + E6];
      for (E6 += B3, p3 = q3 & (1 << -S3) - 1, q3 >>= -S3, S3 += y5;S3 > 0; p3 = p3 * 256 + t[e + E6], E6 += B3, S3 -= 8)
        ;
      for (m3 = p3 & (1 << -S3) - 1, p3 >>= -S3, S3 += o2;S3 > 0; m3 = m3 * 256 + t[e + E6], E6 += B3, S3 -= 8)
        ;
      if (p3 === 0)
        p3 = 1 - x5;
      else {
        if (p3 === M3)
          return m3 ? NaN : (q3 ? -1 : 1) * (1 / 0);
        m3 = m3 + Math.pow(2, o2), p3 = p3 - x5;
      }
      return (q3 ? -1 : 1) * m3 * Math.pow(2, p3 - o2);
    };
    q0.write = function(t, e, r, o2, f3, p3) {
      var m3, y5, M3, x5 = p3 * 8 - f3 - 1, S3 = (1 << x5) - 1, E6 = S3 >> 1, B3 = f3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q3 = o2 ? 0 : p3 - 1, L4 = o2 ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y5 = isNaN(e) ? 1 : 0, m3 = S3) : (m3 = Math.floor(Math.log(e) / Math.LN2), e * (M3 = Math.pow(2, -m3)) < 1 && (m3--, M3 *= 2), m3 + E6 >= 1 ? e += B3 / M3 : e += B3 * Math.pow(2, 1 - E6), e * M3 >= 2 && (m3++, M3 /= 2), m3 + E6 >= S3 ? (y5 = 0, m3 = S3) : m3 + E6 >= 1 ? (y5 = (e * M3 - 1) * Math.pow(2, f3), m3 = m3 + E6) : (y5 = e * Math.pow(2, E6 - 1) * Math.pow(2, f3), m3 = 0));f3 >= 8; t[r + q3] = y5 & 255, q3 += L4, y5 /= 256, f3 -= 8)
        ;
      for (m3 = m3 << f3 | y5, x5 += f3;x5 > 0; t[r + q3] = m3 & 255, q3 += L4, m3 /= 256, x5 -= 8)
        ;
      t[r + q3 - L4] |= ge * 128;
    };
  });
  Ut3 = T3((Xn) => {
    var I02 = Nd(), Gn = Dd2(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo2 = 2147483647;
    Xn.kMaxLength = eo2;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li2(t) {
      if (t > eo2)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, me.prototype), e;
    }
    function me(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e, r);
    }
    me.poolSize = 8192;
    function Ud(t, e, r) {
      if (typeof t == "string")
        return Bw(t, e);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr2(t, ArrayBuffer) || t && Zr2(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr2(t, SharedArrayBuffer) || t && Zr2(t.buffer, SharedArrayBuffer)))
        return k0(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o2 = t.valueOf && t.valueOf();
      if (o2 != null && o2 !== t)
        return me.from(o2, e, r);
      let f3 = Iw(t);
      if (f3)
        return f3;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e, r) {
      return Ud(t, e, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e, r) {
      return zd(t), t <= 0 ? li2(t) : e !== undefined ? typeof r == "string" ? li2(t).fill(e, r) : li2(t).fill(e) : li2(t);
    }
    me.alloc = function(t, e, r) {
      return Rw(t, e, r);
    };
    function N0(t) {
      return zd(t), li2(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = Hd(t, e) | 0, o2 = li2(r), f3 = o2.write(t, e);
      return f3 !== r && (o2 = o2.slice(0, f3)), o2;
    }
    function T0(t) {
      let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li2(e);
      for (let o2 = 0;o2 < e; o2 += 1)
        r[o2] = t[o2] & 255;
      return r;
    }
    function qw(t) {
      if (Zr2(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return k0(e.buffer, e.byteOffset, e.byteLength);
      }
      return T0(t);
    }
    function k0(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o2;
      return e === undefined && r === undefined ? o2 = new Uint8Array(t) : r === undefined ? o2 = new Uint8Array(t, e) : o2 = new Uint8Array(t, e, r), Object.setPrototypeOf(o2, me.prototype), o2;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e = D0(t.length) | 0, r = li2(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li2(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo2)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo2.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== me.prototype;
    };
    me.compare = function(e, r) {
      if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr2(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o2 = e.length, f3 = r.length;
      for (let p3 = 0, m3 = Math.min(o2, f3);p3 < m3; ++p3)
        if (e[p3] !== r[p3]) {
          o2 = e[p3], f3 = r[p3];
          break;
        }
      return o2 < f3 ? -1 : f3 < o2 ? 1 : 0;
    };
    me.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return me.alloc(0);
      let o2;
      if (r === undefined)
        for (r = 0, o2 = 0;o2 < e.length; ++o2)
          r += e[o2].length;
      let f3 = me.allocUnsafe(r), p3 = 0;
      for (o2 = 0;o2 < e.length; ++o2) {
        let m3 = e[o2];
        if (Zr2(m3, Uint8Array))
          p3 + m3.length > f3.length ? (me.isBuffer(m3) || (m3 = me.from(m3)), m3.copy(f3, p3)) : Uint8Array.prototype.set.call(f3, m3, p3);
        else if (me.isBuffer(m3))
          m3.copy(f3, p3);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p3 += m3.length;
      }
      return f3;
    };
    function Hd(t, e) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr2(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o2 = arguments.length > 2 && arguments[2] === true;
      if (!o2 && r === 0)
        return 0;
      let f3 = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f3)
              return o2 ? -1 : L0(t).length;
            e = ("" + e).toLowerCase(), f3 = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e, r) {
      let o2 = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e, r);
          case "ascii":
            return Uw(this, e, r);
          case "latin1":
          case "binary":
            return zw(this, e, r);
          case "base64":
            return Ow(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e, r);
          default:
            if (o2)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o2 = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e, r) {
      let o2 = t[e];
      t[e] = t[r], t[r] = o2;
    }
    me.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e) {
      if (!me.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : me.compare(this, e) === 0;
    };
    me.prototype.inspect = function() {
      let e = "", r = Xn.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e, r, o2, f3, p3) {
      if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o2 === undefined && (o2 = e ? e.length : 0), f3 === undefined && (f3 = 0), p3 === undefined && (p3 = this.length), r < 0 || o2 > e.length || f3 < 0 || p3 > this.length)
        throw new RangeError("out of range index");
      if (f3 >= p3 && r >= o2)
        return 0;
      if (f3 >= p3)
        return -1;
      if (r >= o2)
        return 1;
      if (r >>>= 0, o2 >>>= 0, f3 >>>= 0, p3 >>>= 0, this === e)
        return 0;
      let m3 = p3 - f3, y5 = o2 - r, M3 = Math.min(m3, y5), x5 = this.slice(f3, p3), S3 = e.slice(r, o2);
      for (let E6 = 0;E6 < M3; ++E6)
        if (x5[E6] !== S3[E6]) {
          m3 = x5[E6], y5 = S3[E6];
          break;
        }
      return m3 < y5 ? -1 : y5 < m3 ? 1 : 0;
    };
    function Wd2(t, e, r, o2, f3) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o2 = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f3 ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f3)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f3)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = me.from(e, o2)), me.isBuffer(e))
        return e.length === 0 ? -1 : Cd(t, e, r, o2, f3);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f3 ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o2, f3);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e, r, o2, f3) {
      let p3 = 1, m3 = t.length, y5 = e.length;
      if (o2 !== undefined && (o2 = String(o2).toLowerCase(), o2 === "ucs2" || o2 === "ucs-2" || o2 === "utf16le" || o2 === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p3 = 2, m3 /= 2, y5 /= 2, r /= 2;
      }
      function M3(S3, E6) {
        return p3 === 1 ? S3[E6] : S3.readUInt16BE(E6 * p3);
      }
      let x5;
      if (f3) {
        let S3 = -1;
        for (x5 = r;x5 < m3; x5++)
          if (M3(t, x5) === M3(e, S3 === -1 ? 0 : x5 - S3)) {
            if (S3 === -1 && (S3 = x5), x5 - S3 + 1 === y5)
              return S3 * p3;
          } else
            S3 !== -1 && (x5 -= x5 - S3), S3 = -1;
      } else
        for (r + y5 > m3 && (r = m3 - y5), x5 = r;x5 >= 0; x5--) {
          let S3 = true;
          for (let E6 = 0;E6 < y5; E6++)
            if (M3(t, x5 + E6) !== M3(e, E6)) {
              S3 = false;
              break;
            }
          if (S3)
            return x5;
        }
      return -1;
    }
    me.prototype.includes = function(e, r, o2) {
      return this.indexOf(e, r, o2) !== -1;
    };
    me.prototype.indexOf = function(e, r, o2) {
      return Wd2(this, e, r, o2, true);
    };
    me.prototype.lastIndexOf = function(e, r, o2) {
      return Wd2(this, e, r, o2, false);
    };
    function Lw(t, e, r, o2) {
      r = Number(r) || 0;
      let f3 = t.length - r;
      o2 ? (o2 = Number(o2), o2 > f3 && (o2 = f3)) : o2 = f3;
      let p3 = e.length;
      o2 > p3 / 2 && (o2 = p3 / 2);
      let m3;
      for (m3 = 0;m3 < o2; ++m3) {
        let y5 = parseInt(e.substr(m3 * 2, 2), 16);
        if (C0(y5))
          return m3;
        t[r + m3] = y5;
      }
      return m3;
    }
    function Nw(t, e, r, o2) {
      return to3(L0(e, t.length - r), t, r, o2);
    }
    function Dw(t, e, r, o2) {
      return to3(Vw(e), t, r, o2);
    }
    function Pw(t, e, r, o2) {
      return to3(Xd(e), t, r, o2);
    }
    function Cw(t, e, r, o2) {
      return to3($w(e, t.length - r), t, r, o2);
    }
    me.prototype.write = function(e, r, o2, f3) {
      if (r === undefined)
        f3 = "utf8", o2 = this.length, r = 0;
      else if (o2 === undefined && typeof r == "string")
        f3 = r, o2 = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o2) ? (o2 = o2 >>> 0, f3 === undefined && (f3 = "utf8")) : (f3 = o2, o2 = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p3 = this.length - r;
      if ((o2 === undefined || o2 > p3) && (o2 = p3), e.length > 0 && (o2 < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f3 || (f3 = "utf8");
      let m3 = false;
      for (;; )
        switch (f3) {
          case "hex":
            return Lw(this, e, r, o2);
          case "utf8":
          case "utf-8":
            return Nw(this, e, r, o2);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e, r, o2);
          case "base64":
            return Pw(this, e, r, o2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e, r, o2);
          default:
            if (m3)
              throw new TypeError("Unknown encoding: " + f3);
            f3 = ("" + f3).toLowerCase(), m3 = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e, r) {
      return e === 0 && r === t.length ? I02.fromByteArray(t) : I02.fromByteArray(t.slice(e, r));
    }
    function Kd(t, e, r) {
      r = Math.min(t.length, r);
      let o2 = [], f3 = e;
      for (;f3 < r; ) {
        let p3 = t[f3], m3 = null, y5 = p3 > 239 ? 4 : p3 > 223 ? 3 : p3 > 191 ? 2 : 1;
        if (f3 + y5 <= r) {
          let M3, x5, S3, E6;
          switch (y5) {
            case 1:
              p3 < 128 && (m3 = p3);
              break;
            case 2:
              M3 = t[f3 + 1], (M3 & 192) === 128 && (E6 = (p3 & 31) << 6 | M3 & 63, E6 > 127 && (m3 = E6));
              break;
            case 3:
              M3 = t[f3 + 1], x5 = t[f3 + 2], (M3 & 192) === 128 && (x5 & 192) === 128 && (E6 = (p3 & 15) << 12 | (M3 & 63) << 6 | x5 & 63, E6 > 2047 && (E6 < 55296 || E6 > 57343) && (m3 = E6));
              break;
            case 4:
              M3 = t[f3 + 1], x5 = t[f3 + 2], S3 = t[f3 + 3], (M3 & 192) === 128 && (x5 & 192) === 128 && (S3 & 192) === 128 && (E6 = (p3 & 15) << 18 | (M3 & 63) << 12 | (x5 & 63) << 6 | S3 & 63, E6 > 65535 && E6 < 1114112 && (m3 = E6));
          }
        }
        m3 === null ? (m3 = 65533, y5 = 1) : m3 > 65535 && (m3 -= 65536, o2.push(m3 >>> 10 & 1023 | 55296), m3 = 56320 | m3 & 1023), o2.push(m3), f3 += y5;
      }
      return Fw(o2);
    }
    var Od = 4096;
    function Fw(t) {
      let e = t.length;
      if (e <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o2 = 0;
      for (;o2 < e; )
        r += String.fromCharCode.apply(String, t.slice(o2, o2 += Od));
      return r;
    }
    function Uw(t, e, r) {
      let o2 = "";
      r = Math.min(t.length, r);
      for (let f3 = e;f3 < r; ++f3)
        o2 += String.fromCharCode(t[f3] & 127);
      return o2;
    }
    function zw(t, e, r) {
      let o2 = "";
      r = Math.min(t.length, r);
      for (let f3 = e;f3 < r; ++f3)
        o2 += String.fromCharCode(t[f3]);
      return o2;
    }
    function Hw(t, e, r) {
      let o2 = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o2) && (r = o2);
      let f3 = "";
      for (let p3 = e;p3 < r; ++p3)
        f3 += Gw[t[p3]];
      return f3;
    }
    function Ww(t, e, r) {
      let o2 = t.slice(e, r), f3 = "";
      for (let p3 = 0;p3 < o2.length - 1; p3 += 2)
        f3 += String.fromCharCode(o2[p3] + o2[p3 + 1] * 256);
      return f3;
    }
    me.prototype.slice = function(e, r) {
      let o2 = this.length;
      e = ~~e, r = r === undefined ? o2 : ~~r, e < 0 ? (e += o2, e < 0 && (e = 0)) : e > o2 && (e = o2), r < 0 ? (r += o2, r < 0 && (r = 0)) : r > o2 && (r = o2), r < e && (r = e);
      let f3 = this.subarray(e, r);
      return Object.setPrototypeOf(f3, me.prototype), f3;
    };
    function Dt2(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f3 = this[e], p3 = 1, m3 = 0;
      for (;++m3 < r && (p3 *= 256); )
        f3 += this[e + m3] * p3;
      return f3;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f3 = this[e + --r], p3 = 1;
      for (;r > 0 && (p3 *= 256); )
        f3 += this[e + --r] * p3;
      return f3;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 1, this.length), this[e];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    me.prototype.readBigUInt64LE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f3 = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p3 = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o2 * 2 ** 24;
      return BigInt(f3) + (BigInt(p3) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f3 = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p3 = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o2;
      return (BigInt(f3) << BigInt(32)) + BigInt(p3);
    });
    me.prototype.readIntLE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f3 = this[e], p3 = 1, m3 = 0;
      for (;++m3 < r && (p3 *= 256); )
        f3 += this[e + m3] * p3;
      return p3 *= 128, f3 >= p3 && (f3 -= Math.pow(2, 8 * r)), f3;
    };
    me.prototype.readIntBE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f3 = r, p3 = 1, m3 = this[e + --f3];
      for (;f3 > 0 && (p3 *= 256); )
        m3 += this[e + --f3] * p3;
      return p3 *= 128, m3 >= p3 && (m3 -= Math.pow(2, 8 * r)), m3;
    };
    me.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    me.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Dt2(e, 2, this.length);
      let o2 = this[e] | this[e + 1] << 8;
      return o2 & 32768 ? o2 | 4294901760 : o2;
    };
    me.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Dt2(e, 2, this.length);
      let o2 = this[e + 1] | this[e] << 8;
      return o2 & 32768 ? o2 | 4294901760 : o2;
    };
    me.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    me.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    me.prototype.readBigInt64LE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f3 = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o2 << 24);
      return (BigInt(f3) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f3 = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f3) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o2);
    });
    me.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), Gn.read(this, e, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), Gn.read(this, e, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 8, this.length), Gn.read(this, e, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 8, this.length), Gn.read(this, e, false, 52, 8);
    };
    function er2(t, e, r, o2, f3, p3) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f3 || e < p3)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o2 > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o2, f3) {
      if (e = +e, r = r >>> 0, o2 = o2 >>> 0, !f3) {
        let y5 = Math.pow(2, 8 * o2) - 1;
        er2(this, e, r, o2, y5, 0);
      }
      let p3 = 1, m3 = 0;
      for (this[r] = e & 255;++m3 < o2 && (p3 *= 256); )
        this[r + m3] = e / p3 & 255;
      return r + o2;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o2, f3) {
      if (e = +e, r = r >>> 0, o2 = o2 >>> 0, !f3) {
        let y5 = Math.pow(2, 8 * o2) - 1;
        er2(this, e, r, o2, y5, 0);
      }
      let p3 = o2 - 1, m3 = 1;
      for (this[r + p3] = e & 255;--p3 >= 0 && (m3 *= 256); )
        this[r + p3] = e / m3 & 255;
      return r + o2;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function jd(t, e, r, o2, f3) {
      Yd(e, o2, f3, t, r, 7);
      let p3 = Number(e & BigInt(4294967295));
      t[r++] = p3, p3 = p3 >> 8, t[r++] = p3, p3 = p3 >> 8, t[r++] = p3, p3 = p3 >> 8, t[r++] = p3;
      let m3 = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m3, m3 = m3 >> 8, t[r++] = m3, m3 = m3 >> 8, t[r++] = m3, m3 = m3 >> 8, t[r++] = m3, r;
    }
    function Zd(t, e, r, o2, f3) {
      Yd(e, o2, f3, t, r, 7);
      let p3 = Number(e & BigInt(4294967295));
      t[r + 7] = p3, p3 = p3 >> 8, t[r + 6] = p3, p3 = p3 >> 8, t[r + 5] = p3, p3 = p3 >> 8, t[r + 4] = p3;
      let m3 = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m3, m3 = m3 >> 8, t[r + 2] = m3, m3 = m3 >> 8, t[r + 1] = m3, m3 = m3 >> 8, t[r] = m3, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti2(function(e, r = 0) {
      return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti2(function(e, r = 0) {
      return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e, r, o2, f3) {
      if (e = +e, r = r >>> 0, !f3) {
        let M3 = Math.pow(2, 8 * o2 - 1);
        er2(this, e, r, o2, M3 - 1, -M3);
      }
      let p3 = 0, m3 = 1, y5 = 0;
      for (this[r] = e & 255;++p3 < o2 && (m3 *= 256); )
        e < 0 && y5 === 0 && this[r + p3 - 1] !== 0 && (y5 = 1), this[r + p3] = (e / m3 >> 0) - y5 & 255;
      return r + o2;
    };
    me.prototype.writeIntBE = function(e, r, o2, f3) {
      if (e = +e, r = r >>> 0, !f3) {
        let M3 = Math.pow(2, 8 * o2 - 1);
        er2(this, e, r, o2, M3 - 1, -M3);
      }
      let p3 = o2 - 1, m3 = 1, y5 = 0;
      for (this[r + p3] = e & 255;--p3 >= 0 && (m3 *= 256); )
        e < 0 && y5 === 0 && this[r + p3 + 1] !== 0 && (y5 = 1), this[r + p3] = (e / m3 >> 0) - y5 & 255;
      return r + o2;
    };
    me.prototype.writeInt8 = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti2(function(e, r = 0) {
      return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti2(function(e, r = 0) {
      return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e, r, o2, f3, p3) {
      if (r + o2 > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e, r, o2, f3) {
      return e = +e, r = r >>> 0, f3 || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o2, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e, r, o2) {
      return $d(this, e, r, true, o2);
    };
    me.prototype.writeFloatBE = function(e, r, o2) {
      return $d(this, e, r, false, o2);
    };
    function Gd2(t, e, r, o2, f3) {
      return e = +e, r = r >>> 0, f3 || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o2, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e, r, o2) {
      return Gd2(this, e, r, true, o2);
    };
    me.prototype.writeDoubleBE = function(e, r, o2) {
      return Gd2(this, e, r, false, o2);
    };
    me.prototype.copy = function(e, r, o2, f3) {
      if (!me.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o2 || (o2 = 0), !f3 && f3 !== 0 && (f3 = this.length), r >= e.length && (r = e.length), r || (r = 0), f3 > 0 && f3 < o2 && (f3 = o2), f3 === o2 || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o2 < 0 || o2 >= this.length)
        throw new RangeError("Index out of range");
      if (f3 < 0)
        throw new RangeError("sourceEnd out of bounds");
      f3 > this.length && (f3 = this.length), e.length - r < f3 - o2 && (f3 = e.length - r + o2);
      let p3 = f3 - o2;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o2, f3) : Uint8Array.prototype.set.call(e, this.subarray(o2, f3), r), p3;
    };
    me.prototype.fill = function(e, r, o2, f3) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f3 = r, r = 0, o2 = this.length) : typeof o2 == "string" && (f3 = o2, o2 = this.length), f3 !== undefined && typeof f3 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f3 == "string" && !me.isEncoding(f3))
          throw new TypeError("Unknown encoding: " + f3);
        if (e.length === 1) {
          let m3 = e.charCodeAt(0);
          (f3 === "utf8" && m3 < 128 || f3 === "latin1") && (e = m3);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o2)
        throw new RangeError("Out of range index");
      if (o2 <= r)
        return this;
      r = r >>> 0, o2 = o2 === undefined ? this.length : o2 >>> 0, e || (e = 0);
      let p3;
      if (typeof e == "number")
        for (p3 = r;p3 < o2; ++p3)
          this[p3] = e;
      else {
        let m3 = me.isBuffer(e) ? e : me.from(e, f3), y5 = m3.length;
        if (y5 === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p3 = 0;p3 < o2 - r; ++p3)
          this[p3 + r] = m3[p3 % y5];
      }
      return this;
    };
    var $n = {};
    function P0(t, e, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f3) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f3, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o2 = `The value of "${t}" is out of range.`, f3 = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f3 = Fd(String(r)) : typeof r == "bigint" && (f3 = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f3 = Fd(f3)), f3 += "n"), o2 += ` It must be ${e}. Received ${f3}`, o2;
    }, RangeError);
    function Fd(t) {
      let e = "", r = t.length, o2 = t[0] === "-" ? 1 : 0;
      for (;r >= o2 + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function Kw(t, e, r) {
      Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
    }
    function Yd(t, e, r, o2, f3, p3) {
      if (t > r || t < e) {
        let m3 = typeof e == "bigint" ? "n" : "", y5;
        throw p3 > 3 ? e === 0 || e === BigInt(0) ? y5 = `>= 0${m3} and < 2${m3} ** ${(p3 + 1) * 8}${m3}` : y5 = `>= -(2${m3} ** ${(p3 + 1) * 8 - 1}${m3}) and < 2 ** ${(p3 + 1) * 8 - 1}${m3}` : y5 = `>= ${e}${m3} and <= ${r}${m3}`, new $n.ERR_OUT_OF_RANGE("value", y5, t);
      }
      Kw(o2, f3, p3);
    }
    function Yn(t, e) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Vf(t, e, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e) {
      e = e || 1 / 0;
      let r, o2 = t.length, f3 = null, p3 = [];
      for (let m3 = 0;m3 < o2; ++m3) {
        if (r = t.charCodeAt(m3), r > 55295 && r < 57344) {
          if (!f3) {
            if (r > 56319) {
              (e -= 3) > -1 && p3.push(239, 191, 189);
              continue;
            } else if (m3 + 1 === o2) {
              (e -= 3) > -1 && p3.push(239, 191, 189);
              continue;
            }
            f3 = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p3.push(239, 191, 189), f3 = r;
            continue;
          }
          r = (f3 - 55296 << 10 | r - 56320) + 65536;
        } else
          f3 && (e -= 3) > -1 && p3.push(239, 191, 189);
        if (f3 = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p3.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p3.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p3.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p3.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p3;
    }
    function Vw(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function $w(t, e) {
      let r, o2, f3, p3 = [];
      for (let m3 = 0;m3 < t.length && !((e -= 2) < 0); ++m3)
        r = t.charCodeAt(m3), o2 = r >> 8, f3 = r % 256, p3.push(f3), p3.push(o2);
      return p3;
    }
    function Xd(t) {
      return I02.toByteArray(Zw(t));
    }
    function to3(t, e, r, o2) {
      let f3;
      for (f3 = 0;f3 < o2 && !(f3 + r >= e.length || f3 >= t.length); ++f3)
        e[f3 + r] = t[f3];
      return f3;
    }
    function Zr2(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o2 = r * 16;
        for (let f3 = 0;f3 < 16; ++f3)
          e[o2 + f3] = t[r] + t[f3];
      }
      return e;
    }();
    function Ti2(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T3((O0, Qd) => {
    var ro2 = Ut3(), Vr = ro2.Buffer;
    function Jd(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro2 : (Jd(ro2, O0), O0.Buffer = an2);
    function an2(t, e, r) {
      return Vr(t, e, r);
    }
    an2.prototype = Object.create(Vr.prototype);
    Jd(Vr, an2);
    an2.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    an2.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o2 = Vr(t);
      return e !== undefined ? typeof r == "string" ? o2.fill(e, r) : o2.fill(e) : o2.fill(0), o2;
    };
    an2.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an2.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro2.SlowBuffer(t);
    };
  });
  on = T3((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o2 = 0;o2 < t; o2 += F0)
            io.getRandomValues(r.slice(o2, o2 + F0));
        else
          io.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = T3((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o2 = function() {
        };
        o2.prototype = r.prototype, e.prototype = new o2, e.prototype.constructor = e;
      }
    };
  });
  ki = T3((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o2) {
      return Function.prototype.apply.call(e, r, o2);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : no = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || rc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function ic2(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic2(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o2 = 1;o2 < arguments.length; o2++)
        r.push(arguments[o2]);
      var f3 = e === "error", p3 = this._events;
      if (p3 !== undefined)
        f3 = f3 && p3.error === undefined;
      else if (!f3)
        return false;
      if (f3) {
        var m3;
        if (r.length > 0 && (m3 = r[0]), m3 instanceof Error)
          throw m3;
        var y5 = new Error("Unhandled error." + (m3 ? " (" + m3.message + ")" : ""));
        throw y5.context = m3, y5;
      }
      var M3 = p3[e];
      if (M3 === undefined)
        return false;
      if (typeof M3 == "function")
        ec(M3, this, r);
      else
        for (var x5 = M3.length, S3 = sc(M3, x5), o2 = 0;o2 < x5; ++o2)
          ec(S3[o2], this, r);
      return true;
    };
    function nc(t, e, r, o2) {
      var f3, p3, m3;
      if (fo(r), p3 = t._events, p3 === undefined ? (p3 = t._events = Object.create(null), t._eventsCount = 0) : (p3.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p3 = t._events), m3 = p3[e]), m3 === undefined)
        m3 = p3[e] = r, ++t._eventsCount;
      else if (typeof m3 == "function" ? m3 = p3[e] = o2 ? [r, m3] : [m3, r] : o2 ? m3.unshift(r) : m3.push(r), f3 = ic2(t), f3 > 0 && m3.length > f3 && !m3.warned) {
        m3.warned = true;
        var y5 = new Error("Possible EventEmitter memory leak detected. " + m3.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y5.name = "MaxListenersExceededWarning", y5.emitter = t, y5.type = e, y5.count = m3.length, t6(y5);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return nc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return nc(this, e, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e, r) {
      var o2 = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f3 = r6.bind(o2);
      return f3.listener = r, o2.wrapFn = f3, f3;
    }
    Fe.prototype.once = function(e, r) {
      return fo(r), this.on(e, fc(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return fo(r), this.prependListener(e, fc(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o2, f3, p3, m3, y5;
      if (fo(r), f3 = this._events, f3 === undefined)
        return this;
      if (o2 = f3[e], o2 === undefined)
        return this;
      if (o2 === r || o2.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f3[e], f3.removeListener && this.emit("removeListener", e, o2.listener || r));
      else if (typeof o2 != "function") {
        for (p3 = -1, m3 = o2.length - 1;m3 >= 0; m3--)
          if (o2[m3] === r || o2[m3].listener === r) {
            y5 = o2[m3].listener, p3 = m3;
            break;
          }
        if (p3 < 0)
          return this;
        p3 === 0 ? o2.shift() : i6(o2, p3), o2.length === 1 && (f3[e] = o2[0]), f3.removeListener !== undefined && this.emit("removeListener", e, y5 || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o2, f3;
      if (o2 = this._events, o2 === undefined)
        return this;
      if (o2.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o2[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o2[e]), this;
      if (arguments.length === 0) {
        var p3 = Object.keys(o2), m3;
        for (f3 = 0;f3 < p3.length; ++f3)
          m3 = p3[f3], m3 !== "removeListener" && this.removeAllListeners(m3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o2[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f3 = r.length - 1;f3 >= 0; f3--)
          this.removeListener(e, r[f3]);
      return this;
    };
    function ac(t, e, r) {
      var o2 = t._events;
      if (o2 === undefined)
        return [];
      var f3 = o2[e];
      return f3 === undefined ? [] : typeof f3 == "function" ? r ? [f3.listener || f3] : [f3] : r ? n6(f3) : sc(f3, f3.length);
    }
    Fe.prototype.listeners = function(e) {
      return ac(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return ac(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e) {
      for (var r = new Array(e), o2 = 0;o2 < e; ++o2)
        r[o2] = t[o2];
      return r;
    }
    function i6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function n6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function f6(t, e) {
      return new Promise(function(r, o2) {
        function f3(m3) {
          t.removeListener(e, p3), o2(m3);
        }
        function p3() {
          typeof t.removeListener == "function" && t.removeListener("error", f3), r([].slice.call(arguments));
        }
        hc(t, e, p3, { once: true }), e !== "error" && a6(t, f3, { once: true });
      });
    }
    function a6(t, e, r) {
      typeof t.on == "function" && hc(t, "error", e, r);
    }
    function hc(t, e, r, o2) {
      if (typeof t.on == "function")
        o2.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p3) {
          o2.once && t.removeEventListener(e, f), r(p3);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T3((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T3(() => {
  });
  pc = T3((tI, cc) => {
    function lc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(t);
        e && (o2 = o2.filter(function(f3) {
          return Object.getOwnPropertyDescriptor(t, f3).enumerable;
        })), r.push.apply(r, o2);
      }
      return r;
    }
    function o6(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lc(Object(r), true).forEach(function(o2) {
          s6(t, o2, r[o2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o2) {
          Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(r, o2));
        });
      }
      return t;
    }
    function s6(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function h6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o2 = e[r];
        o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t, o2.key, o2);
      }
    }
    function u6(t, e, r) {
      return e && dc(t.prototype, e), r && dc(t, r), t;
    }
    var l6 = Ut3(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e, r) {
      ao.prototype.copy.call(t, e, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o2 = { data: r, next: null };
        this.length > 0 ? this.tail.next = o2 : this.head = o2, this.tail = o2, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o2 = { data: r, next: this.head };
        this.length === 0 && (this.tail = o2), this.head = o2, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o2 = this.head, f3 = "" + o2.data;o2 = o2.next; )
          f3 += r + o2.data;
        return f3;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o2 = ao.allocUnsafe(r >>> 0), f3 = this.head, p3 = 0;f3; )
          p6(f3.data, o2, p3), p3 += f3.data.length, f3 = f3.next;
        return o2;
      } }, { key: "consume", value: function(r, o2) {
        var f3;
        return r < this.head.data.length ? (f3 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f3 = this.shift() : f3 = o2 ? this._getString(r) : this._getBuffer(r), f3;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o2 = this.head, f3 = 1, p3 = o2.data;
        for (r -= p3.length;o2 = o2.next; ) {
          var m3 = o2.data, y5 = r > m3.length ? m3.length : r;
          if (y5 === m3.length ? p3 += m3 : p3 += m3.slice(0, r), r -= y5, r === 0) {
            y5 === m3.length ? (++f3, o2.next ? this.head = o2.next : this.head = this.tail = null) : (this.head = o2, o2.data = m3.slice(y5));
            break;
          }
          ++f3;
        }
        return this.length -= f3, p3;
      } }, { key: "_getBuffer", value: function(r) {
        var o2 = ao.allocUnsafe(r), f3 = this.head, p3 = 1;
        for (f3.data.copy(o2), r -= f3.data.length;f3 = f3.next; ) {
          var m3 = f3.data, y5 = r > m3.length ? m3.length : r;
          if (m3.copy(o2, o2.length - r, 0, y5), r -= y5, r === 0) {
            y5 === m3.length ? (++p3, f3.next ? this.head = f3.next : this.head = this.tail = null) : (this.head = f3, f3.data = m3.slice(y5));
            break;
          }
          ++p3;
        }
        return this.length -= p3, o2;
      } }, { key: c6, value: function(r, o2) {
        return K0(this, o6({}, o2, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T3((rI, bc) => {
    function v6(t, e) {
      var r = this, o2 = this._readableState && this._readableState.destroyed, f3 = this._writableState && this._writableState.destroyed;
      return o2 || f3 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p3) {
        !e && p3 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc2, r, p3)) : process.nextTick(vc2, r, p3) : e ? (process.nextTick(oo, r), e(p3)) : process.nextTick(oo, r);
      }), this);
    }
    function vc2(t, e) {
      j0(t, e), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e) {
      t.emit("error", e);
    }
    function m6(t, e) {
      var { _readableState: r, _writableState: o2 } = t;
      r && r.autoDestroy || o2 && o2.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T3((iI, yc2) => {
    function g6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gc = {};
    function dr4(t, e, r) {
      r || (r = Error);
      function o2(p3, m3, y5) {
        return typeof e == "string" ? e : e(p3, m3, y5);
      }
      var f3 = function(p3) {
        g6(m3, p3);
        function m3(y5, M3, x5) {
          return p3.call(this, o2(y5, M3, x5)) || this;
        }
        return m3;
      }(r);
      f3.prototype.name = r.name, f3.prototype.code = t, gc[t] = f3;
    }
    function mc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o2) {
          return String(o2);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function y6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function w6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function M6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr4("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr4("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o2;
      typeof e == "string" && y6(e, "not ") ? (o2 = "must not be", e = e.replace(/^not /, "")) : o2 = "must be";
      var f3;
      if (w6(t, " argument"))
        f3 = "The ".concat(t, " ").concat(o2, " ").concat(mc(e, "type"));
      else {
        var p3 = M6(t, ".") ? "property" : "argument";
        f3 = 'The "'.concat(t, '" ').concat(p3, " ").concat(o2, " ").concat(mc(e, "type"));
      }
      return f3 += ". Received type ".concat(typeof r), f3;
    }, TypeError);
    dr4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr4("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr4("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr4("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr4("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr4("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc2.exports.codes = gc;
  });
  V0 = T3((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function S6(t, e, r, o2) {
      var f3 = x6(e, o2, r);
      if (f3 != null) {
        if (!(isFinite(f3) && Math.floor(f3) === f3) || f3 < 0) {
          var p3 = o2 ? r : "highWaterMark";
          throw new _6(p3, f3);
        }
        return Math.floor(f3);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T3((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o2() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e);
          $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o2;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  J0 = T3((aI, Rc2) => {
    Rc2.exports = ht2;
    function xc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e, t);
      };
    }
    var Qn2;
    ht2.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc2 = W0(), ho = Ut3().Buffer, R6 = global.Uint8Array || function() {
    };
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li2 = sn().codes, k6 = Li2.ERR_INVALID_ARG_TYPE, L6 = Li2.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li2.ERR_MULTIPLE_CALLBACK, D6 = Li2.ERR_STREAM_CANNOT_PIPE, P6 = Li2.ERR_STREAM_DESTROYED, C6 = Li2.ERR_STREAM_NULL_VALUES, O6 = Li2.ERR_STREAM_WRITE_AFTER_END, F6 = Li2.ERR_UNKNOWN_ENCODING, ef2 = X0.errorOrDestroy;
    Ie()(ht2, Sc2);
    function U6() {
    }
    function Yf(t, e, r) {
      Qn2 = Qn2 || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn2), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o2 = t.decodeStrings === false;
      this.decodeStrings = !o2, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f3) {
        V6(e, f3);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var so2;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht2, Symbol.hasInstance, { value: function(e) {
      return so2.call(this, e) ? true : this !== ht2 ? false : e && e._writableState instanceof Yf;
    } })) : so2 = function(e) {
      return e instanceof this;
    };
    function ht2(t) {
      Qn2 = Qn2 || hn();
      var e = this instanceof Qn2;
      if (!e && !so2.call(ht2, this))
        return new ht2(t);
      this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc2.call(this);
    }
    ht2.prototype.pipe = function() {
      ef2(this, new D6);
    };
    function z6(t, e) {
      var r = new O6;
      ef2(t, r), process.nextTick(e, r);
    }
    function H6(t, e, r, o2) {
      var f3;
      return r === null ? f3 = new C6 : typeof r != "string" && !e.objectMode && (f3 = new k6("chunk", ["string", "Buffer"], r)), f3 ? (ef2(t, f3), process.nextTick(o2, f3), false) : true;
    }
    ht2.prototype.write = function(t, e, r) {
      var o2 = this._writableState, f3 = false, p3 = !o2.objectMode && q6(t);
      return p3 && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p3 ? e = "buffer" : e || (e = o2.defaultEncoding), typeof r != "function" && (r = U6), o2.ending ? z6(this, r) : (p3 || H6(this, o2, t, r)) && (o2.pendingcb++, f3 = K6(this, o2, p3, t, e, r)), f3;
    };
    ht2.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht2.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht2.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new F6(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
    }
    Object.defineProperty(ht2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e, r, o2, f3, p3) {
      if (!r) {
        var m3 = W6(e, o2, f3);
        o2 !== m3 && (r = true, f3 = "buffer", o2 = m3);
      }
      var y5 = e.objectMode ? 1 : o2.length;
      e.length += y5;
      var M3 = e.length < e.highWaterMark;
      if (M3 || (e.needDrain = true), e.writing || e.corked) {
        var x5 = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o2, encoding: f3, isBuf: r, callback: p3, next: null }, x5 ? x5.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Y0(t, e, false, y5, o2, f3, p3);
      return M3;
    }
    function Y0(t, e, r, o2, f3, p3, m3) {
      e.writelen = o2, e.writecb = m3, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f3, e.onwrite) : t._write(f3, p3, e.onwrite), e.sync = false;
    }
    function j6(t, e, r, o2, f3) {
      --e.pendingcb, r ? (process.nextTick(f3, o2), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef2(t, o2)) : (f3(o2), t._writableState.errorEmitted = true, ef2(t, o2), Gf(t, e));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e) {
      var r = t._writableState, o2 = r.sync, f3 = r.writecb;
      if (typeof f3 != "function")
        throw new N6;
      if (Z6(r), e)
        j6(t, r, o2, e, f3);
      else {
        var p3 = Ac(r) || t.destroyed;
        !p3 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o2 ? process.nextTick(_c2, t, r, p3, f3) : _c2(t, r, p3, f3);
      }
    }
    function _c2(t, e, r, o2) {
      r || $6(t, e), e.pendingcb--, o2(), Gf(t, e);
    }
    function $6(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o2 = e.bufferedRequestCount, f3 = new Array(o2), p3 = e.corkedRequestsFree;
        p3.entry = r;
        for (var m3 = 0, y5 = true;r; )
          f3[m3] = r, r.isBuf || (y5 = false), r = r.next, m3 += 1;
        f3.allBuffers = y5, Y0(t, e, true, e.length, f3, "", p3.finish), e.pendingcb++, e.lastBufferedRequest = null, p3.next ? (e.corkedRequestsFree = p3.next, p3.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M3, encoding: x5, callback: S3 } = r, E6 = e.objectMode ? 1 : M3.length;
          if (Y0(t, e, false, E6, M3, x5, S3), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht2.prototype._write = function(t, e, r) {
      r(new L6("_write()"));
    };
    ht2.prototype._writev = null;
    ht2.prototype.end = function(t, e, r) {
      var o2 = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o2.corked && (o2.corked = 1, this.uncork()), o2.ending || X6(this, o2, r), this;
    };
    Object.defineProperty(ht2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && ef2(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
      });
    }
    function Y6(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e) {
      var r = Ac(e);
      if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o2 = t._readableState;
        (!o2 || o2.autoDestroy && o2.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e, r) {
      e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function J6(t, e, r) {
      var o2 = t.entry;
      for (t.entry = null;o2; ) {
        var f3 = o2.callback;
        e.pendingcb--, f3(r), o2 = o2.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht2.prototype.destroy = X0.destroy;
    ht2.prototype._undestroy = X0.undestroy;
    ht2.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  hn = T3((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    qc.exports = $r3;
    var Bc = th(), eh = J0();
    Ie()($r3, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r3.prototype[lo] || ($r3.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r3(t) {
      if (!(this instanceof $r3))
        return new $r3(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r3.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r3.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r3.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r3.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  co = T3((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function iM(t) {
      var e = rM(t);
      if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e = 4;
          break;
        case "utf8":
          this.fillLast = aM, e = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e, r) {
      var o2 = e.length - 1;
      if (o2 < r)
        return 0;
      var f3 = rh(e[o2]);
      return f3 >= 0 ? (f3 > 0 && (t.lastNeed = f3 - 1), f3) : --o2 < r || f3 === -2 ? 0 : (f3 = rh(e[o2]), f3 >= 0 ? (f3 > 0 && (t.lastNeed = f3 - 2), f3) : --o2 < r || f3 === -2 ? 0 : (f3 = rh(e[o2]), f3 >= 0 ? (f3 > 0 && (f3 === 2 ? f3 = 0 : t.lastNeed = f3 - 3), f3) : 0));
    }
    function fM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "�";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "�";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "�";
      }
    }
    function aM(t) {
      var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e) {
      var r = nM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o2 = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o2), t.toString("utf8", e, o2);
    }
    function sM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "�" : e;
    }
    function hM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o2 = r.charCodeAt(r.length - 1);
          if (o2 >= 55296 && o2 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function uM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function lM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function dM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn2(co());
  });
  vo = T3((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o2 = new Array(r), f3 = 0;f3 < r; f3++)
            o2[f3] = arguments[f3];
          t.apply(this, o2);
        }
      };
    }
    function bM() {
    }
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e, r) {
      if (typeof e == "function")
        return Lc(t, null, e);
      e || (e = {}), r = vM(r || bM);
      var o2 = e.readable || e.readable !== false && t.readable, f3 = e.writable || e.writable !== false && t.writable, p3 = function() {
        t.writable || y5();
      }, m3 = t._writableState && t._writableState.finished, y5 = function() {
        f3 = false, m3 = true, o2 || r.call(t);
      }, M3 = t._readableState && t._readableState.endEmitted, x5 = function() {
        o2 = false, M3 = true, f3 || r.call(t);
      }, S3 = function(L4) {
        r.call(t, L4);
      }, E6 = function() {
        var L4;
        if (o2 && !M3)
          return (!t._readableState || !t._readableState.ended) && (L4 = new kc), r.call(t, L4);
        if (f3 && !m3)
          return (!t._writableState || !t._writableState.ended) && (L4 = new kc), r.call(t, L4);
      }, B3 = function() {
        t.req.on("finish", y5);
      };
      return mM(t) ? (t.on("complete", y5), t.on("abort", E6), t.req ? B3() : t.on("request", B3)) : f3 && !t._writableState && (t.on("end", p3), t.on("close", p3)), t.on("end", x5), t.on("finish", y5), e.error !== false && t.on("error", S3), t.on("close", E6), function() {
        t.removeListener("complete", y5), t.removeListener("abort", E6), t.removeListener("request", B3), t.req && t.req.removeListener("finish", y5), t.removeListener("end", p3), t.removeListener("close", p3), t.removeListener("finish", y5), t.removeListener("end", x5), t.removeListener("error", S3), t.removeListener("close", E6);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T3((uI, Dc) => {
    var bo;
    function Ni2(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var gM = vo(), Di2 = Symbol("lastResolve"), un2 = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh2 = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi2(t, e) {
      return { value: t, done: e };
    }
    function yM(t) {
      var e = t[Di2];
      if (e !== null) {
        var r = t[dn].read();
        r !== null && (t[ln] = null, t[Di2] = null, t[un2] = null, e(Pi2(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e) {
      return function(r, o2) {
        t.then(function() {
          if (e[mo]) {
            r(Pi2(undefined, true));
            return;
          }
          e[nh2](r, o2);
        }, o2);
      };
    }
    var _M = Object.getPrototypeOf(function() {
    }), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi2(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m3, y5) {
          process.nextTick(function() {
            e[ea] ? y5(e[ea]) : m3(Pi2(undefined, true));
          });
        });
      var o2 = this[ln], f3;
      if (o2)
        f3 = new Promise(MM(o2, this));
      else {
        var p3 = this[dn].read();
        if (p3 !== null)
          return Promise.resolve(Pi2(p3, false));
        f3 = new Promise(this[nh2]);
      }
      return this[ln] = f3, f3;
    } }, Ni2(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni2(bo, "return", function() {
      var e = this;
      return new Promise(function(r, o2) {
        e[dn].destroy(null, function(f3) {
          if (f3) {
            o2(f3);
            return;
          }
          r(Pi2(undefined, true));
        });
      });
    }), bo), _M), SM = function(e) {
      var r, o2 = Object.create(xM, (r = {}, Ni2(r, dn, { value: e, writable: true }), Ni2(r, Di2, { value: null, writable: true }), Ni2(r, un2, { value: null, writable: true }), Ni2(r, ea, { value: null, writable: true }), Ni2(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni2(r, nh2, { value: function(p3, m3) {
        var y5 = o2[dn].read();
        y5 ? (o2[ln] = null, o2[Di2] = null, o2[un2] = null, p3(Pi2(y5, false))) : (o2[Di2] = p3, o2[un2] = m3);
      }, writable: true }), r));
      return o2[ln] = null, gM(e, function(f3) {
        if (f3 && f3.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p3 = o2[un2];
          p3 !== null && (o2[ln] = null, o2[Di2] = null, o2[un2] = null, p3(f3)), o2[ea] = f3;
          return;
        }
        var m3 = o2[Di2];
        m3 !== null && (o2[ln] = null, o2[Di2] = null, o2[un2] = null, m3(Pi2(undefined, true))), o2[mo] = true;
      }), e.on("readable", wM.bind(null, o2)), o2;
    };
    Dc.exports = SM;
  });
  Oc = T3((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T3((cI, $c2) => {
    $c2.exports = Ce2;
    var tf2;
    Ce2.ReadableState = Hc;
    var dI = ki().EventEmitter, zc2 = function(e, r) {
      return e.listeners(r).length;
    }, ra = W0(), go = Ut3().Buffer, EM = global.Uint8Array || function() {
    };
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh2 = $f(), Ne;
    fh2 && fh2.debuglog ? Ne = fh2.debuglog("stream") : Ne = function() {
    };
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce2, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Hc(t, e, r) {
      tf2 = tf2 || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf2), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur2(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce2(t) {
      if (tf2 = tf2 || hn(), !(this instanceof Ce2))
        return new Ce2(t);
      var e = this instanceof tf2;
      this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce2.prototype.destroy = dh.destroy;
    Ce2.prototype._undestroy = dh.undestroy;
    Ce2.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce2.prototype.push = function(t, e) {
      var r = this._readableState, o2;
      return r.objectMode ? o2 = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o2 = true), Wc(this, t, e, false, o2);
    };
    Ce2.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e, r, o2, f3) {
      Ne("readableAddChunk", e);
      var p3 = t._readableState;
      if (e === null)
        p3.reading = false, OM(t, p3);
      else {
        var m3;
        if (f3 || (m3 = PM(p3, e)), m3)
          ta(t, m3);
        else if (p3.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p3.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o2)
            p3.endEmitted ? ta(t, new NM) : hh(t, p3, e, true);
          else if (p3.ended)
            ta(t, new kM);
          else {
            if (p3.destroyed)
              return false;
            p3.reading = false, p3.decoder && !r ? (e = p3.decoder.write(e), p3.objectMode || e.length !== 0 ? hh(t, p3, e, false) : lh(t, p3)) : hh(t, p3, e, false);
          }
        else
          o2 || (p3.reading = false, lh(t, p3));
      }
      return !p3.ended && (p3.length < p3.highWaterMark || p3.length === 0);
    }
    function hh(t, e, r, o2) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo2(t)), lh(t, e);
    }
    function PM(t, e) {
      var r;
      return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce2.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur2(Jf)).StringDecoder);
      var e = new rf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o2 = "";r !== null; )
        o2 += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o2 !== "" && this._readableState.buffer.push(o2), this._readableState.length = o2.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc2(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce2.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh2(this) : wo2(this), null;
      if (t = Uc2(t, e), t === 0 && e.ended)
        return e.length === 0 && uh2(this), null;
      var o2 = e.needReadable;
      Ne("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, Ne("length less than watermark", o2)), e.ended || e.reading ? (o2 = false, Ne("reading or ended", o2)) : o2 && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc2(r, e)));
      var f3;
      return t > 0 ? f3 = Zc(t, e) : f3 = null, f3 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh2(this)), f3 !== null && this.emit("data", f3), f3;
    };
    function OM(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? wo2(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
      }
    }
    function wo2(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
    }
    function lh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
    }
    function FM(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce2.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce2.prototype.pipe = function(t, e) {
      var r = this, o2 = this._readableState;
      switch (o2.pipesCount) {
        case 0:
          o2.pipes = t;
          break;
        case 1:
          o2.pipes = [o2.pipes, t];
          break;
        default:
          o2.pipes.push(t);
          break;
      }
      o2.pipesCount += 1, Ne("pipe count=%d opts=%j", o2.pipesCount, e);
      var f3 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p3 = f3 ? y5 : ge;
      o2.endEmitted ? process.nextTick(p3) : r.once("end", p3), t.on("unpipe", m3);
      function m3(_e3, N6) {
        Ne("onunpipe"), _e3 === r && N6 && N6.hasUnpiped === false && (N6.hasUnpiped = true, S3());
      }
      function y5() {
        Ne("onend"), t.end();
      }
      var M3 = UM(r);
      t.on("drain", M3);
      var x5 = false;
      function S3() {
        Ne("cleanup"), t.removeListener("close", q3), t.removeListener("finish", L4), t.removeListener("drain", M3), t.removeListener("error", B3), t.removeListener("unpipe", m3), r.removeListener("end", y5), r.removeListener("end", ge), r.removeListener("data", E6), x5 = true, o2.awaitDrain && (!t._writableState || t._writableState.needDrain) && M3();
      }
      r.on("data", E6);
      function E6(_e3) {
        Ne("ondata");
        var N6 = t.write(_e3);
        Ne("dest.write", N6), N6 === false && ((o2.pipesCount === 1 && o2.pipes === t || o2.pipesCount > 1 && Vc(o2.pipes, t) !== -1) && !x5 && (Ne("false write response, pause", o2.awaitDrain), o2.awaitDrain++), r.pause());
      }
      function B3(_e3) {
        Ne("onerror", _e3), ge(), t.removeListener("error", B3), zc2(t, "error") === 0 && ta(t, _e3);
      }
      DM(t, "error", B3);
      function q3() {
        t.removeListener("finish", L4), ge();
      }
      t.once("close", q3);
      function L4() {
        Ne("onfinish"), t.removeListener("close", q3), ge();
      }
      t.once("finish", L4);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o2.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc2(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce2.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o2, pipesCount: f3 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p3 = 0;p3 < f3; p3++)
          o2[p3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m3 = Vc(e.pipes, t);
      return m3 === -1 ? this : (e.pipes.splice(m3, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce2.prototype.on = function(t, e) {
      var r = ra.prototype.on.call(this, t, e), o2 = this._readableState;
      return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, Ne("on readable", o2.length, o2.reading), o2.length ? wo2(this) : o2.reading || process.nextTick(zM, this)), r;
    };
    Ce2.prototype.addListener = Ce2.prototype.on;
    Ce2.prototype.removeListener = function(t, e) {
      var r = ra.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce2.prototype.removeAllListeners = function(t) {
      var e = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
    };
    function jc(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce2.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
    }
    function WM(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
    }
    Ce2.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce2.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o2 = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m3 = r.decoder.end();
          m3 && m3.length && e.push(m3);
        }
        e.push(null);
      }), t.on("data", function(m3) {
        if (Ne("wrapped data"), r.decoder && (m3 = r.decoder.write(m3)), !(r.objectMode && m3 == null) && !(!r.objectMode && (!m3 || !m3.length))) {
          var y5 = e.push(m3);
          y5 || (o2 = true, t.pause());
        }
      });
      for (var f3 in t)
        this[f3] === undefined && typeof t[f3] == "function" && (this[f3] = function(y5) {
          return function() {
            return t[y5].apply(t, arguments);
          };
        }(f3));
      for (var p3 = 0;p3 < sh.length; p3++)
        t.on(sh[p3], this.emit.bind(this, sh[p3]));
      return this._read = function(m3) {
        Ne("wrapped _read", m3), o2 && (o2 = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce2.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce2.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce2.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce2._fromList = Zc;
    Object.defineProperty(Ce2.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function uh2(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
    }
    function KM(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce2.from = function(t, e) {
      return oh === undefined && (oh = Oc()), oh(Ce2, t, e);
    });
    function Vc(t, e) {
      for (var r = 0, o2 = t.length;r < o2; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  ph = T3((pI, Yc2) => {
    Yc2.exports = di3;
    var Mo3 = sn().codes, jM = Mo3.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo3.ERR_MULTIPLE_CALLBACK, VM = Mo3.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo3.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di3, _o);
    function GM(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o2 = r.writecb;
      if (o2 === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o2(t);
      var f3 = this._readableState;
      f3.reading = false, (f3.needReadable || f3.length < f3.highWaterMark) && this._read(f3.highWaterMark);
    }
    function di3(t) {
      if (!(this instanceof di3))
        return new di3(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Gc(t, e, r);
      }) : Gc(this, null, null);
    }
    di3.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
    };
    di3.prototype._transform = function(t, e, r) {
      r(new jM("_transform()"));
    };
    di3.prototype._write = function(t, e, r) {
      var o2 = this._transformState;
      if (o2.writecb = r, o2.writechunk = t, o2.writeencoding = e, !o2.transforming) {
        var f3 = this._readableState;
        (o2.needTransform || f3.needReadable || f3.length < f3.highWaterMark) && this._read(f3.highWaterMark);
      }
    };
    di3.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    di3.prototype._destroy = function(t, e) {
      _o.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Gc(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T3((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  np = T3((bI, ip) => {
    var vh;
    function XM(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e, r, o2) {
      o2 = XM(o2);
      var f3 = false;
      t.on("close", function() {
        f3 = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m3) {
        if (m3)
          return o2(m3);
        f3 = true, o2();
      });
      var p3 = false;
      return function(m3) {
        if (!f3 && !p3) {
          if (p3 = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o2(m3 || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e) {
      return t.pipe(e);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o2 = i4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new JM("streams");
      var f3, p3 = e.map(function(m3, y5) {
        var M3 = y5 < e.length - 1, x5 = y5 > 0;
        return t4(m3, M3, x5, function(S3) {
          f3 || (f3 = S3), S3 && p3.forEach(tp), !M3 && (p3.forEach(tp), o2(f3));
        });
      });
      return e.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T3((cr2, fp) => {
    cr2 = fp.exports = th();
    cr2.Stream = cr2;
    cr2.Readable = cr2;
    cr2.Writable = J0();
    cr2.Duplex = hn();
    cr2.Transform = ph();
    cr2.PassThrough = Qc();
    cr2.finished = vo();
    cr2.pipeline = np();
  });
  bh2 = T3((mI, sp) => {
    var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
    function a4(t, e) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function Ci(t) {
      op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op);
    Ci.prototype._transform = function(t, e, r) {
      var o2 = null;
      try {
        this.update(t, e);
      } catch (f3) {
        o2 = f3;
      }
      r(o2);
    };
    Ci.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Ci.prototype.update = function(t, e) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e));
      for (var r = this._block, o2 = 0;this._blockOffset + t.length - o2 >= this._blockSize; ) {
        for (var f3 = this._blockOffset;f3 < this._blockSize; )
          r[f3++] = t[o2++];
        this._update(), this._blockOffset = 0;
      }
      for (;o2 < t.length; )
        r[this._blockOffset++] = t[o2++];
      for (var p3 = 0, m3 = t.length * 8;m3 > 0; ++p3)
        this._length[p3] += m3, m3 = this._length[p3] / 4294967296 | 0, m3 > 0 && (this._length[p3] -= 4294967296 * m3);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T3((gI, up) => {
    var o4 = Ie(), hp = bh2(), s4 = Te().Buffer, h42 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h42, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o2 = this._b, f3 = this._c, p3 = this._d;
      r = jt2(r, o2, f3, p3, t[0], 3614090360, 7), p3 = jt2(p3, r, o2, f3, t[1], 3905402710, 12), f3 = jt2(f3, p3, r, o2, t[2], 606105819, 17), o2 = jt2(o2, f3, p3, r, t[3], 3250441966, 22), r = jt2(r, o2, f3, p3, t[4], 4118548399, 7), p3 = jt2(p3, r, o2, f3, t[5], 1200080426, 12), f3 = jt2(f3, p3, r, o2, t[6], 2821735955, 17), o2 = jt2(o2, f3, p3, r, t[7], 4249261313, 22), r = jt2(r, o2, f3, p3, t[8], 1770035416, 7), p3 = jt2(p3, r, o2, f3, t[9], 2336552879, 12), f3 = jt2(f3, p3, r, o2, t[10], 4294925233, 17), o2 = jt2(o2, f3, p3, r, t[11], 2304563134, 22), r = jt2(r, o2, f3, p3, t[12], 1804603682, 7), p3 = jt2(p3, r, o2, f3, t[13], 4254626195, 12), f3 = jt2(f3, p3, r, o2, t[14], 2792965006, 17), o2 = jt2(o2, f3, p3, r, t[15], 1236535329, 22), r = Zt(r, o2, f3, p3, t[1], 4129170786, 5), p3 = Zt(p3, r, o2, f3, t[6], 3225465664, 9), f3 = Zt(f3, p3, r, o2, t[11], 643717713, 14), o2 = Zt(o2, f3, p3, r, t[0], 3921069994, 20), r = Zt(r, o2, f3, p3, t[5], 3593408605, 5), p3 = Zt(p3, r, o2, f3, t[10], 38016083, 9), f3 = Zt(f3, p3, r, o2, t[15], 3634488961, 14), o2 = Zt(o2, f3, p3, r, t[4], 3889429448, 20), r = Zt(r, o2, f3, p3, t[9], 568446438, 5), p3 = Zt(p3, r, o2, f3, t[14], 3275163606, 9), f3 = Zt(f3, p3, r, o2, t[3], 4107603335, 14), o2 = Zt(o2, f3, p3, r, t[8], 1163531501, 20), r = Zt(r, o2, f3, p3, t[13], 2850285829, 5), p3 = Zt(p3, r, o2, f3, t[2], 4243563512, 9), f3 = Zt(f3, p3, r, o2, t[7], 1735328473, 14), o2 = Zt(o2, f3, p3, r, t[12], 2368359562, 20), r = Vt2(r, o2, f3, p3, t[5], 4294588738, 4), p3 = Vt2(p3, r, o2, f3, t[8], 2272392833, 11), f3 = Vt2(f3, p3, r, o2, t[11], 1839030562, 16), o2 = Vt2(o2, f3, p3, r, t[14], 4259657740, 23), r = Vt2(r, o2, f3, p3, t[1], 2763975236, 4), p3 = Vt2(p3, r, o2, f3, t[4], 1272893353, 11), f3 = Vt2(f3, p3, r, o2, t[7], 4139469664, 16), o2 = Vt2(o2, f3, p3, r, t[10], 3200236656, 23), r = Vt2(r, o2, f3, p3, t[13], 681279174, 4), p3 = Vt2(p3, r, o2, f3, t[0], 3936430074, 11), f3 = Vt2(f3, p3, r, o2, t[3], 3572445317, 16), o2 = Vt2(o2, f3, p3, r, t[6], 76029189, 23), r = Vt2(r, o2, f3, p3, t[9], 3654602809, 4), p3 = Vt2(p3, r, o2, f3, t[12], 3873151461, 11), f3 = Vt2(f3, p3, r, o2, t[15], 530742520, 16), o2 = Vt2(o2, f3, p3, r, t[2], 3299628645, 23), r = $t(r, o2, f3, p3, t[0], 4096336452, 6), p3 = $t(p3, r, o2, f3, t[7], 1126891415, 10), f3 = $t(f3, p3, r, o2, t[14], 2878612391, 15), o2 = $t(o2, f3, p3, r, t[5], 4237533241, 21), r = $t(r, o2, f3, p3, t[12], 1700485571, 6), p3 = $t(p3, r, o2, f3, t[3], 2399980690, 10), f3 = $t(f3, p3, r, o2, t[10], 4293915773, 15), o2 = $t(o2, f3, p3, r, t[1], 2240044497, 21), r = $t(r, o2, f3, p3, t[8], 1873313359, 6), p3 = $t(p3, r, o2, f3, t[15], 4264355552, 10), f3 = $t(f3, p3, r, o2, t[6], 2734768916, 15), o2 = $t(o2, f3, p3, r, t[13], 1309151649, 21), r = $t(r, o2, f3, p3, t[4], 4149444226, 6), p3 = $t(p3, r, o2, f3, t[11], 3174756917, 10), f3 = $t(f3, p3, r, o2, t[2], 718787259, 15), o2 = $t(o2, f3, p3, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o2 | 0, this._c = this._c + f3 | 0, this._d = this._d + p3 | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt2(t, e, r, o2, f3, p3, m3) {
      return Eo(t + (e & r | ~e & o2) + f3 + p3 | 0, m3) + e | 0;
    }
    function Zt(t, e, r, o2, f3, p3, m3) {
      return Eo(t + (e & o2 | r & ~o2) + f3 + p3 | 0, m3) + e | 0;
    }
    function Vt2(t, e, r, o2, f3, p3, m3) {
      return Eo(t + (e ^ r ^ o2) + f3 + p3 | 0, m3) + e | 0;
    }
    function $t(t, e, r, o2, f3, p3, m3) {
      return Eo(t + (r ^ (e | ~o2)) + f3 + p3 | 0, m3) + e | 0;
    }
    up.exports = So;
  });
  Bo = T3((yI, mp) => {
    var mh = Ut3().Buffer, u4 = Ie(), bp = bh2(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o2 = this._b | 0, f3 = this._c | 0, p3 = this._d | 0, m3 = this._e | 0, y5 = this._a | 0, M3 = this._b | 0, x5 = this._c | 0, S3 = this._d | 0, E6 = this._e | 0, B3 = 0;B3 < 80; B3 += 1) {
        var q3, L4;
        B3 < 16 ? (q3 = lp(r, o2, f3, p3, m3, t[na[B3]], sa[0], aa[B3]), L4 = vp(y5, M3, x5, S3, E6, t[fa[B3]], ha[0], oa[B3])) : B3 < 32 ? (q3 = dp2(r, o2, f3, p3, m3, t[na[B3]], sa[1], aa[B3]), L4 = pp(y5, M3, x5, S3, E6, t[fa[B3]], ha[1], oa[B3])) : B3 < 48 ? (q3 = cp(r, o2, f3, p3, m3, t[na[B3]], sa[2], aa[B3]), L4 = cp(y5, M3, x5, S3, E6, t[fa[B3]], ha[2], oa[B3])) : B3 < 64 ? (q3 = pp(r, o2, f3, p3, m3, t[na[B3]], sa[3], aa[B3]), L4 = dp2(y5, M3, x5, S3, E6, t[fa[B3]], ha[3], oa[B3])) : (q3 = vp(r, o2, f3, p3, m3, t[na[B3]], sa[4], aa[B3]), L4 = lp(y5, M3, x5, S3, E6, t[fa[B3]], ha[4], oa[B3])), r = m3, m3 = p3, p3 = cn2(f3, 10), f3 = o2, o2 = q3, y5 = E6, E6 = S3, S3 = cn2(x5, 10), x5 = M3, M3 = L4;
      }
      var ge = this._b + f3 + S3 | 0;
      this._b = this._c + p3 + E6 | 0, this._c = this._d + m3 + y5 | 0, this._d = this._e + r + M3 | 0, this._e = this._a + o2 + x5 | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn2(t, e) {
      return t << e | t >>> 32 - e;
    }
    function lp(t, e, r, o2, f3, p3, m3, y5) {
      return cn2(t + (e ^ r ^ o2) + p3 + m3 | 0, y5) + f3 | 0;
    }
    function dp2(t, e, r, o2, f3, p3, m3, y5) {
      return cn2(t + (e & r | ~e & o2) + p3 + m3 | 0, y5) + f3 | 0;
    }
    function cp(t, e, r, o2, f3, p3, m3, y5) {
      return cn2(t + ((e | ~r) ^ o2) + p3 + m3 | 0, y5) + f3 | 0;
    }
    function pp(t, e, r, o2, f3, p3, m3, y5) {
      return cn2(t + (e & o2 | r & ~o2) + p3 + m3 | 0, y5) + f3 | 0;
    }
    function vp(t, e, r, o2, f3, p3, m3, y5) {
      return cn2(t + (e ^ (r | ~o2)) + p3 + m3 | 0, y5) + f3 | 0;
    }
    mp.exports = Ro;
  });
  pn2 = T3((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e) {
      this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
      for (var r = this._block, o2 = this._blockSize, f3 = t.length, p3 = this._len, m3 = 0;m3 < f3; ) {
        for (var y5 = p3 % o2, M3 = Math.min(f3 - m3, o2 - y5), x5 = 0;x5 < M3; x5++)
          r[y5 + x5] = t[m3 + x5];
        p3 += M3, m3 += M3, p3 % o2 === 0 && this._update(r);
      }
      return this._len += f3, this;
    };
    qo.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o2 = (r & 4294967295) >>> 0, f3 = (r - o2) / 4294967296;
        this._block.writeUInt32BE(f3, this._blockSize - 8), this._block.writeUInt32BE(o2, this._blockSize - 4);
      }
      this._update(this._block);
      var p3 = this._hash();
      return t ? p3.toString(t) : p3;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T3((MI, Mp) => {
    var d4 = Ie(), wp = pn2(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b42(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g42(t, e, r, o2) {
      return t === 0 ? e & r | ~e & o2 : t === 2 ? e & r | e & o2 | r & o2 : e ^ r ^ o2;
    }
    ua.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f3 = this._c | 0, p3 = this._d | 0, m3 = this._e | 0, y5 = 0;y5 < 16; ++y5)
        e[y5] = t.readInt32BE(y5 * 4);
      for (;y5 < 80; ++y5)
        e[y5] = e[y5 - 3] ^ e[y5 - 8] ^ e[y5 - 14] ^ e[y5 - 16];
      for (var M3 = 0;M3 < 80; ++M3) {
        var x5 = ~~(M3 / 20), S3 = b42(r) + g42(x5, o2, f3, p3) + m3 + e[M3] + p4[x5] | 0;
        m3 = p3, p3 = f3, f3 = m4(o2), o2 = r, r = S3;
      }
      this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f3 + this._c | 0, this._d = p3 + this._d | 0, this._e = m3 + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T3((_I, Sp) => {
    var y42 = Ie(), xp = pn2(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y42(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x42(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E42(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e, r, o2) {
      return t === 0 ? e & r | ~e & o2 : t === 2 ? e & r | e & o2 | r & o2 : e ^ r ^ o2;
    }
    la.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f3 = this._c | 0, p3 = this._d | 0, m3 = this._e | 0, y5 = 0;y5 < 16; ++y5)
        e[y5] = t.readInt32BE(y5 * 4);
      for (;y5 < 80; ++y5)
        e[y5] = x42(e[y5 - 3] ^ e[y5 - 8] ^ e[y5 - 14] ^ e[y5 - 16]);
      for (var M3 = 0;M3 < 80; ++M3) {
        var x5 = ~~(M3 / 20), S3 = S4(r) + A4(x5, o2, f3, p3) + m3 + e[M3] + M4[x5] | 0;
        m3 = p3, p3 = f3, f3 = E42(o2), o2 = r, r = S3;
      }
      this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f3 + this._c | 0, this._d = p3 + this._d | 0, this._e = m3 + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T3((xI, Rp) => {
    var R4 = Ie(), Ap = pn2(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I42 = new Array(64);
    function da2() {
      this.init(), this._w = I42, Ap.call(this, 64, 56);
    }
    R4(da2, Ap);
    da2.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function k4(t, e, r) {
      return t & e | r & (t | e);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N42(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P4(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da2.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f3 = this._c | 0, p3 = this._d | 0, m3 = this._e | 0, y5 = this._f | 0, M3 = this._g | 0, x5 = this._h | 0, S3 = 0;S3 < 16; ++S3)
        e[S3] = t.readInt32BE(S3 * 4);
      for (;S3 < 64; ++S3)
        e[S3] = P4(e[S3 - 2]) + e[S3 - 7] + D4(e[S3 - 15]) + e[S3 - 16] | 0;
      for (var E6 = 0;E6 < 64; ++E6) {
        var B3 = x5 + N42(m3) + T4(m3, y5, M3) + q4[E6] + e[E6] | 0, q3 = L4(r) + k4(r, o2, f3) | 0;
        x5 = M3, M3 = y5, y5 = m3, m3 = p3 + B3 | 0, p3 = f3, f3 = o2, o2 = r, r = B3 + q3 | 0;
      }
      this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f3 + this._c | 0, this._d = p3 + this._d | 0, this._e = m3 + this._e | 0, this._f = y5 + this._f | 0, this._g = M3 + this._g | 0, this._h = x5 + this._h | 0;
    };
    da2.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da2;
  });
  qp = T3((SI, Bp2) => {
    var C4 = Ie(), O4 = gh(), F4 = pn2(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp2.exports = Io;
  });
  yh = T3((EI, Pp) => {
    var H4 = Ie(), Dp = pn2(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K42 = new Array(160);
    function ca() {
      this.init(), this._w = K42, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function kp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Lp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Np(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function j42(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function Z4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function V42(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Pt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o2 = this._bh | 0, f3 = this._ch | 0, p3 = this._dh | 0, m3 = this._eh | 0, y5 = this._fh | 0, M3 = this._gh | 0, x5 = this._hh | 0, S3 = this._al | 0, E6 = this._bl | 0, B3 = this._cl | 0, q3 = this._dl | 0, L4 = this._el | 0, ge = this._fl | 0, _e3 = this._gl | 0, N6 = this._hl | 0, we = 0;we < 32; we += 2)
        e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye2 = e[we - 30], xe2 = e[we - 15 * 2 + 1], Re = j42(ye2, xe2), Ee = Z4(xe2, ye2);
        ye2 = e[we - 2 * 2], xe2 = e[we - 2 * 2 + 1];
        var Ae2 = V42(ye2, xe2), P4 = $4(xe2, ye2), Se3 = e[we - 7 * 2], v4 = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a3 = e[we - 16 * 2 + 1], h5 = Ee + v4 | 0, s2 = Re + Se3 + Pt(h5, Ee) | 0;
        h5 = h5 + P4 | 0, s2 = s2 + Ae2 + Pt(h5, P4) | 0, h5 = h5 + a3 | 0, s2 = s2 + i + Pt(h5, a3) | 0, e[we] = s2, e[we + 1] = h5;
      }
      for (var u3 = 0;u3 < 160; u3 += 2) {
        s2 = e[u3], h5 = e[u3 + 1];
        var c2 = kp(r, o2, f3), b6 = kp(S3, E6, B3), l3 = Lp(r, S3), n = Lp(S3, r), d4 = Np(m3, L4), w3 = Np(L4, m3), g5 = Ip[u3], _4 = Ip[u3 + 1], A4 = Tp(m3, y5, M3), R4 = Tp(L4, ge, _e3), I5 = N6 + w3 | 0, Me = x5 + d4 + Pt(I5, N6) | 0;
        I5 = I5 + R4 | 0, Me = Me + A4 + Pt(I5, R4) | 0, I5 = I5 + _4 | 0, Me = Me + g5 + Pt(I5, _4) | 0, I5 = I5 + h5 | 0, Me = Me + s2 + Pt(I5, h5) | 0;
        var k4 = n + b6 | 0, D3 = l3 + c2 + Pt(k4, n) | 0;
        x5 = M3, N6 = _e3, M3 = y5, _e3 = ge, y5 = m3, ge = L4, L4 = q3 + I5 | 0, m3 = p3 + Me + Pt(L4, q3) | 0, p3 = f3, q3 = B3, f3 = o2, B3 = E6, o2 = r, E6 = S3, S3 = I5 + k4 | 0, r = Me + D3 + Pt(S3, I5) | 0;
      }
      this._al = this._al + S3 | 0, this._bl = this._bl + E6 | 0, this._cl = this._cl + B3 | 0, this._dl = this._dl + q3 | 0, this._el = this._el + L4 | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e3 | 0, this._hl = this._hl + N6 | 0, this._ah = this._ah + r + Pt(this._al, S3) | 0, this._bh = this._bh + o2 + Pt(this._bl, E6) | 0, this._ch = this._ch + f3 + Pt(this._cl, B3) | 0, this._dh = this._dh + p3 + Pt(this._dl, q3) | 0, this._eh = this._eh + m3 + Pt(this._el, L4) | 0, this._fh = this._fh + y5 + Pt(this._fl, ge) | 0, this._gh = this._gh + M3 + Pt(this._gl, _e3) | 0, this._hh = this._hh + x5 + Pt(this._hl, N6) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e(r, o2, f3) {
        t.writeInt32BE(r, f3), t.writeInt32BE(o2, f3 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T3((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn2(), J4 = Te().Buffer, Q42 = new Array(160);
    function To() {
      this.init(), this._w = Q42, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e(r, o2, f3) {
        t.writeInt32BE(r, f3), t.writeInt32BE(o2, f3 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T3((ci2, Fp) => {
    var ci2 = Fp.exports = function(e) {
      e = e.toLowerCase();
      var r = ci2[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    ci2.sha = _p();
    ci2.sha1 = Ep();
    ci2.sha224 = qp();
    ci2.sha256 = gh();
    ci2.sha384 = Op();
    ci2.sha512 = yh();
  });
  Tt5 = T3((RI, Up2) => {
    Up2.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr2 = T3((BI, Mh) => {
    var e_ = Ut3(), t_ = Object.getPrototypeOf(async function() {
    }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
      return e instanceof zp;
    } : function(e) {
      return false;
    }, wh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o2 = 0;o2 < e.length; o2++)
          r += `    ${e[o2].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o2, f3) => {
        t = o2, e = f3;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o2, ...f3) => o2 ? r(o2) : e(...f3));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o2]) {
        let f3 = e.shift();
        return o2 === "f" ? f3.toFixed(6) : o2 === "j" ? JSON.stringify(f3) : o2 === "s" && typeof f3 == "object" ? `${f3.constructor !== Object ? f3.constructor.name : ""} {}`.trim() : f3.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T3((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T3((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr2(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e);
    }
    function Wp(t) {
      let e = "", r = t.length, o2 = t[0] === "-" ? 1 : 0;
      for (;r >= o2 + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function l_(t, e, r) {
      if (typeof e == "function")
        return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o2 = (e.match(/%[dfijoOs]/g) || []).length;
      return vn(o2 === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o2}).`), r.length === 0 ? e : n_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o2 extends r {
        constructor(...p3) {
          super(l_(t, e, p3));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o2.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o2.prototype.code = t, o2.prototype[o_] = true, Po[t] = o2;
    }
    function Kp2(t) {
      let e = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function d_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new a_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var _h = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o2 = "The ";
      t.endsWith(" argument") ? o2 += `${t} ` : o2 += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o2 += "must be ";
      let f3 = [], p3 = [], m3 = [];
      for (let M3 of e)
        vn(typeof M3 == "string", "All expected entries have to be of type string"), s_.includes(M3) ? f3.push(M3.toLowerCase()) : h_.test(M3) ? p3.push(M3) : (vn(M3 !== "object", 'The value "object" should be written as "Object"'), m3.push(M3));
      if (p3.length > 0) {
        let M3 = f3.indexOf("object");
        M3 !== -1 && (f3.splice(f3, M3, 1), p3.push("Object"));
      }
      if (f3.length > 0) {
        switch (f3.length) {
          case 1:
            o2 += `of type ${f3[0]}`;
            break;
          case 2:
            o2 += `one of type ${f3[0]} or ${f3[1]}`;
            break;
          default: {
            let M3 = f3.pop();
            o2 += `one of type ${f3.join(", ")}, or ${M3}`;
          }
        }
        (p3.length > 0 || m3.length > 0) && (o2 += " or ");
      }
      if (p3.length > 0) {
        switch (p3.length) {
          case 1:
            o2 += `an instance of ${p3[0]}`;
            break;
          case 2:
            o2 += `an instance of ${p3[0]} or ${p3[1]}`;
            break;
          default: {
            let M3 = p3.pop();
            o2 += `an instance of ${p3.join(", ")}, or ${M3}`;
          }
        }
        m3.length > 0 && (o2 += " or ");
      }
      switch (m3.length) {
        case 0:
          break;
        case 1:
          m3[0].toLowerCase() !== m3[0] && (o2 += "an "), o2 += `${m3[0]}`;
          break;
        case 2:
          o2 += `one of ${m3[0]} or ${m3[1]}`;
          break;
        default: {
          let M3 = m3.pop();
          o2 += `one of ${m3.join(", ")}, or ${M3}`;
        }
      }
      if (r == null)
        o2 += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o2 += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y5;
        (y5 = r.constructor) !== null && y5 !== undefined && y5.name ? o2 += `. Received an instance of ${r.constructor.name}` : o2 += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M3 = Do(r, { colors: false });
        M3.length > 25 && (M3 = `${M3.slice(0, 25)}...`), o2 += `. Received type ${typeof r} (${M3})`;
      }
      return o2;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o2 = Do(e);
      return o2.length > 128 && (o2 = o2.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o2}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o2;
      let f3 = r != null && (o2 = r.constructor) !== null && o2 !== undefined && o2.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f3}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o2) => `"${o2}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o2 = t.pop();
            e += `The ${t.join(", ")}, and ${o2} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      vn(e, 'Missing "range" argument');
      let o2;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o2 = Wp(String(r)) : typeof r == "bigint" ? (o2 = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o2 = Wp(o2)), o2 += "n") : o2 = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o2}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp2(d_), hideStackFrames: Kp2, codes: Po };
  });
  pa = T3((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt5(), { hideStackFrames: Ir4, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr2(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr2().types, Vp2 = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e), t;
    }
    var k_ = Ir4((t, e, r = b_, o2 = v_) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o2)
        throw new bn(e, `>= ${r} && <= ${o2}`, t);
    }), L_ = Ir4((t, e, r = -2147483648, o2 = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o2)
        throw new bn(e, `>= ${r} && <= ${o2}`, t);
    }), Xp = Ir4((t, e, r = false) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      let o2 = r ? 1 : 0, f3 = 4294967295;
      if (t < o2 || t > f3)
        throw new bn(e, `>= ${o2} && <= ${f3}`, t);
    });
    function Jp(t, e) {
      if (typeof t != "string")
        throw new tr(e, "string", t);
    }
    function N_(t, e, r = undefined, o2) {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (r != null && t < r || o2 != null && t > o2 || (r != null || o2 != null) && p_(t))
        throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o2 != null ? " && " : ""}${o2 != null ? `<= ${o2}` : ""}`, t);
    }
    var D_ = Ir4((t, e, r) => {
      if (!Gp(r, t)) {
        let o2 = Yp(c_(r, (p3) => typeof p3 == "string" ? `'${p3}'` : w_(p3)), ", "), f3 = "must be one of: " + o2;
        throw new Co(e, t, f3);
      }
    });
    function P_(t, e) {
      if (typeof t != "boolean")
        throw new tr(e, "boolean", t);
    }
    function xh2(t, e, r) {
      return t == null || !g_(t, e) ? r : t[e];
    }
    var C_ = Ir4((t, e, r = null) => {
      let o2 = xh2(r, "allowArray", false), f3 = xh2(r, "allowFunction", false);
      if (!xh2(r, "nullable", false) && t === null || !o2 && $p(t) || typeof t != "object" && (!f3 || typeof t != "function"))
        throw new tr(e, "Object", t);
    }), O_ = Ir4((t, e, r = 0) => {
      if (!$p(t))
        throw new tr(e, "Array", t);
      if (t.length < r) {
        let o2 = `must be longer than ${r}`;
        throw new Co(e, t, o2);
      }
    });
    function F_(t, e = "signal") {
      if (Jp(t, e), Vp2[t] === undefined)
        throw Vp2[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir4((t, e = "buffer") => {
      if (!A_(t))
        throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e) {
      let r = S_(e), o2 = t.length;
      if (r === "hex" && o2 % 2 !== 0)
        throw new Co("encoding", e, `is invalid for data of length ${o2}`);
    }
    function H_(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e, t, r);
      return t | 0;
    }
    var W_ = Ir4((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e, "AbortSignal", t);
    }), K_ = Ir4((t, e) => {
      if (typeof t != "function")
        throw new tr(e, "Function", t);
    }), j_ = Ir4((t, e) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e, "Function", t);
    }), Z_ = Ir4((t, e) => {
      if (t !== undefined)
        throw new tr(e, "undefined", t);
    });
    function V_(t, e, r) {
      if (!Gp(r, t))
        throw new tr(e, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T3((kI, i1) => {
    var dt3 = i1.exports = {}, Yr2, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr2 = setTimeout : Yr2 = Eh;
      } catch {
        Yr2 = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr2 === setTimeout)
        return setTimeout(t, 0);
      if ((Yr2 === Eh || !Yr2) && setTimeout)
        return Yr2 = setTimeout, setTimeout(t, 0);
      try {
        return Yr2(t, 0);
      } catch {
        try {
          return Yr2.call(null, t, 0);
        } catch {
          return Yr2.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi3 = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi3 = mn.concat(pi3) : Oo = -1, pi3.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e = pi3.length;e; ) {
          for (mn = pi3, pi3 = [];++Oo < e; )
            mn && mn[Oo].run();
          Oo = -1, e = pi3.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt3.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      pi3.push(new r1(t, e)), pi3.length === 1 && !nf && e1(t1);
    };
    function r1(t, e) {
      this.fun = t, this.array = e;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt3.title = "browser";
    dt3.browser = true;
    dt3.env = {};
    dt3.argv = [];
    dt3.version = "";
    dt3.versions = {};
    function vi3() {
    }
    dt3.on = vi3;
    dt3.addListener = vi3;
    dt3.once = vi3;
    dt3.off = vi3;
    dt3.removeListener = vi3;
    dt3.removeAllListeners = vi3;
    dt3.emit = vi3;
    dt3.prependListener = vi3;
    dt3.prependOnceListener = vi3;
    dt3.listeners = function(t) {
      return [];
    };
    dt3.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt3.cwd = function() {
      return "/";
    };
    dt3.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt3.umask = function() {
      return 0;
    };
  });
  pr2 = {};
  Ja(pr2, { default: () => Y_ });
  Oi = R0(() => {
    ot3(pr2, rn2(Rh()));
    Y_ = rn2(Rh());
  });
  Fi = T3((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt5(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e) {
      return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o2 = e || r;
      return !!(t.destroyed || t[a1] || o2 != null && o2.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function Q_(t, e) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function u1(t, e) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e) {
      return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function i8(t) {
      var e, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o2 = e || r;
      return !o2 && p1(t) || !!(o2 && o2.autoDestroy && o2.emitClose && o2.closed === false);
    }
    function o8(t) {
      var e;
      return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e, r, o2, f3, p3, m3, y5, M3, x5, S3;
      return !!(t && ((e = (r = (o2 = (f3 = (p3 = (m3 = t[o1]) !== null && m3 !== undefined ? m3 : t.readableErrored) !== null && p3 !== undefined ? p3 : t.writableErrored) !== null && f3 !== undefined ? f3 : (y5 = t._readableState) === null || y5 === undefined ? undefined : y5.errorEmitted) !== null && o2 !== undefined ? o2 : (M3 = t._writableState) === null || M3 === undefined ? undefined : M3.errorEmitted) !== null && r !== undefined ? r : (x5 = t._readableState) === null || x5 === undefined ? undefined : x5.errored) !== null && e !== undefined ? e : (S3 = t._writableState) === null || S3 === undefined ? undefined : S3.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T3((DI, Ih) => {
    var ff2 = (Oi(), ur2(pr2)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr2(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt5(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {
    };
    function S1(t, e, r) {
      var o2, f3;
      arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
      let p3 = (o2 = e.readable) !== null && o2 !== undefined ? o2 : qh(t), m3 = (f3 = e.writable) !== null && f3 !== undefined ? f3 : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y5, _readableState: M3 } = t, x5 = () => {
        t.writable || B3();
      }, S3 = w8(t) && qh(t) === p3 && _1(t) === m3, E6 = x1(t, false), B3 = () => {
        E6 = true, t.destroyed && (S3 = false), !(S3 && (!t.readable || p3)) && (!p3 || q3) && r.call(t);
      }, q3 = w1(t, false), L4 = () => {
        q3 = true, t.destroyed && (S3 = false), !(S3 && (!t.writable || m3)) && (!m3 || E6) && r.call(t);
      }, ge = (xe2) => {
        r.call(t, xe2);
      }, _e3 = b8(t), N6 = () => {
        _e3 = true;
        let xe2 = g8(t) || m8(t);
        if (xe2 && typeof xe2 != "boolean")
          return r.call(t, xe2);
        if (p3 && !q3 && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m3 && !E6 && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B3);
      };
      M8(t) ? (t.on("complete", B3), S3 || t.on("abort", N6), t.req ? we() : t.on("request", we)) : m3 && !y5 && (t.on("end", x5), t.on("close", x5)), !S3 && typeof t.aborted == "boolean" && t.on("aborted", N6), t.on("end", L4), t.on("finish", B3), e.error !== false && t.on("error", ge), t.on("close", N6), _e3 ? ff2.nextTick(N6) : y5 != null && y5.errorEmitted || M3 != null && M3.errorEmitted ? S3 || ff2.nextTick(N6) : (!p3 && (!S3 || y1(t)) && (E6 || M1(t) === false) || !m3 && (!S3 || M1(t)) && (q3 || y1(t) === false) || M3 && t.req && t.aborted) && ff2.nextTick(N6);
      let ye2 = () => {
        r = _8, t.removeListener("aborted", N6), t.removeListener("complete", B3), t.removeListener("abort", N6), t.removeListener("request", we), t.req && t.req.removeListener("finish", B3), t.removeListener("end", x5), t.removeListener("close", x5), t.removeListener("finish", B3), t.removeListener("end", L4), t.removeListener("error", ge), t.removeListener("close", N6);
      };
      if (e.signal && !_e3) {
        let xe2 = () => {
          let Re = r;
          ye2(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          ff2.nextTick(xe2);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e.signal.removeEventListener("abort", xe2), Re.apply(t, Ee);
          }), e.signal.addEventListener("abort", xe2);
        }
      }
      return ye2;
    }
    function x8(t, e) {
      return new v8((r, o2) => {
        S1(t, e, (f3) => {
          f3 ? o2(f3) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k1 = T3((PI, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va2, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr2 } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt5().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt5(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e) {
      if (typeof t != "function")
        throw new va2("fn", ["Function", "AsyncFunction"], t);
      e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f3, p3;
        let m3 = new B1, y5 = this, M3 = [], x5 = m3.signal, S3 = { signal: x5 }, E6 = () => m3.abort();
        e != null && (f3 = e.signal) !== null && f3 !== undefined && f3.aborted && E6(), e == null || (p3 = e.signal) === null || p3 === undefined || p3.addEventListener("abort", E6);
        let B3, q3, L4 = false;
        function ge() {
          L4 = true;
        }
        async function _e3() {
          try {
            for await (let ye2 of y5) {
              var N6;
              if (L4)
                return;
              if (x5.aborted)
                throw new Jr2;
              try {
                ye2 = t(ye2, S3);
              } catch (xe2) {
                ye2 = A1(xe2);
              }
              ye2 !== Wo && (typeof ((N6 = ye2) === null || N6 === undefined ? undefined : N6.catch) == "function" && ye2.catch(ge), M3.push(ye2), B3 && (B3(), B3 = null), !L4 && M3.length && M3.length >= r && await new E1((xe2) => {
                q3 = xe2;
              }));
            }
            M3.push(R1);
          } catch (ye2) {
            let xe2 = A1(ye2);
            L8(xe2, undefined, ge), M3.push(xe2);
          } finally {
            var we;
            L4 = true, B3 && (B3(), B3 = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E6);
          }
        }
        _e3();
        try {
          for (;; ) {
            for (;M3.length > 0; ) {
              let N6 = await M3[0];
              if (N6 === R1)
                return;
              if (x5.aborted)
                throw new Jr2;
              N6 !== Wo && (yield N6), M3.shift(), q3 && (q3(), q3 = null);
            }
            await new E1((N6) => {
              B3 = N6;
            });
          }
        } finally {
          m3.abort(), L4 = true, q3 && (q3(), q3 = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f3 of this) {
          var o2;
          if (t != null && (o2 = t.signal) !== null && o2 !== undefined && o2.aborted)
            throw new Jr2({ cause: t.signal.reason });
          yield [r++, f3];
        }
      }.call(this);
    }
    async function I1(t, e = undefined) {
      for await (let r of kh.call(this, t, e))
        return true;
      return false;
    }
    async function D8(t, e = undefined) {
      if (typeof t != "function")
        throw new va2("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e);
    }
    async function P8(t, e) {
      for await (let r of kh.call(this, t, e))
        return r;
    }
    async function C8(t, e) {
      if (typeof t != "function")
        throw new va2("fn", ["Function", "AsyncFunction"], t);
      async function r(o2, f3) {
        return await t(o2, f3), Wo;
      }
      for await (let o2 of Ko.call(this, r, e))
        ;
    }
    function kh(t, e) {
      if (typeof t != "function")
        throw new va2("fn", ["Function", "AsyncFunction"], t);
      async function r(o2, f3) {
        return await t(o2, f3) ? o2 : Wo;
      }
      return Ko.call(this, r, e);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e, r) {
      var o2;
      if (typeof t != "function")
        throw new va2("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f3 = arguments.length > 1;
      if (r != null && (o2 = r.signal) !== null && o2 !== undefined && o2.aborted) {
        let x5 = new Jr2(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await B8(this.destroy(x5)), x5;
      }
      let p3 = new B1, m3 = p3.signal;
      if (r != null && r.signal) {
        let x5 = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p3.abort(), x5);
      }
      let y5 = false;
      try {
        for await (let x5 of this) {
          var M3;
          if (y5 = true, r != null && (M3 = r.signal) !== null && M3 !== undefined && M3.aborted)
            throw new Jr2;
          f3 ? e = await t(e, x5, { signal: m3 }) : (e = x5, f3 = true);
        }
        if (!y5 && !f3)
          throw new Th;
      } finally {
        p3.abort();
      }
      return e;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e = [];
      for await (let o2 of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr2(undefined, { cause: t.signal.reason });
        q8(e, o2);
      }
      return e;
    }
    function U8(t, e) {
      let r = Ko.call(this, t, e);
      return async function* () {
        for await (let f3 of r)
          yield* f3;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o2;
        if (e != null && (o2 = e.signal) !== null && o2 !== undefined && o2.aborted)
          throw new Jr2;
        for await (let p3 of this) {
          var f3;
          if (e != null && (f3 = e.signal) !== null && f3 !== undefined && f3.aborted)
            throw new Jr2;
          t-- <= 0 && (yield p3);
        }
      }.call(this);
    }
    function H8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o2;
        if (e != null && (o2 = e.signal) !== null && o2 !== undefined && o2.aborted)
          throw new Jr2;
        for await (let p3 of this) {
          var f3;
          if (e != null && (f3 = e.signal) !== null && f3 !== undefined && f3.aborted)
            throw new Jr2;
          if (t-- > 0)
            yield p3;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn2 = T3((CI, U1) => {
    var zi = (Oi(), ur2(pr2)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt5(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e) {
      let r = this._readableState, o2 = this._writableState, f3 = o2 || r;
      return o2 && o2.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o2, r), o2 && (o2.destroyed = true), r && (r.destroyed = true), f3.constructed ? L1(this, t, e) : this.once(P1, function(p3) {
        L1(this, W8(p3, t), e);
      }), this);
    }
    function L1(t, e, r) {
      let o2 = false;
      function f3(p3) {
        if (o2)
          return;
        o2 = true;
        let { _readableState: m3, _writableState: y5 } = t;
        C1(p3, y5, m3), y5 && (y5.closed = true), m3 && (m3.closed = true), typeof r == "function" && r(p3), p3 ? zi.nextTick(X8, t, p3) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e || null, f3);
      } catch (p3) {
        f3(p3);
      }
    }
    function X8(t, e) {
      Dh(t, e), O1(t);
    }
    function O1(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
    }
    function Dh(t, e) {
      let { _readableState: r, _writableState: o2 } = t;
      o2 && o2.errorEmitted || r && r.errorEmitted || (o2 && (o2.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function J8() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Ph(t, e, r) {
      let { _readableState: o2, _writableState: f3 } = t;
      if (f3 && f3.destroyed || o2 && o2.destroyed)
        return this;
      o2 && o2.autoDestroy || f3 && f3.autoDestroy ? t.destroy(e) : e && (e.stack, f3 && !f3.errored && (f3.errored = e), o2 && !o2.errored && (o2.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
    }
    function Q8(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o2 } = t;
      r && (r.constructed = false), o2 && (o2.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e = false;
      function r(o2) {
        if (e) {
          Ph(t, o2 ?? new K8);
          return;
        }
        e = true;
        let { _readableState: f3, _writableState: p3 } = t, m3 = p3 || f3;
        f3 && (f3.constructed = true), p3 && (p3.constructed = true), m3.destroyed ? t.emit(P1, o2) : o2 ? Ph(t, o2, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o2) {
        r(o2);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e) {
      t.emit("error", e), zi.nextTick(F1, t);
    }
    function i5(t, e) {
      !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T3((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt5(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e) {
      let r = this;
      function o2(S3) {
        t.writable && t.write(S3) === false && r.pause && r.pause();
      }
      r.on("data", o2);
      function f3() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f3), !t._isStdio && (!e || e.end !== false) && (r.on("end", m3), r.on("close", y5));
      let p3 = false;
      function m3() {
        p3 || (p3 = true, t.end());
      }
      function y5() {
        p3 || (p3 = true, typeof t.destroy == "function" && t.destroy());
      }
      function M3(S3) {
        x5(), jo.listenerCount(this, "error") === 0 && this.emit("error", S3);
      }
      Ch(r, "error", M3), Ch(t, "error", M3);
      function x5() {
        r.removeListener("data", o2), t.removeListener("drain", f3), r.removeListener("end", m3), r.removeListener("close", y5), r.removeListener("error", M3), t.removeListener("error", M3), r.removeListener("end", x5), r.removeListener("close", x5), t.removeListener("close", x5);
      }
      return r.on("end", x5), r.on("close", x5), t.on("close", x5), t.emit("pipe", r), t;
    };
    function Ch(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T3((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e, r) {
      if (s5(e, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = () => {
        e.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  Z1 = T3((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt5(), { Buffer: Oh2 } = Ut3(), { inspect: d5 } = Gr2();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o2 = "" + r.data;
        for (;(r = r.next) !== null; )
          o2 += e + r.data;
        return o2;
      }
      concat(e) {
        if (this.length === 0)
          return Oh2.alloc(0);
        let r = Oh2.allocUnsafe(e >>> 0), o2 = this.head, f3 = 0;
        for (;o2; )
          Yo(r, o2.data, f3), f3 += o2.data.length, o2 = o2.next;
        return r;
      }
      consume(e, r) {
        let o2 = this.head.data;
        if (e < o2.length) {
          let f3 = o2.slice(0, e);
          return this.head.data = o2.slice(e), f3;
        }
        return e === o2.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o2 = this.head, f3 = 0;
        do {
          let p3 = o2.data;
          if (e > p3.length)
            r += p3, e -= p3.length;
          else {
            e === p3.length ? (r += p3, ++f3, o2.next ? this.head = o2.next : this.head = this.tail = null) : (r += K1(p3, 0, e), this.head = o2, o2.data = K1(p3, e));
            break;
          }
          ++f3;
        } while ((o2 = o2.next) !== null);
        return this.length -= f3, r;
      }
      _getBuffer(e) {
        let r = Oh2.allocUnsafe(e), o2 = e, f3 = this.head, p3 = 0;
        do {
          let m3 = f3.data;
          if (e > m3.length)
            Yo(r, m3, o2 - e), e -= m3.length;
          else {
            e === m3.length ? (Yo(r, m3, o2 - e), ++p3, f3.next ? this.head = f3.next : this.head = this.tail = null) : (Yo(r, new l5(m3.buffer, m3.byteOffset, e), o2 - e), this.head = f3, f3.data = m3.slice(e));
            break;
          }
          ++p3;
        } while ((f3 = f3.next) !== null);
        return this.length -= p3, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T3((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt5(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b52(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e, r, o2) {
      let f3 = b52(e, o2, r);
      if (f3 != null) {
        if (!p5(f3) || f3 < 0) {
          let p3 = o2 ? `options.${r}` : "options.highWaterMark";
          throw new v5(p3, f3);
        }
        return c5(f3);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T3((WI, J1) => {
    var G1 = (Oi(), ur2(pr2)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt5(), { Buffer: y5 } = Ut3(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e, r) {
      let o2;
      if (typeof e == "string" || e instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f3;
      if (e && e[Y1])
        f3 = true, o2 = e[Y1]();
      else if (e && e[X1])
        f3 = false, o2 = e[X1]();
      else
        throw new w5("iterable", ["Iterable"], e);
      let p3 = new t({ objectMode: true, highWaterMark: 1, ...r }), m3 = false;
      p3._read = function() {
        m3 || (m3 = true, M3());
      }, p3._destroy = function(x5, S3) {
        g5(y6(x5), () => G1.nextTick(S3, x5), (E6) => G1.nextTick(S3, E6 || x5));
      };
      async function y6(x5) {
        let S3 = x5 != null, E6 = typeof o2.throw == "function";
        if (S3 && E6) {
          let { value: B3, done: q3 } = await o2.throw(x5);
          if (await B3, q3)
            return;
        }
        if (typeof o2.return == "function") {
          let { value: B3 } = await o2.return();
          await B3;
        }
      }
      async function M3() {
        for (;; ) {
          try {
            let { value: x5, done: S3 } = f3 ? await o2.next() : o2.next();
            if (S3)
              p3.push(null);
            else {
              let E6 = x5 && typeof x5.then == "function" ? await x5 : x5;
              if (E6 === null)
                throw m3 = false, new M5;
              if (p3.push(E6))
                continue;
              m3 = false;
            }
          } catch (x5) {
            p3.destroy(x5);
          }
          break;
        }
      }
      return p3;
    }
    J1.exports = _5;
  });
  ba = T3((KI, lv) => {
    var Tr = (Oi(), ur2(pr2)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E52, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt5();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi2, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut3(), { addAbortSignal: N52 } = Go(), D5 = Ui(), Pe3 = Gr2().debuglog("stream", (t) => {
      Pe3 = t;
    }), P5 = Z1(), hf = yn2(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi2.prototype);
    rv(Le, Hi2);
    var zh = () => {
    }, { errorOrDestroy: sf } = hf;
    function jh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr2()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof Qr2();
      this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N52(t.signal, this)), Hi2.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo2(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return nv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return nv(this, t, e, true);
    };
    function nv(t, e, r, o2) {
      Pe3("readableAddChunk", e);
      let f3 = t._readableState, p3;
      if (f3.objectMode || (typeof e == "string" ? (r = r || f3.defaultEncoding, f3.encoding !== r && (o2 && f3.encoding ? e = Uh.from(e, r).toString(f3.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi2._isUint8Array(e) ? (e = Hi2._uint8ArrayToBuffer(e), r = "") : e != null && (p3 = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p3)
        sf(t, p3);
      else if (e === null)
        f3.reading = false, $5(t, f3);
      else if (f3.objectMode || e && e.length > 0)
        if (o2)
          if (f3.endEmitted)
            sf(t, new W5);
          else {
            if (f3.destroyed || f3.errored)
              return false;
            Hh(t, f3, e, true);
          }
        else if (f3.ended)
          sf(t, new H5);
        else {
          if (f3.destroyed || f3.errored)
            return false;
          f3.reading = false, f3.decoder && !r ? (e = f3.decoder.write(e), f3.objectMode || e.length !== 0 ? Hh(t, f3, e, false) : Jo2(t, f3)) : Hh(t, f3, e, false);
        }
      else
        o2 || (f3.reading = false, Jo2(t, f3));
      return !f3.ended && (f3.length < f3.highWaterMark || f3.length === 0);
    }
    function Hh(t, e, r, o2) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo2(t)), Jo2(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new iv(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o2 = "";
      for (let f3 of r)
        o2 += e.write(f3);
      return r.clear(), o2 !== "" && r.push(o2), this._readableState.length = o2.length, this;
    };
    var Z5 = 1073741824;
    function V52(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E52(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe3("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = V52(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe3("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo2(this), null;
      if (t = ev(t, e), t === 0 && e.ended)
        return e.length === 0 && Wh(this), null;
      let o2 = e.needReadable;
      if (Pe3("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, Pe3("length less than watermark", o2)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o2 = false, Pe3("reading, ended or constructing", o2);
      else if (o2) {
        Pe3("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p3) {
          sf(this, p3);
        }
        e.sync = false, e.reading || (t = ev(r, e));
      }
      let f3;
      return t > 0 ? f3 = hv(t, e) : f3 = null, f3 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f3 !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f3)), f3;
    };
    function $5(t, e) {
      if (Pe3("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Qo2(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
      }
    }
    function Qo2(t) {
      let e = t._readableState;
      Pe3("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe3("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e = t._readableState;
      Pe3("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
    }
    function Jo2(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
    }
    function G5(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (Pe3("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o2 = this._readableState;
      o2.pipes.length === 1 && (o2.multiAwaitDrain || (o2.multiAwaitDrain = true, o2.awaitDrainWriters = new q5(o2.awaitDrainWriters ? [o2.awaitDrainWriters] : []))), o2.pipes.push(t), Pe3("pipe count=%d opts=%j", o2.pipes.length, e);
      let p3 = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y5 : _e3;
      o2.endEmitted ? Tr.nextTick(p3) : r.once("end", p3), t.on("unpipe", m3);
      function m3(N6, we) {
        Pe3("onunpipe"), N6 === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S3());
      }
      function y5() {
        Pe3("onend"), t.end();
      }
      let M3, x6 = false;
      function S3() {
        Pe3("cleanup"), t.removeListener("close", L4), t.removeListener("finish", ge), M3 && t.removeListener("drain", M3), t.removeListener("error", q3), t.removeListener("unpipe", m3), r.removeListener("end", y5), r.removeListener("end", _e3), r.removeListener("data", B3), x6 = true, M3 && o2.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M3();
      }
      function E6() {
        x6 || (o2.pipes.length === 1 && o2.pipes[0] === t ? (Pe3("false write response, pause", 0), o2.awaitDrainWriters = t, o2.multiAwaitDrain = false) : o2.pipes.length > 1 && o2.pipes.includes(t) && (Pe3("false write response, pause", o2.awaitDrainWriters.size), o2.awaitDrainWriters.add(t)), r.pause()), M3 || (M3 = Y5(r, t), t.on("drain", M3));
      }
      r.on("data", B3);
      function B3(N6) {
        Pe3("ondata");
        let we = t.write(N6);
        Pe3("dest.write", we), we === false && E6();
      }
      function q3(N6) {
        if (Pe3("onerror", N6), _e3(), t.removeListener("error", q3), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N6) : t.emit("error", N6);
        }
      }
      L5(t, "error", q3);
      function L4() {
        t.removeListener("finish", ge), _e3();
      }
      t.once("close", L4);
      function ge() {
        Pe3("onfinish"), t.removeListener("close", L4), _e3();
      }
      t.once("finish", ge);
      function _e3() {
        Pe3("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o2.flowing && E6() : o2.flowing || (Pe3("pipe resume"), r.resume()), t;
    };
    function Y5(t, e) {
      return function() {
        let o2 = t._readableState;
        o2.awaitDrainWriters === e ? (Pe3("pipeOnDrain", 1), o2.awaitDrainWriters = null) : o2.multiAwaitDrain && (Pe3("pipeOnDrain", o2.awaitDrainWriters.size), o2.awaitDrainWriters.delete(e)), (!o2.awaitDrainWriters || o2.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f3 = e.pipes;
        e.pipes = [], this.pause();
        for (let p3 = 0;p3 < f3.length; p3++)
          f3[p3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o2 = x5(e.pipes, t);
      return o2 === -1 ? this : (e.pipes.splice(o2, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Hi2.prototype.on.call(this, t, e), o2 = this._readableState;
      return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, Pe3("on readable", o2.length, o2.reading), o2.length ? Qo2(this) : o2.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Hi2.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Hi2.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
    };
    function av(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function X5(t) {
      Pe3("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe3("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
    }
    function Q5(t, e) {
      Pe3("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e = t._readableState;
      for (Pe3("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o2) => {
        !this.push(o2) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o2) => {
        sf(this, o2);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = R5(t);
      for (let o2 = 1;o2 < r.length; o2++) {
        let f3 = r[o2];
        this[f3] === undefined && typeof t[f3] == "function" && (this[f3] = t[f3].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e);
      return r.stream = t, r;
    }
    async function* ex(t, e) {
      let r = zh;
      function o2(m3) {
        this === t ? (r(), r = zh) : r = m3;
      }
      t.on("readable", o2);
      let f3, p3 = D5(t, { writable: false }, (m3) => {
        f3 = m3 ? Q1(f3, m3) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m3 = t.destroyed ? null : t.read();
          if (m3 !== null)
            yield m3;
          else {
            if (f3)
              throw f3;
            if (f3 === null)
              return;
            await new B5(o2);
          }
        }
      } catch (m3) {
        throw f3 = Q1(f3, m3), f3;
      } finally {
        (f3 || e?.destroyOnReturn !== false) && (f3 === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o2), p3());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wh(t) {
      let e = t._readableState;
      Pe3("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
    }
    function tx(t, e) {
      if (Pe3("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(rx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return j5(Le, t, e);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e) {
      return uv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return uv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o2;
      return new Le({ objectMode: (r = (o2 = t.readableObjectMode) !== null && o2 !== undefined ? o2 : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f3, p3) {
        hf.destroyer(t, f3), p3(f3);
      } }).wrap(t);
    };
  });
  Jh = T3((jI, xv) => {
    var Mn = (Oi(), ur2(pr2)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt5();
    xv.exports = st3;
    st3.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut3(), is = yn2(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st3.prototype, ma.prototype);
    mv(st3, ma);
    function $h() {
    }
    var lf = ax("kOnFinished");
    function ya(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr2()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o2 = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o2, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st3(t) {
      let e = this instanceof Qr2();
      if (!e && !vv(st3, this))
        return new st3(t);
      this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st3, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st3 ? false : t && t._writableState instanceof ya;
    } });
    st3.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e, r, o2) {
      let f3 = t._writableState;
      if (typeof r == "function")
        o2 = r, r = f3.defaultEncoding;
      else {
        if (!r)
          r = f3.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o2 != "function" && (o2 = $h);
      }
      if (e === null)
        throw new bx;
      if (!f3.objectMode)
        if (typeof e == "string")
          f3.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
        else if (e instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e))
          e = ma._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p3;
      return f3.ending ? p3 = new mx : f3.destroyed && (p3 = new ga("write")), p3 ? (Mn.nextTick(o2, p3), uf(t, p3, true), p3) : (f3.pendingcb++, gx(t, f3, e, r, o2));
    }
    st3.prototype.write = function(t, e, r) {
      return wv(this, t, e, r) === true;
    };
    st3.prototype.cork = function() {
      this._writableState.corked++;
    };
    st3.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st3.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
        throw new yv(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function gx(t, e, r, o2, f3) {
      let p3 = e.objectMode ? 1 : r.length;
      e.length += p3;
      let m3 = e.length < e.highWaterMark;
      return m3 || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o2, callback: f3 }), e.allBuffers && o2 !== "buffer" && (e.allBuffers = false), e.allNoop && f3 !== $h && (e.allNoop = false)) : (e.writelen = p3, e.writecb = f3, e.writing = true, e.sync = true, t._write(r, o2, e.onwrite), e.sync = false), m3 && !e.errored && !e.destroyed;
    }
    function dv(t, e, r, o2, f3, p3, m3) {
      e.writelen = o2, e.writecb = m3, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f3, e.onwrite) : t._write(f3, p3, e.onwrite), e.sync = false;
    }
    function cv(t, e, r, o2) {
      --e.pendingcb, o2(r), Gh(e), uf(t, r);
    }
    function yx(t, e) {
      let r = t._writableState, o2 = r.sync, f3 = r.writecb;
      if (typeof f3 != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o2 ? Mn.nextTick(cv, t, r, e, f3) : cv(t, r, e, f3)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o2 ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f3 ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f3, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f3));
    }
    function wx({ stream: t, state: e, count: r, cb: o2 }) {
      return e.afterWriteTickInfo = null, Mv(t, e, r, o2);
    }
    function Mv(t, e, r, o2) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o2();
      e.destroyed && Gh(e), Xh(t, e);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f3 = t.bufferedIndex;f3 < t.buffered.length; ++f3) {
        var e;
        let { chunk: p3, callback: m3 } = t.buffered[f3], y5 = t.objectMode ? 1 : p3.length;
        t.length -= y5, m3((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f3 = 0;f3 < r.length; f3++) {
        var o2;
        r[f3]((o2 = t.errored) !== null && o2 !== undefined ? o2 : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o2, objectMode: f3 } = e, p3 = r.length - o2;
      if (!p3)
        return;
      let m3 = o2;
      if (e.bufferProcessing = true, p3 > 1 && t._writev) {
        e.pendingcb -= p3 - 1;
        let y5 = e.allNoop ? $h : (x5) => {
          for (let S3 = m3;S3 < r.length; ++S3)
            r[S3].callback(x5);
        }, M3 = e.allNoop && m3 === 0 ? r : pv(r, m3);
        M3.allBuffers = e.allBuffers, dv(t, e, true, e.length, M3, "", y5), rs(e);
      } else {
        do {
          let { chunk: y5, encoding: M3, callback: x5 } = r[m3];
          r[m3++] = null;
          let S3 = f3 ? 1 : y5.length;
          dv(t, e, false, S3, y5, M3, x5);
        } while (m3 < r.length && !e.writing);
        m3 === r.length ? rs(e) : m3 > 256 ? (r.splice(0, m3), e.bufferedIndex = 0) : e.bufferedIndex = m3;
      }
      e.bufferProcessing = false;
    }
    st3.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new cx("_write()");
    };
    st3.prototype._writev = null;
    st3.prototype.end = function(t, e, r) {
      let o2 = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f3;
      if (t != null) {
        let p3 = wv(this, t, e);
        p3 instanceof ix && (f3 = p3);
      }
      return o2.corked && (o2.corked = 1, this.uncork()), f3 || (!o2.errored && !o2.ending ? (o2.ending = true, Xh(this, o2, true), o2.ended = true) : o2.finished ? f3 = new vx("end") : o2.destroyed && (f3 = new ga("end"))), typeof r == "function" && (f3 || o2.finished ? Mn.nextTick(r, f3) : o2[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e) {
      let r = false;
      function o2(f3) {
        if (r) {
          uf(t, f3 ?? gv());
          return;
        }
        if (r = true, e.pendingcb--, f3) {
          let p3 = e[lf].splice(0);
          for (let m3 = 0;m3 < p3.length; m3++)
            p3[m3](f3);
          uf(t, f3, e.sync);
        } else
          ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh2, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o2);
      } catch (f3) {
        o2(f3);
      }
      e.sync = false;
    }
    function _x(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e, r) {
      ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o2, f3) => {
        ts(f3) ? Vh2(o2, f3) : f3.pendingcb--;
      }, t, e)) : ts(e) && (e.pendingcb++, Vh2(t, e))));
    }
    function Vh2(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[lf].splice(0);
      for (let o2 = 0;o2 < r.length; o2++)
        r[o2]();
      if (t.emit("finish"), e.autoDestroy) {
        let o2 = t._readableState;
        (!o2 || o2.autoDestroy && (o2.endEmitted || o2.readable === false)) && t.destroy();
      }
    }
    nx(st3.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st3.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
    };
    st3.prototype._undestroy = is.undestroy;
    st3.prototype._destroy = function(t, e) {
      e(t);
    };
    st3.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st3.fromWeb = function(t, e) {
      return _v().newStreamWritableFromWritableStream(t, e);
    };
    st3.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T3((ZI, Nv) => {
    var Qh = (Oi(), ur2(pr2)), Sx = Ut3(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn2(), Ix = Qr2(), Tx = ba(), { createDeferredPromise: qv } = Gr2(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
      return e instanceof Tv;
    } : function(e) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt5(), _n2 = class extends Ix {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e, r) {
      if (Bx(e))
        return e;
      if (Ev(e))
        return ns({ readable: e });
      if (Av(e))
        return ns({ writable: e });
      if (Rx(e))
        return ns({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f3, write: p3, final: m3, destroy: y5 } = Nx(e);
        if (Sv(f3))
          return Iv(_n2, f3, { objectMode: true, write: p3, final: m3, destroy: y5 });
        let M3 = f3?.then;
        if (typeof M3 == "function") {
          let x5, S3 = kv(M3, f3, (E6) => {
            if (E6 != null)
              throw new Bv("nully", "body", E6);
          }, (E6) => {
            df(x5, E6);
          });
          return x5 = new _n2({ objectMode: true, readable: false, write: p3, final(E6) {
            m3(async () => {
              try {
                await S3, Qh.nextTick(E6, null);
              } catch (B3) {
                Qh.nextTick(E6, B3);
              }
            });
          }, destroy: y5 });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f3);
      }
      if (kx(e))
        return t(e.arrayBuffer());
      if (Sv(e))
        return Iv(_n2, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f3 = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p3 = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return ns({ readable: f3, writable: p3 });
      }
      let o2 = e?.then;
      if (typeof o2 == "function") {
        let f3;
        return kv(o2, e, (p3) => {
          p3 != null && f3.push(p3), f3.push(null);
        }, (p3) => {
          df(f3, p3);
        }), f3 = new _n2({ objectMode: true, writable: false, read() {
        } });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Nx(t) {
      let { promise: e, resolve: r } = qv(), o2 = new Lx, f3 = o2.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m3 = e;
          e = null;
          let { chunk: y5, done: M3, cb: x5 } = await m3;
          if (Qh.nextTick(x5), M3)
            return;
          if (f3.aborted)
            throw new Lv(undefined, { cause: f3.reason });
          ({ promise: e, resolve: r } = qv()), yield y5;
        }
      }(), { signal: f3 }), write(m3, y5, M3) {
        let x5 = r;
        r = null, x5({ chunk: m3, done: false, cb: M3 });
      }, final(m3) {
        let y5 = r;
        r = null, y5({ done: true, cb: m3 });
      }, destroy(m3, y5) {
        o2.abort(), y5(m3);
      } };
    }
    function ns(t) {
      let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o2 = !!Ex(e), f3 = !!Ax(r), p3, m3, y5, M3, x5;
      function S3(E6) {
        let B3 = M3;
        M3 = null, B3 ? B3(E6) : E6 ? x5.destroy(E6) : !o2 && !f3 && x5.destroy();
      }
      return x5 = new _n2({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o2, writable: f3 }), f3 && (Rv(r, (E6) => {
        f3 = false, E6 && df(e, E6), S3(E6);
      }), x5._write = function(E6, B3, q3) {
        r.write(E6, B3) ? q3() : p3 = q3;
      }, x5._final = function(E6) {
        r.end(), m3 = E6;
      }, r.on("drain", function() {
        if (p3) {
          let E6 = p3;
          p3 = null, E6();
        }
      }), r.on("finish", function() {
        if (m3) {
          let E6 = m3;
          m3 = null, E6();
        }
      })), o2 && (Rv(e, (E6) => {
        o2 = false, E6 && df(e, E6), S3(E6);
      }), e.on("readable", function() {
        if (y5) {
          let E6 = y5;
          y5 = null, E6();
        }
      }), e.on("end", function() {
        x5.push(null);
      }), x5._read = function() {
        for (;; ) {
          let E6 = e.read();
          if (E6 === null) {
            y5 = x5._read;
            return;
          }
          if (!x5.push(E6))
            return;
        }
      }), x5._destroy = function(E6, B3) {
        !E6 && M3 !== null && (E6 = new Lv), y5 = null, p3 = null, m3 = null, M3 === null ? B3(E6) : (M3 = B3, df(r, E6), df(e, E6));
      }, x5;
    }
  });
  Qr2 = T3((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi3, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt5();
    Ov.exports = kr;
    var ru = ba(), vr3 = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr3.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = vr3.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr3.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi3(vr3.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi3(vr3.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi3(vr3.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi3(vr3.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi3(vr3.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi3(vr3.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi3(vr3.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi3(vr3.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi3(vr3.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu2 = T3(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt5();
    Uv.exports = mi3;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr2(), { getHighWaterMark: Fx } = Xo();
    Fv(mi3.prototype, nu.prototype);
    Fv(mi3, nu);
    var wa2 = Cx("kCallback");
    function mi3(t) {
      if (!(this instanceof mi3))
        return new mi3(t);
      let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa2] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu2(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu2 && iu2.call(this);
    }
    mi3.prototype._final = iu2;
    mi3.prototype._transform = function(t, e, r) {
      throw new Ox("_transform()");
    };
    mi3.prototype._write = function(t, e, r) {
      let o2 = this._readableState, f3 = this._writableState, p3 = o2.length;
      this._transform(t, e, (m3, y5) => {
        if (m3) {
          r(m3);
          return;
        }
        y5 != null && this.push(y5), f3.ended || p3 === o2.length || o2.length < o2.highWaterMark ? r() : this[wa2] = r;
      });
    };
    mi3.prototype._read = function() {
      if (this[wa2]) {
        let t = this[wa2];
        this[wa2] = null, t();
      }
    };
  });
  ou2 = T3((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt5();
    Hv.exports = cf2;
    var au2 = fu2();
    zv(cf2.prototype, au2.prototype);
    zv(cf2, au2);
    function cf2(t) {
      if (!(this instanceof cf2))
        return new cf2(t);
      au2.call(this, t);
    }
    cf2.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  os = T3((YI, Gv) => {
    var fs = (Oi(), ur2(pr2)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt5(), as2 = Ui(), { once: Kx } = Gr2(), jx = yn2(), Wv = Qr2(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su2, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu2, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu2, lu2;
    function jv(t, e, r) {
      let o2 = false;
      t.on("close", () => {
        o2 = true;
      });
      let f3 = as2(t, { readable: e, writable: r }, (p3) => {
        o2 = !p3;
      });
      return { destroy: (p3) => {
        o2 || (o2 = true, jx.destroyer(t, p3 || new $x("pipe")));
      }, cleanup: f3 };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu2 || (lu2 = ba()), yield* lu2.prototype[Wx].call(t);
    }
    async function Zv(t, e, r, { end: o2 }) {
      let f3, p3 = null, m3 = (x5) => {
        if (x5 && (f3 = x5), p3) {
          let S3 = p3;
          p3 = null, S3();
        }
      }, y5 = () => new Hx((x5, S3) => {
        f3 ? S3(f3) : p3 = () => {
          f3 ? S3(f3) : x5();
        };
      });
      e.on("drain", m3);
      let M3 = as2(e, { readable: false }, m3);
      try {
        e.writableNeedDrain && await y5();
        for await (let x5 of t)
          e.write(x5) || await y5();
        o2 && e.end(), await y5(), r();
      } catch (x5) {
        r(f3 !== x5 ? Zx(f3, x5) : x5);
      } finally {
        M3(), e.off("drain", m3);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o2 = new Qx, f3 = o2.signal, p3 = r?.signal, m3 = [];
      Jx(p3, "options.signal");
      function y5() {
        q3(new Yx);
      }
      p3?.addEventListener("abort", y5);
      let M3, x5, S3 = [], E6 = 0;
      function B3(N6) {
        q3(N6, --E6 === 0);
      }
      function q3(N6, we) {
        if (N6 && (!M3 || M3.code === "ERR_STREAM_PREMATURE_CLOSE") && (M3 = N6), !(!M3 && !we)) {
          for (;S3.length; )
            S3.shift()(M3);
          p3?.removeEventListener("abort", y5), o2.abort(), we && (M3 || m3.forEach((ye2) => ye2()), fs.nextTick(e, M3, x5));
        }
      }
      let L4;
      for (let N6 = 0;N6 < t.length; N6++) {
        let we = t[N6], ye2 = N6 < t.length - 1, xe2 = N6 > 0, Re = ye2 || r?.end !== false, Ee = N6 === t.length - 1;
        if (Kv(we)) {
          let Ae2 = function(P4) {
            P4 && P4.name !== "AbortError" && P4.code !== "ERR_STREAM_PREMATURE_CLOSE" && B3(P4);
          };
          var _e3 = Ae2;
          if (Re) {
            let { destroy: P4, cleanup: Se3 } = jv(we, ye2, xe2);
            S3.push(P4), hu2(we) && Ee && m3.push(Se3);
          }
          we.on("error", Ae2), hu2(we) && Ee && m3.push(() => {
            we.removeListener("error", Ae2);
          });
        }
        if (N6 === 0)
          if (typeof we == "function") {
            if (L4 = we({ signal: f3 }), !pf(L4))
              throw new su2("Iterable, AsyncIterable or Stream", "source", L4);
          } else
            pf(we) || du(we) ? L4 = we : L4 = Wv.from(we);
        else if (typeof we == "function")
          if (L4 = t7(L4), L4 = we(L4, { signal: f3 }), ye2) {
            if (!pf(L4, true))
              throw new su2("AsyncIterable", `transform[${N6 - 1}]`, L4);
          } else {
            var ge;
            uu2 || (uu2 = ou2());
            let Ae2 = new uu2({ objectMode: true }), P4 = (ge = L4) === null || ge === undefined ? undefined : ge.then;
            if (typeof P4 == "function")
              E6++, P4.call(L4, (i) => {
                x5 = i, i != null && Ae2.write(i), Re && Ae2.end(), fs.nextTick(B3);
              }, (i) => {
                Ae2.destroy(i), fs.nextTick(B3, i);
              });
            else if (pf(L4, true))
              E6++, Zv(L4, Ae2, B3, { end: Re });
            else
              throw new su2("AsyncIterable or Promise", "destination", L4);
            L4 = Ae2;
            let { destroy: Se3, cleanup: v4 } = jv(L4, false, true);
            S3.push(Se3), Ee && m3.push(v4);
          }
        else if (Kv(we)) {
          if (du(L4)) {
            E6 += 2;
            let Ae2 = n7(L4, we, B3, { end: Re });
            hu2(we) && Ee && m3.push(Ae2);
          } else if (pf(L4))
            E6++, Zv(L4, we, B3, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L4);
          L4 = we;
        } else
          L4 = Wv.from(we);
      }
      return (f3 != null && f3.aborted || p3 != null && p3.aborted) && fs.nextTick(y5), L4;
    }
    function n7(t, e, r, { end: o2 }) {
      let f3 = false;
      return e.on("close", () => {
        f3 || r(new Gx);
      }), t.pipe(e, { end: o2 }), o2 ? t.once("end", () => {
        f3 = true, e.end();
      }) : r(), as2(t, { readable: true, writable: false }, (p3) => {
        let m3 = t._readableState;
        p3 && p3.code === "ERR_STREAM_PREMATURE_CLOSE" && m3 && m3.ended && !m3.errored && !m3.errorEmitted ? t.once("end", r).once("error", r) : r(p3);
      }), as2(e, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T3((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr2(), { destroyer: a7 } = yn2(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e) {
      if (e.length === 0)
        throw new h7("streams");
      if (e.length === 1)
        return ss.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
        let q3 = e.length - 1;
        e[q3] = ss.from(e[q3]);
      }
      for (let q3 = 0;q3 < e.length; ++q3)
        if (!!o7(e[q3])) {
          if (q3 < e.length - 1 && !Yv(e[q3]))
            throw new Jv(`streams[${q3}]`, r[q3], "must be readable");
          if (q3 > 0 && !Xv(e[q3]))
            throw new Jv(`streams[${q3}]`, r[q3], "must be writable");
        }
      let o2, f3, p3, m3, y5;
      function M3(q3) {
        let L4 = m3;
        m3 = null, L4 ? L4(q3) : q3 ? y5.destroy(q3) : !B3 && !E6 && y5.destroy();
      }
      let x5 = e[0], S3 = f7(e, M3), E6 = !!Xv(x5), B3 = !!Yv(S3);
      return y5 = new ss({ writableObjectMode: !!(x5 != null && x5.writableObjectMode), readableObjectMode: !!(S3 != null && S3.writableObjectMode), writable: E6, readable: B3 }), E6 && (y5._write = function(q3, L4, ge) {
        x5.write(q3, L4) ? ge() : o2 = ge;
      }, y5._final = function(q3) {
        x5.end(), f3 = q3;
      }, x5.on("drain", function() {
        if (o2) {
          let q3 = o2;
          o2 = null, q3();
        }
      }), S3.on("finish", function() {
        if (f3) {
          let q3 = f3;
          f3 = null, q3();
        }
      })), B3 && (S3.on("readable", function() {
        if (p3) {
          let q3 = p3;
          p3 = null, q3();
        }
      }), S3.on("end", function() {
        y5.push(null);
      }), y5._read = function() {
        for (;; ) {
          let q3 = S3.read();
          if (q3 === null) {
            p3 = y5._read;
            return;
          }
          if (!y5.push(q3))
            return;
        }
      }), y5._destroy = function(q3, L4) {
        !q3 && m3 !== null && (q3 = new s7), p3 = null, o2 = null, f3 = null, m3 === null ? L4(q3) : (m3 = L4, a7(S3, q3));
      }, y5;
    };
  });
  cu2 = T3((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt5(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e, r) => {
        let o2, f3, p3 = t[t.length - 1];
        if (p3 && typeof p3 == "object" && !c7(p3) && !d7(p3)) {
          let m3 = u7(t);
          o2 = m3.signal, f3 = m3.end;
        }
        p7(t, (m3, y5) => {
          m3 ? r(m3) : e(y5);
        }, { signal: o2, end: f3 });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T3((QI, ub) => {
    var { Buffer: m7 } = Ut3(), { ObjectDefineProperty: gi4, ObjectKeys: nb, ReflectApply: fb } = Tt5(), { promisify: { custom: ab } } = Gr2(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn2(), hb = Ui(), pu = cu2(), vu = Fi(), ct3 = ub.exports = Vo().Stream;
    ct3.isDisturbed = vu.isDisturbed;
    ct3.isErrored = vu.isErrored;
    ct3.isReadable = vu.isReadable;
    ct3.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o2) {
        if (new.target)
          throw ob();
        return ct3.Readable.from(fb(e, this, o2));
      };
      M7 = r;
      let e = rb[t];
      gi4(r, "name", { __proto__: null, value: e.name }), gi4(r, "length", { __proto__: null, value: e.length }), gi4(ct3.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f3) {
        if (new.target)
          throw ob();
        return fb(e, this, f3);
      };
      M7 = r;
      let e = ib[t];
      gi4(r, "name", { __proto__: null, value: e.name }), gi4(r, "length", { __proto__: null, value: e.length }), gi4(ct3.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct3.Writable = Jh();
    ct3.Duplex = Qr2();
    ct3.Transform = fu2();
    ct3.PassThrough = ou2();
    ct3.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct3.addAbortSignal = w7;
    ct3.finished = hb;
    ct3.destroy = y7;
    ct3.compose = g7;
    gi4(ct3, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi4(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi4(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct3.Stream = ct3;
    ct3._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct3._uint8ArrayToBuffer = function(e) {
      return m7.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  bu = T3((eT, pt3) => {
    var Lt3 = lb(), _7 = cu2(), x7 = Lt3.Readable.destroy;
    pt3.exports = Lt3.Readable;
    pt3.exports._uint8ArrayToBuffer = Lt3._uint8ArrayToBuffer;
    pt3.exports._isUint8Array = Lt3._isUint8Array;
    pt3.exports.isDisturbed = Lt3.isDisturbed;
    pt3.exports.isErrored = Lt3.isErrored;
    pt3.exports.isReadable = Lt3.isReadable;
    pt3.exports.Readable = Lt3.Readable;
    pt3.exports.Writable = Lt3.Writable;
    pt3.exports.Duplex = Lt3.Duplex;
    pt3.exports.Transform = Lt3.Transform;
    pt3.exports.PassThrough = Lt3.PassThrough;
    pt3.exports.addAbortSignal = Lt3.addAbortSignal;
    pt3.exports.finished = Lt3.finished;
    pt3.exports.destroy = Lt3.destroy;
    pt3.exports.destroy = x7;
    pt3.exports.pipeline = Lt3.pipeline;
    pt3.exports.compose = Lt3.compose;
    Object.defineProperty(Lt3, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt3.exports.Stream = Lt3.Stream;
    pt3.exports.default = pt3.exports;
  });
  vf2 = {};
  Ja(vf2, { default: () => S7 });
  db = R0(() => {
    ot3(vf2, rn2(bu()));
    S7 = rn2(bu());
  });
  yi2 = T3((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur2(vf2)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = cb.from(t, e));
      var o2 = this._update(t);
      return this.hashMode ? this : (r && (o2 = this._toString(o2, r)), o2);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o2;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f3) {
        o2 = f3;
      } finally {
        r(o2);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || cb.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o2 = this._decoder.write(t);
      return r && (o2 += this._decoder.end()), o2;
    };
    vb.exports = Lr;
  });
  bf = T3((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi2();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
    };
  });
  wb = T3((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi2(), k7 = xn.alloc(128), mf2 = 64;
    function us(t, e) {
      gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf2 ? e = t(e) : e.length < mf2 && (e = xn.concat([e, k7], mf2));
      for (var r = this._ipad = xn.allocUnsafe(mf2), o2 = this._opad = xn.allocUnsafe(mf2), f3 = 0;f3 < mf2; f3++)
        r[f3] = e[f3] ^ 54, o2[f3] = e[f3] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T3((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T3((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi2(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e) {
      _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o2 = t === "rmd160" ? new gu : yu(t);
        e = o2.update(e).digest();
      } else
        e.length < r && (e = Ma.concat([e, C7], r));
      for (var f3 = this._ipad = Ma.allocUnsafe(r), p3 = this._opad = Ma.allocUnsafe(r), m3 = 0;m3 < r; m3++)
        f3[m3] = e[m3] ^ 54, p3[m3] = e[m3] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f3);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    xb.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
    };
  });
  Mu = T3((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T3((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T3((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > F7 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  xu = T3((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu2 = T3((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T3((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn2 = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu2(), K7 = Sn2.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e, r) {
      var o2 = j7(t), f3 = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f3 ? e = o2(e) : e.length < f3 && (e = Sn2.concat([e, K7], f3));
      for (var p3 = Sn2.allocUnsafe(f3 + ds[t]), m3 = Sn2.allocUnsafe(f3 + ds[t]), y5 = 0;y5 < f3; y5++)
        p3[y5] = e[y5] ^ 54, m3[y5] = e[y5] ^ 92;
      var M3 = Sn2.allocUnsafe(f3 + r + 4);
      p3.copy(M3, 0, 0, f3), this.ipad1 = M3, this.ipad2 = p3, this.opad = m3, this.alg = t, this.blocksize = f3, this.hash = o2, this.size = ds[t];
    }
    kb.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e(o2) {
        return H7(t).update(o2).digest();
      }
      function r(o2) {
        return new z7().update(o2).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
    }
    function Z7(t, e, r, o2, f3) {
      W7(r, o2), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f3 = f3 || "sha1";
      var p3 = new kb(f3, t, e.length), m3 = Sn2.allocUnsafe(o2), y5 = Sn2.allocUnsafe(e.length + 4);
      e.copy(y5, 0, 0, e.length);
      for (var M3 = 0, x5 = ds[f3], S3 = Math.ceil(o2 / x5), E6 = 1;E6 <= S3; E6++) {
        y5.writeUInt32BE(E6, e.length);
        for (var B3 = p3.run(y5, p3.ipad1), q3 = B3, L4 = 1;L4 < r; L4++) {
          q3 = p3.run(q3, p3.ipad2);
          for (var ge = 0;ge < x5; ge++)
            B3[ge] ^= q3[ge];
        }
        B3.copy(m3, M3), M3 += x5;
      }
      return m3;
    }
    Lb.exports = Z7;
  });
  Ub = T3((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu2(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e, e;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e, r, o2, f3) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p3) {
        return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f3 } }, p3, o2 << 3);
      }).then(function(p3) {
        return Cb.from(p3);
      });
    }
    function Y7(t, e) {
      t.then(function(r) {
        Bu()(function() {
          e(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e(r);
        });
      });
    }
    Fb.exports = function(t, e, r, o2, f3, p3) {
      typeof f3 == "function" && (p3 = f3, f3 = undefined), f3 = f3 || "sha1";
      var m3 = $7[f3.toLowerCase()];
      if (!m3 || typeof global.Promise != "function") {
        Bu()(function() {
          var y5;
          try {
            y5 = Db(t, e, r, o2, f3);
          } catch (M3) {
            return p3(M3);
          }
          p3(null, y5);
        });
        return;
      }
      if (V7(r, o2), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p3 != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m3).then(function(y5) {
        return y5 ? Ob(t, e, r, o2, m3) : Db(t, e, r, o2, f3);
      }), p3);
    };
  });
  Iu = T3((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T3((br4) => {
    br4.readUInt32BE = function(e, r) {
      var o2 = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o2 >>> 0;
    };
    br4.writeUInt32BE = function(e, r, o2) {
      e[0 + o2] = r >>> 24, e[1 + o2] = r >>> 16 & 255, e[2 + o2] = r >>> 8 & 255, e[3 + o2] = r & 255;
    };
    br4.ip = function(e, r, o2, f3) {
      for (var p3 = 0, m3 = 0, y5 = 6;y5 >= 0; y5 -= 2) {
        for (var M3 = 0;M3 <= 24; M3 += 8)
          p3 <<= 1, p3 |= r >>> M3 + y5 & 1;
        for (var M3 = 0;M3 <= 24; M3 += 8)
          p3 <<= 1, p3 |= e >>> M3 + y5 & 1;
      }
      for (var y5 = 6;y5 >= 0; y5 -= 2) {
        for (var M3 = 1;M3 <= 25; M3 += 8)
          m3 <<= 1, m3 |= r >>> M3 + y5 & 1;
        for (var M3 = 1;M3 <= 25; M3 += 8)
          m3 <<= 1, m3 |= e >>> M3 + y5 & 1;
      }
      o2[f3 + 0] = p3 >>> 0, o2[f3 + 1] = m3 >>> 0;
    };
    br4.rip = function(e, r, o2, f3) {
      for (var p3 = 0, m3 = 0, y5 = 0;y5 < 4; y5++)
        for (var M3 = 24;M3 >= 0; M3 -= 8)
          p3 <<= 1, p3 |= r >>> M3 + y5 & 1, p3 <<= 1, p3 |= e >>> M3 + y5 & 1;
      for (var y5 = 4;y5 < 8; y5++)
        for (var M3 = 24;M3 >= 0; M3 -= 8)
          m3 <<= 1, m3 |= r >>> M3 + y5 & 1, m3 <<= 1, m3 |= e >>> M3 + y5 & 1;
      o2[f3 + 0] = p3 >>> 0, o2[f3 + 1] = m3 >>> 0;
    };
    br4.pc1 = function(e, r, o2, f3) {
      for (var p3 = 0, m3 = 0, y5 = 7;y5 >= 5; y5--) {
        for (var M3 = 0;M3 <= 24; M3 += 8)
          p3 <<= 1, p3 |= r >> M3 + y5 & 1;
        for (var M3 = 0;M3 <= 24; M3 += 8)
          p3 <<= 1, p3 |= e >> M3 + y5 & 1;
      }
      for (var M3 = 0;M3 <= 24; M3 += 8)
        p3 <<= 1, p3 |= r >> M3 + y5 & 1;
      for (var y5 = 1;y5 <= 3; y5++) {
        for (var M3 = 0;M3 <= 24; M3 += 8)
          m3 <<= 1, m3 |= r >> M3 + y5 & 1;
        for (var M3 = 0;M3 <= 24; M3 += 8)
          m3 <<= 1, m3 |= e >> M3 + y5 & 1;
      }
      for (var M3 = 0;M3 <= 24; M3 += 8)
        m3 <<= 1, m3 |= e >> M3 + y5 & 1;
      o2[f3 + 0] = p3 >>> 0, o2[f3 + 1] = m3 >>> 0;
    };
    br4.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br4.pc2 = function(e, r, o2, f3) {
      for (var p3 = 0, m3 = 0, y5 = ps.length >>> 1, M3 = 0;M3 < y5; M3++)
        p3 <<= 1, p3 |= e >>> ps[M3] & 1;
      for (var M3 = y5;M3 < ps.length; M3++)
        m3 <<= 1, m3 |= r >>> ps[M3] & 1;
      o2[f3 + 0] = p3 >>> 0, o2[f3 + 1] = m3 >>> 0;
    };
    br4.expand = function(e, r, o2) {
      var f3 = 0, p3 = 0;
      f3 = (e & 1) << 5 | e >>> 27;
      for (var m3 = 23;m3 >= 15; m3 -= 4)
        f3 <<= 6, f3 |= e >>> m3 & 63;
      for (var m3 = 11;m3 >= 3; m3 -= 4)
        p3 |= e >>> m3 & 63, p3 <<= 6;
      p3 |= (e & 31) << 1 | e >>> 31, r[o2 + 0] = f3 >>> 0, r[o2 + 1] = p3 >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br4.substitute = function(e, r) {
      for (var o2 = 0, f3 = 0;f3 < 4; f3++) {
        var p3 = e >>> 18 - f3 * 6 & 63, m3 = zb[f3 * 64 + p3];
        o2 <<= 4, o2 |= m3;
      }
      for (var f3 = 0;f3 < 4; f3++) {
        var p3 = r >>> 18 - f3 * 6 & 63, m3 = zb[4 * 64 + f3 * 64 + p3];
        o2 <<= 4, o2 |= m3;
      }
      return o2 >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br4.permute = function(e) {
      for (var r = 0, o2 = 0;o2 < Hb.length; o2++)
        r <<= 1, r |= e >>> Hb[o2] & 1;
      return r >>> 0;
    };
    br4.padSplit = function(e, r, o2) {
      for (var f3 = e.toString(2);f3.length < r; )
        f3 = "0" + f3;
      for (var p3 = [], m3 = 0;m3 < r; m3 += o2)
        p3.push(f3.slice(m3, m3 + o2));
      return p3.join(" ");
    };
  });
  ar2 = T3((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    Wb.equal = function(e, r, o2) {
      if (e != r)
        throw new Error(o2 || "Assertion failed: " + e + " != " + r);
    };
  });
  vs = T3((mT, jb) => {
    var X7 = ar2();
    function mr3(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr3;
    mr3.prototype._init = function() {
    };
    mr3.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    mr3.prototype._buffer = function(e, r) {
      for (var o2 = Math.min(this.buffer.length - this.bufferOff, e.length - r), f3 = 0;f3 < o2; f3++)
        this.buffer[this.bufferOff + f3] = e[r + f3];
      return this.bufferOff += o2, o2;
    };
    mr3.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    mr3.prototype._updateEncrypt = function(e) {
      var r = 0, o2 = 0, f3 = (this.bufferOff + e.length) / this.blockSize | 0, p3 = new Array(f3 * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o2 += this._flushBuffer(p3, o2)));
      for (var m3 = e.length - (e.length - r) % this.blockSize;r < m3; r += this.blockSize)
        this._update(e, r, p3, o2), o2 += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p3;
    };
    mr3.prototype._updateDecrypt = function(e) {
      for (var r = 0, o2 = 0, f3 = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p3 = new Array(f3 * this.blockSize);f3 > 0; f3--)
        r += this._buffer(e, r), o2 += this._flushBuffer(p3, o2);
      return r += this._buffer(e, r), p3;
    };
    mr3.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o2;
      return this.type === "encrypt" ? o2 = this._finalEncrypt() : o2 = this._finalDecrypt(), r ? r.concat(o2) : o2;
    };
    mr3.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    mr3.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    mr3.prototype._unpad = function(e) {
      return e;
    };
    mr3.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  ku = T3((gT, $b) => {
    var Zb = ar2(), J7 = Ie(), Nt3 = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e = new Q7;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e) {
      return new ei(e);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o2 = Nt3.readUInt32BE(r, 0), f3 = Nt3.readUInt32BE(r, 4);
      Nt3.pc1(o2, f3, e.tmp, 0), o2 = e.tmp[0], f3 = e.tmp[1];
      for (var p3 = 0;p3 < e.keys.length; p3 += 2) {
        var m3 = e9[p3 >>> 1];
        o2 = Nt3.r28shl(o2, m3), f3 = Nt3.r28shl(f3, m3), Nt3.pc2(o2, f3, e.keys, p3);
      }
    };
    ei.prototype._update = function(e, r, o2, f3) {
      var p3 = this._desState, m3 = Nt3.readUInt32BE(e, r), y5 = Nt3.readUInt32BE(e, r + 4);
      Nt3.ip(m3, y5, p3.tmp, 0), m3 = p3.tmp[0], y5 = p3.tmp[1], this.type === "encrypt" ? this._encrypt(p3, m3, y5, p3.tmp, 0) : this._decrypt(p3, m3, y5, p3.tmp, 0), m3 = p3.tmp[0], y5 = p3.tmp[1], Nt3.writeUInt32BE(o2, m3, f3), Nt3.writeUInt32BE(o2, y5, f3 + 4);
    };
    ei.prototype._pad = function(e, r) {
      for (var o2 = e.length - r, f3 = r;f3 < e.length; f3++)
        e[f3] = o2;
      return true;
    };
    ei.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], o2 = e.length - r;o2 < e.length; o2++)
        Zb.equal(e[o2], r);
      return e.slice(0, e.length - r);
    };
    ei.prototype._encrypt = function(e, r, o2, f3, p3) {
      for (var m3 = r, y5 = o2, M3 = 0;M3 < e.keys.length; M3 += 2) {
        var x5 = e.keys[M3], S3 = e.keys[M3 + 1];
        Nt3.expand(y5, e.tmp, 0), x5 ^= e.tmp[0], S3 ^= e.tmp[1];
        var E6 = Nt3.substitute(x5, S3), B3 = Nt3.permute(E6), q3 = y5;
        y5 = (m3 ^ B3) >>> 0, m3 = q3;
      }
      Nt3.rip(y5, m3, f3, p3);
    };
    ei.prototype._decrypt = function(e, r, o2, f3, p3) {
      for (var m3 = o2, y5 = r, M3 = e.keys.length - 2;M3 >= 0; M3 -= 2) {
        var x5 = e.keys[M3], S3 = e.keys[M3 + 1];
        Nt3.expand(m3, e.tmp, 0), x5 ^= e.tmp[0], S3 ^= e.tmp[1];
        var E6 = Nt3.substitute(x5, S3), B3 = Nt3.permute(E6), q3 = m3;
        m3 = (y5 ^ B3) >>> 0, y5 = q3;
      }
      Nt3.rip(m3, y5, f3, p3);
    };
  });
  Yb = T3((Gb) => {
    var t9 = ar2(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function n9(t) {
      function e(p3) {
        t.call(this, p3), this._cbcInit();
      }
      r9(e, t);
      for (var r = Object.keys(bs), o2 = 0;o2 < r.length; o2++) {
        var f3 = r[o2];
        e.prototype[f3] = bs[f3];
      }
      return e.create = function(m3) {
        return new e(m3);
      }, e;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e = new i9(this.options.iv);
      this._cbcState = e;
    };
    bs._update = function(e, r, o2, f3) {
      var p3 = this._cbcState, m3 = this.constructor.super_.prototype, y5 = p3.iv;
      if (this.type === "encrypt") {
        for (var M3 = 0;M3 < this.blockSize; M3++)
          y5[M3] ^= e[r + M3];
        m3._update.call(this, y5, 0, o2, f3);
        for (var M3 = 0;M3 < this.blockSize; M3++)
          y5[M3] = o2[f3 + M3];
      } else {
        m3._update.call(this, e, r, o2, f3);
        for (var M3 = 0;M3 < this.blockSize; M3++)
          o2[f3 + M3] ^= y5[M3];
        for (var M3 = 0;M3 < this.blockSize; M3++)
          y5[M3] = e[r + M3];
      }
    };
  });
  Qb = T3((wT, Jb) => {
    var f9 = ar2(), a9 = Ie(), Xb = vs(), Wi2 = ku();
    function o9(t, e) {
      f9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o2 = e.slice(8, 16), f3 = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi2.create({ type: "encrypt", key: r }), Wi2.create({ type: "decrypt", key: o2 }), Wi2.create({ type: "encrypt", key: f3 })] : this.ciphers = [Wi2.create({ type: "decrypt", key: f3 }), Wi2.create({ type: "encrypt", key: o2 }), Wi2.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e = new o9(this.type, this.options.key);
      this._edeState = e;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e) {
      return new An(e);
    };
    An.prototype._update = function(e, r, o2, f3) {
      var p3 = this._edeState;
      p3.ciphers[0]._update(e, r, o2, f3), p3.ciphers[1]._update(o2, f3, o2, f3), p3.ciphers[2]._update(o2, f3, o2, f3);
    };
    An.prototype._pad = Wi2.prototype._pad;
    An.prototype._unpad = Wi2.prototype._unpad;
  });
  em = T3((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T3((_T, rm) => {
    var tm = yi2(), wi3 = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi3.CBC.instantiate(wi3.EDE), "des-ede3": wi3.EDE, "des-ede-cbc": wi3.CBC.instantiate(wi3.EDE), "des-ede": wi3.EDE, "des-cbc": wi3.CBC.instantiate(wi3.DES), "des-ecb": wi3.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e = t.mode.toLowerCase(), r = Sa[e], o2;
      t.decrypt ? o2 = "decrypt" : o2 = "encrypt";
      var f3 = t.key;
      Rn.isBuffer(f3) || (f3 = Rn.from(f3)), (e === "des-ede" || e === "des-ede-cbc") && (f3 = Rn.concat([f3, f3.slice(0, 8)]));
      var p3 = t.iv;
      Rn.isBuffer(p3) || (p3 = Rn.from(p3)), this._des = r.create({ key: f3, iv: p3, type: o2 });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T3((Lu) => {
    Lu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Lu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  yf2 = T3((ST, fm) => {
    fm.exports = function(e, r) {
      for (var o2 = Math.min(e.length, r.length), f3 = new Buffer(o2), p3 = 0;p3 < o2; ++p3)
        f3[p3] = e[p3] ^ r[p3];
      return f3;
    };
  });
  om = T3((Nu) => {
    var am = yf2();
    Nu.encrypt = function(t, e) {
      var r = am(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o2 = t._cipher.decryptBlock(e);
      return am(o2, r);
    };
  });
  um = T3((hm) => {
    var Ea = Te().Buffer, h9 = yf2();
    function sm(t, e, r) {
      var o2 = e.length, f3 = h9(e, t._cache);
      return t._cache = t._cache.slice(o2), t._prev = Ea.concat([t._prev, r ? e : f3]), f3;
    }
    hm.encrypt = function(t, e, r) {
      for (var o2 = Ea.allocUnsafe(0), f3;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
          f3 = t._cache.length, o2 = Ea.concat([o2, sm(t, e.slice(0, f3), r)]), e = e.slice(f3);
        else {
          o2 = Ea.concat([o2, sm(t, e, r)]);
          break;
        }
      return o2;
    };
  });
  dm = T3((lm) => {
    var Du = Te().Buffer;
    function u9(t, e, r) {
      var o2 = t._cipher.encryptBlock(t._prev), f3 = o2[0] ^ e;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f3])]), f3;
    }
    lm.encrypt = function(t, e, r) {
      for (var o2 = e.length, f3 = Du.allocUnsafe(o2), p3 = -1;++p3 < o2; )
        f3[p3] = u9(t, e[p3], r);
      return f3;
    };
  });
  pm = T3((cm2) => {
    var gs = Te().Buffer;
    function l9(t, e, r) {
      for (var o2, f3 = -1, p3 = 8, m3 = 0, y5, M3;++f3 < p3; )
        o2 = t._cipher.encryptBlock(t._prev), y5 = e & 1 << 7 - f3 ? 128 : 0, M3 = o2[0] ^ y5, m3 += (M3 & 128) >> f3 % 8, t._prev = d9(t._prev, r ? y5 : M3);
      return m3;
    }
    function d9(t, e) {
      var r = t.length, o2 = -1, f3 = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e])]);++o2 < r; )
        f3[o2] = t[o2] << 1 | t[o2 + 1] >> 7;
      return f3;
    }
    cm2.encrypt = function(t, e, r) {
      for (var o2 = e.length, f3 = gs.allocUnsafe(o2), p3 = -1;++p3 < o2; )
        f3[p3] = l9(t, e[p3], r);
      return f3;
    };
  });
  bm = T3((vm) => {
    var c9 = yf2();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), c9(e, r);
    };
  });
  Pu = T3((IT, mm) => {
    function v9(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T3((ym) => {
    var b9 = yf2(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e;
    }
    var Cu = 16;
    ym.encrypt = function(t, e) {
      var r = Math.ceil(e.length / Cu), o2 = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f3 = 0;f3 < r; f3++) {
        var p3 = g9(t), m3 = o2 + f3 * Cu;
        t._cache.writeUInt32BE(p3[0], m3 + 0), t._cache.writeUInt32BE(p3[1], m3 + 4), t._cache.writeUInt32BE(p3[2], m3 + 8), t._cache.writeUInt32BE(p3[3], m3 + 12);
      }
      var y5 = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), b9(e, y5);
    };
  });
  Fu = T3((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T3((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T3((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o2 = 0;o2 < e; o2++)
        r[o2] = t.readUInt32BE(o2 * 4);
      return r;
    }
    function zu(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Mm(t, e, r, o2, f3) {
      for (var p3 = r[0], m3 = r[1], y5 = r[2], M3 = r[3], x5 = t[0] ^ e[0], S3 = t[1] ^ e[1], E6 = t[2] ^ e[2], B3 = t[3] ^ e[3], q3, L4, ge, _e3, N6 = 4, we = 1;we < f3; we++)
        q3 = p3[x5 >>> 24] ^ m3[S3 >>> 16 & 255] ^ y5[E6 >>> 8 & 255] ^ M3[B3 & 255] ^ e[N6++], L4 = p3[S3 >>> 24] ^ m3[E6 >>> 16 & 255] ^ y5[B3 >>> 8 & 255] ^ M3[x5 & 255] ^ e[N6++], ge = p3[E6 >>> 24] ^ m3[B3 >>> 16 & 255] ^ y5[x5 >>> 8 & 255] ^ M3[S3 & 255] ^ e[N6++], _e3 = p3[B3 >>> 24] ^ m3[x5 >>> 16 & 255] ^ y5[S3 >>> 8 & 255] ^ M3[E6 & 255] ^ e[N6++], x5 = q3, S3 = L4, E6 = ge, B3 = _e3;
      return q3 = (o2[x5 >>> 24] << 24 | o2[S3 >>> 16 & 255] << 16 | o2[E6 >>> 8 & 255] << 8 | o2[B3 & 255]) ^ e[N6++], L4 = (o2[S3 >>> 24] << 24 | o2[E6 >>> 16 & 255] << 16 | o2[B3 >>> 8 & 255] << 8 | o2[x5 & 255]) ^ e[N6++], ge = (o2[E6 >>> 24] << 24 | o2[B3 >>> 16 & 255] << 16 | o2[x5 >>> 8 & 255] << 8 | o2[S3 & 255]) ^ e[N6++], _e3 = (o2[B3 >>> 24] << 24 | o2[x5 >>> 16 & 255] << 16 | o2[S3 >>> 8 & 255] << 8 | o2[E6 & 255]) ^ e[N6++], q3 = q3 >>> 0, L4 = L4 >>> 0, ge = ge >>> 0, _e3 = _e3 >>> 0, [q3, L4, ge, _e3];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt2 = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o2 = [], f3 = [[], [], [], []], p3 = [[], [], [], []], m3 = 0, y5 = 0, M3 = 0;M3 < 256; ++M3) {
        var x5 = y5 ^ y5 << 1 ^ y5 << 2 ^ y5 << 3 ^ y5 << 4;
        x5 = x5 >>> 8 ^ x5 & 255 ^ 99, r[m3] = x5, o2[x5] = m3;
        var S3 = t[m3], E6 = t[S3], B3 = t[E6], q3 = t[x5] * 257 ^ x5 * 16843008;
        f3[0][m3] = q3 << 24 | q3 >>> 8, f3[1][m3] = q3 << 16 | q3 >>> 16, f3[2][m3] = q3 << 8 | q3 >>> 24, f3[3][m3] = q3, q3 = B3 * 16843009 ^ E6 * 65537 ^ S3 * 257 ^ m3 * 16843008, p3[0][x5] = q3 << 24 | q3 >>> 8, p3[1][x5] = q3 << 16 | q3 >>> 16, p3[2][x5] = q3 << 8 | q3 >>> 24, p3[3][x5] = q3, m3 === 0 ? m3 = y5 = 1 : (m3 = S3 ^ t[t[t[B3 ^ S3]]], y5 ^= t[t[y5]]);
      }
      return { SBOX: r, INV_SBOX: o2, SUB_MIX: f3, INV_SUB_MIX: p3 };
    }();
    function gr4(t) {
      this._key = Hu(t), this._reset();
    }
    gr4.blockSize = 4 * 4;
    gr4.keySize = 256 / 8;
    gr4.prototype.blockSize = gr4.blockSize;
    gr4.prototype.keySize = gr4.keySize;
    gr4.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o2 = (r + 1) * 4, f3 = [], p3 = 0;p3 < e; p3++)
        f3[p3] = t[p3];
      for (p3 = e;p3 < o2; p3++) {
        var m3 = f3[p3 - 1];
        p3 % e === 0 ? (m3 = m3 << 8 | m3 >>> 24, m3 = kt2.SBOX[m3 >>> 24] << 24 | kt2.SBOX[m3 >>> 16 & 255] << 16 | kt2.SBOX[m3 >>> 8 & 255] << 8 | kt2.SBOX[m3 & 255], m3 ^= M9[p3 / e | 0] << 24) : e > 6 && p3 % e === 4 && (m3 = kt2.SBOX[m3 >>> 24] << 24 | kt2.SBOX[m3 >>> 16 & 255] << 16 | kt2.SBOX[m3 >>> 8 & 255] << 8 | kt2.SBOX[m3 & 255]), f3[p3] = f3[p3 - e] ^ m3;
      }
      for (var y5 = [], M3 = 0;M3 < o2; M3++) {
        var x5 = o2 - M3, S3 = f3[x5 - (M3 % 4 ? 0 : 4)];
        M3 < 4 || x5 <= 4 ? y5[M3] = S3 : y5[M3] = kt2.INV_SUB_MIX[0][kt2.SBOX[S3 >>> 24]] ^ kt2.INV_SUB_MIX[1][kt2.SBOX[S3 >>> 16 & 255]] ^ kt2.INV_SUB_MIX[2][kt2.SBOX[S3 >>> 8 & 255]] ^ kt2.INV_SUB_MIX[3][kt2.SBOX[S3 & 255]];
      }
      this._nRounds = r, this._keySchedule = f3, this._invKeySchedule = y5;
    };
    gr4.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt2.SUB_MIX, kt2.SBOX, this._nRounds);
    };
    gr4.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    gr4.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Mm(t, this._invKeySchedule, kt2.INV_SUB_MIX, kt2.INV_SBOX, this._nRounds), o2 = Ms.allocUnsafe(16);
      return o2.writeUInt32BE(r[0], 0), o2.writeUInt32BE(r[3], 4), o2.writeUInt32BE(r[2], 8), o2.writeUInt32BE(r[1], 12), o2;
    };
    gr4.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr4;
  });
  Em = T3((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e = wf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e = [0, 0, 0, 0], r, o2, f3, p3 = -1;++p3 < 128; ) {
        for (o2 = (this.state[~~(p3 / 8)] & 1 << 7 - p3 % 8) !== 0, o2 && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f3 = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f3 && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    Ra.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T3((PT, Bm) => {
    var S9 = Aa(), rr2 = Te().Buffer, Am = yi2(), E9 = Ie(), Rm = Em(), A9 = yf2(), R9 = Pu();
    function B9(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o2 = Math.min(t.length, e.length), f3 = 0;f3 < o2; ++f3)
        r += t[f3] ^ e[f3];
      return r;
    }
    function q9(t, e, r) {
      if (e.length === 12)
        return t._finID = rr2.concat([e, rr2.from([0, 0, 0, 1])]), rr2.concat([e, rr2.from([0, 0, 0, 2])]);
      var o2 = new Rm(r), f3 = e.length, p3 = f3 % 16;
      o2.update(e), p3 && (p3 = 16 - p3, o2.update(rr2.alloc(p3, 0))), o2.update(rr2.alloc(8, 0));
      var m3 = f3 * 8, y5 = rr2.alloc(8);
      y5.writeUIntBE(m3, 0, 8), o2.update(y5), t._finID = o2.state;
      var M3 = rr2.from(t._finID);
      return R9(M3), M3;
    }
    function Bn3(t, e, r, o2) {
      Am.call(this);
      var f3 = rr2.alloc(4, 0);
      this._cipher = new S9.AES(e);
      var p3 = this._cipher.encryptBlock(f3);
      this._ghash = new Rm(p3), r = q9(this, r, p3), this._prev = rr2.from(r), this._cache = rr2.allocUnsafe(0), this._secCache = rr2.allocUnsafe(0), this._decrypt = o2, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn3, Am);
    Bn3.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr2.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn3.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn3.prototype.getAuthTag = function() {
      if (this._decrypt || !rr2.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn3.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Bn3.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Bm.exports = Bn3;
  });
  ju = T3((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi2(), T9 = Ie();
    function _s(t, e, r, o2) {
      qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o2, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T3((OT, Tm) => {
    var qn2 = Te().Buffer, k9 = Ao();
    function L9(t, e, r, o2) {
      if (qn2.isBuffer(t) || (t = qn2.from(t, "binary")), e && (qn2.isBuffer(e) || (e = qn2.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f3 = r / 8, p3 = qn2.alloc(f3), m3 = qn2.alloc(o2 || 0), y5 = qn2.alloc(0);f3 > 0 || o2 > 0; ) {
        var M3 = new k9;
        M3.update(y5), M3.update(t), e && M3.update(e), y5 = M3.digest();
        var x5 = 0;
        if (f3 > 0) {
          var S3 = p3.length - f3;
          x5 = Math.min(f3, y5.length), y5.copy(p3, S3, 0, x5), f3 -= x5;
        }
        if (x5 < y5.length && o2 > 0) {
          var E6 = m3.length - o2, B3 = Math.min(o2, y5.length - x5);
          y5.copy(m3, E6, x5, x5 + B3), o2 -= B3;
        }
      }
      return y5.fill(0), { key: p3, iv: m3 };
    }
    Tm.exports = L9;
  });
  Dm = T3((Zu2) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi2(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o2 = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o2.push(r);
      return Mi.concat(o2);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Mi.concat([this.cache, e]);
    };
    function Nm(t, e, r) {
      var o2 = km[t.toLowerCase()];
      if (!o2)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Mi.from(e)), e.length !== o2.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Mi.from(r)), o2.mode !== "GCM" && r.length !== o2.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o2.type === "stream" ? new D9(o2.module, e, r) : o2.type === "auth" ? new N9(o2.module, e, r) : new qa(o2.module, e, r);
    }
    function U9(t, e) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o2 = C9(e, false, r.key, r.iv);
      return Nm(t, o2.key, o2.iv);
    }
    Zu2.createCipheriv = Nm;
    Zu2.createCipher = U9;
  });
  Fm = T3((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi2(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia2(t, e, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia2, Cm);
    Ia2.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o2 = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o2.push(r);
      return Mf.concat(o2);
    };
    Ia2.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia2.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function Om(t, e, r) {
      var o2 = Pm[t.toLowerCase()];
      if (!o2)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o2.mode !== "GCM" && r.length !== o2.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Mf.from(e)), e.length !== o2.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o2.type === "stream" ? new H9(o2.module, e, r, true) : o2.type === "auth" ? new z9(o2.module, e, r, true) : new Ia2(o2.module, e, r);
    }
    function V9(t, e) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o2 = K9(e, false, r.key, r.iv);
      return Om(t, o2.key, o2.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T3((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T3((_i3) => {
    _i3["des-ecb"] = { key: 8, iv: 0 };
    _i3["des-cbc"] = _i3.des = { key: 8, iv: 8 };
    _i3["des-ede3-cbc"] = _i3.des3 = { key: 24, iv: 8 };
    _i3["des-ede3"] = { key: 24, iv: 0 };
    _i3["des-ede-cbc"] = { key: 16, iv: 8 };
    _i3["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T3((Dr2) => {
    var Wm = im(), $u = Es(), Ki2 = ws(), xi3 = Hm(), Km = Ba();
    function Y9(t, e) {
      t = t.toLowerCase();
      var r, o2;
      if (Ki2[t])
        r = Ki2[t].key, o2 = Ki2[t].iv;
      else if (xi3[t])
        r = xi3[t].key * 8, o2 = xi3[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f3 = Km(e, false, r, o2);
      return jm(t, f3.key, f3.iv);
    }
    function X9(t, e) {
      t = t.toLowerCase();
      var r, o2;
      if (Ki2[t])
        r = Ki2[t].key, o2 = Ki2[t].iv;
      else if (xi3[t])
        r = xi3[t].key * 8, o2 = xi3[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f3 = Km(e, false, r, o2);
      return Zm(t, f3.key, f3.iv);
    }
    function jm(t, e, r) {
      if (t = t.toLowerCase(), Ki2[t])
        return $u.createCipheriv(t, e, r);
      if (xi3[t])
        return new Wm({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e, r) {
      if (t = t.toLowerCase(), Ki2[t])
        return $u.createDecipheriv(t, e, r);
      if (xi3[t])
        return new Wm({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi3).concat($u.getCiphers());
    }
    Dr2.createCipher = Dr2.Cipher = Y9;
    Dr2.createCipheriv = Dr2.Cipheriv = jm;
    Dr2.createDecipher = Dr2.Decipher = X9;
    Dr2.createDecipheriv = Dr2.Decipheriv = Zm;
    Dr2.listCiphers = Dr2.getCiphers = J9;
  });
  ji2 = T3(() => {
  });
  Yu2 = T3(($m, Gu2) => {
    (function(t, e) {
      function r(v4, i) {
        if (!v4)
          throw new Error(i || "Assertion failed");
      }
      function o2(v4, i) {
        v4.super_ = i;
        var a3 = function() {
        };
        a3.prototype = i.prototype, v4.prototype = new a3, v4.prototype.constructor = v4;
      }
      function f3(v4, i, a3) {
        if (f3.isBN(v4))
          return v4;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v4 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v4 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(i) {
        return i instanceof f3 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f3.wordSize && Array.isArray(i.words);
      }, f3.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f3.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f3.prototype._init = function(i, a3, h5) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h5);
        if (typeof i == "object")
          return this._initArray(i, a3, h5);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s2 = 0;
        i[0] === "-" && (s2++, this.negative = 1), s2 < i.length && (a3 === 16 ? this._parseHex(i, s2, h5) : (this._parseBase(i, a3, s2), h5 === "le" && this._initArray(this.toArray(), a3, h5)));
      }, f3.prototype._initNumber = function(i, a3, h5) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h5 === "le" && this._initArray(this.toArray(), a3, h5);
      }, f3.prototype._initArray = function(i, a3, h5) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3, c2, b6 = 0;
        if (h5 === "be")
          for (s2 = i.length - 1, u3 = 0;s2 >= 0; s2 -= 3)
            c2 = i[s2] | i[s2 - 1] << 8 | i[s2 - 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        else if (h5 === "le")
          for (s2 = 0, u3 = 0;s2 < i.length; s2 += 3)
            c2 = i[s2] | i[s2 + 1] << 8 | i[s2 + 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        return this.strip();
      };
      function m3(v4, i) {
        var a3 = v4.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y5(v4, i, a3) {
        var h5 = m3(v4, a3);
        return a3 - 1 >= i && (h5 |= m3(v4, a3 - 1) << 4), h5;
      }
      f3.prototype._parseHex = function(i, a3, h5) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3 = 0, c2 = 0, b6;
        if (h5 === "be")
          for (s2 = i.length - 1;s2 >= a3; s2 -= 2)
            b6 = y5(i, a3, s2) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        else {
          var l3 = i.length - a3;
          for (s2 = l3 % 2 === 0 ? a3 + 1 : a3;s2 < i.length; s2 += 2)
            b6 = y5(i, a3, s2) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M3(v4, i, a3, h5) {
        for (var s2 = 0, u3 = Math.min(v4.length, a3), c2 = i;c2 < u3; c2++) {
          var b6 = v4.charCodeAt(c2) - 48;
          s2 *= h5, b6 >= 49 ? s2 += b6 - 49 + 10 : b6 >= 17 ? s2 += b6 - 17 + 10 : s2 += b6;
        }
        return s2;
      }
      f3.prototype._parseBase = function(i, a3, h5) {
        this.words = [0], this.length = 1;
        for (var s2 = 0, u3 = 1;u3 <= 67108863; u3 *= a3)
          s2++;
        s2--, u3 = u3 / a3 | 0;
        for (var c2 = i.length - h5, b6 = c2 % s2, l3 = Math.min(c2, c2 - b6) + h5, n = 0, d4 = h5;d4 < l3; d4 += s2)
          n = M3(i, d4, d4 + s2, a3), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b6 !== 0) {
          var w3 = 1;
          for (n = M3(i, d4, i.length, a3), d4 = 0;d4 < b6; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f3.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f3.prototype.clone = function() {
        var i = new f3(null);
        return this.copy(i), i;
      }, f3.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f3.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h5;
        if (i === 16 || i === "hex") {
          h5 = "";
          for (var s2 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b6 = this.words[c2], l3 = ((b6 << s2 | u3) & 16777215).toString(16);
            u3 = b6 >>> 24 - s2 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h5 = x5[6 - l3.length] + l3 + h5 : h5 = l3 + h5, s2 += 2, s2 >= 26 && (s2 -= 26, c2--);
          }
          for (u3 !== 0 && (h5 = u3.toString(16) + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S3[i], d4 = E6[i];
          h5 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g5 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h5 = g5 + h5 : h5 = x5[n - g5.length] + g5 + h5;
          }
          for (this.isZero() && (h5 = "0" + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f3.prototype.toJSON = function() {
        return this.toString(16);
      }, f3.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f3.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f3.prototype.toArrayLike = function(i, a3, h5) {
        var s2 = this.byteLength(), u3 = h5 || Math.max(1, s2);
        r(s2 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b6 = new i(u3), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[n] = l3;
          for (;n < u3; n++)
            b6[n] = 0;
        } else {
          for (n = 0;n < u3 - s2; n++)
            b6[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[u3 - n - 1] = l3;
        }
        return b6;
      }, Math.clz32 ? f3.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f3.prototype._countBits = function(i) {
        var a3 = i, h5 = 0;
        return a3 >= 4096 && (h5 += 13, a3 >>>= 13), a3 >= 64 && (h5 += 7, a3 >>>= 7), a3 >= 8 && (h5 += 4, a3 >>>= 4), a3 >= 2 && (h5 += 2, a3 >>>= 2), h5 + a3;
      }, f3.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h5 = 0;
        return (a3 & 8191) === 0 && (h5 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h5 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h5 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h5 += 2, a3 >>>= 2), (a3 & 1) === 0 && h5++, h5;
      }, f3.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v4) {
        for (var i = new Array(v4.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h5 = a3 / 26 | 0, s2 = a3 % 26;
          i[a3] = (v4.words[h5] & 1 << s2) >>> s2;
        }
        return i;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h5 = this._zeroBits(this.words[a3]);
          if (i += h5, h5 !== 26)
            break;
        }
        return i;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f3.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f3.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f3.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f3.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h5 = 0;h5 < a3.length; h5++)
          this.words[h5] = this.words[h5] & i.words[h5];
        return this.length = a3.length, this.strip();
      }, f3.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f3.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f3.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f3.prototype.iuxor = function(i) {
        var a3, h5;
        this.length > i.length ? (a3 = this, h5 = i) : (a3 = i, h5 = this);
        for (var s2 = 0;s2 < h5.length; s2++)
          this.words[s2] = a3.words[s2] ^ h5.words[s2];
        if (this !== a3)
          for (;s2 < a3.length; s2++)
            this.words[s2] = a3.words[s2];
        return this.length = a3.length, this.strip();
      }, f3.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f3.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f3.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f3.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h5 = i % 26;
        this._expand(a3), h5 > 0 && a3--;
        for (var s2 = 0;s2 < a3; s2++)
          this.words[s2] = ~this.words[s2] & 67108863;
        return h5 > 0 && (this.words[s2] = ~this.words[s2] & 67108863 >> 26 - h5), this.strip();
      }, f3.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f3.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h5 = i / 26 | 0, s2 = i % 26;
        return this._expand(h5 + 1), a3 ? this.words[h5] = this.words[h5] | 1 << s2 : this.words[h5] = this.words[h5] & ~(1 << s2), this.strip();
      }, f3.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h5, s2;
        this.length > i.length ? (h5 = this, s2 = i) : (h5 = i, s2 = this);
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++)
          a3 = (h5.words[c2] | 0) + (s2.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        for (;u3 !== 0 && c2 < h5.length; c2++)
          a3 = (h5.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        if (this.length = h5.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h5 !== this)
          for (;c2 < h5.length; c2++)
            this.words[c2] = h5.words[c2];
        return this;
      }, f3.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f3.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h5 = this.cmp(i);
        if (h5 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s2, u3;
        h5 > 0 ? (s2 = this, u3 = i) : (s2 = i, u3 = this);
        for (var c2 = 0, b6 = 0;b6 < u3.length; b6++)
          a3 = (s2.words[b6] | 0) - (u3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        for (;c2 !== 0 && b6 < s2.length; b6++)
          a3 = (s2.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        if (c2 === 0 && b6 < s2.length && s2 !== this)
          for (;b6 < s2.length; b6++)
            this.words[b6] = s2.words[b6];
        return this.length = Math.max(this.length, b6), s2 !== this && (this.negative = 1), this.strip();
      }, f3.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q3(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative;
        var h5 = v4.length + i.length | 0;
        a3.length = h5, h5 = h5 - 1 | 0;
        var s2 = v4.words[0] | 0, u3 = i.words[0] | 0, c2 = s2 * u3, b6 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b6;
        for (var n = 1;n < h5; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g5 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v4.length + 1);_4 <= g5; _4++) {
            var A4 = n - _4 | 0;
            s2 = v4.words[A4] | 0, u3 = i.words[_4] | 0, c2 = s2 * u3 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h5) {
        var s2 = i.words, u3 = a3.words, c2 = h5.words, b6 = 0, l3, n, d4, w3 = s2[0] | 0, g5 = w3 & 8191, _4 = w3 >>> 13, A4 = s2[1] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = s2[2] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = s2[3] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = s2[4] | 0, F2 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = s2[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = s2[6] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = s2[7] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s2[8] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = s2[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u3[0] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = u3[1] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = u3[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = u3[3] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = u3[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = u3[5] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = u3[6] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = u3[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = u3[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u3[9] | 0, ve = It & 8191, be2 = It >>> 13;
        h5.negative = i.negative ^ a3.negative, h5.length = 19, l3 = Math.imul(g5, X4), n = Math.imul(g5, J3), n = n + Math.imul(_4, X4) | 0, d4 = Math.imul(_4, J3);
        var ft2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l3 = Math.imul(R4, X4), n = Math.imul(R4, J3), n = n + Math.imul(I5, X4) | 0, d4 = Math.imul(I5, J3), l3 = l3 + Math.imul(g5, Q5) | 0, n = n + Math.imul(g5, ee) | 0, n = n + Math.imul(_4, Q5) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X4), n = Math.imul(k4, J3), n = n + Math.imul(D3, X4) | 0, d4 = Math.imul(D3, J3), l3 = l3 + Math.imul(R4, Q5) | 0, n = n + Math.imul(R4, ee) | 0, n = n + Math.imul(I5, Q5) | 0, d4 = d4 + Math.imul(I5, ee) | 0, l3 = l3 + Math.imul(g5, te2) | 0, n = n + Math.imul(g5, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C4, X4), n = Math.imul(C4, J3), n = n + Math.imul(O4, X4) | 0, d4 = Math.imul(O4, J3), l3 = l3 + Math.imul(k4, Q5) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D3, Q5) | 0, d4 = d4 + Math.imul(D3, ee) | 0, l3 = l3 + Math.imul(R4, te2) | 0, n = n + Math.imul(R4, re2) | 0, n = n + Math.imul(I5, te2) | 0, d4 = d4 + Math.imul(I5, re2) | 0, l3 = l3 + Math.imul(g5, ie) | 0, n = n + Math.imul(g5, ne2) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne2) | 0;
        var ze = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F2, X4), n = Math.imul(F2, J3), n = n + Math.imul(U3, X4) | 0, d4 = Math.imul(U3, J3), l3 = l3 + Math.imul(C4, Q5) | 0, n = n + Math.imul(C4, ee) | 0, n = n + Math.imul(O4, Q5) | 0, d4 = d4 + Math.imul(O4, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D3, te2) | 0, d4 = d4 + Math.imul(D3, re2) | 0, l3 = l3 + Math.imul(R4, ie) | 0, n = n + Math.imul(R4, ne2) | 0, n = n + Math.imul(I5, ie) | 0, d4 = d4 + Math.imul(I5, ne2) | 0, l3 = l3 + Math.imul(g5, fe3) | 0, n = n + Math.imul(g5, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X4), n = Math.imul(z, J3), n = n + Math.imul(H3, X4) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F2, Q5) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U3, Q5) | 0, d4 = d4 + Math.imul(U3, ee) | 0, l3 = l3 + Math.imul(C4, te2) | 0, n = n + Math.imul(C4, re2) | 0, n = n + Math.imul(O4, te2) | 0, d4 = d4 + Math.imul(O4, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne2) | 0, n = n + Math.imul(D3, ie) | 0, d4 = d4 + Math.imul(D3, ne2) | 0, l3 = l3 + Math.imul(R4, fe3) | 0, n = n + Math.imul(R4, ae2) | 0, n = n + Math.imul(I5, fe3) | 0, d4 = d4 + Math.imul(I5, ae2) | 0, l3 = l3 + Math.imul(g5, oe3) | 0, n = n + Math.imul(g5, se3) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se3) | 0;
        var We2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X4), n = Math.imul(W, J3), n = n + Math.imul(K5, X4) | 0, d4 = Math.imul(K5, J3), l3 = l3 + Math.imul(z, Q5) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q5) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F2, te2) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U3, te2) | 0, d4 = d4 + Math.imul(U3, re2) | 0, l3 = l3 + Math.imul(C4, ie) | 0, n = n + Math.imul(C4, ne2) | 0, n = n + Math.imul(O4, ie) | 0, d4 = d4 + Math.imul(O4, ne2) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D3, fe3) | 0, d4 = d4 + Math.imul(D3, ae2) | 0, l3 = l3 + Math.imul(R4, oe3) | 0, n = n + Math.imul(R4, se3) | 0, n = n + Math.imul(I5, oe3) | 0, d4 = d4 + Math.imul(I5, se3) | 0, l3 = l3 + Math.imul(g5, he) | 0, n = n + Math.imul(g5, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j5, X4), n = Math.imul(j5, J3), n = n + Math.imul(Z3, X4) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q5) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K5, Q5) | 0, d4 = d4 + Math.imul(K5, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne2) | 0, n = n + Math.imul(U3, ie) | 0, d4 = d4 + Math.imul(U3, ne2) | 0, l3 = l3 + Math.imul(C4, fe3) | 0, n = n + Math.imul(C4, ae2) | 0, n = n + Math.imul(O4, fe3) | 0, d4 = d4 + Math.imul(O4, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se3) | 0, n = n + Math.imul(D3, oe3) | 0, d4 = d4 + Math.imul(D3, se3) | 0, l3 = l3 + Math.imul(R4, he) | 0, n = n + Math.imul(R4, ue4) | 0, n = n + Math.imul(I5, he) | 0, d4 = d4 + Math.imul(I5, ue4) | 0, l3 = l3 + Math.imul(g5, le) | 0, n = n + Math.imul(g5, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V6, X4), n = Math.imul(V6, J3), n = n + Math.imul($3, X4) | 0, d4 = Math.imul($3, J3), l3 = l3 + Math.imul(j5, Q5) | 0, n = n + Math.imul(j5, ee) | 0, n = n + Math.imul(Z3, Q5) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K5, te2) | 0, d4 = d4 + Math.imul(K5, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne2) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne2) | 0, l3 = l3 + Math.imul(F2, fe3) | 0, n = n + Math.imul(F2, ae2) | 0, n = n + Math.imul(U3, fe3) | 0, d4 = d4 + Math.imul(U3, ae2) | 0, l3 = l3 + Math.imul(C4, oe3) | 0, n = n + Math.imul(C4, se3) | 0, n = n + Math.imul(O4, oe3) | 0, d4 = d4 + Math.imul(O4, se3) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D3, he) | 0, d4 = d4 + Math.imul(D3, ue4) | 0, l3 = l3 + Math.imul(R4, le) | 0, n = n + Math.imul(R4, de) | 0, n = n + Math.imul(I5, le) | 0, d4 = d4 + Math.imul(I5, de) | 0, l3 = l3 + Math.imul(g5, ce3) | 0, n = n + Math.imul(g5, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X4), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X4) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V6, Q5) | 0, n = n + Math.imul(V6, ee) | 0, n = n + Math.imul($3, Q5) | 0, d4 = d4 + Math.imul($3, ee) | 0, l3 = l3 + Math.imul(j5, te2) | 0, n = n + Math.imul(j5, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne2) | 0, n = n + Math.imul(K5, ie) | 0, d4 = d4 + Math.imul(K5, ne2) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F2, oe3) | 0, n = n + Math.imul(F2, se3) | 0, n = n + Math.imul(U3, oe3) | 0, d4 = d4 + Math.imul(U3, se3) | 0, l3 = l3 + Math.imul(C4, he) | 0, n = n + Math.imul(C4, ue4) | 0, n = n + Math.imul(O4, he) | 0, d4 = d4 + Math.imul(O4, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D3, le) | 0, d4 = d4 + Math.imul(D3, de) | 0, l3 = l3 + Math.imul(R4, ce3) | 0, n = n + Math.imul(R4, pe2) | 0, n = n + Math.imul(I5, ce3) | 0, d4 = d4 + Math.imul(I5, pe2) | 0, l3 = l3 + Math.imul(g5, ve) | 0, n = n + Math.imul(g5, be2) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be2) | 0;
        var Ve = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q5), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q5) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V6, te2) | 0, n = n + Math.imul(V6, re2) | 0, n = n + Math.imul($3, te2) | 0, d4 = d4 + Math.imul($3, re2) | 0, l3 = l3 + Math.imul(j5, ie) | 0, n = n + Math.imul(j5, ne2) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne2) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K5, fe3) | 0, d4 = d4 + Math.imul(K5, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se3) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se3) | 0, l3 = l3 + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue4) | 0, n = n + Math.imul(U3, he) | 0, d4 = d4 + Math.imul(U3, ue4) | 0, l3 = l3 + Math.imul(C4, le) | 0, n = n + Math.imul(C4, de) | 0, n = n + Math.imul(O4, le) | 0, d4 = d4 + Math.imul(O4, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D3, ce3) | 0, d4 = d4 + Math.imul(D3, pe2) | 0, l3 = l3 + Math.imul(R4, ve) | 0, n = n + Math.imul(R4, be2) | 0, n = n + Math.imul(I5, ve) | 0, d4 = d4 + Math.imul(I5, be2) | 0;
        var $e2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V6, ie) | 0, n = n + Math.imul(V6, ne2) | 0, n = n + Math.imul($3, ie) | 0, d4 = d4 + Math.imul($3, ne2) | 0, l3 = l3 + Math.imul(j5, fe3) | 0, n = n + Math.imul(j5, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se3) | 0, n = n + Math.imul(K5, oe3) | 0, d4 = d4 + Math.imul(K5, se3) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U3, le) | 0, d4 = d4 + Math.imul(U3, de) | 0, l3 = l3 + Math.imul(C4, ce3) | 0, n = n + Math.imul(C4, pe2) | 0, n = n + Math.imul(O4, ce3) | 0, d4 = d4 + Math.imul(O4, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be2) | 0, n = n + Math.imul(D3, ve) | 0, d4 = d4 + Math.imul(D3, be2) | 0;
        var Ge = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne2), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne2), l3 = l3 + Math.imul(V6, fe3) | 0, n = n + Math.imul(V6, ae2) | 0, n = n + Math.imul($3, fe3) | 0, d4 = d4 + Math.imul($3, ae2) | 0, l3 = l3 + Math.imul(j5, oe3) | 0, n = n + Math.imul(j5, se3) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se3) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K5, he) | 0, d4 = d4 + Math.imul(K5, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F2, ce3) | 0, n = n + Math.imul(F2, pe2) | 0, n = n + Math.imul(U3, ce3) | 0, d4 = d4 + Math.imul(U3, pe2) | 0, l3 = l3 + Math.imul(C4, ve) | 0, n = n + Math.imul(C4, be2) | 0, n = n + Math.imul(O4, ve) | 0, d4 = d4 + Math.imul(O4, be2) | 0;
        var Ye = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V6, oe3) | 0, n = n + Math.imul(V6, se3) | 0, n = n + Math.imul($3, oe3) | 0, d4 = d4 + Math.imul($3, se3) | 0, l3 = l3 + Math.imul(j5, he) | 0, n = n + Math.imul(j5, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K5, le) | 0, d4 = d4 + Math.imul(K5, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be2) | 0, n = n + Math.imul(U3, ve) | 0, d4 = d4 + Math.imul(U3, be2) | 0;
        var Xe = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se3), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se3), l3 = l3 + Math.imul(V6, he) | 0, n = n + Math.imul(V6, ue4) | 0, n = n + Math.imul($3, he) | 0, d4 = d4 + Math.imul($3, ue4) | 0, l3 = l3 + Math.imul(j5, le) | 0, n = n + Math.imul(j5, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K5, ce3) | 0, d4 = d4 + Math.imul(K5, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be2) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be2) | 0;
        var Je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V6, le) | 0, n = n + Math.imul(V6, de) | 0, n = n + Math.imul($3, le) | 0, d4 = d4 + Math.imul($3, de) | 0, l3 = l3 + Math.imul(j5, ce3) | 0, n = n + Math.imul(j5, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be2) | 0, n = n + Math.imul(K5, ve) | 0, d4 = d4 + Math.imul(K5, be2) | 0;
        var Qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V6, ce3) | 0, n = n + Math.imul(V6, pe2) | 0, n = n + Math.imul($3, ce3) | 0, d4 = d4 + Math.imul($3, pe2) | 0, l3 = l3 + Math.imul(j5, ve) | 0, n = n + Math.imul(j5, be2) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be2) | 0;
        var et3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V6, ve) | 0, n = n + Math.imul(V6, be2) | 0, n = n + Math.imul($3, ve) | 0, d4 = d4 + Math.imul($3, be2) | 0;
        var tt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be2), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be2);
        var rt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b6 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft2, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et3, c2[17] = tt4, c2[18] = rt4, b6 !== 0 && (c2[19] = b6, h5.length++), h5;
      };
      Math.imul || (L4 = q3);
      function ge(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative, a3.length = v4.length + i.length;
        for (var h5 = 0, s2 = 0, u3 = 0;u3 < a3.length - 1; u3++) {
          var c2 = s2;
          s2 = 0;
          for (var b6 = h5 & 67108863, l3 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v4.length + 1);n <= l3; n++) {
            var d4 = u3 - n, w3 = v4.words[d4] | 0, g5 = i.words[n] | 0, _4 = w3 * g5, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b6 | 0, b6 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s2 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u3] = b6, h5 = c2, c2 = s2;
        }
        return h5 !== 0 ? a3.words[u3] = h5 : a3.length--, a3.strip();
      }
      function _e3(v4, i, a3) {
        var h5 = new N6;
        return h5.mulp(v4, i, a3);
      }
      f3.prototype.mulTo = function(i, a3) {
        var h5, s2 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h5 = L4(this, i, a3) : s2 < 63 ? h5 = q3(this, i, a3) : s2 < 1024 ? h5 = ge(this, i, a3) : h5 = _e3(this, i, a3), h5;
      };
      function N6(v4, i) {
        this.x = v4, this.y = i;
      }
      N6.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h5 = f3.prototype._countBits(i) - 1, s2 = 0;s2 < i; s2++)
          a3[s2] = this.revBin(s2, h5, i);
        return a3;
      }, N6.prototype.revBin = function(i, a3, h5) {
        if (i === 0 || i === h5 - 1)
          return i;
        for (var s2 = 0, u3 = 0;u3 < a3; u3++)
          s2 |= (i & 1) << a3 - u3 - 1, i >>= 1;
        return s2;
      }, N6.prototype.permute = function(i, a3, h5, s2, u3, c2) {
        for (var b6 = 0;b6 < c2; b6++)
          s2[b6] = a3[i[b6]], u3[b6] = h5[i[b6]];
      }, N6.prototype.transform = function(i, a3, h5, s2, u3, c2) {
        this.permute(c2, i, a3, h5, s2, u3);
        for (var b6 = 1;b6 < u3; b6 <<= 1)
          for (var l3 = b6 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u3; w3 += l3)
            for (var g5 = n, _4 = d4, A4 = 0;A4 < b6; A4++) {
              var R4 = h5[w3 + A4], I5 = s2[w3 + A4], Me = h5[w3 + A4 + b6], k4 = s2[w3 + A4 + b6], D3 = g5 * Me - _4 * k4;
              k4 = g5 * k4 + _4 * Me, Me = D3, h5[w3 + A4] = R4 + Me, s2[w3 + A4] = I5 + k4, h5[w3 + A4 + b6] = R4 - Me, s2[w3 + A4 + b6] = I5 - k4, A4 !== l3 && (D3 = n * g5 - d4 * _4, _4 = n * _4 + d4 * g5, g5 = D3);
            }
      }, N6.prototype.guessLen13b = function(i, a3) {
        var h5 = Math.max(a3, i) | 1, s2 = h5 & 1, u3 = 0;
        for (h5 = h5 / 2 | 0;h5; h5 = h5 >>> 1)
          u3++;
        return 1 << u3 + 1 + s2;
      }, N6.prototype.conjugate = function(i, a3, h5) {
        if (!(h5 <= 1))
          for (var s2 = 0;s2 < h5 / 2; s2++) {
            var u3 = i[s2];
            i[s2] = i[h5 - s2 - 1], i[h5 - s2 - 1] = u3, u3 = a3[s2], a3[s2] = -a3[h5 - s2 - 1], a3[h5 - s2 - 1] = -u3;
          }
      }, N6.prototype.normalize13b = function(i, a3) {
        for (var h5 = 0, s2 = 0;s2 < a3 / 2; s2++) {
          var u3 = Math.round(i[2 * s2 + 1] / a3) * 8192 + Math.round(i[2 * s2] / a3) + h5;
          i[s2] = u3 & 67108863, u3 < 67108864 ? h5 = 0 : h5 = u3 / 67108864 | 0;
        }
        return i;
      }, N6.prototype.convert13b = function(i, a3, h5, s2) {
        for (var u3 = 0, c2 = 0;c2 < a3; c2++)
          u3 = u3 + (i[c2] | 0), h5[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h5[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a3;c2 < s2; ++c2)
          h5[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N6.prototype.stub = function(i) {
        for (var a3 = new Array(i), h5 = 0;h5 < i; h5++)
          a3[h5] = 0;
        return a3;
      }, N6.prototype.mulp = function(i, a3, h5) {
        var s2 = 2 * this.guessLen13b(i.length, a3.length), u3 = this.makeRBT(s2), c2 = this.stub(s2), b6 = new Array(s2), l3 = new Array(s2), n = new Array(s2), d4 = new Array(s2), w3 = new Array(s2), g5 = new Array(s2), _4 = h5.words;
        _4.length = s2, this.convert13b(i.words, i.length, b6, s2), this.convert13b(a3.words, a3.length, d4, s2), this.transform(b6, c2, l3, n, s2, u3), this.transform(d4, c2, w3, g5, s2, u3);
        for (var A4 = 0;A4 < s2; A4++) {
          var R4 = l3[A4] * w3[A4] - n[A4] * g5[A4];
          n[A4] = l3[A4] * g5[A4] + n[A4] * w3[A4], l3[A4] = R4;
        }
        return this.conjugate(l3, n, s2), this.transform(l3, n, _4, c2, s2, u3), this.conjugate(_4, c2, s2), this.normalize13b(_4, s2), h5.negative = i.negative ^ a3.negative, h5.length = i.length + a3.length, h5.strip();
      }, f3.prototype.mul = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f3.prototype.mulf = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f3.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f3.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h5 = 0;h5 < this.length; h5++) {
          var s2 = (this.words[h5] | 0) * i, u3 = (s2 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s2 / 67108864 | 0, a3 += u3 >>> 26, this.words[h5] = u3 & 67108863;
        }
        return a3 !== 0 && (this.words[h5] = a3, this.length++), this;
      }, f3.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f3(1);
        for (var h5 = this, s2 = 0;s2 < a3.length && a3[s2] === 0; s2++, h5 = h5.sqr())
          ;
        if (++s2 < a3.length)
          for (var u3 = h5.sqr();s2 < a3.length; s2++, u3 = u3.sqr())
            a3[s2] !== 0 && (h5 = h5.mul(u3));
        return h5;
      }, f3.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s2 = 67108863 >>> 26 - a3 << 26 - a3, u3;
        if (a3 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b6 = this.words[u3] & s2, l3 = (this.words[u3] | 0) - b6 << a3;
            this.words[u3] = l3 | c2, c2 = b6 >>> 26 - a3;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h5 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h5] = this.words[u3];
          for (u3 = 0;u3 < h5; u3++)
            this.words[u3] = 0;
          this.length += h5;
        }
        return this.strip();
      }, f3.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f3.prototype.iushrn = function(i, a3, h5) {
        r(typeof i == "number" && i >= 0);
        var s2;
        a3 ? s2 = (a3 - a3 % 26) / 26 : s2 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b6 = 67108863 ^ 67108863 >>> u3 << u3, l3 = h5;
        if (s2 -= c2, s2 = Math.max(0, s2), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s2); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u3 | w3 >>> u3, d4 = w3 & b6;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f3.prototype.ishrn = function(i, a3, h5) {
        return r(this.negative === 0), this.iushrn(i, a3, h5);
      }, f3.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f3.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f3.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f3.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f3.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h5)
          return false;
        var u3 = this.words[h5];
        return !!(u3 & s2);
      }, f3.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h5)
          return this;
        if (a3 !== 0 && h5++, this.length = Math.min(h5, this.length), a3 !== 0) {
          var s2 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s2;
        }
        return this.strip();
      }, f3.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f3.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f3.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f3.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f3.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f3.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(i, a3, h5) {
        var s2 = i.length + h5, u3;
        this._expand(s2);
        var c2, b6 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h5] | 0) + b6;
          var l3 = (i.words[u3] | 0) * a3;
          c2 -= l3 & 67108863, b6 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u3 + h5] = c2 & 67108863;
        }
        for (;u3 < this.length - h5; u3++)
          c2 = (this.words[u3 + h5] | 0) + b6, b6 = c2 >> 26, this.words[u3 + h5] = c2 & 67108863;
        if (b6 === 0)
          return this.strip();
        for (r(b6 === -1), b6 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b6, b6 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f3.prototype._wordDiv = function(i, a3) {
        var h5 = this.length - i.length, s2 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b6 = this._countBits(c2);
        h5 = 26 - b6, h5 !== 0 && (u3 = u3.ushln(h5), s2.iushln(h5), c2 = u3.words[u3.length - 1] | 0);
        var l3 = s2.length - u3.length, n;
        if (a3 !== "mod") {
          n = new f3(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s2.clone()._ishlnsubmul(u3, 1, l3);
        w3.negative === 0 && (s2 = w3, n && (n.words[l3] = 1));
        for (var g5 = l3 - 1;g5 >= 0; g5--) {
          var _4 = (s2.words[u3.length + g5] | 0) * 67108864 + (s2.words[u3.length + g5 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s2._ishlnsubmul(u3, _4, g5);s2.negative !== 0; )
            _4--, s2.negative = 0, s2._ishlnsubmul(u3, 1, g5), s2.isZero() || (s2.negative ^= 1);
          n && (n.words[g5] = _4);
        }
        return n && n.strip(), s2.strip(), a3 !== "div" && h5 !== 0 && s2.iushrn(h5), { div: n || null, mod: s2 };
      }, f3.prototype.divmod = function(i, a3, h5) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var s2, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s2 = c2.div.neg()), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.iadd(i)), { div: s2, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s2 = c2.div.neg()), { div: s2, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f3(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f3(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f3(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f3.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f3.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f3.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f3.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h5 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s2 = i.ushrn(1), u3 = i.andln(1), c2 = h5.cmp(s2);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f3.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h5 = 0, s2 = this.length - 1;s2 >= 0; s2--)
          h5 = (a3 * h5 + (this.words[s2] | 0)) % i;
        return h5;
      }, f3.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s2 = (this.words[h5] | 0) + a3 * 67108864;
          this.words[h5] = s2 / i | 0, a3 = s2 % i;
        }
        return this.strip();
      }, f3.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f3.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f3(1), u3 = new f3(0), c2 = new f3(0), b6 = new f3(1), l3 = 0;a3.isEven() && h5.isEven(); )
          a3.iushrn(1), h5.iushrn(1), ++l3;
        for (var n = h5.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g5 = 1;(a3.words[0] & g5) === 0 && w3 < 26; ++w3, g5 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s2.isOdd() || u3.isOdd()) && (s2.iadd(n), u3.isub(d4)), s2.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A4 = 1;(h5.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h5.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b6.isOdd()) && (c2.iadd(n), b6.isub(d4)), c2.iushrn(1), b6.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s2.isub(c2), u3.isub(b6)) : (h5.isub(a3), c2.isub(s2), b6.isub(u3));
        }
        return { a: c2, b: b6, gcd: h5.iushln(l3) };
      }, f3.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f3(1), u3 = new f3(0), c2 = h5.clone();a3.cmpn(1) > 0 && h5.cmpn(1) > 0; ) {
          for (var b6 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b6 < 26; ++b6, l3 <<= 1)
            ;
          if (b6 > 0)
            for (a3.iushrn(b6);b6-- > 0; )
              s2.isOdd() && s2.iadd(c2), s2.iushrn(1);
          for (var n = 0, d4 = 1;(h5.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h5.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s2.isub(u3)) : (h5.isub(a3), u3.isub(s2));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s2 : w3 = u3, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f3.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h5 = i.clone();
        a3.negative = 0, h5.negative = 0;
        for (var s2 = 0;a3.isEven() && h5.isEven(); s2++)
          a3.iushrn(1), h5.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h5.isEven(); )
            h5.iushrn(1);
          var u3 = a3.cmp(h5);
          if (u3 < 0) {
            var c2 = a3;
            a3 = h5, h5 = c2;
          } else if (u3 === 0 || h5.cmpn(1) === 0)
            break;
          a3.isub(h5);
        } while (true);
        return h5.iushln(s2);
      }, f3.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f3.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h5 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h5)
          return this._expand(h5 + 1), this.words[h5] |= s2, this;
        for (var u3 = s2, c2 = h5;u3 !== 0 && c2 < this.length; c2++) {
          var b6 = this.words[c2] | 0;
          b6 += u3, u3 = b6 >>> 26, b6 &= 67108863, this.words[c2] = b6;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h5;
        if (this.length > 1)
          h5 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s2 = this.words[0] | 0;
          h5 = s2 === i ? 0 : s2 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h5 | 0 : h5;
      }, f3.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f3.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s2 = this.words[h5] | 0, u3 = i.words[h5] | 0;
          if (s2 !== u3) {
            s2 < u3 ? a3 = -1 : s2 > u3 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f3.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f3.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f3.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f3.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f3.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f3.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f3.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f3.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f3.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f3.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f3.red = function(i) {
        return new P4(i);
      }, f3.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f3.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f3.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f3.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f3.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f3.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f3.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f3.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f3.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye2(v4, i) {
        this.name = v4, this.p = new f3(i, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye2.prototype._tmp = function() {
        var i = new f3(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye2.prototype.ireduce = function(i) {
        var a3 = i, h5;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h5 = a3.bitLength();
        while (h5 > this.n);
        var s2 = h5 < this.n ? -1 : a3.ucmp(this.p);
        return s2 === 0 ? (a3.words[0] = 0, a3.length = 1) : s2 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye2.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye2.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe2() {
        ye2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe2, ye2), xe2.prototype.split = function(i, a3) {
        for (var h5 = 4194303, s2 = Math.min(i.length, 9), u3 = 0;u3 < s2; u3++)
          a3.words[u3] = i.words[u3];
        if (a3.length = s2, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h5, u3 = 10;u3 < i.length; u3++) {
          var b6 = i.words[u3] | 0;
          i.words[u3 - 10] = (b6 & h5) << 4 | c2 >>> 22, c2 = b6;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe2.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s2 = i.words[h5] | 0;
          a3 += s2 * 977, i.words[h5] = a3 & 67108863, a3 = s2 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye2);
      function Ee() {
        ye2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye2);
      function Ae2() {
        ye2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye2), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s2 = (i.words[h5] | 0) * 19 + a3, u3 = s2 & 67108863;
          s2 >>>= 26, i.words[h5] = u3, a3 = s2;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f3._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe2;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P4(v4) {
        if (typeof v4 == "string") {
          var i = f3._prime(v4);
          this.m = i.p, this.prime = i;
        } else
          r(v4.gtn(1), "modulus must be greater than 1"), this.m = v4, this.prime = null;
      }
      P4.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P4.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P4.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P4.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P4.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.add(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5._forceRed(this);
      }, P4.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.iadd(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5;
      }, P4.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.sub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5._forceRed(this);
      }, P4.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.isub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5;
      }, P4.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P4.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P4.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P4.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P4.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P4.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h5 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(i, h5);
        }
        for (var s2 = this.m.subn(1), u3 = 0;!s2.isZero() && s2.andln(1) === 0; )
          u3++, s2.iushrn(1);
        r(!s2.isZero());
        var c2 = new f3(1).toRed(this), b6 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f3(2 * n * n).toRed(this);this.pow(n, l3).cmp(b6) !== 0; )
          n.redIAdd(b6);
        for (var d4 = this.pow(n, s2), w3 = this.pow(i, s2.addn(1).iushrn(1)), g5 = this.pow(i, s2), _4 = u3;g5.cmp(c2) !== 0; ) {
          for (var A4 = g5, R4 = 0;A4.cmp(c2) !== 0; R4++)
            A4 = A4.redSqr();
          r(R4 < _4);
          var I5 = this.pow(d4, new f3(1).iushln(_4 - R4 - 1));
          w3 = w3.redMul(I5), d4 = I5.redSqr(), g5 = g5.redMul(d4), _4 = R4;
        }
        return w3;
      }, P4.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P4.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f3(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h5 = 4, s2 = new Array(1 << h5);
        s2[0] = new f3(1).toRed(this), s2[1] = i;
        for (var u3 = 2;u3 < s2.length; u3++)
          s2[u3] = this.mul(s2[u3 - 1], i);
        var c2 = s2[0], b6 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a3.length - 1;u3 >= 0; u3--) {
          for (var d4 = a3.words[u3], w3 = n - 1;w3 >= 0; w3--) {
            var g5 = d4 >> w3 & 1;
            if (c2 !== s2[0] && (c2 = this.sqr(c2)), g5 === 0 && b6 === 0) {
              l3 = 0;
              continue;
            }
            b6 <<= 1, b6 |= g5, l3++, !(l3 !== h5 && (u3 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s2[b6]), l3 = 0, b6 = 0);
          }
          n = 26;
        }
        return c2;
      }, P4.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P4.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f3.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v4) {
        P4.call(this, v4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P4), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h5 = i.imul(a3), s2 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f3(0)._forceRed(this);
        var h5 = i.mul(a3), s2 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Gu2 > "u" || Gu2, $m);
  });
  Ym = T3((Gm, Xu) => {
    (function(t, e) {
      function r(v4, i) {
        if (!v4)
          throw new Error(i || "Assertion failed");
      }
      function o2(v4, i) {
        v4.super_ = i;
        var a3 = function() {
        };
        a3.prototype = i.prototype, v4.prototype = new a3, v4.prototype.constructor = v4;
      }
      function f3(v4, i, a3) {
        if (f3.isBN(v4))
          return v4;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v4 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v4 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(i) {
        return i instanceof f3 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f3.wordSize && Array.isArray(i.words);
      }, f3.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f3.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f3.prototype._init = function(i, a3, h5) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h5);
        if (typeof i == "object")
          return this._initArray(i, a3, h5);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s2 = 0;
        i[0] === "-" && (s2++, this.negative = 1), s2 < i.length && (a3 === 16 ? this._parseHex(i, s2, h5) : (this._parseBase(i, a3, s2), h5 === "le" && this._initArray(this.toArray(), a3, h5)));
      }, f3.prototype._initNumber = function(i, a3, h5) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h5 === "le" && this._initArray(this.toArray(), a3, h5);
      }, f3.prototype._initArray = function(i, a3, h5) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3, c2, b6 = 0;
        if (h5 === "be")
          for (s2 = i.length - 1, u3 = 0;s2 >= 0; s2 -= 3)
            c2 = i[s2] | i[s2 - 1] << 8 | i[s2 - 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        else if (h5 === "le")
          for (s2 = 0, u3 = 0;s2 < i.length; s2 += 3)
            c2 = i[s2] | i[s2 + 1] << 8 | i[s2 + 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        return this.strip();
      };
      function m3(v4, i) {
        var a3 = v4.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y5(v4, i, a3) {
        var h5 = m3(v4, a3);
        return a3 - 1 >= i && (h5 |= m3(v4, a3 - 1) << 4), h5;
      }
      f3.prototype._parseHex = function(i, a3, h5) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3 = 0, c2 = 0, b6;
        if (h5 === "be")
          for (s2 = i.length - 1;s2 >= a3; s2 -= 2)
            b6 = y5(i, a3, s2) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        else {
          var l3 = i.length - a3;
          for (s2 = l3 % 2 === 0 ? a3 + 1 : a3;s2 < i.length; s2 += 2)
            b6 = y5(i, a3, s2) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M3(v4, i, a3, h5) {
        for (var s2 = 0, u3 = Math.min(v4.length, a3), c2 = i;c2 < u3; c2++) {
          var b6 = v4.charCodeAt(c2) - 48;
          s2 *= h5, b6 >= 49 ? s2 += b6 - 49 + 10 : b6 >= 17 ? s2 += b6 - 17 + 10 : s2 += b6;
        }
        return s2;
      }
      f3.prototype._parseBase = function(i, a3, h5) {
        this.words = [0], this.length = 1;
        for (var s2 = 0, u3 = 1;u3 <= 67108863; u3 *= a3)
          s2++;
        s2--, u3 = u3 / a3 | 0;
        for (var c2 = i.length - h5, b6 = c2 % s2, l3 = Math.min(c2, c2 - b6) + h5, n = 0, d4 = h5;d4 < l3; d4 += s2)
          n = M3(i, d4, d4 + s2, a3), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b6 !== 0) {
          var w3 = 1;
          for (n = M3(i, d4, i.length, a3), d4 = 0;d4 < b6; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f3.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f3.prototype.clone = function() {
        var i = new f3(null);
        return this.copy(i), i;
      }, f3.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f3.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h5;
        if (i === 16 || i === "hex") {
          h5 = "";
          for (var s2 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b6 = this.words[c2], l3 = ((b6 << s2 | u3) & 16777215).toString(16);
            u3 = b6 >>> 24 - s2 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h5 = x5[6 - l3.length] + l3 + h5 : h5 = l3 + h5, s2 += 2, s2 >= 26 && (s2 -= 26, c2--);
          }
          for (u3 !== 0 && (h5 = u3.toString(16) + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S3[i], d4 = E6[i];
          h5 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g5 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h5 = g5 + h5 : h5 = x5[n - g5.length] + g5 + h5;
          }
          for (this.isZero() && (h5 = "0" + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f3.prototype.toJSON = function() {
        return this.toString(16);
      }, f3.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f3.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f3.prototype.toArrayLike = function(i, a3, h5) {
        var s2 = this.byteLength(), u3 = h5 || Math.max(1, s2);
        r(s2 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b6 = new i(u3), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[n] = l3;
          for (;n < u3; n++)
            b6[n] = 0;
        } else {
          for (n = 0;n < u3 - s2; n++)
            b6[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[u3 - n - 1] = l3;
        }
        return b6;
      }, Math.clz32 ? f3.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f3.prototype._countBits = function(i) {
        var a3 = i, h5 = 0;
        return a3 >= 4096 && (h5 += 13, a3 >>>= 13), a3 >= 64 && (h5 += 7, a3 >>>= 7), a3 >= 8 && (h5 += 4, a3 >>>= 4), a3 >= 2 && (h5 += 2, a3 >>>= 2), h5 + a3;
      }, f3.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h5 = 0;
        return (a3 & 8191) === 0 && (h5 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h5 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h5 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h5 += 2, a3 >>>= 2), (a3 & 1) === 0 && h5++, h5;
      }, f3.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v4) {
        for (var i = new Array(v4.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h5 = a3 / 26 | 0, s2 = a3 % 26;
          i[a3] = (v4.words[h5] & 1 << s2) >>> s2;
        }
        return i;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h5 = this._zeroBits(this.words[a3]);
          if (i += h5, h5 !== 26)
            break;
        }
        return i;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f3.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f3.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f3.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f3.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h5 = 0;h5 < a3.length; h5++)
          this.words[h5] = this.words[h5] & i.words[h5];
        return this.length = a3.length, this.strip();
      }, f3.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f3.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f3.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f3.prototype.iuxor = function(i) {
        var a3, h5;
        this.length > i.length ? (a3 = this, h5 = i) : (a3 = i, h5 = this);
        for (var s2 = 0;s2 < h5.length; s2++)
          this.words[s2] = a3.words[s2] ^ h5.words[s2];
        if (this !== a3)
          for (;s2 < a3.length; s2++)
            this.words[s2] = a3.words[s2];
        return this.length = a3.length, this.strip();
      }, f3.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f3.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f3.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f3.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h5 = i % 26;
        this._expand(a3), h5 > 0 && a3--;
        for (var s2 = 0;s2 < a3; s2++)
          this.words[s2] = ~this.words[s2] & 67108863;
        return h5 > 0 && (this.words[s2] = ~this.words[s2] & 67108863 >> 26 - h5), this.strip();
      }, f3.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f3.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h5 = i / 26 | 0, s2 = i % 26;
        return this._expand(h5 + 1), a3 ? this.words[h5] = this.words[h5] | 1 << s2 : this.words[h5] = this.words[h5] & ~(1 << s2), this.strip();
      }, f3.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h5, s2;
        this.length > i.length ? (h5 = this, s2 = i) : (h5 = i, s2 = this);
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++)
          a3 = (h5.words[c2] | 0) + (s2.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        for (;u3 !== 0 && c2 < h5.length; c2++)
          a3 = (h5.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        if (this.length = h5.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h5 !== this)
          for (;c2 < h5.length; c2++)
            this.words[c2] = h5.words[c2];
        return this;
      }, f3.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f3.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h5 = this.cmp(i);
        if (h5 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s2, u3;
        h5 > 0 ? (s2 = this, u3 = i) : (s2 = i, u3 = this);
        for (var c2 = 0, b6 = 0;b6 < u3.length; b6++)
          a3 = (s2.words[b6] | 0) - (u3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        for (;c2 !== 0 && b6 < s2.length; b6++)
          a3 = (s2.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        if (c2 === 0 && b6 < s2.length && s2 !== this)
          for (;b6 < s2.length; b6++)
            this.words[b6] = s2.words[b6];
        return this.length = Math.max(this.length, b6), s2 !== this && (this.negative = 1), this.strip();
      }, f3.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q3(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative;
        var h5 = v4.length + i.length | 0;
        a3.length = h5, h5 = h5 - 1 | 0;
        var s2 = v4.words[0] | 0, u3 = i.words[0] | 0, c2 = s2 * u3, b6 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b6;
        for (var n = 1;n < h5; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g5 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v4.length + 1);_4 <= g5; _4++) {
            var A4 = n - _4 | 0;
            s2 = v4.words[A4] | 0, u3 = i.words[_4] | 0, c2 = s2 * u3 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h5) {
        var s2 = i.words, u3 = a3.words, c2 = h5.words, b6 = 0, l3, n, d4, w3 = s2[0] | 0, g5 = w3 & 8191, _4 = w3 >>> 13, A4 = s2[1] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = s2[2] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = s2[3] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = s2[4] | 0, F2 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = s2[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = s2[6] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = s2[7] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s2[8] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = s2[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u3[0] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = u3[1] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = u3[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = u3[3] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = u3[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = u3[5] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = u3[6] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = u3[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = u3[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u3[9] | 0, ve = It & 8191, be2 = It >>> 13;
        h5.negative = i.negative ^ a3.negative, h5.length = 19, l3 = Math.imul(g5, X4), n = Math.imul(g5, J3), n = n + Math.imul(_4, X4) | 0, d4 = Math.imul(_4, J3);
        var ft2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l3 = Math.imul(R4, X4), n = Math.imul(R4, J3), n = n + Math.imul(I5, X4) | 0, d4 = Math.imul(I5, J3), l3 = l3 + Math.imul(g5, Q5) | 0, n = n + Math.imul(g5, ee) | 0, n = n + Math.imul(_4, Q5) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X4), n = Math.imul(k4, J3), n = n + Math.imul(D3, X4) | 0, d4 = Math.imul(D3, J3), l3 = l3 + Math.imul(R4, Q5) | 0, n = n + Math.imul(R4, ee) | 0, n = n + Math.imul(I5, Q5) | 0, d4 = d4 + Math.imul(I5, ee) | 0, l3 = l3 + Math.imul(g5, te2) | 0, n = n + Math.imul(g5, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C4, X4), n = Math.imul(C4, J3), n = n + Math.imul(O4, X4) | 0, d4 = Math.imul(O4, J3), l3 = l3 + Math.imul(k4, Q5) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D3, Q5) | 0, d4 = d4 + Math.imul(D3, ee) | 0, l3 = l3 + Math.imul(R4, te2) | 0, n = n + Math.imul(R4, re2) | 0, n = n + Math.imul(I5, te2) | 0, d4 = d4 + Math.imul(I5, re2) | 0, l3 = l3 + Math.imul(g5, ie) | 0, n = n + Math.imul(g5, ne2) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne2) | 0;
        var ze = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F2, X4), n = Math.imul(F2, J3), n = n + Math.imul(U3, X4) | 0, d4 = Math.imul(U3, J3), l3 = l3 + Math.imul(C4, Q5) | 0, n = n + Math.imul(C4, ee) | 0, n = n + Math.imul(O4, Q5) | 0, d4 = d4 + Math.imul(O4, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D3, te2) | 0, d4 = d4 + Math.imul(D3, re2) | 0, l3 = l3 + Math.imul(R4, ie) | 0, n = n + Math.imul(R4, ne2) | 0, n = n + Math.imul(I5, ie) | 0, d4 = d4 + Math.imul(I5, ne2) | 0, l3 = l3 + Math.imul(g5, fe3) | 0, n = n + Math.imul(g5, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X4), n = Math.imul(z, J3), n = n + Math.imul(H3, X4) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F2, Q5) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U3, Q5) | 0, d4 = d4 + Math.imul(U3, ee) | 0, l3 = l3 + Math.imul(C4, te2) | 0, n = n + Math.imul(C4, re2) | 0, n = n + Math.imul(O4, te2) | 0, d4 = d4 + Math.imul(O4, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne2) | 0, n = n + Math.imul(D3, ie) | 0, d4 = d4 + Math.imul(D3, ne2) | 0, l3 = l3 + Math.imul(R4, fe3) | 0, n = n + Math.imul(R4, ae2) | 0, n = n + Math.imul(I5, fe3) | 0, d4 = d4 + Math.imul(I5, ae2) | 0, l3 = l3 + Math.imul(g5, oe3) | 0, n = n + Math.imul(g5, se3) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se3) | 0;
        var We2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X4), n = Math.imul(W, J3), n = n + Math.imul(K5, X4) | 0, d4 = Math.imul(K5, J3), l3 = l3 + Math.imul(z, Q5) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q5) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F2, te2) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U3, te2) | 0, d4 = d4 + Math.imul(U3, re2) | 0, l3 = l3 + Math.imul(C4, ie) | 0, n = n + Math.imul(C4, ne2) | 0, n = n + Math.imul(O4, ie) | 0, d4 = d4 + Math.imul(O4, ne2) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D3, fe3) | 0, d4 = d4 + Math.imul(D3, ae2) | 0, l3 = l3 + Math.imul(R4, oe3) | 0, n = n + Math.imul(R4, se3) | 0, n = n + Math.imul(I5, oe3) | 0, d4 = d4 + Math.imul(I5, se3) | 0, l3 = l3 + Math.imul(g5, he) | 0, n = n + Math.imul(g5, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j5, X4), n = Math.imul(j5, J3), n = n + Math.imul(Z3, X4) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q5) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K5, Q5) | 0, d4 = d4 + Math.imul(K5, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne2) | 0, n = n + Math.imul(U3, ie) | 0, d4 = d4 + Math.imul(U3, ne2) | 0, l3 = l3 + Math.imul(C4, fe3) | 0, n = n + Math.imul(C4, ae2) | 0, n = n + Math.imul(O4, fe3) | 0, d4 = d4 + Math.imul(O4, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se3) | 0, n = n + Math.imul(D3, oe3) | 0, d4 = d4 + Math.imul(D3, se3) | 0, l3 = l3 + Math.imul(R4, he) | 0, n = n + Math.imul(R4, ue4) | 0, n = n + Math.imul(I5, he) | 0, d4 = d4 + Math.imul(I5, ue4) | 0, l3 = l3 + Math.imul(g5, le) | 0, n = n + Math.imul(g5, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V6, X4), n = Math.imul(V6, J3), n = n + Math.imul($3, X4) | 0, d4 = Math.imul($3, J3), l3 = l3 + Math.imul(j5, Q5) | 0, n = n + Math.imul(j5, ee) | 0, n = n + Math.imul(Z3, Q5) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K5, te2) | 0, d4 = d4 + Math.imul(K5, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne2) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne2) | 0, l3 = l3 + Math.imul(F2, fe3) | 0, n = n + Math.imul(F2, ae2) | 0, n = n + Math.imul(U3, fe3) | 0, d4 = d4 + Math.imul(U3, ae2) | 0, l3 = l3 + Math.imul(C4, oe3) | 0, n = n + Math.imul(C4, se3) | 0, n = n + Math.imul(O4, oe3) | 0, d4 = d4 + Math.imul(O4, se3) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D3, he) | 0, d4 = d4 + Math.imul(D3, ue4) | 0, l3 = l3 + Math.imul(R4, le) | 0, n = n + Math.imul(R4, de) | 0, n = n + Math.imul(I5, le) | 0, d4 = d4 + Math.imul(I5, de) | 0, l3 = l3 + Math.imul(g5, ce3) | 0, n = n + Math.imul(g5, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X4), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X4) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V6, Q5) | 0, n = n + Math.imul(V6, ee) | 0, n = n + Math.imul($3, Q5) | 0, d4 = d4 + Math.imul($3, ee) | 0, l3 = l3 + Math.imul(j5, te2) | 0, n = n + Math.imul(j5, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne2) | 0, n = n + Math.imul(K5, ie) | 0, d4 = d4 + Math.imul(K5, ne2) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F2, oe3) | 0, n = n + Math.imul(F2, se3) | 0, n = n + Math.imul(U3, oe3) | 0, d4 = d4 + Math.imul(U3, se3) | 0, l3 = l3 + Math.imul(C4, he) | 0, n = n + Math.imul(C4, ue4) | 0, n = n + Math.imul(O4, he) | 0, d4 = d4 + Math.imul(O4, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D3, le) | 0, d4 = d4 + Math.imul(D3, de) | 0, l3 = l3 + Math.imul(R4, ce3) | 0, n = n + Math.imul(R4, pe2) | 0, n = n + Math.imul(I5, ce3) | 0, d4 = d4 + Math.imul(I5, pe2) | 0, l3 = l3 + Math.imul(g5, ve) | 0, n = n + Math.imul(g5, be2) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be2) | 0;
        var Ve = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q5), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q5) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V6, te2) | 0, n = n + Math.imul(V6, re2) | 0, n = n + Math.imul($3, te2) | 0, d4 = d4 + Math.imul($3, re2) | 0, l3 = l3 + Math.imul(j5, ie) | 0, n = n + Math.imul(j5, ne2) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne2) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K5, fe3) | 0, d4 = d4 + Math.imul(K5, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se3) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se3) | 0, l3 = l3 + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue4) | 0, n = n + Math.imul(U3, he) | 0, d4 = d4 + Math.imul(U3, ue4) | 0, l3 = l3 + Math.imul(C4, le) | 0, n = n + Math.imul(C4, de) | 0, n = n + Math.imul(O4, le) | 0, d4 = d4 + Math.imul(O4, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D3, ce3) | 0, d4 = d4 + Math.imul(D3, pe2) | 0, l3 = l3 + Math.imul(R4, ve) | 0, n = n + Math.imul(R4, be2) | 0, n = n + Math.imul(I5, ve) | 0, d4 = d4 + Math.imul(I5, be2) | 0;
        var $e2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V6, ie) | 0, n = n + Math.imul(V6, ne2) | 0, n = n + Math.imul($3, ie) | 0, d4 = d4 + Math.imul($3, ne2) | 0, l3 = l3 + Math.imul(j5, fe3) | 0, n = n + Math.imul(j5, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se3) | 0, n = n + Math.imul(K5, oe3) | 0, d4 = d4 + Math.imul(K5, se3) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U3, le) | 0, d4 = d4 + Math.imul(U3, de) | 0, l3 = l3 + Math.imul(C4, ce3) | 0, n = n + Math.imul(C4, pe2) | 0, n = n + Math.imul(O4, ce3) | 0, d4 = d4 + Math.imul(O4, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be2) | 0, n = n + Math.imul(D3, ve) | 0, d4 = d4 + Math.imul(D3, be2) | 0;
        var Ge = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne2), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne2), l3 = l3 + Math.imul(V6, fe3) | 0, n = n + Math.imul(V6, ae2) | 0, n = n + Math.imul($3, fe3) | 0, d4 = d4 + Math.imul($3, ae2) | 0, l3 = l3 + Math.imul(j5, oe3) | 0, n = n + Math.imul(j5, se3) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se3) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K5, he) | 0, d4 = d4 + Math.imul(K5, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F2, ce3) | 0, n = n + Math.imul(F2, pe2) | 0, n = n + Math.imul(U3, ce3) | 0, d4 = d4 + Math.imul(U3, pe2) | 0, l3 = l3 + Math.imul(C4, ve) | 0, n = n + Math.imul(C4, be2) | 0, n = n + Math.imul(O4, ve) | 0, d4 = d4 + Math.imul(O4, be2) | 0;
        var Ye = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V6, oe3) | 0, n = n + Math.imul(V6, se3) | 0, n = n + Math.imul($3, oe3) | 0, d4 = d4 + Math.imul($3, se3) | 0, l3 = l3 + Math.imul(j5, he) | 0, n = n + Math.imul(j5, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K5, le) | 0, d4 = d4 + Math.imul(K5, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be2) | 0, n = n + Math.imul(U3, ve) | 0, d4 = d4 + Math.imul(U3, be2) | 0;
        var Xe = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se3), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se3), l3 = l3 + Math.imul(V6, he) | 0, n = n + Math.imul(V6, ue4) | 0, n = n + Math.imul($3, he) | 0, d4 = d4 + Math.imul($3, ue4) | 0, l3 = l3 + Math.imul(j5, le) | 0, n = n + Math.imul(j5, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K5, ce3) | 0, d4 = d4 + Math.imul(K5, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be2) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be2) | 0;
        var Je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V6, le) | 0, n = n + Math.imul(V6, de) | 0, n = n + Math.imul($3, le) | 0, d4 = d4 + Math.imul($3, de) | 0, l3 = l3 + Math.imul(j5, ce3) | 0, n = n + Math.imul(j5, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be2) | 0, n = n + Math.imul(K5, ve) | 0, d4 = d4 + Math.imul(K5, be2) | 0;
        var Qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V6, ce3) | 0, n = n + Math.imul(V6, pe2) | 0, n = n + Math.imul($3, ce3) | 0, d4 = d4 + Math.imul($3, pe2) | 0, l3 = l3 + Math.imul(j5, ve) | 0, n = n + Math.imul(j5, be2) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be2) | 0;
        var et3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V6, ve) | 0, n = n + Math.imul(V6, be2) | 0, n = n + Math.imul($3, ve) | 0, d4 = d4 + Math.imul($3, be2) | 0;
        var tt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be2), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be2);
        var rt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b6 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft2, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et3, c2[17] = tt4, c2[18] = rt4, b6 !== 0 && (c2[19] = b6, h5.length++), h5;
      };
      Math.imul || (L4 = q3);
      function ge(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative, a3.length = v4.length + i.length;
        for (var h5 = 0, s2 = 0, u3 = 0;u3 < a3.length - 1; u3++) {
          var c2 = s2;
          s2 = 0;
          for (var b6 = h5 & 67108863, l3 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v4.length + 1);n <= l3; n++) {
            var d4 = u3 - n, w3 = v4.words[d4] | 0, g5 = i.words[n] | 0, _4 = w3 * g5, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b6 | 0, b6 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s2 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u3] = b6, h5 = c2, c2 = s2;
        }
        return h5 !== 0 ? a3.words[u3] = h5 : a3.length--, a3.strip();
      }
      function _e3(v4, i, a3) {
        var h5 = new N6;
        return h5.mulp(v4, i, a3);
      }
      f3.prototype.mulTo = function(i, a3) {
        var h5, s2 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h5 = L4(this, i, a3) : s2 < 63 ? h5 = q3(this, i, a3) : s2 < 1024 ? h5 = ge(this, i, a3) : h5 = _e3(this, i, a3), h5;
      };
      function N6(v4, i) {
        this.x = v4, this.y = i;
      }
      N6.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h5 = f3.prototype._countBits(i) - 1, s2 = 0;s2 < i; s2++)
          a3[s2] = this.revBin(s2, h5, i);
        return a3;
      }, N6.prototype.revBin = function(i, a3, h5) {
        if (i === 0 || i === h5 - 1)
          return i;
        for (var s2 = 0, u3 = 0;u3 < a3; u3++)
          s2 |= (i & 1) << a3 - u3 - 1, i >>= 1;
        return s2;
      }, N6.prototype.permute = function(i, a3, h5, s2, u3, c2) {
        for (var b6 = 0;b6 < c2; b6++)
          s2[b6] = a3[i[b6]], u3[b6] = h5[i[b6]];
      }, N6.prototype.transform = function(i, a3, h5, s2, u3, c2) {
        this.permute(c2, i, a3, h5, s2, u3);
        for (var b6 = 1;b6 < u3; b6 <<= 1)
          for (var l3 = b6 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u3; w3 += l3)
            for (var g5 = n, _4 = d4, A4 = 0;A4 < b6; A4++) {
              var R4 = h5[w3 + A4], I5 = s2[w3 + A4], Me = h5[w3 + A4 + b6], k4 = s2[w3 + A4 + b6], D3 = g5 * Me - _4 * k4;
              k4 = g5 * k4 + _4 * Me, Me = D3, h5[w3 + A4] = R4 + Me, s2[w3 + A4] = I5 + k4, h5[w3 + A4 + b6] = R4 - Me, s2[w3 + A4 + b6] = I5 - k4, A4 !== l3 && (D3 = n * g5 - d4 * _4, _4 = n * _4 + d4 * g5, g5 = D3);
            }
      }, N6.prototype.guessLen13b = function(i, a3) {
        var h5 = Math.max(a3, i) | 1, s2 = h5 & 1, u3 = 0;
        for (h5 = h5 / 2 | 0;h5; h5 = h5 >>> 1)
          u3++;
        return 1 << u3 + 1 + s2;
      }, N6.prototype.conjugate = function(i, a3, h5) {
        if (!(h5 <= 1))
          for (var s2 = 0;s2 < h5 / 2; s2++) {
            var u3 = i[s2];
            i[s2] = i[h5 - s2 - 1], i[h5 - s2 - 1] = u3, u3 = a3[s2], a3[s2] = -a3[h5 - s2 - 1], a3[h5 - s2 - 1] = -u3;
          }
      }, N6.prototype.normalize13b = function(i, a3) {
        for (var h5 = 0, s2 = 0;s2 < a3 / 2; s2++) {
          var u3 = Math.round(i[2 * s2 + 1] / a3) * 8192 + Math.round(i[2 * s2] / a3) + h5;
          i[s2] = u3 & 67108863, u3 < 67108864 ? h5 = 0 : h5 = u3 / 67108864 | 0;
        }
        return i;
      }, N6.prototype.convert13b = function(i, a3, h5, s2) {
        for (var u3 = 0, c2 = 0;c2 < a3; c2++)
          u3 = u3 + (i[c2] | 0), h5[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h5[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a3;c2 < s2; ++c2)
          h5[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N6.prototype.stub = function(i) {
        for (var a3 = new Array(i), h5 = 0;h5 < i; h5++)
          a3[h5] = 0;
        return a3;
      }, N6.prototype.mulp = function(i, a3, h5) {
        var s2 = 2 * this.guessLen13b(i.length, a3.length), u3 = this.makeRBT(s2), c2 = this.stub(s2), b6 = new Array(s2), l3 = new Array(s2), n = new Array(s2), d4 = new Array(s2), w3 = new Array(s2), g5 = new Array(s2), _4 = h5.words;
        _4.length = s2, this.convert13b(i.words, i.length, b6, s2), this.convert13b(a3.words, a3.length, d4, s2), this.transform(b6, c2, l3, n, s2, u3), this.transform(d4, c2, w3, g5, s2, u3);
        for (var A4 = 0;A4 < s2; A4++) {
          var R4 = l3[A4] * w3[A4] - n[A4] * g5[A4];
          n[A4] = l3[A4] * g5[A4] + n[A4] * w3[A4], l3[A4] = R4;
        }
        return this.conjugate(l3, n, s2), this.transform(l3, n, _4, c2, s2, u3), this.conjugate(_4, c2, s2), this.normalize13b(_4, s2), h5.negative = i.negative ^ a3.negative, h5.length = i.length + a3.length, h5.strip();
      }, f3.prototype.mul = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f3.prototype.mulf = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f3.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f3.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h5 = 0;h5 < this.length; h5++) {
          var s2 = (this.words[h5] | 0) * i, u3 = (s2 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s2 / 67108864 | 0, a3 += u3 >>> 26, this.words[h5] = u3 & 67108863;
        }
        return a3 !== 0 && (this.words[h5] = a3, this.length++), this;
      }, f3.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f3(1);
        for (var h5 = this, s2 = 0;s2 < a3.length && a3[s2] === 0; s2++, h5 = h5.sqr())
          ;
        if (++s2 < a3.length)
          for (var u3 = h5.sqr();s2 < a3.length; s2++, u3 = u3.sqr())
            a3[s2] !== 0 && (h5 = h5.mul(u3));
        return h5;
      }, f3.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s2 = 67108863 >>> 26 - a3 << 26 - a3, u3;
        if (a3 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b6 = this.words[u3] & s2, l3 = (this.words[u3] | 0) - b6 << a3;
            this.words[u3] = l3 | c2, c2 = b6 >>> 26 - a3;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h5 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h5] = this.words[u3];
          for (u3 = 0;u3 < h5; u3++)
            this.words[u3] = 0;
          this.length += h5;
        }
        return this.strip();
      }, f3.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f3.prototype.iushrn = function(i, a3, h5) {
        r(typeof i == "number" && i >= 0);
        var s2;
        a3 ? s2 = (a3 - a3 % 26) / 26 : s2 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b6 = 67108863 ^ 67108863 >>> u3 << u3, l3 = h5;
        if (s2 -= c2, s2 = Math.max(0, s2), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s2); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u3 | w3 >>> u3, d4 = w3 & b6;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f3.prototype.ishrn = function(i, a3, h5) {
        return r(this.negative === 0), this.iushrn(i, a3, h5);
      }, f3.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f3.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f3.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f3.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f3.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h5)
          return false;
        var u3 = this.words[h5];
        return !!(u3 & s2);
      }, f3.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h5)
          return this;
        if (a3 !== 0 && h5++, this.length = Math.min(h5, this.length), a3 !== 0) {
          var s2 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s2;
        }
        return this.strip();
      }, f3.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f3.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f3.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f3.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f3.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f3.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(i, a3, h5) {
        var s2 = i.length + h5, u3;
        this._expand(s2);
        var c2, b6 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h5] | 0) + b6;
          var l3 = (i.words[u3] | 0) * a3;
          c2 -= l3 & 67108863, b6 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u3 + h5] = c2 & 67108863;
        }
        for (;u3 < this.length - h5; u3++)
          c2 = (this.words[u3 + h5] | 0) + b6, b6 = c2 >> 26, this.words[u3 + h5] = c2 & 67108863;
        if (b6 === 0)
          return this.strip();
        for (r(b6 === -1), b6 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b6, b6 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f3.prototype._wordDiv = function(i, a3) {
        var h5 = this.length - i.length, s2 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b6 = this._countBits(c2);
        h5 = 26 - b6, h5 !== 0 && (u3 = u3.ushln(h5), s2.iushln(h5), c2 = u3.words[u3.length - 1] | 0);
        var l3 = s2.length - u3.length, n;
        if (a3 !== "mod") {
          n = new f3(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s2.clone()._ishlnsubmul(u3, 1, l3);
        w3.negative === 0 && (s2 = w3, n && (n.words[l3] = 1));
        for (var g5 = l3 - 1;g5 >= 0; g5--) {
          var _4 = (s2.words[u3.length + g5] | 0) * 67108864 + (s2.words[u3.length + g5 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s2._ishlnsubmul(u3, _4, g5);s2.negative !== 0; )
            _4--, s2.negative = 0, s2._ishlnsubmul(u3, 1, g5), s2.isZero() || (s2.negative ^= 1);
          n && (n.words[g5] = _4);
        }
        return n && n.strip(), s2.strip(), a3 !== "div" && h5 !== 0 && s2.iushrn(h5), { div: n || null, mod: s2 };
      }, f3.prototype.divmod = function(i, a3, h5) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var s2, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s2 = c2.div.neg()), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.iadd(i)), { div: s2, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s2 = c2.div.neg()), { div: s2, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f3(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f3(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f3(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f3.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f3.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f3.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f3.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h5 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s2 = i.ushrn(1), u3 = i.andln(1), c2 = h5.cmp(s2);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f3.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h5 = 0, s2 = this.length - 1;s2 >= 0; s2--)
          h5 = (a3 * h5 + (this.words[s2] | 0)) % i;
        return h5;
      }, f3.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s2 = (this.words[h5] | 0) + a3 * 67108864;
          this.words[h5] = s2 / i | 0, a3 = s2 % i;
        }
        return this.strip();
      }, f3.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f3.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f3(1), u3 = new f3(0), c2 = new f3(0), b6 = new f3(1), l3 = 0;a3.isEven() && h5.isEven(); )
          a3.iushrn(1), h5.iushrn(1), ++l3;
        for (var n = h5.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g5 = 1;(a3.words[0] & g5) === 0 && w3 < 26; ++w3, g5 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s2.isOdd() || u3.isOdd()) && (s2.iadd(n), u3.isub(d4)), s2.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A4 = 1;(h5.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h5.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b6.isOdd()) && (c2.iadd(n), b6.isub(d4)), c2.iushrn(1), b6.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s2.isub(c2), u3.isub(b6)) : (h5.isub(a3), c2.isub(s2), b6.isub(u3));
        }
        return { a: c2, b: b6, gcd: h5.iushln(l3) };
      }, f3.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f3(1), u3 = new f3(0), c2 = h5.clone();a3.cmpn(1) > 0 && h5.cmpn(1) > 0; ) {
          for (var b6 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b6 < 26; ++b6, l3 <<= 1)
            ;
          if (b6 > 0)
            for (a3.iushrn(b6);b6-- > 0; )
              s2.isOdd() && s2.iadd(c2), s2.iushrn(1);
          for (var n = 0, d4 = 1;(h5.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h5.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s2.isub(u3)) : (h5.isub(a3), u3.isub(s2));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s2 : w3 = u3, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f3.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h5 = i.clone();
        a3.negative = 0, h5.negative = 0;
        for (var s2 = 0;a3.isEven() && h5.isEven(); s2++)
          a3.iushrn(1), h5.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h5.isEven(); )
            h5.iushrn(1);
          var u3 = a3.cmp(h5);
          if (u3 < 0) {
            var c2 = a3;
            a3 = h5, h5 = c2;
          } else if (u3 === 0 || h5.cmpn(1) === 0)
            break;
          a3.isub(h5);
        } while (true);
        return h5.iushln(s2);
      }, f3.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f3.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h5 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h5)
          return this._expand(h5 + 1), this.words[h5] |= s2, this;
        for (var u3 = s2, c2 = h5;u3 !== 0 && c2 < this.length; c2++) {
          var b6 = this.words[c2] | 0;
          b6 += u3, u3 = b6 >>> 26, b6 &= 67108863, this.words[c2] = b6;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h5;
        if (this.length > 1)
          h5 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s2 = this.words[0] | 0;
          h5 = s2 === i ? 0 : s2 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h5 | 0 : h5;
      }, f3.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f3.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s2 = this.words[h5] | 0, u3 = i.words[h5] | 0;
          if (s2 !== u3) {
            s2 < u3 ? a3 = -1 : s2 > u3 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f3.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f3.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f3.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f3.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f3.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f3.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f3.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f3.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f3.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f3.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f3.red = function(i) {
        return new P4(i);
      }, f3.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f3.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f3.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f3.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f3.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f3.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f3.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f3.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f3.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye2(v4, i) {
        this.name = v4, this.p = new f3(i, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye2.prototype._tmp = function() {
        var i = new f3(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye2.prototype.ireduce = function(i) {
        var a3 = i, h5;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h5 = a3.bitLength();
        while (h5 > this.n);
        var s2 = h5 < this.n ? -1 : a3.ucmp(this.p);
        return s2 === 0 ? (a3.words[0] = 0, a3.length = 1) : s2 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye2.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye2.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe2() {
        ye2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe2, ye2), xe2.prototype.split = function(i, a3) {
        for (var h5 = 4194303, s2 = Math.min(i.length, 9), u3 = 0;u3 < s2; u3++)
          a3.words[u3] = i.words[u3];
        if (a3.length = s2, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h5, u3 = 10;u3 < i.length; u3++) {
          var b6 = i.words[u3] | 0;
          i.words[u3 - 10] = (b6 & h5) << 4 | c2 >>> 22, c2 = b6;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe2.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s2 = i.words[h5] | 0;
          a3 += s2 * 977, i.words[h5] = a3 & 67108863, a3 = s2 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye2);
      function Ee() {
        ye2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye2);
      function Ae2() {
        ye2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye2), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s2 = (i.words[h5] | 0) * 19 + a3, u3 = s2 & 67108863;
          s2 >>>= 26, i.words[h5] = u3, a3 = s2;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f3._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe2;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P4(v4) {
        if (typeof v4 == "string") {
          var i = f3._prime(v4);
          this.m = i.p, this.prime = i;
        } else
          r(v4.gtn(1), "modulus must be greater than 1"), this.m = v4, this.prime = null;
      }
      P4.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P4.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P4.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P4.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P4.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.add(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5._forceRed(this);
      }, P4.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.iadd(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5;
      }, P4.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.sub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5._forceRed(this);
      }, P4.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.isub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5;
      }, P4.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P4.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P4.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P4.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P4.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P4.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h5 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(i, h5);
        }
        for (var s2 = this.m.subn(1), u3 = 0;!s2.isZero() && s2.andln(1) === 0; )
          u3++, s2.iushrn(1);
        r(!s2.isZero());
        var c2 = new f3(1).toRed(this), b6 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f3(2 * n * n).toRed(this);this.pow(n, l3).cmp(b6) !== 0; )
          n.redIAdd(b6);
        for (var d4 = this.pow(n, s2), w3 = this.pow(i, s2.addn(1).iushrn(1)), g5 = this.pow(i, s2), _4 = u3;g5.cmp(c2) !== 0; ) {
          for (var A4 = g5, R4 = 0;A4.cmp(c2) !== 0; R4++)
            A4 = A4.redSqr();
          r(R4 < _4);
          var I5 = this.pow(d4, new f3(1).iushln(_4 - R4 - 1));
          w3 = w3.redMul(I5), d4 = I5.redSqr(), g5 = g5.redMul(d4), _4 = R4;
        }
        return w3;
      }, P4.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P4.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f3(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h5 = 4, s2 = new Array(1 << h5);
        s2[0] = new f3(1).toRed(this), s2[1] = i;
        for (var u3 = 2;u3 < s2.length; u3++)
          s2[u3] = this.mul(s2[u3 - 1], i);
        var c2 = s2[0], b6 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a3.length - 1;u3 >= 0; u3--) {
          for (var d4 = a3.words[u3], w3 = n - 1;w3 >= 0; w3--) {
            var g5 = d4 >> w3 & 1;
            if (c2 !== s2[0] && (c2 = this.sqr(c2)), g5 === 0 && b6 === 0) {
              l3 = 0;
              continue;
            }
            b6 <<= 1, b6 |= g5, l3++, !(l3 !== h5 && (u3 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s2[b6]), l3 = 0, b6 = 0);
          }
          n = 26;
        }
        return c2;
      }, P4.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P4.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f3.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v4) {
        P4.call(this, v4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P4), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h5 = i.imul(a3), s2 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f3(0)._forceRed(this);
        var h5 = i.mul(a3), s2 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T3(() => {
  });
  As = T3(($T, el) => {
    var Ju2;
    el.exports = function(e) {
      return Ju2 || (Ju2 = new Zi(null)), Ju2.generate(e);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e) {
      return this._rand(e);
    };
    Zi.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o2 = 0;o2 < r.length; o2++)
        r[o2] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e) {
          return Qu.randomBytes(e);
        };
      } catch {
      }
    var Qu;
  });
  tl = T3((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn2(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn2;
    Tn2.create = function(e) {
      return new Tn2(e);
    };
    Tn2.prototype._randbelow = function(e) {
      var r = e.bitLength(), o2 = Math.ceil(r / 8);
      do
        var f3 = new In(this.rand.generate(o2));
      while (f3.cmp(e) >= 0);
      return f3;
    };
    Tn2.prototype._randrange = function(e, r) {
      var o2 = r.sub(e);
      return e.add(this._randbelow(o2));
    };
    Tn2.prototype.test = function(e, r, o2) {
      var f3 = e.bitLength(), p3 = In.mont(e), m3 = new In(1).toRed(p3);
      r || (r = Math.max(1, f3 / 48 | 0));
      for (var y5 = e.subn(1), M3 = 0;!y5.testn(M3); M3++)
        ;
      for (var x5 = e.shrn(M3), S3 = y5.toRed(p3), E6 = true;r > 0; r--) {
        var B3 = this._randrange(new In(2), y5);
        o2 && o2(B3);
        var q3 = B3.toRed(p3).redPow(x5);
        if (!(q3.cmp(m3) === 0 || q3.cmp(S3) === 0)) {
          for (var L4 = 1;L4 < M3; L4++) {
            if (q3 = q3.redSqr(), q3.cmp(m3) === 0)
              return false;
            if (q3.cmp(S3) === 0)
              break;
          }
          if (L4 === M3)
            return false;
        }
      }
      return E6;
    };
    Tn2.prototype.getDivisor = function(e, r) {
      var o2 = e.bitLength(), f3 = In.mont(e), p3 = new In(1).toRed(f3);
      r || (r = Math.max(1, o2 / 48 | 0));
      for (var m3 = e.subn(1), y5 = 0;!m3.testn(y5); y5++)
        ;
      for (var M3 = e.shrn(y5), x5 = m3.toRed(f3);r > 0; r--) {
        var S3 = this._randrange(new In(2), m3), E6 = e.gcd(S3);
        if (E6.cmpn(1) !== 0)
          return E6;
        var B3 = S3.toRed(f3).redPow(M3);
        if (!(B3.cmp(p3) === 0 || B3.cmp(x5) === 0)) {
          for (var q3 = 1;q3 < y5; q3++) {
            if (B3 = B3.redSqr(), B3.cmp(p3) === 0)
              return B3.fromRed().subn(1).gcd(e);
            if (B3.cmp(x5) === 0)
              break;
          }
          if (q3 === y5)
            return B3 = B3.redSqr(), B3.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  ol2 = T3((ek, tg) => {
    var eS = on();
    tg.exports = al2;
    al2.simpleSieve = nl;
    al2.fermatTest = fl2;
    var Ht2 = Yu2(), tS = new Ht2(24), rS = tl(), Qm = new rS, iS = new Ht2(1), il = new Ht2(2), nS = new Ht2(5), YT = new Ht2(16), XT = new Ht2(8), fS = new Ht2(10), aS = new Ht2(3), JT = new Ht2(7), oS = new Ht2(11), eg = new Ht2(4), QT = new Ht2(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o2 = 3;o2 < t; o2 += 2) {
        for (var f3 = Math.ceil(Math.sqrt(o2)), p3 = 0;p3 < r && e[p3] <= f3 && o2 % e[p3] !== 0; p3++)
          ;
        r !== p3 && e[p3] <= f3 || (e[r++] = o2);
      }
      return rl = e, e;
    }
    function nl(t) {
      for (var e = sS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function fl2(t) {
      var e = Ht2.mont(t);
      return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al2(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht2([140, 123]) : new Ht2([140, 39]);
      e = new Ht2(e);
      for (var r, o2;; ) {
        for (r = new Ht2(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
          if (!e.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o2 = r.shrn(1), nl(o2) && nl(r) && fl2(o2) && fl2(r) && Qm.test(o2) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T3((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T3((rk, fg) => {
    var yr2 = Yu2(), uS = tl(), ig = new uS, lS = new yr2(24), dS = new yr2(11), cS = new yr2(10), pS = new yr2(3), vS = new yr2(7), ng = ol2(), bS = on();
    fg.exports = Si4;
    function mS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr2(t), this;
    }
    function gS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr2(t), this;
    }
    var Rs = {};
    function yS(t, e) {
      var r = e.toString("hex"), o2 = [r, t.toString(16)].join("_");
      if (o2 in Rs)
        return Rs[o2];
      var f3 = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f3 += 1, r === "02" || r === "05" ? f3 += 8 : f3 += 4, Rs[o2] = f3, f3;
      ig.test(t.shrn(1)) || (f3 += 2);
      var p3;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f3 += 8);
          break;
        case "05":
          p3 = t.mod(cS), p3.cmp(pS) && p3.cmp(vS) && (f3 += 8);
          break;
        default:
          f3 += 4;
      }
      return Rs[o2] = f3, f3;
    }
    function Si4(t, e, r) {
      this.setGenerator(e), this.__prime = new yr2(t), this._prime = yr2.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si4.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si4.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr2(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si4.prototype.computeSecret = function(t) {
      t = new yr2(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o2 = this.getPrime();
      if (r.length < o2.length) {
        var f3 = new Buffer(o2.length - r.length);
        f3.fill(0), r = Buffer.concat([f3, r]);
      }
      return r;
    };
    Si4.prototype.getPublicKey = function(e) {
      return Bs(this._pub, e);
    };
    Si4.prototype.getPrivateKey = function(e) {
      return Bs(this._priv, e);
    };
    Si4.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si4.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si4.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr2(t), this;
    };
    function Bs(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  hg = T3((_f) => {
    var wS = ol2(), og = rg(), sl2 = ag();
    function MS(t) {
      var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl2(e, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e, r, o2) {
      return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o2 = o2 || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o2)), typeof t == "number" ? new sl2(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl2(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl2 = T3((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T3((fk, cg) => {
    function lg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(t);
        e && (o2 = o2.filter(function(f3) {
          return Object.getOwnPropertyDescriptor(t, f3).enumerable;
        })), r.push.apply(r, o2);
      }
      return r;
    }
    function xS(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lg(Object(r), true).forEach(function(o2) {
          SS(t, o2, r[o2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o2) {
          Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(r, o2));
        });
      }
      return t;
    }
    function SS(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function ES(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o2 = e[r];
        o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t, o2.key, o2);
      }
    }
    function AS(t, e, r) {
      return e && dg(t.prototype, e), r && dg(t, r), t;
    }
    var RS = Ut3(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e, r) {
      qs.prototype.copy.call(t, e, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o2 = { data: r, next: null };
        this.length > 0 ? this.tail.next = o2 : this.head = o2, this.tail = o2, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o2 = { data: r, next: this.head };
        this.length === 0 && (this.tail = o2), this.head = o2, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o2 = this.head, f3 = "" + o2.data;o2 = o2.next; )
          f3 += r + o2.data;
        return f3;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o2 = qs.allocUnsafe(r >>> 0), f3 = this.head, p3 = 0;f3; )
          IS(f3.data, o2, p3), p3 += f3.data.length, f3 = f3.next;
        return o2;
      } }, { key: "consume", value: function(r, o2) {
        var f3;
        return r < this.head.data.length ? (f3 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f3 = this.shift() : f3 = o2 ? this._getString(r) : this._getBuffer(r), f3;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o2 = this.head, f3 = 1, p3 = o2.data;
        for (r -= p3.length;o2 = o2.next; ) {
          var m3 = o2.data, y5 = r > m3.length ? m3.length : r;
          if (y5 === m3.length ? p3 += m3 : p3 += m3.slice(0, r), r -= y5, r === 0) {
            y5 === m3.length ? (++f3, o2.next ? this.head = o2.next : this.head = this.tail = null) : (this.head = o2, o2.data = m3.slice(y5));
            break;
          }
          ++f3;
        }
        return this.length -= f3, p3;
      } }, { key: "_getBuffer", value: function(r) {
        var o2 = qs.allocUnsafe(r), f3 = this.head, p3 = 1;
        for (f3.data.copy(o2), r -= f3.data.length;f3 = f3.next; ) {
          var m3 = f3.data, y5 = r > m3.length ? m3.length : r;
          if (m3.copy(o2, o2.length - r, 0, y5), r -= y5, r === 0) {
            y5 === m3.length ? (++p3, f3.next ? this.head = f3.next : this.head = this.tail = null) : (this.head = f3, f3.data = m3.slice(y5));
            break;
          }
          ++p3;
        }
        return this.length -= p3, o2;
      } }, { key: qS, value: function(r, o2) {
        return ul(this, xS({}, o2, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl2 = T3((ak, bg) => {
    function TS(t, e) {
      var r = this, o2 = this._readableState && this._readableState.destroyed, f3 = this._writableState && this._writableState.destroyed;
      return o2 || f3 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p3) {
        !e && p3 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p3)) : process.nextTick(vg, r, p3) : e ? (process.nextTick(Is, r), e(p3)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e) {
      ll(t, e), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e) {
      t.emit("error", e);
    }
    function LS(t, e) {
      var { _readableState: r, _writableState: o2 } = t;
      r && r.autoDestroy || o2 && o2.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T3((ok, yg) => {
    function NS(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gg = {};
    function wr(t, e, r) {
      r || (r = Error);
      function o2(p3, m3, y5) {
        return typeof e == "string" ? e : e(p3, m3, y5);
      }
      var f3 = function(p3) {
        NS(m3, p3);
        function m3(y5, M3, x5) {
          return p3.call(this, o2(y5, M3, x5)) || this;
        }
        return m3;
      }(r);
      f3.prototype.name = r.name, f3.prototype.code = t, gg[t] = f3;
    }
    function mg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o2) {
          return String(o2);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function DS(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function PS(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function CS(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o2;
      typeof e == "string" && DS(e, "not ") ? (o2 = "must not be", e = e.replace(/^not /, "")) : o2 = "must be";
      var f3;
      if (PS(t, " argument"))
        f3 = "The ".concat(t, " ").concat(o2, " ").concat(mg(e, "type"));
      else {
        var p3 = CS(t, ".") ? "property" : "argument";
        f3 = 'The "'.concat(t, '" ').concat(p3, " ").concat(o2, " ").concat(mg(e, "type"));
      }
      return f3 += ". Received type ".concat(typeof r), f3;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl3 = T3((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function US(t, e, r, o2) {
      var f3 = FS(e, o2, r);
      if (f3 != null) {
        if (!(isFinite(f3) && Math.floor(f3) === f3) || f3 < 0) {
          var p3 = o2 ? r : "highWaterMark";
          throw new OS(p3, f3);
        }
        return Math.floor(f3);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T3((hk, Ag) => {
    Ag.exports = ut3;
    function _g(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e, t);
      };
    }
    var xf;
    ut3.WritableState = ka2;
    var zS = { deprecate: G0() }, xg = hl2(), ks = Ut3().Buffer, HS = global.Uint8Array || function() {
    };
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl2(), jS = cl3(), ZS = jS.getHighWaterMark, Vi3 = kn().codes, VS = Vi3.ERR_INVALID_ARG_TYPE, $S = Vi3.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi3.ERR_MULTIPLE_CALLBACK, YS = Vi3.ERR_STREAM_CANNOT_PIPE, XS = Vi3.ERR_STREAM_DESTROYED, JS = Vi3.ERR_STREAM_NULL_VALUES, QS = Vi3.ERR_STREAM_WRITE_AFTER_END, eE = Vi3.ERR_UNKNOWN_ENCODING, Sf2 = vl.errorOrDestroy;
    Ie()(ut3, xg);
    function tE() {
    }
    function ka2(t, e, r) {
      xf = xf || Ln3(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o2 = t.decodeStrings === false;
      this.decodeStrings = !o2, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f3) {
        sE(e, f3);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka2.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka2.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut3, Symbol.hasInstance, { value: function(e) {
      return Ts.call(this, e) ? true : this !== ut3 ? false : e && e._writableState instanceof ka2;
    } })) : Ts = function(e) {
      return e instanceof this;
    };
    function ut3(t) {
      xf = xf || Ln3();
      var e = this instanceof xf;
      if (!e && !Ts.call(ut3, this))
        return new ut3(t);
      this._writableState = new ka2(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut3.prototype.pipe = function() {
      Sf2(this, new YS);
    };
    function rE(t, e) {
      var r = new QS;
      Sf2(t, r), process.nextTick(e, r);
    }
    function iE(t, e, r, o2) {
      var f3;
      return r === null ? f3 = new JS : typeof r != "string" && !e.objectMode && (f3 = new VS("chunk", ["string", "Buffer"], r)), f3 ? (Sf2(t, f3), process.nextTick(o2, f3), false) : true;
    }
    ut3.prototype.write = function(t, e, r) {
      var o2 = this._writableState, f3 = false, p3 = !o2.objectMode && KS(t);
      return p3 && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p3 ? e = "buffer" : e || (e = o2.defaultEncoding), typeof r != "function" && (r = tE), o2.ending ? rE(this, r) : (p3 || iE(this, o2, t, r)) && (o2.pendingcb++, f3 = fE(this, o2, p3, t, e, r)), f3;
    };
    ut3.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut3.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut3.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new eE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut3.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
    }
    Object.defineProperty(ut3.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e, r, o2, f3, p3) {
      if (!r) {
        var m3 = nE(e, o2, f3);
        o2 !== m3 && (r = true, f3 = "buffer", o2 = m3);
      }
      var y5 = e.objectMode ? 1 : o2.length;
      e.length += y5;
      var M3 = e.length < e.highWaterMark;
      if (M3 || (e.needDrain = true), e.writing || e.corked) {
        var x5 = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o2, encoding: f3, isBuf: r, callback: p3, next: null }, x5 ? x5.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        pl2(t, e, false, y5, o2, f3, p3);
      return M3;
    }
    function pl2(t, e, r, o2, f3, p3, m3) {
      e.writelen = o2, e.writecb = m3, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f3, e.onwrite) : t._write(f3, p3, e.onwrite), e.sync = false;
    }
    function aE(t, e, r, o2, f3) {
      --e.pendingcb, r ? (process.nextTick(f3, o2), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf2(t, o2)) : (f3(o2), t._writableState.errorEmitted = true, Sf2(t, o2), Ta(t, e));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e) {
      var r = t._writableState, o2 = r.sync, f3 = r.writecb;
      if (typeof f3 != "function")
        throw new GS;
      if (oE(r), e)
        aE(t, r, o2, e, f3);
      else {
        var p3 = Eg(r) || t.destroyed;
        !p3 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o2 ? process.nextTick(Mg, t, r, p3, f3) : Mg(t, r, p3, f3);
      }
    }
    function Mg(t, e, r, o2) {
      r || hE(t, e), e.pendingcb--, o2(), Ta(t, e);
    }
    function hE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o2 = e.bufferedRequestCount, f3 = new Array(o2), p3 = e.corkedRequestsFree;
        p3.entry = r;
        for (var m3 = 0, y5 = true;r; )
          f3[m3] = r, r.isBuf || (y5 = false), r = r.next, m3 += 1;
        f3.allBuffers = y5, pl2(t, e, true, e.length, f3, "", p3.finish), e.pendingcb++, e.lastBufferedRequest = null, p3.next ? (e.corkedRequestsFree = p3.next, p3.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M3, encoding: x5, callback: S3 } = r, E6 = e.objectMode ? 1 : M3.length;
          if (pl2(t, e, false, E6, M3, x5, S3), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut3.prototype._write = function(t, e, r) {
      r(new $S("_write()"));
    };
    ut3.prototype._writev = null;
    ut3.prototype.end = function(t, e, r) {
      var o2 = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o2.corked && (o2.corked = 1, this.uncork()), o2.ending || dE(this, o2, r), this;
    };
    Object.defineProperty(ut3.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Sf2(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
      });
    }
    function lE(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e) {
      var r = Eg(e);
      if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o2 = t._readableState;
        (!o2 || o2.autoDestroy && o2.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e, r) {
      e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function cE(t, e, r) {
      var o2 = t.entry;
      for (t.entry = null;o2; ) {
        var f3 = o2.callback;
        e.pendingcb--, f3(r), o2 = o2.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut3.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut3.prototype.destroy = vl.destroy;
    ut3.prototype._undestroy = vl.undestroy;
    ut3.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  Ln3 = T3((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    Bg.exports = ti2;
    var Rg = yl2(), gl = bl();
    Ie()(ti2, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti2.prototype[Ns] || (ti2.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti2(t) {
      if (!(this instanceof ti2))
        return new ti2(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Ds = T3((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o2 = new Array(r), f3 = 0;f3 < r; f3++)
            o2[f3] = arguments[f3];
          t.apply(this, o2);
        }
      };
    }
    function gE() {
    }
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e, r) {
      if (typeof e == "function")
        return Ig(t, null, e);
      e || (e = {}), r = mE(r || gE);
      var o2 = e.readable || e.readable !== false && t.readable, f3 = e.writable || e.writable !== false && t.writable, p3 = function() {
        t.writable || y5();
      }, m3 = t._writableState && t._writableState.finished, y5 = function() {
        f3 = false, m3 = true, o2 || r.call(t);
      }, M3 = t._readableState && t._readableState.endEmitted, x5 = function() {
        o2 = false, M3 = true, f3 || r.call(t);
      }, S3 = function(L4) {
        r.call(t, L4);
      }, E6 = function() {
        var L4;
        if (o2 && !M3)
          return (!t._readableState || !t._readableState.ended) && (L4 = new qg), r.call(t, L4);
        if (f3 && !m3)
          return (!t._writableState || !t._writableState.ended) && (L4 = new qg), r.call(t, L4);
      }, B3 = function() {
        t.req.on("finish", y5);
      };
      return yE(t) ? (t.on("complete", y5), t.on("abort", E6), t.req ? B3() : t.on("request", B3)) : f3 && !t._writableState && (t.on("end", p3), t.on("close", p3)), t.on("end", x5), t.on("finish", y5), e.error !== false && t.on("error", S3), t.on("close", E6), function() {
        t.removeListener("complete", y5), t.removeListener("abort", E6), t.removeListener("request", B3), t.req && t.req.removeListener("finish", y5), t.removeListener("end", p3), t.removeListener("close", p3), t.removeListener("finish", y5), t.removeListener("end", x5), t.removeListener("error", S3), t.removeListener("close", E6);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T3((dk, kg) => {
    var Ps;
    function $i(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var wE = Ds(), Gi3 = Symbol("lastResolve"), Nn2 = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn3 = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi2(t, e) {
      return { value: t, done: e };
    }
    function ME(t) {
      var e = t[Gi3];
      if (e !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn3] = null, t[Gi3] = null, t[Nn2] = null, e(Yi2(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e) {
      return function(r, o2) {
        t.then(function() {
          if (e[Cs]) {
            r(Yi2(undefined, true));
            return;
          }
          e[wl](r, o2);
        }, o2);
      };
    }
    var SE = Object.getPrototypeOf(function() {
    }), EE2 = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi2(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m3, y5) {
          process.nextTick(function() {
            e[La] ? y5(e[La]) : m3(Yi2(undefined, true));
          });
        });
      var o2 = this[Dn3], f3;
      if (o2)
        f3 = new Promise(xE(o2, this));
      else {
        var p3 = this[Pn].read();
        if (p3 !== null)
          return Promise.resolve(Yi2(p3, false));
        f3 = new Promise(this[wl]);
      }
      return this[Dn3] = f3, f3;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e = this;
      return new Promise(function(r, o2) {
        e[Pn].destroy(null, function(f3) {
          if (f3) {
            o2(f3);
            return;
          }
          r(Yi2(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e) {
      var r, o2 = Object.create(EE2, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi3, { value: null, writable: true }), $i(r, Nn2, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p3, m3) {
        var y5 = o2[Pn].read();
        y5 ? (o2[Dn3] = null, o2[Gi3] = null, o2[Nn2] = null, p3(Yi2(y5, false))) : (o2[Gi3] = p3, o2[Nn2] = m3);
      }, writable: true }), r));
      return o2[Dn3] = null, wE(e, function(f3) {
        if (f3 && f3.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p3 = o2[Nn2];
          p3 !== null && (o2[Dn3] = null, o2[Gi3] = null, o2[Nn2] = null, p3(f3)), o2[La] = f3;
          return;
        }
        var m3 = o2[Gi3];
        m3 !== null && (o2[Dn3] = null, o2[Gi3] = null, o2[Nn2] = null, m3(Yi2(undefined, true))), o2[Cs] = true;
      }), e.on("readable", _E.bind(null, o2)), o2;
    };
    kg.exports = AE;
  });
  Dg = T3((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl2 = T3((vk, jg) => {
    jg.exports = Oe;
    var Ef2;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e, r) {
      return e.listeners(r).length;
    }, Da = hl2(), Os = Ut3().Buffer, RE = global.Uint8Array || function() {
    };
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
    };
    var IE = pg(), Bl = dl2(), TE = cl3(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af2, _l, xl;
    Ie()(Oe, Da);
    var Na2 = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Fg(t, e, r) {
      Ef2 = Ef2 || Ln3(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef2), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af2 || (Af2 = (Qf(), ur2(Jf)).StringDecoder), this.decoder = new Af2(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef2 = Ef2 || Ln3(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Ef2;
      this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o2;
      return r.objectMode ? o2 = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o2 = true), Ug(this, t, e, false, o2);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e, r, o2, f3) {
      De("readableAddChunk", e);
      var p3 = t._readableState;
      if (e === null)
        p3.reading = false, UE(t, p3);
      else {
        var m3;
        if (f3 || (m3 = OE(p3, e)), m3)
          Na2(t, m3);
        else if (p3.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p3.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o2)
            p3.endEmitted ? Na2(t, new PE) : El(t, p3, e, true);
          else if (p3.ended)
            Na2(t, new NE);
          else {
            if (p3.destroyed)
              return false;
            p3.reading = false, p3.decoder && !r ? (e = p3.decoder.write(e), p3.objectMode || e.length !== 0 ? El(t, p3, e, false) : Rl(t, p3)) : El(t, p3, e, false);
          }
        else
          o2 || (p3.reading = false, Rl(t, p3));
      }
      return !p3.ended && (p3.length < p3.highWaterMark || p3.length === 0);
    }
    function El(t, e, r, o2) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us2(t)), Rl(t, e);
    }
    function OE(t, e) {
      var r;
      return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af2 || (Af2 = (Qf(), ur2(Jf)).StringDecoder);
      var e = new Af2(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o2 = "";r !== null; )
        o2 += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o2 !== "" && this._readableState.buffer.push(o2), this._readableState.length = o2.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us2(this), null;
      if (t = Cg(t, e), t === 0 && e.ended)
        return e.length === 0 && Al(this), null;
      var o2 = e.needReadable;
      De("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, De("length less than watermark", o2)), e.ended || e.reading ? (o2 = false, De("reading or ended", o2)) : o2 && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
      var f3;
      return t > 0 ? f3 = Wg(t, e) : f3 = null, f3 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f3 !== null && this.emit("data", f3), f3;
    };
    function UE(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Us2(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
      }
    }
    function Us2(t) {
      var e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
    }
    function Rl(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
    }
    function zE(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na2(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o2 = this._readableState;
      switch (o2.pipesCount) {
        case 0:
          o2.pipes = t;
          break;
        case 1:
          o2.pipes = [o2.pipes, t];
          break;
        default:
          o2.pipes.push(t);
          break;
      }
      o2.pipesCount += 1, De("pipe count=%d opts=%j", o2.pipesCount, e);
      var f3 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p3 = f3 ? y5 : ge;
      o2.endEmitted ? process.nextTick(p3) : r.once("end", p3), t.on("unpipe", m3);
      function m3(_e3, N6) {
        De("onunpipe"), _e3 === r && N6 && N6.hasUnpiped === false && (N6.hasUnpiped = true, S3());
      }
      function y5() {
        De("onend"), t.end();
      }
      var M3 = HE(r);
      t.on("drain", M3);
      var x5 = false;
      function S3() {
        De("cleanup"), t.removeListener("close", q3), t.removeListener("finish", L4), t.removeListener("drain", M3), t.removeListener("error", B3), t.removeListener("unpipe", m3), r.removeListener("end", y5), r.removeListener("end", ge), r.removeListener("data", E6), x5 = true, o2.awaitDrain && (!t._writableState || t._writableState.needDrain) && M3();
      }
      r.on("data", E6);
      function E6(_e3) {
        De("ondata");
        var N6 = t.write(_e3);
        De("dest.write", N6), N6 === false && ((o2.pipesCount === 1 && o2.pipes === t || o2.pipesCount > 1 && Kg(o2.pipes, t) !== -1) && !x5 && (De("false write response, pause", o2.awaitDrain), o2.awaitDrain++), r.pause());
      }
      function B3(_e3) {
        De("onerror", _e3), ge(), t.removeListener("error", B3), Og(t, "error") === 0 && Na2(t, _e3);
      }
      CE(t, "error", B3);
      function q3() {
        t.removeListener("finish", L4), ge();
      }
      t.once("close", q3);
      function L4() {
        De("onfinish"), t.removeListener("close", q3), ge();
      }
      t.once("finish", L4);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o2.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o2, pipesCount: f3 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p3 = 0;p3 < f3; p3++)
          o2[p3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m3 = Kg(e.pipes, t);
      return m3 === -1 ? this : (e.pipes.splice(m3, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Da.prototype.on.call(this, t, e), o2 = this._readableState;
      return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, De("on readable", o2.length, o2.reading), o2.length ? Us2(this) : o2.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Da.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
    };
    function Hg(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
    }
    function jE(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o2 = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m3 = r.decoder.end();
          m3 && m3.length && e.push(m3);
        }
        e.push(null);
      }), t.on("data", function(m3) {
        if (De("wrapped data"), r.decoder && (m3 = r.decoder.write(m3)), !(r.objectMode && m3 == null) && !(!r.objectMode && (!m3 || !m3.length))) {
          var y5 = e.push(m3);
          y5 || (o2 = true, t.pause());
        }
      });
      for (var f3 in t)
        this[f3] === undefined && typeof t[f3] == "function" && (this[f3] = function(y5) {
          return function() {
            return t[y5].apply(t, arguments);
          };
        }(f3));
      for (var p3 = 0;p3 < Sl.length; p3++)
        t.on(Sl[p3], this.emit.bind(this, Sl[p3]));
      return this._read = function(m3) {
        De("wrapped _read", m3), o2 && (o2 = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Al(t) {
      var e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
    }
    function ZE(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e);
    });
    function Kg(t, e) {
      for (var r = 0, o2 = t.length;r < o2; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Il = T3((bk, Vg) => {
    Vg.exports = Ei2;
    var zs2 = kn().codes, VE = zs2.ERR_METHOD_NOT_IMPLEMENTED, $E = zs2.ERR_MULTIPLE_CALLBACK, GE = zs2.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs2.ERR_TRANSFORM_WITH_LENGTH_0, Hs2 = Ln3();
    Ie()(Ei2, Hs2);
    function XE(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o2 = r.writecb;
      if (o2 === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o2(t);
      var f3 = this._readableState;
      f3.reading = false, (f3.needReadable || f3.length < f3.highWaterMark) && this._read(f3.highWaterMark);
    }
    function Ei2(t) {
      if (!(this instanceof Ei2))
        return new Ei2(t);
      Hs2.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Zg(t, e, r);
      }) : Zg(this, null, null);
    }
    Ei2.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Hs2.prototype.push.call(this, t, e);
    };
    Ei2.prototype._transform = function(t, e, r) {
      r(new VE("_transform()"));
    };
    Ei2.prototype._write = function(t, e, r) {
      var o2 = this._transformState;
      if (o2.writecb = r, o2.writechunk = t, o2.writeencoding = e, !o2.transforming) {
        var f3 = this._readableState;
        (o2.needTransform || f3.needReadable || f3.length < f3.highWaterMark) && this._read(f3.highWaterMark);
      }
    };
    Ei2.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    Ei2.prototype._destroy = function(t, e) {
      Hs2.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Zg(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T3((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  t2 = T3((gk, e2) => {
    var Tl;
    function QE(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e, r, o2) {
      o2 = QE(o2);
      var f3 = false;
      t.on("close", function() {
        f3 = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m3) {
        if (m3)
          return o2(m3);
        f3 = true, o2();
      });
      var p3 = false;
      return function(m3) {
        if (!f3 && !p3) {
          if (p3 = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o2(m3 || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e) {
      return t.pipe(e);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o2 = fA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new eA("streams");
      var f3, p3 = e.map(function(m3, y5) {
        var M3 = y5 < e.length - 1, x5 = y5 > 0;
        return iA(m3, M3, x5, function(S3) {
          f3 || (f3 = S3), S3 && p3.forEach(Jg), !M3 && (p3.forEach(Jg), o2(f3));
        });
      });
      return e.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T3((Mr, r2) => {
    Mr = r2.exports = yl2();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln3();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws2 = T3((n2, kl) => {
    (function(t, e) {
      function r(h5, s2) {
        if (!h5)
          throw new Error(s2 || "Assertion failed");
      }
      function o2(h5, s2) {
        h5.super_ = s2;
        var u3 = function() {
        };
        u3.prototype = s2.prototype, h5.prototype = new u3, h5.prototype.constructor = h5;
      }
      function f3(h5, s2, u3) {
        if (f3.isBN(h5))
          return h5;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h5 !== null && ((s2 === "le" || s2 === "be") && (u3 = s2, s2 = 10), this._init(h5 || 0, s2 || 10, u3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(s2) {
        return s2 instanceof f3 ? true : s2 !== null && typeof s2 == "object" && s2.constructor.wordSize === f3.wordSize && Array.isArray(s2.words);
      }, f3.max = function(s2, u3) {
        return s2.cmp(u3) > 0 ? s2 : u3;
      }, f3.min = function(s2, u3) {
        return s2.cmp(u3) < 0 ? s2 : u3;
      }, f3.prototype._init = function(s2, u3, c2) {
        if (typeof s2 == "number")
          return this._initNumber(s2, u3, c2);
        if (typeof s2 == "object")
          return this._initArray(s2, u3, c2);
        u3 === "hex" && (u3 = 16), r(u3 === (u3 | 0) && u3 >= 2 && u3 <= 36), s2 = s2.toString().replace(/\s+/g, "");
        var b6 = 0;
        s2[0] === "-" && (b6++, this.negative = 1), b6 < s2.length && (u3 === 16 ? this._parseHex(s2, b6, c2) : (this._parseBase(s2, u3, b6), c2 === "le" && this._initArray(this.toArray(), u3, c2)));
      }, f3.prototype._initNumber = function(s2, u3, c2) {
        s2 < 0 && (this.negative = 1, s2 = -s2), s2 < 67108864 ? (this.words = [s2 & 67108863], this.length = 1) : s2 < 4503599627370496 ? (this.words = [s2 & 67108863, s2 / 67108864 & 67108863], this.length = 2) : (r(s2 < 9007199254740992), this.words = [s2 & 67108863, s2 / 67108864 & 67108863, 1], this.length = 3), c2 === "le" && this._initArray(this.toArray(), u3, c2);
      }, f3.prototype._initArray = function(s2, u3, c2) {
        if (r(typeof s2.length == "number"), s2.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s2.length / 3), this.words = new Array(this.length);
        for (var b6 = 0;b6 < this.length; b6++)
          this.words[b6] = 0;
        var l3, n, d4 = 0;
        if (c2 === "be")
          for (b6 = s2.length - 1, l3 = 0;b6 >= 0; b6 -= 3)
            n = s2[b6] | s2[b6 - 1] << 8 | s2[b6 - 2] << 16, this.words[l3] |= n << d4 & 67108863, this.words[l3 + 1] = n >>> 26 - d4 & 67108863, d4 += 24, d4 >= 26 && (d4 -= 26, l3++);
        else if (c2 === "le")
          for (b6 = 0, l3 = 0;b6 < s2.length; b6 += 3)
            n = s2[b6] | s2[b6 + 1] << 8 | s2[b6 + 2] << 16, this.words[l3] |= n << d4 & 67108863, this.words[l3 + 1] = n >>> 26 - d4 & 67108863, d4 += 24, d4 >= 26 && (d4 -= 26, l3++);
        return this._strip();
      };
      function m3(h5, s2) {
        var u3 = h5.charCodeAt(s2);
        if (u3 >= 48 && u3 <= 57)
          return u3 - 48;
        if (u3 >= 65 && u3 <= 70)
          return u3 - 55;
        if (u3 >= 97 && u3 <= 102)
          return u3 - 87;
        r(false, "Invalid character in " + h5);
      }
      function y5(h5, s2, u3) {
        var c2 = m3(h5, u3);
        return u3 - 1 >= s2 && (c2 |= m3(h5, u3 - 1) << 4), c2;
      }
      f3.prototype._parseHex = function(s2, u3, c2) {
        this.length = Math.ceil((s2.length - u3) / 6), this.words = new Array(this.length);
        for (var b6 = 0;b6 < this.length; b6++)
          this.words[b6] = 0;
        var l3 = 0, n = 0, d4;
        if (c2 === "be")
          for (b6 = s2.length - 1;b6 >= u3; b6 -= 2)
            d4 = y5(s2, u3, b6) << l3, this.words[n] |= d4 & 67108863, l3 >= 18 ? (l3 -= 18, n += 1, this.words[n] |= d4 >>> 26) : l3 += 8;
        else {
          var w3 = s2.length - u3;
          for (b6 = w3 % 2 === 0 ? u3 + 1 : u3;b6 < s2.length; b6 += 2)
            d4 = y5(s2, u3, b6) << l3, this.words[n] |= d4 & 67108863, l3 >= 18 ? (l3 -= 18, n += 1, this.words[n] |= d4 >>> 26) : l3 += 8;
        }
        this._strip();
      };
      function M3(h5, s2, u3, c2) {
        for (var b6 = 0, l3 = 0, n = Math.min(h5.length, u3), d4 = s2;d4 < n; d4++) {
          var w3 = h5.charCodeAt(d4) - 48;
          b6 *= c2, w3 >= 49 ? l3 = w3 - 49 + 10 : w3 >= 17 ? l3 = w3 - 17 + 10 : l3 = w3, r(w3 >= 0 && l3 < c2, "Invalid character"), b6 += l3;
        }
        return b6;
      }
      f3.prototype._parseBase = function(s2, u3, c2) {
        this.words = [0], this.length = 1;
        for (var b6 = 0, l3 = 1;l3 <= 67108863; l3 *= u3)
          b6++;
        b6--, l3 = l3 / u3 | 0;
        for (var n = s2.length - c2, d4 = n % b6, w3 = Math.min(n, n - d4) + c2, g5 = 0, _4 = c2;_4 < w3; _4 += b6)
          g5 = M3(s2, _4, _4 + b6, u3), this.imuln(l3), this.words[0] + g5 < 67108864 ? this.words[0] += g5 : this._iaddn(g5);
        if (d4 !== 0) {
          var A4 = 1;
          for (g5 = M3(s2, _4, s2.length, u3), _4 = 0;_4 < d4; _4++)
            A4 *= u3;
          this.imuln(A4), this.words[0] + g5 < 67108864 ? this.words[0] += g5 : this._iaddn(g5);
        }
        this._strip();
      }, f3.prototype.copy = function(s2) {
        s2.words = new Array(this.length);
        for (var u3 = 0;u3 < this.length; u3++)
          s2.words[u3] = this.words[u3];
        s2.length = this.length, s2.negative = this.negative, s2.red = this.red;
      };
      function x5(h5, s2) {
        h5.words = s2.words, h5.length = s2.length, h5.negative = s2.negative, h5.red = s2.red;
      }
      if (f3.prototype._move = function(s2) {
        x5(s2, this);
      }, f3.prototype.clone = function() {
        var s2 = new f3(null);
        return this.copy(s2), s2;
      }, f3.prototype._expand = function(s2) {
        for (;this.length < s2; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f3.prototype[Symbol.for("nodejs.util.inspect.custom")] = S3;
        } catch {
          f3.prototype.inspect = S3;
        }
      else
        f3.prototype.inspect = S3;
      function S3() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E6 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(s2, u3) {
        s2 = s2 || 10, u3 = u3 | 0 || 1;
        var c2;
        if (s2 === 16 || s2 === "hex") {
          c2 = "";
          for (var b6 = 0, l3 = 0, n = 0;n < this.length; n++) {
            var d4 = this.words[n], w3 = ((d4 << b6 | l3) & 16777215).toString(16);
            l3 = d4 >>> 24 - b6 & 16777215, b6 += 2, b6 >= 26 && (b6 -= 26, n--), l3 !== 0 || n !== this.length - 1 ? c2 = E6[6 - w3.length] + w3 + c2 : c2 = w3 + c2;
          }
          for (l3 !== 0 && (c2 = l3.toString(16) + c2);c2.length % u3 !== 0; )
            c2 = "0" + c2;
          return this.negative !== 0 && (c2 = "-" + c2), c2;
        }
        if (s2 === (s2 | 0) && s2 >= 2 && s2 <= 36) {
          var g5 = B3[s2], _4 = q3[s2];
          c2 = "";
          var A4 = this.clone();
          for (A4.negative = 0;!A4.isZero(); ) {
            var R4 = A4.modrn(_4).toString(s2);
            A4 = A4.idivn(_4), A4.isZero() ? c2 = R4 + c2 : c2 = E6[g5 - R4.length] + R4 + c2;
          }
          for (this.isZero() && (c2 = "0" + c2);c2.length % u3 !== 0; )
            c2 = "0" + c2;
          return this.negative !== 0 && (c2 = "-" + c2), c2;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var s2 = this.words[0];
        return this.length === 2 ? s2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s2 : s2;
      }, f3.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p3 && (f3.prototype.toBuffer = function(s2, u3) {
        return this.toArrayLike(p3, s2, u3);
      }), f3.prototype.toArray = function(s2, u3) {
        return this.toArrayLike(Array, s2, u3);
      };
      var L4 = function(s2, u3) {
        return s2.allocUnsafe ? s2.allocUnsafe(u3) : new s2(u3);
      };
      f3.prototype.toArrayLike = function(s2, u3, c2) {
        this._strip();
        var b6 = this.byteLength(), l3 = c2 || Math.max(1, b6);
        r(b6 <= l3, "byte array longer than desired length"), r(l3 > 0, "Requested array length <= 0");
        var n = L4(s2, l3), d4 = u3 === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d4](n, b6), n;
      }, f3.prototype._toArrayLikeLE = function(s2, u3) {
        for (var c2 = 0, b6 = 0, l3 = 0, n = 0;l3 < this.length; l3++) {
          var d4 = this.words[l3] << n | b6;
          s2[c2++] = d4 & 255, c2 < s2.length && (s2[c2++] = d4 >> 8 & 255), c2 < s2.length && (s2[c2++] = d4 >> 16 & 255), n === 6 ? (c2 < s2.length && (s2[c2++] = d4 >> 24 & 255), b6 = 0, n = 0) : (b6 = d4 >>> 24, n += 2);
        }
        if (c2 < s2.length)
          for (s2[c2++] = b6;c2 < s2.length; )
            s2[c2++] = 0;
      }, f3.prototype._toArrayLikeBE = function(s2, u3) {
        for (var c2 = s2.length - 1, b6 = 0, l3 = 0, n = 0;l3 < this.length; l3++) {
          var d4 = this.words[l3] << n | b6;
          s2[c2--] = d4 & 255, c2 >= 0 && (s2[c2--] = d4 >> 8 & 255), c2 >= 0 && (s2[c2--] = d4 >> 16 & 255), n === 6 ? (c2 >= 0 && (s2[c2--] = d4 >> 24 & 255), b6 = 0, n = 0) : (b6 = d4 >>> 24, n += 2);
        }
        if (c2 >= 0)
          for (s2[c2--] = b6;c2 >= 0; )
            s2[c2--] = 0;
      }, Math.clz32 ? f3.prototype._countBits = function(s2) {
        return 32 - Math.clz32(s2);
      } : f3.prototype._countBits = function(s2) {
        var u3 = s2, c2 = 0;
        return u3 >= 4096 && (c2 += 13, u3 >>>= 13), u3 >= 64 && (c2 += 7, u3 >>>= 7), u3 >= 8 && (c2 += 4, u3 >>>= 4), u3 >= 2 && (c2 += 2, u3 >>>= 2), c2 + u3;
      }, f3.prototype._zeroBits = function(s2) {
        if (s2 === 0)
          return 26;
        var u3 = s2, c2 = 0;
        return (u3 & 8191) === 0 && (c2 += 13, u3 >>>= 13), (u3 & 127) === 0 && (c2 += 7, u3 >>>= 7), (u3 & 15) === 0 && (c2 += 4, u3 >>>= 4), (u3 & 3) === 0 && (c2 += 2, u3 >>>= 2), (u3 & 1) === 0 && c2++, c2;
      }, f3.prototype.bitLength = function() {
        var s2 = this.words[this.length - 1], u3 = this._countBits(s2);
        return (this.length - 1) * 26 + u3;
      };
      function ge(h5) {
        for (var s2 = new Array(h5.bitLength()), u3 = 0;u3 < s2.length; u3++) {
          var c2 = u3 / 26 | 0, b6 = u3 % 26;
          s2[u3] = h5.words[c2] >>> b6 & 1;
        }
        return s2;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s2 = 0, u3 = 0;u3 < this.length; u3++) {
          var c2 = this._zeroBits(this.words[u3]);
          if (s2 += c2, c2 !== 26)
            break;
        }
        return s2;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(s2) {
        return this.negative !== 0 ? this.abs().inotn(s2).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(s2) {
        return this.testn(s2 - 1) ? this.notn(s2).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(s2) {
        for (;this.length < s2.length; )
          this.words[this.length++] = 0;
        for (var u3 = 0;u3 < s2.length; u3++)
          this.words[u3] = this.words[u3] | s2.words[u3];
        return this._strip();
      }, f3.prototype.ior = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuor(s2);
      }, f3.prototype.or = function(s2) {
        return this.length > s2.length ? this.clone().ior(s2) : s2.clone().ior(this);
      }, f3.prototype.uor = function(s2) {
        return this.length > s2.length ? this.clone().iuor(s2) : s2.clone().iuor(this);
      }, f3.prototype.iuand = function(s2) {
        var u3;
        this.length > s2.length ? u3 = s2 : u3 = this;
        for (var c2 = 0;c2 < u3.length; c2++)
          this.words[c2] = this.words[c2] & s2.words[c2];
        return this.length = u3.length, this._strip();
      }, f3.prototype.iand = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuand(s2);
      }, f3.prototype.and = function(s2) {
        return this.length > s2.length ? this.clone().iand(s2) : s2.clone().iand(this);
      }, f3.prototype.uand = function(s2) {
        return this.length > s2.length ? this.clone().iuand(s2) : s2.clone().iuand(this);
      }, f3.prototype.iuxor = function(s2) {
        var u3, c2;
        this.length > s2.length ? (u3 = this, c2 = s2) : (u3 = s2, c2 = this);
        for (var b6 = 0;b6 < c2.length; b6++)
          this.words[b6] = u3.words[b6] ^ c2.words[b6];
        if (this !== u3)
          for (;b6 < u3.length; b6++)
            this.words[b6] = u3.words[b6];
        return this.length = u3.length, this._strip();
      }, f3.prototype.ixor = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuxor(s2);
      }, f3.prototype.xor = function(s2) {
        return this.length > s2.length ? this.clone().ixor(s2) : s2.clone().ixor(this);
      }, f3.prototype.uxor = function(s2) {
        return this.length > s2.length ? this.clone().iuxor(s2) : s2.clone().iuxor(this);
      }, f3.prototype.inotn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = Math.ceil(s2 / 26) | 0, c2 = s2 % 26;
        this._expand(u3), c2 > 0 && u3--;
        for (var b6 = 0;b6 < u3; b6++)
          this.words[b6] = ~this.words[b6] & 67108863;
        return c2 > 0 && (this.words[b6] = ~this.words[b6] & 67108863 >> 26 - c2), this._strip();
      }, f3.prototype.notn = function(s2) {
        return this.clone().inotn(s2);
      }, f3.prototype.setn = function(s2, u3) {
        r(typeof s2 == "number" && s2 >= 0);
        var c2 = s2 / 26 | 0, b6 = s2 % 26;
        return this._expand(c2 + 1), u3 ? this.words[c2] = this.words[c2] | 1 << b6 : this.words[c2] = this.words[c2] & ~(1 << b6), this._strip();
      }, f3.prototype.iadd = function(s2) {
        var u3;
        if (this.negative !== 0 && s2.negative === 0)
          return this.negative = 0, u3 = this.isub(s2), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s2.negative !== 0)
          return s2.negative = 0, u3 = this.isub(s2), s2.negative = 1, u3._normSign();
        var c2, b6;
        this.length > s2.length ? (c2 = this, b6 = s2) : (c2 = s2, b6 = this);
        for (var l3 = 0, n = 0;n < b6.length; n++)
          u3 = (c2.words[n] | 0) + (b6.words[n] | 0) + l3, this.words[n] = u3 & 67108863, l3 = u3 >>> 26;
        for (;l3 !== 0 && n < c2.length; n++)
          u3 = (c2.words[n] | 0) + l3, this.words[n] = u3 & 67108863, l3 = u3 >>> 26;
        if (this.length = c2.length, l3 !== 0)
          this.words[this.length] = l3, this.length++;
        else if (c2 !== this)
          for (;n < c2.length; n++)
            this.words[n] = c2.words[n];
        return this;
      }, f3.prototype.add = function(s2) {
        var u3;
        return s2.negative !== 0 && this.negative === 0 ? (s2.negative = 0, u3 = this.sub(s2), s2.negative ^= 1, u3) : s2.negative === 0 && this.negative !== 0 ? (this.negative = 0, u3 = s2.sub(this), this.negative = 1, u3) : this.length > s2.length ? this.clone().iadd(s2) : s2.clone().iadd(this);
      }, f3.prototype.isub = function(s2) {
        if (s2.negative !== 0) {
          s2.negative = 0;
          var u3 = this.iadd(s2);
          return s2.negative = 1, u3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s2), this.negative = 1, this._normSign();
        var c2 = this.cmp(s2);
        if (c2 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b6, l3;
        c2 > 0 ? (b6 = this, l3 = s2) : (b6 = s2, l3 = this);
        for (var n = 0, d4 = 0;d4 < l3.length; d4++)
          u3 = (b6.words[d4] | 0) - (l3.words[d4] | 0) + n, n = u3 >> 26, this.words[d4] = u3 & 67108863;
        for (;n !== 0 && d4 < b6.length; d4++)
          u3 = (b6.words[d4] | 0) + n, n = u3 >> 26, this.words[d4] = u3 & 67108863;
        if (n === 0 && d4 < b6.length && b6 !== this)
          for (;d4 < b6.length; d4++)
            this.words[d4] = b6.words[d4];
        return this.length = Math.max(this.length, d4), b6 !== this && (this.negative = 1), this._strip();
      }, f3.prototype.sub = function(s2) {
        return this.clone().isub(s2);
      };
      function _e3(h5, s2, u3) {
        u3.negative = s2.negative ^ h5.negative;
        var c2 = h5.length + s2.length | 0;
        u3.length = c2, c2 = c2 - 1 | 0;
        var b6 = h5.words[0] | 0, l3 = s2.words[0] | 0, n = b6 * l3, d4 = n & 67108863, w3 = n / 67108864 | 0;
        u3.words[0] = d4;
        for (var g5 = 1;g5 < c2; g5++) {
          for (var _4 = w3 >>> 26, A4 = w3 & 67108863, R4 = Math.min(g5, s2.length - 1), I5 = Math.max(0, g5 - h5.length + 1);I5 <= R4; I5++) {
            var Me = g5 - I5 | 0;
            b6 = h5.words[Me] | 0, l3 = s2.words[I5] | 0, n = b6 * l3 + A4, _4 += n / 67108864 | 0, A4 = n & 67108863;
          }
          u3.words[g5] = A4 | 0, w3 = _4 | 0;
        }
        return w3 !== 0 ? u3.words[g5] = w3 | 0 : u3.length--, u3._strip();
      }
      var N6 = function(s2, u3, c2) {
        var b6 = s2.words, l3 = u3.words, n = c2.words, d4 = 0, w3, g5, _4, A4 = b6[0] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = b6[1] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = b6[2] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = b6[3] | 0, F2 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = b6[4] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = b6[5] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = b6[6] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = b6[7] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = b6[8] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = b6[9] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = l3[0] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = l3[1] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = l3[2] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = l3[3] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = l3[4] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = l3[5] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = l3[6] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = l3[7] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = l3[8] | 0, ve = It & 8191, be2 = It >>> 13, ft2 = l3[9] | 0, Be = ft2 & 8191, qe2 = ft2 >>> 13;
        c2.negative = s2.negative ^ u3.negative, c2.length = 19, w3 = Math.imul(R4, Q5), g5 = Math.imul(R4, ee), g5 = g5 + Math.imul(I5, Q5) | 0, _4 = Math.imul(I5, ee);
        var ze = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w3 = Math.imul(k4, Q5), g5 = Math.imul(k4, ee), g5 = g5 + Math.imul(D3, Q5) | 0, _4 = Math.imul(D3, ee), w3 = w3 + Math.imul(R4, te2) | 0, g5 = g5 + Math.imul(R4, re2) | 0, g5 = g5 + Math.imul(I5, te2) | 0, _4 = _4 + Math.imul(I5, re2) | 0;
        var He3 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, w3 = Math.imul(C4, Q5), g5 = Math.imul(C4, ee), g5 = g5 + Math.imul(O4, Q5) | 0, _4 = Math.imul(O4, ee), w3 = w3 + Math.imul(k4, te2) | 0, g5 = g5 + Math.imul(k4, re2) | 0, g5 = g5 + Math.imul(D3, te2) | 0, _4 = _4 + Math.imul(D3, re2) | 0, w3 = w3 + Math.imul(R4, ie) | 0, g5 = g5 + Math.imul(R4, ne2) | 0, g5 = g5 + Math.imul(I5, ie) | 0, _4 = _4 + Math.imul(I5, ne2) | 0;
        var We2 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, w3 = Math.imul(F2, Q5), g5 = Math.imul(F2, ee), g5 = g5 + Math.imul(U3, Q5) | 0, _4 = Math.imul(U3, ee), w3 = w3 + Math.imul(C4, te2) | 0, g5 = g5 + Math.imul(C4, re2) | 0, g5 = g5 + Math.imul(O4, te2) | 0, _4 = _4 + Math.imul(O4, re2) | 0, w3 = w3 + Math.imul(k4, ie) | 0, g5 = g5 + Math.imul(k4, ne2) | 0, g5 = g5 + Math.imul(D3, ie) | 0, _4 = _4 + Math.imul(D3, ne2) | 0, w3 = w3 + Math.imul(R4, fe3) | 0, g5 = g5 + Math.imul(R4, ae2) | 0, g5 = g5 + Math.imul(I5, fe3) | 0, _4 = _4 + Math.imul(I5, ae2) | 0;
        var Ke2 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, w3 = Math.imul(z, Q5), g5 = Math.imul(z, ee), g5 = g5 + Math.imul(H3, Q5) | 0, _4 = Math.imul(H3, ee), w3 = w3 + Math.imul(F2, te2) | 0, g5 = g5 + Math.imul(F2, re2) | 0, g5 = g5 + Math.imul(U3, te2) | 0, _4 = _4 + Math.imul(U3, re2) | 0, w3 = w3 + Math.imul(C4, ie) | 0, g5 = g5 + Math.imul(C4, ne2) | 0, g5 = g5 + Math.imul(O4, ie) | 0, _4 = _4 + Math.imul(O4, ne2) | 0, w3 = w3 + Math.imul(k4, fe3) | 0, g5 = g5 + Math.imul(k4, ae2) | 0, g5 = g5 + Math.imul(D3, fe3) | 0, _4 = _4 + Math.imul(D3, ae2) | 0, w3 = w3 + Math.imul(R4, oe3) | 0, g5 = g5 + Math.imul(R4, se3) | 0, g5 = g5 + Math.imul(I5, oe3) | 0, _4 = _4 + Math.imul(I5, se3) | 0;
        var je = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w3 = Math.imul(W, Q5), g5 = Math.imul(W, ee), g5 = g5 + Math.imul(K5, Q5) | 0, _4 = Math.imul(K5, ee), w3 = w3 + Math.imul(z, te2) | 0, g5 = g5 + Math.imul(z, re2) | 0, g5 = g5 + Math.imul(H3, te2) | 0, _4 = _4 + Math.imul(H3, re2) | 0, w3 = w3 + Math.imul(F2, ie) | 0, g5 = g5 + Math.imul(F2, ne2) | 0, g5 = g5 + Math.imul(U3, ie) | 0, _4 = _4 + Math.imul(U3, ne2) | 0, w3 = w3 + Math.imul(C4, fe3) | 0, g5 = g5 + Math.imul(C4, ae2) | 0, g5 = g5 + Math.imul(O4, fe3) | 0, _4 = _4 + Math.imul(O4, ae2) | 0, w3 = w3 + Math.imul(k4, oe3) | 0, g5 = g5 + Math.imul(k4, se3) | 0, g5 = g5 + Math.imul(D3, oe3) | 0, _4 = _4 + Math.imul(D3, se3) | 0, w3 = w3 + Math.imul(R4, he) | 0, g5 = g5 + Math.imul(R4, ue4) | 0, g5 = g5 + Math.imul(I5, he) | 0, _4 = _4 + Math.imul(I5, ue4) | 0;
        var Ze2 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, w3 = Math.imul(j5, Q5), g5 = Math.imul(j5, ee), g5 = g5 + Math.imul(Z3, Q5) | 0, _4 = Math.imul(Z3, ee), w3 = w3 + Math.imul(W, te2) | 0, g5 = g5 + Math.imul(W, re2) | 0, g5 = g5 + Math.imul(K5, te2) | 0, _4 = _4 + Math.imul(K5, re2) | 0, w3 = w3 + Math.imul(z, ie) | 0, g5 = g5 + Math.imul(z, ne2) | 0, g5 = g5 + Math.imul(H3, ie) | 0, _4 = _4 + Math.imul(H3, ne2) | 0, w3 = w3 + Math.imul(F2, fe3) | 0, g5 = g5 + Math.imul(F2, ae2) | 0, g5 = g5 + Math.imul(U3, fe3) | 0, _4 = _4 + Math.imul(U3, ae2) | 0, w3 = w3 + Math.imul(C4, oe3) | 0, g5 = g5 + Math.imul(C4, se3) | 0, g5 = g5 + Math.imul(O4, oe3) | 0, _4 = _4 + Math.imul(O4, se3) | 0, w3 = w3 + Math.imul(k4, he) | 0, g5 = g5 + Math.imul(k4, ue4) | 0, g5 = g5 + Math.imul(D3, he) | 0, _4 = _4 + Math.imul(D3, ue4) | 0, w3 = w3 + Math.imul(R4, le) | 0, g5 = g5 + Math.imul(R4, de) | 0, g5 = g5 + Math.imul(I5, le) | 0, _4 = _4 + Math.imul(I5, de) | 0;
        var Ve = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w3 = Math.imul(V6, Q5), g5 = Math.imul(V6, ee), g5 = g5 + Math.imul($3, Q5) | 0, _4 = Math.imul($3, ee), w3 = w3 + Math.imul(j5, te2) | 0, g5 = g5 + Math.imul(j5, re2) | 0, g5 = g5 + Math.imul(Z3, te2) | 0, _4 = _4 + Math.imul(Z3, re2) | 0, w3 = w3 + Math.imul(W, ie) | 0, g5 = g5 + Math.imul(W, ne2) | 0, g5 = g5 + Math.imul(K5, ie) | 0, _4 = _4 + Math.imul(K5, ne2) | 0, w3 = w3 + Math.imul(z, fe3) | 0, g5 = g5 + Math.imul(z, ae2) | 0, g5 = g5 + Math.imul(H3, fe3) | 0, _4 = _4 + Math.imul(H3, ae2) | 0, w3 = w3 + Math.imul(F2, oe3) | 0, g5 = g5 + Math.imul(F2, se3) | 0, g5 = g5 + Math.imul(U3, oe3) | 0, _4 = _4 + Math.imul(U3, se3) | 0, w3 = w3 + Math.imul(C4, he) | 0, g5 = g5 + Math.imul(C4, ue4) | 0, g5 = g5 + Math.imul(O4, he) | 0, _4 = _4 + Math.imul(O4, ue4) | 0, w3 = w3 + Math.imul(k4, le) | 0, g5 = g5 + Math.imul(k4, de) | 0, g5 = g5 + Math.imul(D3, le) | 0, _4 = _4 + Math.imul(D3, de) | 0, w3 = w3 + Math.imul(R4, ce3) | 0, g5 = g5 + Math.imul(R4, pe2) | 0, g5 = g5 + Math.imul(I5, ce3) | 0, _4 = _4 + Math.imul(I5, pe2) | 0;
        var $e2 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, w3 = Math.imul(G2, Q5), g5 = Math.imul(G2, ee), g5 = g5 + Math.imul(Y3, Q5) | 0, _4 = Math.imul(Y3, ee), w3 = w3 + Math.imul(V6, te2) | 0, g5 = g5 + Math.imul(V6, re2) | 0, g5 = g5 + Math.imul($3, te2) | 0, _4 = _4 + Math.imul($3, re2) | 0, w3 = w3 + Math.imul(j5, ie) | 0, g5 = g5 + Math.imul(j5, ne2) | 0, g5 = g5 + Math.imul(Z3, ie) | 0, _4 = _4 + Math.imul(Z3, ne2) | 0, w3 = w3 + Math.imul(W, fe3) | 0, g5 = g5 + Math.imul(W, ae2) | 0, g5 = g5 + Math.imul(K5, fe3) | 0, _4 = _4 + Math.imul(K5, ae2) | 0, w3 = w3 + Math.imul(z, oe3) | 0, g5 = g5 + Math.imul(z, se3) | 0, g5 = g5 + Math.imul(H3, oe3) | 0, _4 = _4 + Math.imul(H3, se3) | 0, w3 = w3 + Math.imul(F2, he) | 0, g5 = g5 + Math.imul(F2, ue4) | 0, g5 = g5 + Math.imul(U3, he) | 0, _4 = _4 + Math.imul(U3, ue4) | 0, w3 = w3 + Math.imul(C4, le) | 0, g5 = g5 + Math.imul(C4, de) | 0, g5 = g5 + Math.imul(O4, le) | 0, _4 = _4 + Math.imul(O4, de) | 0, w3 = w3 + Math.imul(k4, ce3) | 0, g5 = g5 + Math.imul(k4, pe2) | 0, g5 = g5 + Math.imul(D3, ce3) | 0, _4 = _4 + Math.imul(D3, pe2) | 0, w3 = w3 + Math.imul(R4, ve) | 0, g5 = g5 + Math.imul(R4, be2) | 0, g5 = g5 + Math.imul(I5, ve) | 0, _4 = _4 + Math.imul(I5, be2) | 0;
        var Ge = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w3 = Math.imul(X4, Q5), g5 = Math.imul(X4, ee), g5 = g5 + Math.imul(J3, Q5) | 0, _4 = Math.imul(J3, ee), w3 = w3 + Math.imul(G2, te2) | 0, g5 = g5 + Math.imul(G2, re2) | 0, g5 = g5 + Math.imul(Y3, te2) | 0, _4 = _4 + Math.imul(Y3, re2) | 0, w3 = w3 + Math.imul(V6, ie) | 0, g5 = g5 + Math.imul(V6, ne2) | 0, g5 = g5 + Math.imul($3, ie) | 0, _4 = _4 + Math.imul($3, ne2) | 0, w3 = w3 + Math.imul(j5, fe3) | 0, g5 = g5 + Math.imul(j5, ae2) | 0, g5 = g5 + Math.imul(Z3, fe3) | 0, _4 = _4 + Math.imul(Z3, ae2) | 0, w3 = w3 + Math.imul(W, oe3) | 0, g5 = g5 + Math.imul(W, se3) | 0, g5 = g5 + Math.imul(K5, oe3) | 0, _4 = _4 + Math.imul(K5, se3) | 0, w3 = w3 + Math.imul(z, he) | 0, g5 = g5 + Math.imul(z, ue4) | 0, g5 = g5 + Math.imul(H3, he) | 0, _4 = _4 + Math.imul(H3, ue4) | 0, w3 = w3 + Math.imul(F2, le) | 0, g5 = g5 + Math.imul(F2, de) | 0, g5 = g5 + Math.imul(U3, le) | 0, _4 = _4 + Math.imul(U3, de) | 0, w3 = w3 + Math.imul(C4, ce3) | 0, g5 = g5 + Math.imul(C4, pe2) | 0, g5 = g5 + Math.imul(O4, ce3) | 0, _4 = _4 + Math.imul(O4, pe2) | 0, w3 = w3 + Math.imul(k4, ve) | 0, g5 = g5 + Math.imul(k4, be2) | 0, g5 = g5 + Math.imul(D3, ve) | 0, _4 = _4 + Math.imul(D3, be2) | 0, w3 = w3 + Math.imul(R4, Be) | 0, g5 = g5 + Math.imul(R4, qe2) | 0, g5 = g5 + Math.imul(I5, Be) | 0, _4 = _4 + Math.imul(I5, qe2) | 0;
        var Ye = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w3 = Math.imul(X4, te2), g5 = Math.imul(X4, re2), g5 = g5 + Math.imul(J3, te2) | 0, _4 = Math.imul(J3, re2), w3 = w3 + Math.imul(G2, ie) | 0, g5 = g5 + Math.imul(G2, ne2) | 0, g5 = g5 + Math.imul(Y3, ie) | 0, _4 = _4 + Math.imul(Y3, ne2) | 0, w3 = w3 + Math.imul(V6, fe3) | 0, g5 = g5 + Math.imul(V6, ae2) | 0, g5 = g5 + Math.imul($3, fe3) | 0, _4 = _4 + Math.imul($3, ae2) | 0, w3 = w3 + Math.imul(j5, oe3) | 0, g5 = g5 + Math.imul(j5, se3) | 0, g5 = g5 + Math.imul(Z3, oe3) | 0, _4 = _4 + Math.imul(Z3, se3) | 0, w3 = w3 + Math.imul(W, he) | 0, g5 = g5 + Math.imul(W, ue4) | 0, g5 = g5 + Math.imul(K5, he) | 0, _4 = _4 + Math.imul(K5, ue4) | 0, w3 = w3 + Math.imul(z, le) | 0, g5 = g5 + Math.imul(z, de) | 0, g5 = g5 + Math.imul(H3, le) | 0, _4 = _4 + Math.imul(H3, de) | 0, w3 = w3 + Math.imul(F2, ce3) | 0, g5 = g5 + Math.imul(F2, pe2) | 0, g5 = g5 + Math.imul(U3, ce3) | 0, _4 = _4 + Math.imul(U3, pe2) | 0, w3 = w3 + Math.imul(C4, ve) | 0, g5 = g5 + Math.imul(C4, be2) | 0, g5 = g5 + Math.imul(O4, ve) | 0, _4 = _4 + Math.imul(O4, be2) | 0, w3 = w3 + Math.imul(k4, Be) | 0, g5 = g5 + Math.imul(k4, qe2) | 0, g5 = g5 + Math.imul(D3, Be) | 0, _4 = _4 + Math.imul(D3, qe2) | 0;
        var Xe = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w3 = Math.imul(X4, ie), g5 = Math.imul(X4, ne2), g5 = g5 + Math.imul(J3, ie) | 0, _4 = Math.imul(J3, ne2), w3 = w3 + Math.imul(G2, fe3) | 0, g5 = g5 + Math.imul(G2, ae2) | 0, g5 = g5 + Math.imul(Y3, fe3) | 0, _4 = _4 + Math.imul(Y3, ae2) | 0, w3 = w3 + Math.imul(V6, oe3) | 0, g5 = g5 + Math.imul(V6, se3) | 0, g5 = g5 + Math.imul($3, oe3) | 0, _4 = _4 + Math.imul($3, se3) | 0, w3 = w3 + Math.imul(j5, he) | 0, g5 = g5 + Math.imul(j5, ue4) | 0, g5 = g5 + Math.imul(Z3, he) | 0, _4 = _4 + Math.imul(Z3, ue4) | 0, w3 = w3 + Math.imul(W, le) | 0, g5 = g5 + Math.imul(W, de) | 0, g5 = g5 + Math.imul(K5, le) | 0, _4 = _4 + Math.imul(K5, de) | 0, w3 = w3 + Math.imul(z, ce3) | 0, g5 = g5 + Math.imul(z, pe2) | 0, g5 = g5 + Math.imul(H3, ce3) | 0, _4 = _4 + Math.imul(H3, pe2) | 0, w3 = w3 + Math.imul(F2, ve) | 0, g5 = g5 + Math.imul(F2, be2) | 0, g5 = g5 + Math.imul(U3, ve) | 0, _4 = _4 + Math.imul(U3, be2) | 0, w3 = w3 + Math.imul(C4, Be) | 0, g5 = g5 + Math.imul(C4, qe2) | 0, g5 = g5 + Math.imul(O4, Be) | 0, _4 = _4 + Math.imul(O4, qe2) | 0;
        var Je = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w3 = Math.imul(X4, fe3), g5 = Math.imul(X4, ae2), g5 = g5 + Math.imul(J3, fe3) | 0, _4 = Math.imul(J3, ae2), w3 = w3 + Math.imul(G2, oe3) | 0, g5 = g5 + Math.imul(G2, se3) | 0, g5 = g5 + Math.imul(Y3, oe3) | 0, _4 = _4 + Math.imul(Y3, se3) | 0, w3 = w3 + Math.imul(V6, he) | 0, g5 = g5 + Math.imul(V6, ue4) | 0, g5 = g5 + Math.imul($3, he) | 0, _4 = _4 + Math.imul($3, ue4) | 0, w3 = w3 + Math.imul(j5, le) | 0, g5 = g5 + Math.imul(j5, de) | 0, g5 = g5 + Math.imul(Z3, le) | 0, _4 = _4 + Math.imul(Z3, de) | 0, w3 = w3 + Math.imul(W, ce3) | 0, g5 = g5 + Math.imul(W, pe2) | 0, g5 = g5 + Math.imul(K5, ce3) | 0, _4 = _4 + Math.imul(K5, pe2) | 0, w3 = w3 + Math.imul(z, ve) | 0, g5 = g5 + Math.imul(z, be2) | 0, g5 = g5 + Math.imul(H3, ve) | 0, _4 = _4 + Math.imul(H3, be2) | 0, w3 = w3 + Math.imul(F2, Be) | 0, g5 = g5 + Math.imul(F2, qe2) | 0, g5 = g5 + Math.imul(U3, Be) | 0, _4 = _4 + Math.imul(U3, qe2) | 0;
        var Qe2 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, w3 = Math.imul(X4, oe3), g5 = Math.imul(X4, se3), g5 = g5 + Math.imul(J3, oe3) | 0, _4 = Math.imul(J3, se3), w3 = w3 + Math.imul(G2, he) | 0, g5 = g5 + Math.imul(G2, ue4) | 0, g5 = g5 + Math.imul(Y3, he) | 0, _4 = _4 + Math.imul(Y3, ue4) | 0, w3 = w3 + Math.imul(V6, le) | 0, g5 = g5 + Math.imul(V6, de) | 0, g5 = g5 + Math.imul($3, le) | 0, _4 = _4 + Math.imul($3, de) | 0, w3 = w3 + Math.imul(j5, ce3) | 0, g5 = g5 + Math.imul(j5, pe2) | 0, g5 = g5 + Math.imul(Z3, ce3) | 0, _4 = _4 + Math.imul(Z3, pe2) | 0, w3 = w3 + Math.imul(W, ve) | 0, g5 = g5 + Math.imul(W, be2) | 0, g5 = g5 + Math.imul(K5, ve) | 0, _4 = _4 + Math.imul(K5, be2) | 0, w3 = w3 + Math.imul(z, Be) | 0, g5 = g5 + Math.imul(z, qe2) | 0, g5 = g5 + Math.imul(H3, Be) | 0, _4 = _4 + Math.imul(H3, qe2) | 0;
        var et3 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, w3 = Math.imul(X4, he), g5 = Math.imul(X4, ue4), g5 = g5 + Math.imul(J3, he) | 0, _4 = Math.imul(J3, ue4), w3 = w3 + Math.imul(G2, le) | 0, g5 = g5 + Math.imul(G2, de) | 0, g5 = g5 + Math.imul(Y3, le) | 0, _4 = _4 + Math.imul(Y3, de) | 0, w3 = w3 + Math.imul(V6, ce3) | 0, g5 = g5 + Math.imul(V6, pe2) | 0, g5 = g5 + Math.imul($3, ce3) | 0, _4 = _4 + Math.imul($3, pe2) | 0, w3 = w3 + Math.imul(j5, ve) | 0, g5 = g5 + Math.imul(j5, be2) | 0, g5 = g5 + Math.imul(Z3, ve) | 0, _4 = _4 + Math.imul(Z3, be2) | 0, w3 = w3 + Math.imul(W, Be) | 0, g5 = g5 + Math.imul(W, qe2) | 0, g5 = g5 + Math.imul(K5, Be) | 0, _4 = _4 + Math.imul(K5, qe2) | 0;
        var tt4 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, w3 = Math.imul(X4, le), g5 = Math.imul(X4, de), g5 = g5 + Math.imul(J3, le) | 0, _4 = Math.imul(J3, de), w3 = w3 + Math.imul(G2, ce3) | 0, g5 = g5 + Math.imul(G2, pe2) | 0, g5 = g5 + Math.imul(Y3, ce3) | 0, _4 = _4 + Math.imul(Y3, pe2) | 0, w3 = w3 + Math.imul(V6, ve) | 0, g5 = g5 + Math.imul(V6, be2) | 0, g5 = g5 + Math.imul($3, ve) | 0, _4 = _4 + Math.imul($3, be2) | 0, w3 = w3 + Math.imul(j5, Be) | 0, g5 = g5 + Math.imul(j5, qe2) | 0, g5 = g5 + Math.imul(Z3, Be) | 0, _4 = _4 + Math.imul(Z3, qe2) | 0;
        var rt4 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, w3 = Math.imul(X4, ce3), g5 = Math.imul(X4, pe2), g5 = g5 + Math.imul(J3, ce3) | 0, _4 = Math.imul(J3, pe2), w3 = w3 + Math.imul(G2, ve) | 0, g5 = g5 + Math.imul(G2, be2) | 0, g5 = g5 + Math.imul(Y3, ve) | 0, _4 = _4 + Math.imul(Y3, be2) | 0, w3 = w3 + Math.imul(V6, Be) | 0, g5 = g5 + Math.imul(V6, qe2) | 0, g5 = g5 + Math.imul($3, Be) | 0, _4 = _4 + Math.imul($3, qe2) | 0;
        var S0 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w3 = Math.imul(X4, ve), g5 = Math.imul(X4, be2), g5 = g5 + Math.imul(J3, ve) | 0, _4 = Math.imul(J3, be2), w3 = w3 + Math.imul(G2, Be) | 0, g5 = g5 + Math.imul(G2, qe2) | 0, g5 = g5 + Math.imul(Y3, Be) | 0, _4 = _4 + Math.imul(Y3, qe2) | 0;
        var E0 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        d4 = (_4 + (g5 >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w3 = Math.imul(X4, Be), g5 = Math.imul(X4, qe2), g5 = g5 + Math.imul(J3, Be) | 0, _4 = Math.imul(J3, qe2);
        var A0 = (d4 + w3 | 0) + ((g5 & 8191) << 13) | 0;
        return d4 = (_4 + (g5 >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He3, n[2] = We2, n[3] = Ke2, n[4] = je, n[5] = Ze2, n[6] = Ve, n[7] = $e2, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe2, n[13] = et3, n[14] = tt4, n[15] = rt4, n[16] = S0, n[17] = E0, n[18] = A0, d4 !== 0 && (n[19] = d4, c2.length++), c2;
      };
      Math.imul || (N6 = _e3);
      function we(h5, s2, u3) {
        u3.negative = s2.negative ^ h5.negative, u3.length = h5.length + s2.length;
        for (var c2 = 0, b6 = 0, l3 = 0;l3 < u3.length - 1; l3++) {
          var n = b6;
          b6 = 0;
          for (var d4 = c2 & 67108863, w3 = Math.min(l3, s2.length - 1), g5 = Math.max(0, l3 - h5.length + 1);g5 <= w3; g5++) {
            var _4 = l3 - g5, A4 = h5.words[_4] | 0, R4 = s2.words[g5] | 0, I5 = A4 * R4, Me = I5 & 67108863;
            n = n + (I5 / 67108864 | 0) | 0, Me = Me + d4 | 0, d4 = Me & 67108863, n = n + (Me >>> 26) | 0, b6 += n >>> 26, n &= 67108863;
          }
          u3.words[l3] = d4, c2 = n, n = b6;
        }
        return c2 !== 0 ? u3.words[l3] = c2 : u3.length--, u3._strip();
      }
      function ye2(h5, s2, u3) {
        return we(h5, s2, u3);
      }
      f3.prototype.mulTo = function(s2, u3) {
        var c2, b6 = this.length + s2.length;
        return this.length === 10 && s2.length === 10 ? c2 = N6(this, s2, u3) : b6 < 63 ? c2 = _e3(this, s2, u3) : b6 < 1024 ? c2 = we(this, s2, u3) : c2 = ye2(this, s2, u3), c2;
      };
      function xe2(h5, s2) {
        this.x = h5, this.y = s2;
      }
      xe2.prototype.makeRBT = function(s2) {
        for (var u3 = new Array(s2), c2 = f3.prototype._countBits(s2) - 1, b6 = 0;b6 < s2; b6++)
          u3[b6] = this.revBin(b6, c2, s2);
        return u3;
      }, xe2.prototype.revBin = function(s2, u3, c2) {
        if (s2 === 0 || s2 === c2 - 1)
          return s2;
        for (var b6 = 0, l3 = 0;l3 < u3; l3++)
          b6 |= (s2 & 1) << u3 - l3 - 1, s2 >>= 1;
        return b6;
      }, xe2.prototype.permute = function(s2, u3, c2, b6, l3, n) {
        for (var d4 = 0;d4 < n; d4++)
          b6[d4] = u3[s2[d4]], l3[d4] = c2[s2[d4]];
      }, xe2.prototype.transform = function(s2, u3, c2, b6, l3, n) {
        this.permute(n, s2, u3, c2, b6, l3);
        for (var d4 = 1;d4 < l3; d4 <<= 1)
          for (var w3 = d4 << 1, g5 = Math.cos(2 * Math.PI / w3), _4 = Math.sin(2 * Math.PI / w3), A4 = 0;A4 < l3; A4 += w3)
            for (var R4 = g5, I5 = _4, Me = 0;Me < d4; Me++) {
              var k4 = c2[A4 + Me], D3 = b6[A4 + Me], nt4 = c2[A4 + Me + d4], C4 = b6[A4 + Me + d4], O4 = R4 * nt4 - I5 * C4;
              C4 = R4 * C4 + I5 * nt4, nt4 = O4, c2[A4 + Me] = k4 + nt4, b6[A4 + Me] = D3 + C4, c2[A4 + Me + d4] = k4 - nt4, b6[A4 + Me + d4] = D3 - C4, Me !== w3 && (O4 = g5 * R4 - _4 * I5, I5 = g5 * I5 + _4 * R4, R4 = O4);
            }
      }, xe2.prototype.guessLen13b = function(s2, u3) {
        var c2 = Math.max(u3, s2) | 1, b6 = c2 & 1, l3 = 0;
        for (c2 = c2 / 2 | 0;c2; c2 = c2 >>> 1)
          l3++;
        return 1 << l3 + 1 + b6;
      }, xe2.prototype.conjugate = function(s2, u3, c2) {
        if (!(c2 <= 1))
          for (var b6 = 0;b6 < c2 / 2; b6++) {
            var l3 = s2[b6];
            s2[b6] = s2[c2 - b6 - 1], s2[c2 - b6 - 1] = l3, l3 = u3[b6], u3[b6] = -u3[c2 - b6 - 1], u3[c2 - b6 - 1] = -l3;
          }
      }, xe2.prototype.normalize13b = function(s2, u3) {
        for (var c2 = 0, b6 = 0;b6 < u3 / 2; b6++) {
          var l3 = Math.round(s2[2 * b6 + 1] / u3) * 8192 + Math.round(s2[2 * b6] / u3) + c2;
          s2[b6] = l3 & 67108863, l3 < 67108864 ? c2 = 0 : c2 = l3 / 67108864 | 0;
        }
        return s2;
      }, xe2.prototype.convert13b = function(s2, u3, c2, b6) {
        for (var l3 = 0, n = 0;n < u3; n++)
          l3 = l3 + (s2[n] | 0), c2[2 * n] = l3 & 8191, l3 = l3 >>> 13, c2[2 * n + 1] = l3 & 8191, l3 = l3 >>> 13;
        for (n = 2 * u3;n < b6; ++n)
          c2[n] = 0;
        r(l3 === 0), r((l3 & -8192) === 0);
      }, xe2.prototype.stub = function(s2) {
        for (var u3 = new Array(s2), c2 = 0;c2 < s2; c2++)
          u3[c2] = 0;
        return u3;
      }, xe2.prototype.mulp = function(s2, u3, c2) {
        var b6 = 2 * this.guessLen13b(s2.length, u3.length), l3 = this.makeRBT(b6), n = this.stub(b6), d4 = new Array(b6), w3 = new Array(b6), g5 = new Array(b6), _4 = new Array(b6), A4 = new Array(b6), R4 = new Array(b6), I5 = c2.words;
        I5.length = b6, this.convert13b(s2.words, s2.length, d4, b6), this.convert13b(u3.words, u3.length, _4, b6), this.transform(d4, n, w3, g5, b6, l3), this.transform(_4, n, A4, R4, b6, l3);
        for (var Me = 0;Me < b6; Me++) {
          var k4 = w3[Me] * A4[Me] - g5[Me] * R4[Me];
          g5[Me] = w3[Me] * R4[Me] + g5[Me] * A4[Me], w3[Me] = k4;
        }
        return this.conjugate(w3, g5, b6), this.transform(w3, g5, I5, n, b6, l3), this.conjugate(I5, n, b6), this.normalize13b(I5, b6), c2.negative = s2.negative ^ u3.negative, c2.length = s2.length + u3.length, c2._strip();
      }, f3.prototype.mul = function(s2) {
        var u3 = new f3(null);
        return u3.words = new Array(this.length + s2.length), this.mulTo(s2, u3);
      }, f3.prototype.mulf = function(s2) {
        var u3 = new f3(null);
        return u3.words = new Array(this.length + s2.length), ye2(this, s2, u3);
      }, f3.prototype.imul = function(s2) {
        return this.clone().mulTo(s2, this);
      }, f3.prototype.imuln = function(s2) {
        var u3 = s2 < 0;
        u3 && (s2 = -s2), r(typeof s2 == "number"), r(s2 < 67108864);
        for (var c2 = 0, b6 = 0;b6 < this.length; b6++) {
          var l3 = (this.words[b6] | 0) * s2, n = (l3 & 67108863) + (c2 & 67108863);
          c2 >>= 26, c2 += l3 / 67108864 | 0, c2 += n >>> 26, this.words[b6] = n & 67108863;
        }
        return c2 !== 0 && (this.words[b6] = c2, this.length++), u3 ? this.ineg() : this;
      }, f3.prototype.muln = function(s2) {
        return this.clone().imuln(s2);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(s2) {
        var u3 = ge(s2);
        if (u3.length === 0)
          return new f3(1);
        for (var c2 = this, b6 = 0;b6 < u3.length && u3[b6] === 0; b6++, c2 = c2.sqr())
          ;
        if (++b6 < u3.length)
          for (var l3 = c2.sqr();b6 < u3.length; b6++, l3 = l3.sqr())
            u3[b6] !== 0 && (c2 = c2.mul(l3));
        return c2;
      }, f3.prototype.iushln = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = s2 % 26, c2 = (s2 - u3) / 26, b6 = 67108863 >>> 26 - u3 << 26 - u3, l3;
        if (u3 !== 0) {
          var n = 0;
          for (l3 = 0;l3 < this.length; l3++) {
            var d4 = this.words[l3] & b6, w3 = (this.words[l3] | 0) - d4 << u3;
            this.words[l3] = w3 | n, n = d4 >>> 26 - u3;
          }
          n && (this.words[l3] = n, this.length++);
        }
        if (c2 !== 0) {
          for (l3 = this.length - 1;l3 >= 0; l3--)
            this.words[l3 + c2] = this.words[l3];
          for (l3 = 0;l3 < c2; l3++)
            this.words[l3] = 0;
          this.length += c2;
        }
        return this._strip();
      }, f3.prototype.ishln = function(s2) {
        return r(this.negative === 0), this.iushln(s2);
      }, f3.prototype.iushrn = function(s2, u3, c2) {
        r(typeof s2 == "number" && s2 >= 0);
        var b6;
        u3 ? b6 = (u3 - u3 % 26) / 26 : b6 = 0;
        var l3 = s2 % 26, n = Math.min((s2 - l3) / 26, this.length), d4 = 67108863 ^ 67108863 >>> l3 << l3, w3 = c2;
        if (b6 -= n, b6 = Math.max(0, b6), w3) {
          for (var g5 = 0;g5 < n; g5++)
            w3.words[g5] = this.words[g5];
          w3.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g5 = 0;g5 < this.length; g5++)
              this.words[g5] = this.words[g5 + n];
          else
            this.words[0] = 0, this.length = 1;
        var _4 = 0;
        for (g5 = this.length - 1;g5 >= 0 && (_4 !== 0 || g5 >= b6); g5--) {
          var A4 = this.words[g5] | 0;
          this.words[g5] = _4 << 26 - l3 | A4 >>> l3, _4 = A4 & d4;
        }
        return w3 && _4 !== 0 && (w3.words[w3.length++] = _4), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f3.prototype.ishrn = function(s2, u3, c2) {
        return r(this.negative === 0), this.iushrn(s2, u3, c2);
      }, f3.prototype.shln = function(s2) {
        return this.clone().ishln(s2);
      }, f3.prototype.ushln = function(s2) {
        return this.clone().iushln(s2);
      }, f3.prototype.shrn = function(s2) {
        return this.clone().ishrn(s2);
      }, f3.prototype.ushrn = function(s2) {
        return this.clone().iushrn(s2);
      }, f3.prototype.testn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = s2 % 26, c2 = (s2 - u3) / 26, b6 = 1 << u3;
        if (this.length <= c2)
          return false;
        var l3 = this.words[c2];
        return !!(l3 & b6);
      }, f3.prototype.imaskn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = s2 % 26, c2 = (s2 - u3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c2)
          return this;
        if (u3 !== 0 && c2++, this.length = Math.min(c2, this.length), u3 !== 0) {
          var b6 = 67108863 ^ 67108863 >>> u3 << u3;
          this.words[this.length - 1] &= b6;
        }
        return this._strip();
      }, f3.prototype.maskn = function(s2) {
        return this.clone().imaskn(s2);
      }, f3.prototype.iaddn = function(s2) {
        return r(typeof s2 == "number"), r(s2 < 67108864), s2 < 0 ? this.isubn(-s2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s2 ? (this.words[0] = s2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s2), this.negative = 1, this) : this._iaddn(s2);
      }, f3.prototype._iaddn = function(s2) {
        this.words[0] += s2;
        for (var u3 = 0;u3 < this.length && this.words[u3] >= 67108864; u3++)
          this.words[u3] -= 67108864, u3 === this.length - 1 ? this.words[u3 + 1] = 1 : this.words[u3 + 1]++;
        return this.length = Math.max(this.length, u3 + 1), this;
      }, f3.prototype.isubn = function(s2) {
        if (r(typeof s2 == "number"), r(s2 < 67108864), s2 < 0)
          return this.iaddn(-s2);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s2), this.negative = 1, this;
        if (this.words[0] -= s2, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u3 = 0;u3 < this.length && this.words[u3] < 0; u3++)
            this.words[u3] += 67108864, this.words[u3 + 1] -= 1;
        return this._strip();
      }, f3.prototype.addn = function(s2) {
        return this.clone().iaddn(s2);
      }, f3.prototype.subn = function(s2) {
        return this.clone().isubn(s2);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(s2, u3, c2) {
        var b6 = s2.length + c2, l3;
        this._expand(b6);
        var n, d4 = 0;
        for (l3 = 0;l3 < s2.length; l3++) {
          n = (this.words[l3 + c2] | 0) + d4;
          var w3 = (s2.words[l3] | 0) * u3;
          n -= w3 & 67108863, d4 = (n >> 26) - (w3 / 67108864 | 0), this.words[l3 + c2] = n & 67108863;
        }
        for (;l3 < this.length - c2; l3++)
          n = (this.words[l3 + c2] | 0) + d4, d4 = n >> 26, this.words[l3 + c2] = n & 67108863;
        if (d4 === 0)
          return this._strip();
        for (r(d4 === -1), d4 = 0, l3 = 0;l3 < this.length; l3++)
          n = -(this.words[l3] | 0) + d4, d4 = n >> 26, this.words[l3] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f3.prototype._wordDiv = function(s2, u3) {
        var c2 = this.length - s2.length, b6 = this.clone(), l3 = s2, n = l3.words[l3.length - 1] | 0, d4 = this._countBits(n);
        c2 = 26 - d4, c2 !== 0 && (l3 = l3.ushln(c2), b6.iushln(c2), n = l3.words[l3.length - 1] | 0);
        var w3 = b6.length - l3.length, g5;
        if (u3 !== "mod") {
          g5 = new f3(null), g5.length = w3 + 1, g5.words = new Array(g5.length);
          for (var _4 = 0;_4 < g5.length; _4++)
            g5.words[_4] = 0;
        }
        var A4 = b6.clone()._ishlnsubmul(l3, 1, w3);
        A4.negative === 0 && (b6 = A4, g5 && (g5.words[w3] = 1));
        for (var R4 = w3 - 1;R4 >= 0; R4--) {
          var I5 = (b6.words[l3.length + R4] | 0) * 67108864 + (b6.words[l3.length + R4 - 1] | 0);
          for (I5 = Math.min(I5 / n | 0, 67108863), b6._ishlnsubmul(l3, I5, R4);b6.negative !== 0; )
            I5--, b6.negative = 0, b6._ishlnsubmul(l3, 1, R4), b6.isZero() || (b6.negative ^= 1);
          g5 && (g5.words[R4] = I5);
        }
        return g5 && g5._strip(), b6._strip(), u3 !== "div" && c2 !== 0 && b6.iushrn(c2), { div: g5 || null, mod: b6 };
      }, f3.prototype.divmod = function(s2, u3, c2) {
        if (r(!s2.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var b6, l3, n;
        return this.negative !== 0 && s2.negative === 0 ? (n = this.neg().divmod(s2, u3), u3 !== "mod" && (b6 = n.div.neg()), u3 !== "div" && (l3 = n.mod.neg(), c2 && l3.negative !== 0 && l3.iadd(s2)), { div: b6, mod: l3 }) : this.negative === 0 && s2.negative !== 0 ? (n = this.divmod(s2.neg(), u3), u3 !== "mod" && (b6 = n.div.neg()), { div: b6, mod: n.mod }) : (this.negative & s2.negative) !== 0 ? (n = this.neg().divmod(s2.neg(), u3), u3 !== "div" && (l3 = n.mod.neg(), c2 && l3.negative !== 0 && l3.isub(s2)), { div: n.div, mod: l3 }) : s2.length > this.length || this.cmp(s2) < 0 ? { div: new f3(0), mod: this } : s2.length === 1 ? u3 === "div" ? { div: this.divn(s2.words[0]), mod: null } : u3 === "mod" ? { div: null, mod: new f3(this.modrn(s2.words[0])) } : { div: this.divn(s2.words[0]), mod: new f3(this.modrn(s2.words[0])) } : this._wordDiv(s2, u3);
      }, f3.prototype.div = function(s2) {
        return this.divmod(s2, "div", false).div;
      }, f3.prototype.mod = function(s2) {
        return this.divmod(s2, "mod", false).mod;
      }, f3.prototype.umod = function(s2) {
        return this.divmod(s2, "mod", true).mod;
      }, f3.prototype.divRound = function(s2) {
        var u3 = this.divmod(s2);
        if (u3.mod.isZero())
          return u3.div;
        var c2 = u3.div.negative !== 0 ? u3.mod.isub(s2) : u3.mod, b6 = s2.ushrn(1), l3 = s2.andln(1), n = c2.cmp(b6);
        return n < 0 || l3 === 1 && n === 0 ? u3.div : u3.div.negative !== 0 ? u3.div.isubn(1) : u3.div.iaddn(1);
      }, f3.prototype.modrn = function(s2) {
        var u3 = s2 < 0;
        u3 && (s2 = -s2), r(s2 <= 67108863);
        for (var c2 = (1 << 26) % s2, b6 = 0, l3 = this.length - 1;l3 >= 0; l3--)
          b6 = (c2 * b6 + (this.words[l3] | 0)) % s2;
        return u3 ? -b6 : b6;
      }, f3.prototype.modn = function(s2) {
        return this.modrn(s2);
      }, f3.prototype.idivn = function(s2) {
        var u3 = s2 < 0;
        u3 && (s2 = -s2), r(s2 <= 67108863);
        for (var c2 = 0, b6 = this.length - 1;b6 >= 0; b6--) {
          var l3 = (this.words[b6] | 0) + c2 * 67108864;
          this.words[b6] = l3 / s2 | 0, c2 = l3 % s2;
        }
        return this._strip(), u3 ? this.ineg() : this;
      }, f3.prototype.divn = function(s2) {
        return this.clone().idivn(s2);
      }, f3.prototype.egcd = function(s2) {
        r(s2.negative === 0), r(!s2.isZero());
        var u3 = this, c2 = s2.clone();
        u3.negative !== 0 ? u3 = u3.umod(s2) : u3 = u3.clone();
        for (var b6 = new f3(1), l3 = new f3(0), n = new f3(0), d4 = new f3(1), w3 = 0;u3.isEven() && c2.isEven(); )
          u3.iushrn(1), c2.iushrn(1), ++w3;
        for (var g5 = c2.clone(), _4 = u3.clone();!u3.isZero(); ) {
          for (var A4 = 0, R4 = 1;(u3.words[0] & R4) === 0 && A4 < 26; ++A4, R4 <<= 1)
            ;
          if (A4 > 0)
            for (u3.iushrn(A4);A4-- > 0; )
              (b6.isOdd() || l3.isOdd()) && (b6.iadd(g5), l3.isub(_4)), b6.iushrn(1), l3.iushrn(1);
          for (var I5 = 0, Me = 1;(c2.words[0] & Me) === 0 && I5 < 26; ++I5, Me <<= 1)
            ;
          if (I5 > 0)
            for (c2.iushrn(I5);I5-- > 0; )
              (n.isOdd() || d4.isOdd()) && (n.iadd(g5), d4.isub(_4)), n.iushrn(1), d4.iushrn(1);
          u3.cmp(c2) >= 0 ? (u3.isub(c2), b6.isub(n), l3.isub(d4)) : (c2.isub(u3), n.isub(b6), d4.isub(l3));
        }
        return { a: n, b: d4, gcd: c2.iushln(w3) };
      }, f3.prototype._invmp = function(s2) {
        r(s2.negative === 0), r(!s2.isZero());
        var u3 = this, c2 = s2.clone();
        u3.negative !== 0 ? u3 = u3.umod(s2) : u3 = u3.clone();
        for (var b6 = new f3(1), l3 = new f3(0), n = c2.clone();u3.cmpn(1) > 0 && c2.cmpn(1) > 0; ) {
          for (var d4 = 0, w3 = 1;(u3.words[0] & w3) === 0 && d4 < 26; ++d4, w3 <<= 1)
            ;
          if (d4 > 0)
            for (u3.iushrn(d4);d4-- > 0; )
              b6.isOdd() && b6.iadd(n), b6.iushrn(1);
          for (var g5 = 0, _4 = 1;(c2.words[0] & _4) === 0 && g5 < 26; ++g5, _4 <<= 1)
            ;
          if (g5 > 0)
            for (c2.iushrn(g5);g5-- > 0; )
              l3.isOdd() && l3.iadd(n), l3.iushrn(1);
          u3.cmp(c2) >= 0 ? (u3.isub(c2), b6.isub(l3)) : (c2.isub(u3), l3.isub(b6));
        }
        var A4;
        return u3.cmpn(1) === 0 ? A4 = b6 : A4 = l3, A4.cmpn(0) < 0 && A4.iadd(s2), A4;
      }, f3.prototype.gcd = function(s2) {
        if (this.isZero())
          return s2.abs();
        if (s2.isZero())
          return this.abs();
        var u3 = this.clone(), c2 = s2.clone();
        u3.negative = 0, c2.negative = 0;
        for (var b6 = 0;u3.isEven() && c2.isEven(); b6++)
          u3.iushrn(1), c2.iushrn(1);
        do {
          for (;u3.isEven(); )
            u3.iushrn(1);
          for (;c2.isEven(); )
            c2.iushrn(1);
          var l3 = u3.cmp(c2);
          if (l3 < 0) {
            var n = u3;
            u3 = c2, c2 = n;
          } else if (l3 === 0 || c2.cmpn(1) === 0)
            break;
          u3.isub(c2);
        } while (true);
        return c2.iushln(b6);
      }, f3.prototype.invm = function(s2) {
        return this.egcd(s2).a.umod(s2);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(s2) {
        return this.words[0] & s2;
      }, f3.prototype.bincn = function(s2) {
        r(typeof s2 == "number");
        var u3 = s2 % 26, c2 = (s2 - u3) / 26, b6 = 1 << u3;
        if (this.length <= c2)
          return this._expand(c2 + 1), this.words[c2] |= b6, this;
        for (var l3 = b6, n = c2;l3 !== 0 && n < this.length; n++) {
          var d4 = this.words[n] | 0;
          d4 += l3, l3 = d4 >>> 26, d4 &= 67108863, this.words[n] = d4;
        }
        return l3 !== 0 && (this.words[n] = l3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(s2) {
        var u3 = s2 < 0;
        if (this.negative !== 0 && !u3)
          return -1;
        if (this.negative === 0 && u3)
          return 1;
        this._strip();
        var c2;
        if (this.length > 1)
          c2 = 1;
        else {
          u3 && (s2 = -s2), r(s2 <= 67108863, "Number is too big");
          var b6 = this.words[0] | 0;
          c2 = b6 === s2 ? 0 : b6 < s2 ? -1 : 1;
        }
        return this.negative !== 0 ? -c2 | 0 : c2;
      }, f3.prototype.cmp = function(s2) {
        if (this.negative !== 0 && s2.negative === 0)
          return -1;
        if (this.negative === 0 && s2.negative !== 0)
          return 1;
        var u3 = this.ucmp(s2);
        return this.negative !== 0 ? -u3 | 0 : u3;
      }, f3.prototype.ucmp = function(s2) {
        if (this.length > s2.length)
          return 1;
        if (this.length < s2.length)
          return -1;
        for (var u3 = 0, c2 = this.length - 1;c2 >= 0; c2--) {
          var b6 = this.words[c2] | 0, l3 = s2.words[c2] | 0;
          if (b6 !== l3) {
            b6 < l3 ? u3 = -1 : b6 > l3 && (u3 = 1);
            break;
          }
        }
        return u3;
      }, f3.prototype.gtn = function(s2) {
        return this.cmpn(s2) === 1;
      }, f3.prototype.gt = function(s2) {
        return this.cmp(s2) === 1;
      }, f3.prototype.gten = function(s2) {
        return this.cmpn(s2) >= 0;
      }, f3.prototype.gte = function(s2) {
        return this.cmp(s2) >= 0;
      }, f3.prototype.ltn = function(s2) {
        return this.cmpn(s2) === -1;
      }, f3.prototype.lt = function(s2) {
        return this.cmp(s2) === -1;
      }, f3.prototype.lten = function(s2) {
        return this.cmpn(s2) <= 0;
      }, f3.prototype.lte = function(s2) {
        return this.cmp(s2) <= 0;
      }, f3.prototype.eqn = function(s2) {
        return this.cmpn(s2) === 0;
      }, f3.prototype.eq = function(s2) {
        return this.cmp(s2) === 0;
      }, f3.red = function(s2) {
        return new i(s2);
      }, f3.prototype.toRed = function(s2) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s2.convertTo(this)._forceRed(s2);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(s2) {
        return this.red = s2, this;
      }, f3.prototype.forceRed = function(s2) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s2);
      }, f3.prototype.redAdd = function(s2) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s2);
      }, f3.prototype.redIAdd = function(s2) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s2);
      }, f3.prototype.redSub = function(s2) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s2);
      }, f3.prototype.redISub = function(s2) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s2);
      }, f3.prototype.redShl = function(s2) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s2);
      }, f3.prototype.redMul = function(s2) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s2), this.red.mul(this, s2);
      }, f3.prototype.redIMul = function(s2) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s2), this.red.imul(this, s2);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(s2) {
        return r(this.red && !s2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s2);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h5, s2) {
        this.name = h5, this.p = new f3(s2, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s2 = new f3(null);
        return s2.words = new Array(Math.ceil(this.n / 13)), s2;
      }, Ee.prototype.ireduce = function(s2) {
        var u3 = s2, c2;
        do
          this.split(u3, this.tmp), u3 = this.imulK(u3), u3 = u3.iadd(this.tmp), c2 = u3.bitLength();
        while (c2 > this.n);
        var b6 = c2 < this.n ? -1 : u3.ucmp(this.p);
        return b6 === 0 ? (u3.words[0] = 0, u3.length = 1) : b6 > 0 ? u3.isub(this.p) : u3.strip !== undefined ? u3.strip() : u3._strip(), u3;
      }, Ee.prototype.split = function(s2, u3) {
        s2.iushrn(this.n, 0, u3);
      }, Ee.prototype.imulK = function(s2) {
        return s2.imul(this.k);
      };
      function Ae2() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(Ae2, Ee), Ae2.prototype.split = function(s2, u3) {
        for (var c2 = 4194303, b6 = Math.min(s2.length, 9), l3 = 0;l3 < b6; l3++)
          u3.words[l3] = s2.words[l3];
        if (u3.length = b6, s2.length <= 9) {
          s2.words[0] = 0, s2.length = 1;
          return;
        }
        var n = s2.words[9];
        for (u3.words[u3.length++] = n & c2, l3 = 10;l3 < s2.length; l3++) {
          var d4 = s2.words[l3] | 0;
          s2.words[l3 - 10] = (d4 & c2) << 4 | n >>> 22, n = d4;
        }
        n >>>= 22, s2.words[l3 - 10] = n, n === 0 && s2.length > 10 ? s2.length -= 10 : s2.length -= 9;
      }, Ae2.prototype.imulK = function(s2) {
        s2.words[s2.length] = 0, s2.words[s2.length + 1] = 0, s2.length += 2;
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++) {
          var b6 = s2.words[c2] | 0;
          u3 += b6 * 977, s2.words[c2] = u3 & 67108863, u3 = b6 * 64 + (u3 / 67108864 | 0);
        }
        return s2.words[s2.length - 1] === 0 && (s2.length--, s2.words[s2.length - 1] === 0 && s2.length--), s2;
      };
      function P4() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(P4, Ee);
      function Se3() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Se3, Ee);
      function v4() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(v4, Ee), v4.prototype.imulK = function(s2) {
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++) {
          var b6 = (s2.words[c2] | 0) * 19 + u3, l3 = b6 & 67108863;
          b6 >>>= 26, s2.words[c2] = l3, u3 = b6;
        }
        return u3 !== 0 && (s2.words[s2.length++] = u3), s2;
      }, f3._prime = function(s2) {
        if (Re[s2])
          return Re[s2];
        var u3;
        if (s2 === "k256")
          u3 = new Ae2;
        else if (s2 === "p224")
          u3 = new P4;
        else if (s2 === "p192")
          u3 = new Se3;
        else if (s2 === "p25519")
          u3 = new v4;
        else
          throw new Error("Unknown prime " + s2);
        return Re[s2] = u3, u3;
      };
      function i(h5) {
        if (typeof h5 == "string") {
          var s2 = f3._prime(h5);
          this.m = s2.p, this.prime = s2;
        } else
          r(h5.gtn(1), "modulus must be greater than 1"), this.m = h5, this.prime = null;
      }
      i.prototype._verify1 = function(s2) {
        r(s2.negative === 0, "red works only with positives"), r(s2.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s2, u3) {
        r((s2.negative | u3.negative) === 0, "red works only with positives"), r(s2.red && s2.red === u3.red, "red works only with red numbers");
      }, i.prototype.imod = function(s2) {
        return this.prime ? this.prime.ireduce(s2)._forceRed(this) : (x5(s2, s2.umod(this.m)._forceRed(this)), s2);
      }, i.prototype.neg = function(s2) {
        return s2.isZero() ? s2.clone() : this.m.sub(s2)._forceRed(this);
      }, i.prototype.add = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.add(u3);
        return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2._forceRed(this);
      }, i.prototype.iadd = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.iadd(u3);
        return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2;
      }, i.prototype.sub = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.sub(u3);
        return c2.cmpn(0) < 0 && c2.iadd(this.m), c2._forceRed(this);
      }, i.prototype.isub = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.isub(u3);
        return c2.cmpn(0) < 0 && c2.iadd(this.m), c2;
      }, i.prototype.shl = function(s2, u3) {
        return this._verify1(s2), this.imod(s2.ushln(u3));
      }, i.prototype.imul = function(s2, u3) {
        return this._verify2(s2, u3), this.imod(s2.imul(u3));
      }, i.prototype.mul = function(s2, u3) {
        return this._verify2(s2, u3), this.imod(s2.mul(u3));
      }, i.prototype.isqr = function(s2) {
        return this.imul(s2, s2.clone());
      }, i.prototype.sqr = function(s2) {
        return this.mul(s2, s2);
      }, i.prototype.sqrt = function(s2) {
        if (s2.isZero())
          return s2.clone();
        var u3 = this.m.andln(3);
        if (r(u3 % 2 === 1), u3 === 3) {
          var c2 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(s2, c2);
        }
        for (var b6 = this.m.subn(1), l3 = 0;!b6.isZero() && b6.andln(1) === 0; )
          l3++, b6.iushrn(1);
        r(!b6.isZero());
        var n = new f3(1).toRed(this), d4 = n.redNeg(), w3 = this.m.subn(1).iushrn(1), g5 = this.m.bitLength();
        for (g5 = new f3(2 * g5 * g5).toRed(this);this.pow(g5, w3).cmp(d4) !== 0; )
          g5.redIAdd(d4);
        for (var _4 = this.pow(g5, b6), A4 = this.pow(s2, b6.addn(1).iushrn(1)), R4 = this.pow(s2, b6), I5 = l3;R4.cmp(n) !== 0; ) {
          for (var Me = R4, k4 = 0;Me.cmp(n) !== 0; k4++)
            Me = Me.redSqr();
          r(k4 < I5);
          var D3 = this.pow(_4, new f3(1).iushln(I5 - k4 - 1));
          A4 = A4.redMul(D3), _4 = D3.redSqr(), R4 = R4.redMul(_4), I5 = k4;
        }
        return A4;
      }, i.prototype.invm = function(s2) {
        var u3 = s2._invmp(this.m);
        return u3.negative !== 0 ? (u3.negative = 0, this.imod(u3).redNeg()) : this.imod(u3);
      }, i.prototype.pow = function(s2, u3) {
        if (u3.isZero())
          return new f3(1).toRed(this);
        if (u3.cmpn(1) === 0)
          return s2.clone();
        var c2 = 4, b6 = new Array(1 << c2);
        b6[0] = new f3(1).toRed(this), b6[1] = s2;
        for (var l3 = 2;l3 < b6.length; l3++)
          b6[l3] = this.mul(b6[l3 - 1], s2);
        var n = b6[0], d4 = 0, w3 = 0, g5 = u3.bitLength() % 26;
        for (g5 === 0 && (g5 = 26), l3 = u3.length - 1;l3 >= 0; l3--) {
          for (var _4 = u3.words[l3], A4 = g5 - 1;A4 >= 0; A4--) {
            var R4 = _4 >> A4 & 1;
            if (n !== b6[0] && (n = this.sqr(n)), R4 === 0 && d4 === 0) {
              w3 = 0;
              continue;
            }
            d4 <<= 1, d4 |= R4, w3++, !(w3 !== c2 && (l3 !== 0 || A4 !== 0)) && (n = this.mul(n, b6[d4]), w3 = 0, d4 = 0);
          }
          g5 = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s2) {
        var u3 = s2.umod(this.m);
        return u3 === s2 ? u3.clone() : u3;
      }, i.prototype.convertFrom = function(s2) {
        var u3 = s2.clone();
        return u3.red = null, u3;
      }, f3.mont = function(s2) {
        return new a3(s2);
      };
      function a3(h5) {
        i.call(this, h5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(a3, i), a3.prototype.convertTo = function(s2) {
        return this.imod(s2.ushln(this.shift));
      }, a3.prototype.convertFrom = function(s2) {
        var u3 = this.imod(s2.mul(this.rinv));
        return u3.red = null, u3;
      }, a3.prototype.imul = function(s2, u3) {
        if (s2.isZero() || u3.isZero())
          return s2.words[0] = 0, s2.length = 1, s2;
        var c2 = s2.imul(u3), b6 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l3 = c2.isub(b6).iushrn(this.shift), n = l3;
        return l3.cmp(this.m) >= 0 ? n = l3.isub(this.m) : l3.cmpn(0) < 0 && (n = l3.iadd(this.m)), n._forceRed(this);
      }, a3.prototype.mul = function(s2, u3) {
        if (s2.isZero() || u3.isZero())
          return new f3(0)._forceRed(this);
        var c2 = s2.mul(u3), b6 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l3 = c2.isub(b6).iushrn(this.shift), n = l3;
        return l3.cmp(this.m) >= 0 ? n = l3.isub(this.m) : l3.cmpn(0) < 0 && (n = l3.iadd(this.m)), n._forceRed(this);
      }, a3.prototype.invm = function(s2) {
        var u3 = this.imod(s2._invmp(this.m).mul(this.r2));
        return u3._forceRed(this);
      };
    })(typeof kl > "u" || kl, n2);
  });
  Ks2 = T3((yk, o2) => {
    var Rf = Ws2(), oA = on();
    function sA(t) {
      var e = f22(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function f22(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a22(t, e) {
      var r = sA(e), o3 = e.modulus.byteLength(), f3 = new Rf(t).mul(r.blinder).umod(e.modulus), p3 = f3.toRed(Rf.mont(e.prime1)), m3 = f3.toRed(Rf.mont(e.prime2)), y5 = e.coefficient, M3 = e.prime1, x5 = e.prime2, S3 = p3.redPow(e.exponent1).fromRed(), E6 = m3.redPow(e.exponent2).fromRed(), B3 = S3.isub(E6).imul(y5).umod(M3).imul(x5);
      return E6.iadd(B3).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o3);
    }
    a22.getr = f22;
    o2.exports = a22;
  });
  s2 = T3((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri3 = T3((h22, Ll) => {
    (function(t, e) {
      function r(v4, i) {
        if (!v4)
          throw new Error(i || "Assertion failed");
      }
      function o2(v4, i) {
        v4.super_ = i;
        var a3 = function() {
        };
        a3.prototype = i.prototype, v4.prototype = new a3, v4.prototype.constructor = v4;
      }
      function f3(v4, i, a3) {
        if (f3.isBN(v4))
          return v4;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v4 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v4 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(i) {
        return i instanceof f3 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f3.wordSize && Array.isArray(i.words);
      }, f3.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f3.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f3.prototype._init = function(i, a3, h5) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h5);
        if (typeof i == "object")
          return this._initArray(i, a3, h5);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h5) : (this._parseBase(i, a3, s3), h5 === "le" && this._initArray(this.toArray(), a3, h5)));
      }, f3.prototype._initNumber = function(i, a3, h5) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h5 === "le" && this._initArray(this.toArray(), a3, h5);
      }, f3.prototype._initArray = function(i, a3, h5) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b6 = 0;
        if (h5 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        else if (h5 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        return this.strip();
      };
      function m3(v4, i) {
        var a3 = v4.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y5(v4, i, a3) {
        var h5 = m3(v4, a3);
        return a3 - 1 >= i && (h5 |= m3(v4, a3 - 1) << 4), h5;
      }
      f3.prototype._parseHex = function(i, a3, h5) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b6;
        if (h5 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M3(v4, i, a3, h5) {
        for (var s3 = 0, u3 = Math.min(v4.length, a3), c2 = i;c2 < u3; c2++) {
          var b6 = v4.charCodeAt(c2) - 48;
          s3 *= h5, b6 >= 49 ? s3 += b6 - 49 + 10 : b6 >= 17 ? s3 += b6 - 17 + 10 : s3 += b6;
        }
        return s3;
      }
      f3.prototype._parseBase = function(i, a3, h5) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a3)
          s3++;
        s3--, u3 = u3 / a3 | 0;
        for (var c2 = i.length - h5, b6 = c2 % s3, l3 = Math.min(c2, c2 - b6) + h5, n = 0, d4 = h5;d4 < l3; d4 += s3)
          n = M3(i, d4, d4 + s3, a3), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b6 !== 0) {
          var w3 = 1;
          for (n = M3(i, d4, i.length, a3), d4 = 0;d4 < b6; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f3.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f3.prototype.clone = function() {
        var i = new f3(null);
        return this.copy(i), i;
      }, f3.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f3.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h5;
        if (i === 16 || i === "hex") {
          h5 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b6 = this.words[c2], l3 = ((b6 << s3 | u3) & 16777215).toString(16);
            u3 = b6 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h5 = x5[6 - l3.length] + l3 + h5 : h5 = l3 + h5, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h5 = u3.toString(16) + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S3[i], d4 = E6[i];
          h5 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g5 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h5 = g5 + h5 : h5 = x5[n - g5.length] + g5 + h5;
          }
          for (this.isZero() && (h5 = "0" + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f3.prototype.toJSON = function() {
        return this.toString(16);
      }, f3.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f3.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f3.prototype.toArrayLike = function(i, a3, h5) {
        var s3 = this.byteLength(), u3 = h5 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b6 = new i(u3), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[n] = l3;
          for (;n < u3; n++)
            b6[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b6[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[u3 - n - 1] = l3;
        }
        return b6;
      }, Math.clz32 ? f3.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f3.prototype._countBits = function(i) {
        var a3 = i, h5 = 0;
        return a3 >= 4096 && (h5 += 13, a3 >>>= 13), a3 >= 64 && (h5 += 7, a3 >>>= 7), a3 >= 8 && (h5 += 4, a3 >>>= 4), a3 >= 2 && (h5 += 2, a3 >>>= 2), h5 + a3;
      }, f3.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h5 = 0;
        return (a3 & 8191) === 0 && (h5 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h5 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h5 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h5 += 2, a3 >>>= 2), (a3 & 1) === 0 && h5++, h5;
      }, f3.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v4) {
        for (var i = new Array(v4.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h5 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v4.words[h5] & 1 << s3) >>> s3;
        }
        return i;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h5 = this._zeroBits(this.words[a3]);
          if (i += h5, h5 !== 26)
            break;
        }
        return i;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f3.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f3.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f3.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f3.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h5 = 0;h5 < a3.length; h5++)
          this.words[h5] = this.words[h5] & i.words[h5];
        return this.length = a3.length, this.strip();
      }, f3.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f3.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f3.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f3.prototype.iuxor = function(i) {
        var a3, h5;
        this.length > i.length ? (a3 = this, h5 = i) : (a3 = i, h5 = this);
        for (var s3 = 0;s3 < h5.length; s3++)
          this.words[s3] = a3.words[s3] ^ h5.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f3.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f3.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f3.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f3.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h5 = i % 26;
        this._expand(a3), h5 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h5 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h5), this.strip();
      }, f3.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f3.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h5 = i / 26 | 0, s3 = i % 26;
        return this._expand(h5 + 1), a3 ? this.words[h5] = this.words[h5] | 1 << s3 : this.words[h5] = this.words[h5] & ~(1 << s3), this.strip();
      }, f3.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h5, s3;
        this.length > i.length ? (h5 = this, s3 = i) : (h5 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h5.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        for (;u3 !== 0 && c2 < h5.length; c2++)
          a3 = (h5.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        if (this.length = h5.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h5 !== this)
          for (;c2 < h5.length; c2++)
            this.words[c2] = h5.words[c2];
        return this;
      }, f3.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f3.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h5 = this.cmp(i);
        if (h5 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h5 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b6 = 0;b6 < u3.length; b6++)
          a3 = (s3.words[b6] | 0) - (u3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        for (;c2 !== 0 && b6 < s3.length; b6++)
          a3 = (s3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        if (c2 === 0 && b6 < s3.length && s3 !== this)
          for (;b6 < s3.length; b6++)
            this.words[b6] = s3.words[b6];
        return this.length = Math.max(this.length, b6), s3 !== this && (this.negative = 1), this.strip();
      }, f3.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q3(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative;
        var h5 = v4.length + i.length | 0;
        a3.length = h5, h5 = h5 - 1 | 0;
        var s3 = v4.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b6 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b6;
        for (var n = 1;n < h5; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g5 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v4.length + 1);_4 <= g5; _4++) {
            var A4 = n - _4 | 0;
            s3 = v4.words[A4] | 0, u3 = i.words[_4] | 0, c2 = s3 * u3 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h5) {
        var s3 = i.words, u3 = a3.words, c2 = h5.words, b6 = 0, l3, n, d4, w3 = s3[0] | 0, g5 = w3 & 8191, _4 = w3 >>> 13, A4 = s3[1] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = s3[3] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = s3[4] | 0, F2 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = s3[6] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = s3[7] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u3[0] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = u3[1] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = u3[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = u3[3] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = u3[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = u3[5] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = u3[6] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = u3[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = u3[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u3[9] | 0, ve = It & 8191, be2 = It >>> 13;
        h5.negative = i.negative ^ a3.negative, h5.length = 19, l3 = Math.imul(g5, X4), n = Math.imul(g5, J3), n = n + Math.imul(_4, X4) | 0, d4 = Math.imul(_4, J3);
        var ft2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l3 = Math.imul(R4, X4), n = Math.imul(R4, J3), n = n + Math.imul(I5, X4) | 0, d4 = Math.imul(I5, J3), l3 = l3 + Math.imul(g5, Q5) | 0, n = n + Math.imul(g5, ee) | 0, n = n + Math.imul(_4, Q5) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X4), n = Math.imul(k4, J3), n = n + Math.imul(D3, X4) | 0, d4 = Math.imul(D3, J3), l3 = l3 + Math.imul(R4, Q5) | 0, n = n + Math.imul(R4, ee) | 0, n = n + Math.imul(I5, Q5) | 0, d4 = d4 + Math.imul(I5, ee) | 0, l3 = l3 + Math.imul(g5, te2) | 0, n = n + Math.imul(g5, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C4, X4), n = Math.imul(C4, J3), n = n + Math.imul(O4, X4) | 0, d4 = Math.imul(O4, J3), l3 = l3 + Math.imul(k4, Q5) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D3, Q5) | 0, d4 = d4 + Math.imul(D3, ee) | 0, l3 = l3 + Math.imul(R4, te2) | 0, n = n + Math.imul(R4, re2) | 0, n = n + Math.imul(I5, te2) | 0, d4 = d4 + Math.imul(I5, re2) | 0, l3 = l3 + Math.imul(g5, ie) | 0, n = n + Math.imul(g5, ne2) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne2) | 0;
        var ze = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F2, X4), n = Math.imul(F2, J3), n = n + Math.imul(U3, X4) | 0, d4 = Math.imul(U3, J3), l3 = l3 + Math.imul(C4, Q5) | 0, n = n + Math.imul(C4, ee) | 0, n = n + Math.imul(O4, Q5) | 0, d4 = d4 + Math.imul(O4, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D3, te2) | 0, d4 = d4 + Math.imul(D3, re2) | 0, l3 = l3 + Math.imul(R4, ie) | 0, n = n + Math.imul(R4, ne2) | 0, n = n + Math.imul(I5, ie) | 0, d4 = d4 + Math.imul(I5, ne2) | 0, l3 = l3 + Math.imul(g5, fe3) | 0, n = n + Math.imul(g5, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X4), n = Math.imul(z, J3), n = n + Math.imul(H3, X4) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F2, Q5) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U3, Q5) | 0, d4 = d4 + Math.imul(U3, ee) | 0, l3 = l3 + Math.imul(C4, te2) | 0, n = n + Math.imul(C4, re2) | 0, n = n + Math.imul(O4, te2) | 0, d4 = d4 + Math.imul(O4, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne2) | 0, n = n + Math.imul(D3, ie) | 0, d4 = d4 + Math.imul(D3, ne2) | 0, l3 = l3 + Math.imul(R4, fe3) | 0, n = n + Math.imul(R4, ae2) | 0, n = n + Math.imul(I5, fe3) | 0, d4 = d4 + Math.imul(I5, ae2) | 0, l3 = l3 + Math.imul(g5, oe3) | 0, n = n + Math.imul(g5, se3) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se3) | 0;
        var We2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X4), n = Math.imul(W, J3), n = n + Math.imul(K5, X4) | 0, d4 = Math.imul(K5, J3), l3 = l3 + Math.imul(z, Q5) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q5) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F2, te2) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U3, te2) | 0, d4 = d4 + Math.imul(U3, re2) | 0, l3 = l3 + Math.imul(C4, ie) | 0, n = n + Math.imul(C4, ne2) | 0, n = n + Math.imul(O4, ie) | 0, d4 = d4 + Math.imul(O4, ne2) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D3, fe3) | 0, d4 = d4 + Math.imul(D3, ae2) | 0, l3 = l3 + Math.imul(R4, oe3) | 0, n = n + Math.imul(R4, se3) | 0, n = n + Math.imul(I5, oe3) | 0, d4 = d4 + Math.imul(I5, se3) | 0, l3 = l3 + Math.imul(g5, he) | 0, n = n + Math.imul(g5, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j5, X4), n = Math.imul(j5, J3), n = n + Math.imul(Z3, X4) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q5) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K5, Q5) | 0, d4 = d4 + Math.imul(K5, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne2) | 0, n = n + Math.imul(U3, ie) | 0, d4 = d4 + Math.imul(U3, ne2) | 0, l3 = l3 + Math.imul(C4, fe3) | 0, n = n + Math.imul(C4, ae2) | 0, n = n + Math.imul(O4, fe3) | 0, d4 = d4 + Math.imul(O4, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se3) | 0, n = n + Math.imul(D3, oe3) | 0, d4 = d4 + Math.imul(D3, se3) | 0, l3 = l3 + Math.imul(R4, he) | 0, n = n + Math.imul(R4, ue4) | 0, n = n + Math.imul(I5, he) | 0, d4 = d4 + Math.imul(I5, ue4) | 0, l3 = l3 + Math.imul(g5, le) | 0, n = n + Math.imul(g5, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V6, X4), n = Math.imul(V6, J3), n = n + Math.imul($3, X4) | 0, d4 = Math.imul($3, J3), l3 = l3 + Math.imul(j5, Q5) | 0, n = n + Math.imul(j5, ee) | 0, n = n + Math.imul(Z3, Q5) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K5, te2) | 0, d4 = d4 + Math.imul(K5, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne2) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne2) | 0, l3 = l3 + Math.imul(F2, fe3) | 0, n = n + Math.imul(F2, ae2) | 0, n = n + Math.imul(U3, fe3) | 0, d4 = d4 + Math.imul(U3, ae2) | 0, l3 = l3 + Math.imul(C4, oe3) | 0, n = n + Math.imul(C4, se3) | 0, n = n + Math.imul(O4, oe3) | 0, d4 = d4 + Math.imul(O4, se3) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D3, he) | 0, d4 = d4 + Math.imul(D3, ue4) | 0, l3 = l3 + Math.imul(R4, le) | 0, n = n + Math.imul(R4, de) | 0, n = n + Math.imul(I5, le) | 0, d4 = d4 + Math.imul(I5, de) | 0, l3 = l3 + Math.imul(g5, ce3) | 0, n = n + Math.imul(g5, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X4), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X4) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V6, Q5) | 0, n = n + Math.imul(V6, ee) | 0, n = n + Math.imul($3, Q5) | 0, d4 = d4 + Math.imul($3, ee) | 0, l3 = l3 + Math.imul(j5, te2) | 0, n = n + Math.imul(j5, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne2) | 0, n = n + Math.imul(K5, ie) | 0, d4 = d4 + Math.imul(K5, ne2) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F2, oe3) | 0, n = n + Math.imul(F2, se3) | 0, n = n + Math.imul(U3, oe3) | 0, d4 = d4 + Math.imul(U3, se3) | 0, l3 = l3 + Math.imul(C4, he) | 0, n = n + Math.imul(C4, ue4) | 0, n = n + Math.imul(O4, he) | 0, d4 = d4 + Math.imul(O4, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D3, le) | 0, d4 = d4 + Math.imul(D3, de) | 0, l3 = l3 + Math.imul(R4, ce3) | 0, n = n + Math.imul(R4, pe2) | 0, n = n + Math.imul(I5, ce3) | 0, d4 = d4 + Math.imul(I5, pe2) | 0, l3 = l3 + Math.imul(g5, ve) | 0, n = n + Math.imul(g5, be2) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be2) | 0;
        var Ve = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q5), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q5) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V6, te2) | 0, n = n + Math.imul(V6, re2) | 0, n = n + Math.imul($3, te2) | 0, d4 = d4 + Math.imul($3, re2) | 0, l3 = l3 + Math.imul(j5, ie) | 0, n = n + Math.imul(j5, ne2) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne2) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K5, fe3) | 0, d4 = d4 + Math.imul(K5, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se3) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se3) | 0, l3 = l3 + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue4) | 0, n = n + Math.imul(U3, he) | 0, d4 = d4 + Math.imul(U3, ue4) | 0, l3 = l3 + Math.imul(C4, le) | 0, n = n + Math.imul(C4, de) | 0, n = n + Math.imul(O4, le) | 0, d4 = d4 + Math.imul(O4, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D3, ce3) | 0, d4 = d4 + Math.imul(D3, pe2) | 0, l3 = l3 + Math.imul(R4, ve) | 0, n = n + Math.imul(R4, be2) | 0, n = n + Math.imul(I5, ve) | 0, d4 = d4 + Math.imul(I5, be2) | 0;
        var $e2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V6, ie) | 0, n = n + Math.imul(V6, ne2) | 0, n = n + Math.imul($3, ie) | 0, d4 = d4 + Math.imul($3, ne2) | 0, l3 = l3 + Math.imul(j5, fe3) | 0, n = n + Math.imul(j5, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se3) | 0, n = n + Math.imul(K5, oe3) | 0, d4 = d4 + Math.imul(K5, se3) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U3, le) | 0, d4 = d4 + Math.imul(U3, de) | 0, l3 = l3 + Math.imul(C4, ce3) | 0, n = n + Math.imul(C4, pe2) | 0, n = n + Math.imul(O4, ce3) | 0, d4 = d4 + Math.imul(O4, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be2) | 0, n = n + Math.imul(D3, ve) | 0, d4 = d4 + Math.imul(D3, be2) | 0;
        var Ge = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne2), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne2), l3 = l3 + Math.imul(V6, fe3) | 0, n = n + Math.imul(V6, ae2) | 0, n = n + Math.imul($3, fe3) | 0, d4 = d4 + Math.imul($3, ae2) | 0, l3 = l3 + Math.imul(j5, oe3) | 0, n = n + Math.imul(j5, se3) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se3) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K5, he) | 0, d4 = d4 + Math.imul(K5, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F2, ce3) | 0, n = n + Math.imul(F2, pe2) | 0, n = n + Math.imul(U3, ce3) | 0, d4 = d4 + Math.imul(U3, pe2) | 0, l3 = l3 + Math.imul(C4, ve) | 0, n = n + Math.imul(C4, be2) | 0, n = n + Math.imul(O4, ve) | 0, d4 = d4 + Math.imul(O4, be2) | 0;
        var Ye = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V6, oe3) | 0, n = n + Math.imul(V6, se3) | 0, n = n + Math.imul($3, oe3) | 0, d4 = d4 + Math.imul($3, se3) | 0, l3 = l3 + Math.imul(j5, he) | 0, n = n + Math.imul(j5, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K5, le) | 0, d4 = d4 + Math.imul(K5, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be2) | 0, n = n + Math.imul(U3, ve) | 0, d4 = d4 + Math.imul(U3, be2) | 0;
        var Xe = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se3), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se3), l3 = l3 + Math.imul(V6, he) | 0, n = n + Math.imul(V6, ue4) | 0, n = n + Math.imul($3, he) | 0, d4 = d4 + Math.imul($3, ue4) | 0, l3 = l3 + Math.imul(j5, le) | 0, n = n + Math.imul(j5, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K5, ce3) | 0, d4 = d4 + Math.imul(K5, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be2) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be2) | 0;
        var Je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V6, le) | 0, n = n + Math.imul(V6, de) | 0, n = n + Math.imul($3, le) | 0, d4 = d4 + Math.imul($3, de) | 0, l3 = l3 + Math.imul(j5, ce3) | 0, n = n + Math.imul(j5, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be2) | 0, n = n + Math.imul(K5, ve) | 0, d4 = d4 + Math.imul(K5, be2) | 0;
        var Qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V6, ce3) | 0, n = n + Math.imul(V6, pe2) | 0, n = n + Math.imul($3, ce3) | 0, d4 = d4 + Math.imul($3, pe2) | 0, l3 = l3 + Math.imul(j5, ve) | 0, n = n + Math.imul(j5, be2) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be2) | 0;
        var et3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V6, ve) | 0, n = n + Math.imul(V6, be2) | 0, n = n + Math.imul($3, ve) | 0, d4 = d4 + Math.imul($3, be2) | 0;
        var tt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be2), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be2);
        var rt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b6 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft2, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et3, c2[17] = tt4, c2[18] = rt4, b6 !== 0 && (c2[19] = b6, h5.length++), h5;
      };
      Math.imul || (L4 = q3);
      function ge(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative, a3.length = v4.length + i.length;
        for (var h5 = 0, s3 = 0, u3 = 0;u3 < a3.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b6 = h5 & 67108863, l3 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v4.length + 1);n <= l3; n++) {
            var d4 = u3 - n, w3 = v4.words[d4] | 0, g5 = i.words[n] | 0, _4 = w3 * g5, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b6 | 0, b6 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u3] = b6, h5 = c2, c2 = s3;
        }
        return h5 !== 0 ? a3.words[u3] = h5 : a3.length--, a3.strip();
      }
      function _e3(v4, i, a3) {
        var h5 = new N6;
        return h5.mulp(v4, i, a3);
      }
      f3.prototype.mulTo = function(i, a3) {
        var h5, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h5 = L4(this, i, a3) : s3 < 63 ? h5 = q3(this, i, a3) : s3 < 1024 ? h5 = ge(this, i, a3) : h5 = _e3(this, i, a3), h5;
      };
      function N6(v4, i) {
        this.x = v4, this.y = i;
      }
      N6.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h5 = f3.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h5, i);
        return a3;
      }, N6.prototype.revBin = function(i, a3, h5) {
        if (i === 0 || i === h5 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a3; u3++)
          s3 |= (i & 1) << a3 - u3 - 1, i >>= 1;
        return s3;
      }, N6.prototype.permute = function(i, a3, h5, s3, u3, c2) {
        for (var b6 = 0;b6 < c2; b6++)
          s3[b6] = a3[i[b6]], u3[b6] = h5[i[b6]];
      }, N6.prototype.transform = function(i, a3, h5, s3, u3, c2) {
        this.permute(c2, i, a3, h5, s3, u3);
        for (var b6 = 1;b6 < u3; b6 <<= 1)
          for (var l3 = b6 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u3; w3 += l3)
            for (var g5 = n, _4 = d4, A4 = 0;A4 < b6; A4++) {
              var R4 = h5[w3 + A4], I5 = s3[w3 + A4], Me = h5[w3 + A4 + b6], k4 = s3[w3 + A4 + b6], D3 = g5 * Me - _4 * k4;
              k4 = g5 * k4 + _4 * Me, Me = D3, h5[w3 + A4] = R4 + Me, s3[w3 + A4] = I5 + k4, h5[w3 + A4 + b6] = R4 - Me, s3[w3 + A4 + b6] = I5 - k4, A4 !== l3 && (D3 = n * g5 - d4 * _4, _4 = n * _4 + d4 * g5, g5 = D3);
            }
      }, N6.prototype.guessLen13b = function(i, a3) {
        var h5 = Math.max(a3, i) | 1, s3 = h5 & 1, u3 = 0;
        for (h5 = h5 / 2 | 0;h5; h5 = h5 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N6.prototype.conjugate = function(i, a3, h5) {
        if (!(h5 <= 1))
          for (var s3 = 0;s3 < h5 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h5 - s3 - 1], i[h5 - s3 - 1] = u3, u3 = a3[s3], a3[s3] = -a3[h5 - s3 - 1], a3[h5 - s3 - 1] = -u3;
          }
      }, N6.prototype.normalize13b = function(i, a3) {
        for (var h5 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h5;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h5 = 0 : h5 = u3 / 67108864 | 0;
        }
        return i;
      }, N6.prototype.convert13b = function(i, a3, h5, s3) {
        for (var u3 = 0, c2 = 0;c2 < a3; c2++)
          u3 = u3 + (i[c2] | 0), h5[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h5[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h5[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N6.prototype.stub = function(i) {
        for (var a3 = new Array(i), h5 = 0;h5 < i; h5++)
          a3[h5] = 0;
        return a3;
      }, N6.prototype.mulp = function(i, a3, h5) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b6 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d4 = new Array(s3), w3 = new Array(s3), g5 = new Array(s3), _4 = h5.words;
        _4.length = s3, this.convert13b(i.words, i.length, b6, s3), this.convert13b(a3.words, a3.length, d4, s3), this.transform(b6, c2, l3, n, s3, u3), this.transform(d4, c2, w3, g5, s3, u3);
        for (var A4 = 0;A4 < s3; A4++) {
          var R4 = l3[A4] * w3[A4] - n[A4] * g5[A4];
          n[A4] = l3[A4] * g5[A4] + n[A4] * w3[A4], l3[A4] = R4;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _4, c2, s3, u3), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h5.negative = i.negative ^ a3.negative, h5.length = i.length + a3.length, h5.strip();
      }, f3.prototype.mul = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f3.prototype.mulf = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f3.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f3.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h5 = 0;h5 < this.length; h5++) {
          var s3 = (this.words[h5] | 0) * i, u3 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u3 >>> 26, this.words[h5] = u3 & 67108863;
        }
        return a3 !== 0 && (this.words[h5] = a3, this.length++), this;
      }, f3.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f3(1);
        for (var h5 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h5 = h5.sqr())
          ;
        if (++s3 < a3.length)
          for (var u3 = h5.sqr();s3 < a3.length; s3++, u3 = u3.sqr())
            a3[s3] !== 0 && (h5 = h5.mul(u3));
        return h5;
      }, f3.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u3;
        if (a3 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b6 = this.words[u3] & s3, l3 = (this.words[u3] | 0) - b6 << a3;
            this.words[u3] = l3 | c2, c2 = b6 >>> 26 - a3;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h5 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h5] = this.words[u3];
          for (u3 = 0;u3 < h5; u3++)
            this.words[u3] = 0;
          this.length += h5;
        }
        return this.strip();
      }, f3.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f3.prototype.iushrn = function(i, a3, h5) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b6 = 67108863 ^ 67108863 >>> u3 << u3, l3 = h5;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u3 | w3 >>> u3, d4 = w3 & b6;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f3.prototype.ishrn = function(i, a3, h5) {
        return r(this.negative === 0), this.iushrn(i, a3, h5);
      }, f3.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f3.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f3.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f3.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f3.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return false;
        var u3 = this.words[h5];
        return !!(u3 & s3);
      }, f3.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h5)
          return this;
        if (a3 !== 0 && h5++, this.length = Math.min(h5, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f3.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f3.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f3.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f3.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f3.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f3.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(i, a3, h5) {
        var s3 = i.length + h5, u3;
        this._expand(s3);
        var c2, b6 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h5] | 0) + b6;
          var l3 = (i.words[u3] | 0) * a3;
          c2 -= l3 & 67108863, b6 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u3 + h5] = c2 & 67108863;
        }
        for (;u3 < this.length - h5; u3++)
          c2 = (this.words[u3 + h5] | 0) + b6, b6 = c2 >> 26, this.words[u3 + h5] = c2 & 67108863;
        if (b6 === 0)
          return this.strip();
        for (r(b6 === -1), b6 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b6, b6 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f3.prototype._wordDiv = function(i, a3) {
        var h5 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b6 = this._countBits(c2);
        h5 = 26 - b6, h5 !== 0 && (u3 = u3.ushln(h5), s3.iushln(h5), c2 = u3.words[u3.length - 1] | 0);
        var l3 = s3.length - u3.length, n;
        if (a3 !== "mod") {
          n = new f3(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u3, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g5 = l3 - 1;g5 >= 0; g5--) {
          var _4 = (s3.words[u3.length + g5] | 0) * 67108864 + (s3.words[u3.length + g5 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _4, g5);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g5), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g5] = _4);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h5 !== 0 && s3.iushrn(h5), { div: n || null, mod: s3 };
      }, f3.prototype.divmod = function(i, a3, h5) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f3(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f3(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f3(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f3.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f3.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f3.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f3.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h5 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h5.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f3.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h5 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h5 = (a3 * h5 + (this.words[s3] | 0)) % i;
        return h5;
      }, f3.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = (this.words[h5] | 0) + a3 * 67108864;
          this.words[h5] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f3.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f3.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = new f3(0), b6 = new f3(1), l3 = 0;a3.isEven() && h5.isEven(); )
          a3.iushrn(1), h5.iushrn(1), ++l3;
        for (var n = h5.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g5 = 1;(a3.words[0] & g5) === 0 && w3 < 26; ++w3, g5 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d4)), s3.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A4 = 1;(h5.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h5.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b6.isOdd()) && (c2.iadd(n), b6.isub(d4)), c2.iushrn(1), b6.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(c2), u3.isub(b6)) : (h5.isub(a3), c2.isub(s3), b6.isub(u3));
        }
        return { a: c2, b: b6, gcd: h5.iushln(l3) };
      }, f3.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = h5.clone();a3.cmpn(1) > 0 && h5.cmpn(1) > 0; ) {
          for (var b6 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b6 < 26; ++b6, l3 <<= 1)
            ;
          if (b6 > 0)
            for (a3.iushrn(b6);b6-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d4 = 1;(h5.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h5.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(u3)) : (h5.isub(a3), u3.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u3, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f3.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h5 = i.clone();
        a3.negative = 0, h5.negative = 0;
        for (var s3 = 0;a3.isEven() && h5.isEven(); s3++)
          a3.iushrn(1), h5.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h5.isEven(); )
            h5.iushrn(1);
          var u3 = a3.cmp(h5);
          if (u3 < 0) {
            var c2 = a3;
            a3 = h5, h5 = c2;
          } else if (u3 === 0 || h5.cmpn(1) === 0)
            break;
          a3.isub(h5);
        } while (true);
        return h5.iushln(s3);
      }, f3.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f3.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return this._expand(h5 + 1), this.words[h5] |= s3, this;
        for (var u3 = s3, c2 = h5;u3 !== 0 && c2 < this.length; c2++) {
          var b6 = this.words[c2] | 0;
          b6 += u3, u3 = b6 >>> 26, b6 &= 67108863, this.words[c2] = b6;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h5;
        if (this.length > 1)
          h5 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h5 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h5 | 0 : h5;
      }, f3.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f3.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = this.words[h5] | 0, u3 = i.words[h5] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a3 = -1 : s3 > u3 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f3.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f3.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f3.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f3.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f3.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f3.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f3.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f3.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f3.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f3.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f3.red = function(i) {
        return new P4(i);
      }, f3.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f3.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f3.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f3.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f3.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f3.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f3.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f3.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f3.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye2(v4, i) {
        this.name = v4, this.p = new f3(i, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye2.prototype._tmp = function() {
        var i = new f3(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye2.prototype.ireduce = function(i) {
        var a3 = i, h5;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h5 = a3.bitLength();
        while (h5 > this.n);
        var s3 = h5 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye2.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye2.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe2() {
        ye2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe2, ye2), xe2.prototype.split = function(i, a3) {
        for (var h5 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a3.words[u3] = i.words[u3];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h5, u3 = 10;u3 < i.length; u3++) {
          var b6 = i.words[u3] | 0;
          i.words[u3 - 10] = (b6 & h5) << 4 | c2 >>> 22, c2 = b6;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe2.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = i.words[h5] | 0;
          a3 += s3 * 977, i.words[h5] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye2);
      function Ee() {
        ye2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye2);
      function Ae2() {
        ye2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye2), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = (i.words[h5] | 0) * 19 + a3, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h5] = u3, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f3._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe2;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P4(v4) {
        if (typeof v4 == "string") {
          var i = f3._prime(v4);
          this.m = i.p, this.prime = i;
        } else
          r(v4.gtn(1), "modulus must be greater than 1"), this.m = v4, this.prime = null;
      }
      P4.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P4.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P4.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P4.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P4.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.add(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5._forceRed(this);
      }, P4.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.iadd(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5;
      }, P4.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.sub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5._forceRed(this);
      }, P4.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.isub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5;
      }, P4.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P4.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P4.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P4.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P4.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P4.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h5 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(i, h5);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f3(1).toRed(this), b6 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f3(2 * n * n).toRed(this);this.pow(n, l3).cmp(b6) !== 0; )
          n.redIAdd(b6);
        for (var d4 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g5 = this.pow(i, s3), _4 = u3;g5.cmp(c2) !== 0; ) {
          for (var A4 = g5, R4 = 0;A4.cmp(c2) !== 0; R4++)
            A4 = A4.redSqr();
          r(R4 < _4);
          var I5 = this.pow(d4, new f3(1).iushln(_4 - R4 - 1));
          w3 = w3.redMul(I5), d4 = I5.redSqr(), g5 = g5.redMul(d4), _4 = R4;
        }
        return w3;
      }, P4.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P4.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f3(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h5 = 4, s3 = new Array(1 << h5);
        s3[0] = new f3(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b6 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a3.length - 1;u3 >= 0; u3--) {
          for (var d4 = a3.words[u3], w3 = n - 1;w3 >= 0; w3--) {
            var g5 = d4 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g5 === 0 && b6 === 0) {
              l3 = 0;
              continue;
            }
            b6 <<= 1, b6 |= g5, l3++, !(l3 !== h5 && (u3 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b6]), l3 = 0, b6 = 0);
          }
          n = 26;
        }
        return c2;
      }, P4.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P4.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f3.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v4) {
        P4.call(this, v4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P4), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h5 = i.imul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f3(0)._forceRed(this);
        var h5 = i.mul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h22);
  });
  Nl = T3((d22) => {
    var js2 = d22;
    function uA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o2 = 0;o2 < t.length; o2++)
          r[o2] = t[o2] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o2 = 0;o2 < t.length; o2 += 2)
          r.push(parseInt(t[o2] + t[o2 + 1], 16));
      } else
        for (var o2 = 0;o2 < t.length; o2++) {
          var f3 = t.charCodeAt(o2), p3 = f3 >> 8, m3 = f3 & 255;
          p3 ? r.push(p3, m3) : r.push(m3);
        }
      return r;
    }
    js2.toArray = uA;
    function u22(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js2.zero2 = u22;
    function l22(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += u22(t[r].toString(16));
      return e;
    }
    js2.toHex = l22;
    js2.encode = function(e, r) {
      return r === "hex" ? l22(e) : e;
    };
  });
  or = T3((c2) => {
    var Pr = c2, lA = ri3(), dA = ar2(), Zs2 = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs2.toArray;
    Pr.zero2 = Zs2.zero2;
    Pr.toHex = Zs2.toHex;
    Pr.encode = Zs2.encode;
    function cA(t, e, r) {
      var o2 = new Array(Math.max(t.bitLength(), r) + 1);
      o2.fill(0);
      for (var f3 = 1 << e + 1, p3 = t.clone(), m3 = 0;m3 < o2.length; m3++) {
        var y5, M3 = p3.andln(f3 - 1);
        p3.isOdd() ? (M3 > (f3 >> 1) - 1 ? y5 = (f3 >> 1) - M3 : y5 = M3, p3.isubn(y5)) : y5 = 0, o2[m3] = y5, p3.iushrn(1);
      }
      return o2;
    }
    Pr.getNAF = cA;
    function pA(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o2 = 0, f3 = 0, p3;t.cmpn(-o2) > 0 || e.cmpn(-f3) > 0; ) {
        var m3 = t.andln(3) + o2 & 3, y5 = e.andln(3) + f3 & 3;
        m3 === 3 && (m3 = -1), y5 === 3 && (y5 = -1);
        var M3;
        (m3 & 1) === 0 ? M3 = 0 : (p3 = t.andln(7) + o2 & 7, (p3 === 3 || p3 === 5) && y5 === 2 ? M3 = -m3 : M3 = m3), r[0].push(M3);
        var x5;
        (y5 & 1) === 0 ? x5 = 0 : (p3 = e.andln(7) + f3 & 7, (p3 === 3 || p3 === 5) && m3 === 2 ? x5 = -y5 : x5 = y5), r[1].push(x5), 2 * o2 === M3 + 1 && (o2 = 1 - o2), 2 * f3 === x5 + 1 && (f3 = 1 - f3), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e, r) {
      var o2 = "_" + e;
      t.prototype[e] = function() {
        return this[o2] !== undefined ? this[o2] : this[o2] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T3((xk, p22) => {
    var Cn = ri3(), Ca = or(), Vs2 = Ca.getNAF, gA = Ca.getJSF, $s2 = Ca.assert;
    function Xi2(t, e) {
      this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p22.exports = Xi2;
    Xi2.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi2.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi2.prototype._fixedNafMul = function(e, r) {
      $s2(e.precomputed);
      var o2 = e._getDoubles(), f3 = Vs2(r, 1, this._bitLength), p3 = (1 << o2.step + 1) - (o2.step % 2 === 0 ? 2 : 1);
      p3 /= 3;
      var m3 = [], y5, M3;
      for (y5 = 0;y5 < f3.length; y5 += o2.step) {
        M3 = 0;
        for (var x5 = y5 + o2.step - 1;x5 >= y5; x5--)
          M3 = (M3 << 1) + f3[x5];
        m3.push(M3);
      }
      for (var S3 = this.jpoint(null, null, null), E6 = this.jpoint(null, null, null), B3 = p3;B3 > 0; B3--) {
        for (y5 = 0;y5 < m3.length; y5++)
          M3 = m3[y5], M3 === B3 ? E6 = E6.mixedAdd(o2.points[y5]) : M3 === -B3 && (E6 = E6.mixedAdd(o2.points[y5].neg()));
        S3 = S3.add(E6);
      }
      return S3.toP();
    };
    Xi2.prototype._wnafMul = function(e, r) {
      var o2 = 4, f3 = e._getNAFPoints(o2);
      o2 = f3.wnd;
      for (var p3 = f3.points, m3 = Vs2(r, o2, this._bitLength), y5 = this.jpoint(null, null, null), M3 = m3.length - 1;M3 >= 0; M3--) {
        for (var x5 = 0;M3 >= 0 && m3[M3] === 0; M3--)
          x5++;
        if (M3 >= 0 && x5++, y5 = y5.dblp(x5), M3 < 0)
          break;
        var S3 = m3[M3];
        $s2(S3 !== 0), e.type === "affine" ? S3 > 0 ? y5 = y5.mixedAdd(p3[S3 - 1 >> 1]) : y5 = y5.mixedAdd(p3[-S3 - 1 >> 1].neg()) : S3 > 0 ? y5 = y5.add(p3[S3 - 1 >> 1]) : y5 = y5.add(p3[-S3 - 1 >> 1].neg());
      }
      return e.type === "affine" ? y5.toP() : y5;
    };
    Xi2.prototype._wnafMulAdd = function(e, r, o2, f3, p3) {
      var m3 = this._wnafT1, y5 = this._wnafT2, M3 = this._wnafT3, x5 = 0, S3, E6, B3;
      for (S3 = 0;S3 < f3; S3++) {
        B3 = r[S3];
        var q3 = B3._getNAFPoints(e);
        m3[S3] = q3.wnd, y5[S3] = q3.points;
      }
      for (S3 = f3 - 1;S3 >= 1; S3 -= 2) {
        var L4 = S3 - 1, ge = S3;
        if (m3[L4] !== 1 || m3[ge] !== 1) {
          M3[L4] = Vs2(o2[L4], m3[L4], this._bitLength), M3[ge] = Vs2(o2[ge], m3[ge], this._bitLength), x5 = Math.max(M3[L4].length, x5), x5 = Math.max(M3[ge].length, x5);
          continue;
        }
        var _e3 = [r[L4], null, null, r[ge]];
        r[L4].y.cmp(r[ge].y) === 0 ? (_e3[1] = r[L4].add(r[ge]), _e3[2] = r[L4].toJ().mixedAdd(r[ge].neg())) : r[L4].y.cmp(r[ge].y.redNeg()) === 0 ? (_e3[1] = r[L4].toJ().mixedAdd(r[ge]), _e3[2] = r[L4].add(r[ge].neg())) : (_e3[1] = r[L4].toJ().mixedAdd(r[ge]), _e3[2] = r[L4].toJ().mixedAdd(r[ge].neg()));
        var N6 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o2[L4], o2[ge]);
        for (x5 = Math.max(we[0].length, x5), M3[L4] = new Array(x5), M3[ge] = new Array(x5), E6 = 0;E6 < x5; E6++) {
          var ye2 = we[0][E6] | 0, xe2 = we[1][E6] | 0;
          M3[L4][E6] = N6[(ye2 + 1) * 3 + (xe2 + 1)], M3[ge][E6] = 0, y5[L4] = _e3;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S3 = x5;S3 >= 0; S3--) {
        for (var Ae2 = 0;S3 >= 0; ) {
          var P4 = true;
          for (E6 = 0;E6 < f3; E6++)
            Ee[E6] = M3[E6][S3] | 0, Ee[E6] !== 0 && (P4 = false);
          if (!P4)
            break;
          Ae2++, S3--;
        }
        if (S3 >= 0 && Ae2++, Re = Re.dblp(Ae2), S3 < 0)
          break;
        for (E6 = 0;E6 < f3; E6++) {
          var Se3 = Ee[E6];
          Se3 !== 0 && (Se3 > 0 ? B3 = y5[E6][Se3 - 1 >> 1] : Se3 < 0 && (B3 = y5[E6][-Se3 - 1 >> 1].neg()), B3.type === "affine" ? Re = Re.mixedAdd(B3) : Re = Re.add(B3));
        }
      }
      for (S3 = 0;S3 < f3; S3++)
        y5[S3] = null;
      return p3 ? Re : Re.toP();
    };
    function _r3(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Xi2.BasePoint = _r3;
    _r3.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r3.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi2.prototype.decodePoint = function(e, r) {
      e = Ca.toArray(e, r);
      var o2 = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o2) {
        e[0] === 6 ? $s2(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s2(e[e.length - 1] % 2 === 1);
        var f3 = this.point(e.slice(1, 1 + o2), e.slice(1 + o2, 1 + 2 * o2));
        return f3;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o2)
        return this.pointFromX(e.slice(1, 1 + o2), e[0] === 3);
      throw new Error("Unknown point format");
    };
    _r3.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    _r3.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o2 = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o2) : [4].concat(o2, this.getY().toArray("be", r));
    };
    _r3.prototype.encode = function(e, r) {
      return Ca.encode(this._encode(r), e);
    };
    _r3.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r3.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    _r3.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o2 = [this], f3 = this, p3 = 0;p3 < r; p3 += e) {
        for (var m3 = 0;m3 < e; m3++)
          f3 = f3.dbl();
        o2.push(f3);
      }
      return { step: e, points: o2 };
    };
    _r3.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o2 = (1 << e) - 1, f3 = o2 === 1 ? null : this.dbl(), p3 = 1;p3 < o2; p3++)
        r[p3] = r[p3 - 1].add(f3);
      return { wnd: e, points: r };
    };
    _r3.prototype._getBeta = function() {
      return null;
    };
    _r3.prototype.dblp = function(e) {
      for (var r = this, o2 = 0;o2 < e; o2++)
        r = r.dbl();
      return r;
    };
  });
  b22 = T3((Sk, v22) => {
    var yA = or(), lt3 = ri3(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr2(t) {
      Bf.call(this, "short", t), this.a = new lt3(t.a, 16).toRed(this.red), this.b = new lt3(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr2, Bf);
    v22.exports = xr2;
    xr2.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o2;
        if (e.beta)
          r = new lt3(e.beta, 16).toRed(this.red);
        else {
          var f3 = this._getEndoRoots(this.p);
          r = f3[0].cmp(f3[1]) < 0 ? f3[0] : f3[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o2 = new lt3(e.lambda, 16);
        else {
          var p3 = this._getEndoRoots(this.n);
          this.g.mul(p3[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o2 = p3[0] : (o2 = p3[1], wA(this.g.mul(o2).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m3;
        return e.basis ? m3 = e.basis.map(function(y5) {
          return { a: new lt3(y5.a, 16), b: new lt3(y5.b, 16) };
        }) : m3 = this._getEndoBasis(o2), { beta: r, lambda: o2, basis: m3 };
      }
    };
    xr2.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt3.mont(e), o2 = new lt3(2).toRed(r).redInvm(), f3 = o2.redNeg(), p3 = new lt3(3).toRed(r).redNeg().redSqrt().redMul(o2), m3 = f3.redAdd(p3).fromRed(), y5 = f3.redSub(p3).fromRed();
      return [m3, y5];
    };
    xr2.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o2 = e, f3 = this.n.clone(), p3 = new lt3(1), m3 = new lt3(0), y5 = new lt3(0), M3 = new lt3(1), x5, S3, E6, B3, q3, L4, ge, _e3 = 0, N6, we;o2.cmpn(0) !== 0; ) {
        var ye2 = f3.div(o2);
        N6 = f3.sub(ye2.mul(o2)), we = y5.sub(ye2.mul(p3));
        var xe2 = M3.sub(ye2.mul(m3));
        if (!E6 && N6.cmp(r) < 0)
          x5 = ge.neg(), S3 = p3, E6 = N6.neg(), B3 = we;
        else if (E6 && ++_e3 === 2)
          break;
        ge = N6, f3 = o2, o2 = N6, y5 = p3, p3 = we, M3 = m3, m3 = xe2;
      }
      q3 = N6.neg(), L4 = we;
      var Re = E6.sqr().add(B3.sqr()), Ee = q3.sqr().add(L4.sqr());
      return Ee.cmp(Re) >= 0 && (q3 = x5, L4 = S3), E6.negative && (E6 = E6.neg(), B3 = B3.neg()), q3.negative && (q3 = q3.neg(), L4 = L4.neg()), [{ a: E6, b: B3 }, { a: q3, b: L4 }];
    };
    xr2.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o2 = r[0], f3 = r[1], p3 = f3.b.mul(e).divRound(this.n), m3 = o2.b.neg().mul(e).divRound(this.n), y5 = p3.mul(o2.a), M3 = m3.mul(f3.a), x5 = p3.mul(o2.b), S3 = m3.mul(f3.b), E6 = e.sub(y5).sub(M3), B3 = x5.add(S3).neg();
      return { k1: E6, k2: B3 };
    };
    xr2.prototype.pointFromX = function(e, r) {
      e = new lt3(e, 16), e.red || (e = e.toRed(this.red));
      var o2 = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f3 = o2.redSqrt();
      if (f3.redSqr().redSub(o2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p3 = f3.fromRed().isOdd();
      return (r && !p3 || !r && p3) && (f3 = f3.redNeg()), this.point(e, f3);
    };
    xr2.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o2 } = e, f3 = this.a.redMul(r), p3 = r.redSqr().redMul(r).redIAdd(f3).redIAdd(this.b);
      return o2.redSqr().redISub(p3).cmpn(0) === 0;
    };
    xr2.prototype._endoWnafMulAdd = function(e, r, o2) {
      for (var f3 = this._endoWnafT1, p3 = this._endoWnafT2, m3 = 0;m3 < e.length; m3++) {
        var y5 = this._endoSplit(r[m3]), M3 = e[m3], x5 = M3._getBeta();
        y5.k1.negative && (y5.k1.ineg(), M3 = M3.neg(true)), y5.k2.negative && (y5.k2.ineg(), x5 = x5.neg(true)), f3[m3 * 2] = M3, f3[m3 * 2 + 1] = x5, p3[m3 * 2] = y5.k1, p3[m3 * 2 + 1] = y5.k2;
      }
      for (var S3 = this._wnafMulAdd(1, f3, p3, m3 * 2, o2), E6 = 0;E6 < m3 * 2; E6++)
        f3[E6] = null, p3[E6] = null;
      return S3;
    };
    function Ct(t, e, r, o2) {
      Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt3(e, 16), this.y = new lt3(r, 16), o2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr2.prototype.point = function(e, r, o2) {
      return new Ct(this, e, r, o2);
    };
    xr2.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o2 = this.curve, f3 = function(p3) {
            return o2.point(p3.x.redMul(o2.endo.beta), p3.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f3) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f3) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o2) {
      typeof r == "string" && (r = JSON.parse(r));
      var f3 = e.point(r[0], r[1], o2);
      if (!r[2])
        return f3;
      function p3(y5) {
        return e.point(y5[0], y5[1], o2);
      }
      var m3 = r[2];
      return f3.precomputed = { beta: null, doubles: m3.doubles && { step: m3.doubles.step, points: [f3].concat(m3.doubles.points.map(p3)) }, naf: m3.naf && { wnd: m3.naf.wnd, points: [f3].concat(m3.naf.points.map(p3)) } }, f3;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o2 = r.redSqr().redISub(this.x).redISub(e.x), f3 = r.redMul(this.x.redSub(o2)).redISub(this.y);
      return this.curve.point(o2, f3);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o2 = this.x.redSqr(), f3 = e.redInvm(), p3 = o2.redAdd(o2).redIAdd(o2).redIAdd(r).redMul(f3), m3 = p3.redSqr().redISub(this.x.redAdd(this.x)), y5 = p3.redMul(this.x.redSub(m3)).redISub(this.y);
      return this.curve.point(m3, y5);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt3(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o2) {
      var f3 = [this, r], p3 = [e, o2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f3, p3) : this.curve._wnafMulAdd(1, f3, p3, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o2) {
      var f3 = [this, r], p3 = [e, o2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f3, p3, true) : this.curve._wnafMulAdd(1, f3, p3, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o2 = this.precomputed, f3 = function(p3) {
          return p3.neg();
        };
        r.precomputed = { naf: o2.naf && { wnd: o2.naf.wnd, points: o2.naf.points.map(f3) }, doubles: o2.doubles && { step: o2.doubles.step, points: o2.doubles.points.map(f3) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt2(t, e, r, o2) {
      Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt3(0)) : (this.x = new lt3(e, 16), this.y = new lt3(r, 16), this.z = new lt3(o2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt2, Bf.BasePoint);
    xr2.prototype.jpoint = function(e, r, o2) {
      return new Wt2(this, e, r, o2);
    };
    Wt2.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o2 = this.x.redMul(r), f3 = this.y.redMul(r).redMul(e);
      return this.curve.point(o2, f3);
    };
    Wt2.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt2.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o2 = this.z.redSqr(), f3 = this.x.redMul(r), p3 = e.x.redMul(o2), m3 = this.y.redMul(r.redMul(e.z)), y5 = e.y.redMul(o2.redMul(this.z)), M3 = f3.redSub(p3), x5 = m3.redSub(y5);
      if (M3.cmpn(0) === 0)
        return x5.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S3 = M3.redSqr(), E6 = S3.redMul(M3), B3 = f3.redMul(S3), q3 = x5.redSqr().redIAdd(E6).redISub(B3).redISub(B3), L4 = x5.redMul(B3.redISub(q3)).redISub(m3.redMul(E6)), ge = this.z.redMul(e.z).redMul(M3);
      return this.curve.jpoint(q3, L4, ge);
    };
    Wt2.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o2 = this.x, f3 = e.x.redMul(r), p3 = this.y, m3 = e.y.redMul(r).redMul(this.z), y5 = o2.redSub(f3), M3 = p3.redSub(m3);
      if (y5.cmpn(0) === 0)
        return M3.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x5 = y5.redSqr(), S3 = x5.redMul(y5), E6 = o2.redMul(x5), B3 = M3.redSqr().redIAdd(S3).redISub(E6).redISub(E6), q3 = M3.redMul(E6.redISub(B3)).redISub(p3.redMul(S3)), L4 = this.z.redMul(y5);
      return this.curve.jpoint(B3, q3, L4);
    };
    Wt2.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o2 = this;
        for (r = 0;r < e; r++)
          o2 = o2.dbl();
        return o2;
      }
      var f3 = this.curve.a, p3 = this.curve.tinv, m3 = this.x, y5 = this.y, M3 = this.z, x5 = M3.redSqr().redSqr(), S3 = y5.redAdd(y5);
      for (r = 0;r < e; r++) {
        var E6 = m3.redSqr(), B3 = S3.redSqr(), q3 = B3.redSqr(), L4 = E6.redAdd(E6).redIAdd(E6).redIAdd(f3.redMul(x5)), ge = m3.redMul(B3), _e3 = L4.redSqr().redISub(ge.redAdd(ge)), N6 = ge.redISub(_e3), we = L4.redMul(N6);
        we = we.redIAdd(we).redISub(q3);
        var ye2 = S3.redMul(M3);
        r + 1 < e && (x5 = x5.redMul(q3)), m3 = _e3, M3 = ye2, S3 = we;
      }
      return this.curve.jpoint(m3, S3.redMul(p3), M3);
    };
    Wt2.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt2.prototype._zeroDbl = function() {
      var e, r, o2;
      if (this.zOne) {
        var f3 = this.x.redSqr(), p3 = this.y.redSqr(), m3 = p3.redSqr(), y5 = this.x.redAdd(p3).redSqr().redISub(f3).redISub(m3);
        y5 = y5.redIAdd(y5);
        var M3 = f3.redAdd(f3).redIAdd(f3), x5 = M3.redSqr().redISub(y5).redISub(y5), S3 = m3.redIAdd(m3);
        S3 = S3.redIAdd(S3), S3 = S3.redIAdd(S3), e = x5, r = M3.redMul(y5.redISub(x5)).redISub(S3), o2 = this.y.redAdd(this.y);
      } else {
        var E6 = this.x.redSqr(), B3 = this.y.redSqr(), q3 = B3.redSqr(), L4 = this.x.redAdd(B3).redSqr().redISub(E6).redISub(q3);
        L4 = L4.redIAdd(L4);
        var ge = E6.redAdd(E6).redIAdd(E6), _e3 = ge.redSqr(), N6 = q3.redIAdd(q3);
        N6 = N6.redIAdd(N6), N6 = N6.redIAdd(N6), e = _e3.redISub(L4).redISub(L4), r = ge.redMul(L4.redISub(e)).redISub(N6), o2 = this.y.redMul(this.z), o2 = o2.redIAdd(o2);
      }
      return this.curve.jpoint(e, r, o2);
    };
    Wt2.prototype._threeDbl = function() {
      var e, r, o2;
      if (this.zOne) {
        var f3 = this.x.redSqr(), p3 = this.y.redSqr(), m3 = p3.redSqr(), y5 = this.x.redAdd(p3).redSqr().redISub(f3).redISub(m3);
        y5 = y5.redIAdd(y5);
        var M3 = f3.redAdd(f3).redIAdd(f3).redIAdd(this.curve.a), x5 = M3.redSqr().redISub(y5).redISub(y5);
        e = x5;
        var S3 = m3.redIAdd(m3);
        S3 = S3.redIAdd(S3), S3 = S3.redIAdd(S3), r = M3.redMul(y5.redISub(x5)).redISub(S3), o2 = this.y.redAdd(this.y);
      } else {
        var E6 = this.z.redSqr(), B3 = this.y.redSqr(), q3 = this.x.redMul(B3), L4 = this.x.redSub(E6).redMul(this.x.redAdd(E6));
        L4 = L4.redAdd(L4).redIAdd(L4);
        var ge = q3.redIAdd(q3);
        ge = ge.redIAdd(ge);
        var _e3 = ge.redAdd(ge);
        e = L4.redSqr().redISub(_e3), o2 = this.y.redAdd(this.z).redSqr().redISub(B3).redISub(E6);
        var N6 = B3.redSqr();
        N6 = N6.redIAdd(N6), N6 = N6.redIAdd(N6), N6 = N6.redIAdd(N6), r = L4.redMul(ge.redISub(e)).redISub(N6);
      }
      return this.curve.jpoint(e, r, o2);
    };
    Wt2.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o2 = this.y, f3 = this.z, p3 = f3.redSqr().redSqr(), m3 = r.redSqr(), y5 = o2.redSqr(), M3 = m3.redAdd(m3).redIAdd(m3).redIAdd(e.redMul(p3)), x5 = r.redAdd(r);
      x5 = x5.redIAdd(x5);
      var S3 = x5.redMul(y5), E6 = M3.redSqr().redISub(S3.redAdd(S3)), B3 = S3.redISub(E6), q3 = y5.redSqr();
      q3 = q3.redIAdd(q3), q3 = q3.redIAdd(q3), q3 = q3.redIAdd(q3);
      var L4 = M3.redMul(B3).redISub(q3), ge = o2.redAdd(o2).redMul(f3);
      return this.curve.jpoint(E6, L4, ge);
    };
    Wt2.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o2 = this.z.redSqr(), f3 = r.redSqr(), p3 = e.redAdd(e).redIAdd(e), m3 = p3.redSqr(), y5 = this.x.redAdd(r).redSqr().redISub(e).redISub(f3);
      y5 = y5.redIAdd(y5), y5 = y5.redAdd(y5).redIAdd(y5), y5 = y5.redISub(m3);
      var M3 = y5.redSqr(), x5 = f3.redIAdd(f3);
      x5 = x5.redIAdd(x5), x5 = x5.redIAdd(x5), x5 = x5.redIAdd(x5);
      var S3 = p3.redIAdd(y5).redSqr().redISub(m3).redISub(M3).redISub(x5), E6 = r.redMul(S3);
      E6 = E6.redIAdd(E6), E6 = E6.redIAdd(E6);
      var B3 = this.x.redMul(M3).redISub(E6);
      B3 = B3.redIAdd(B3), B3 = B3.redIAdd(B3);
      var q3 = this.y.redMul(S3.redMul(x5.redISub(S3)).redISub(y5.redMul(M3)));
      q3 = q3.redIAdd(q3), q3 = q3.redIAdd(q3), q3 = q3.redIAdd(q3);
      var L4 = this.z.redAdd(y5).redSqr().redISub(o2).redISub(M3);
      return this.curve.jpoint(B3, q3, L4);
    };
    Wt2.prototype.mul = function(e, r) {
      return e = new lt3(e, r), this.curve._wnafMul(this, e);
    };
    Wt2.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o2 = e.z.redSqr();
      if (this.x.redMul(o2).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f3 = r.redMul(this.z), p3 = o2.redMul(e.z);
      return this.y.redMul(p3).redISub(e.y.redMul(f3)).cmpn(0) === 0;
    };
    Wt2.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o2 = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o2) === 0)
        return true;
      for (var f3 = e.clone(), p3 = this.curve.redN.redMul(r);; ) {
        if (f3.iadd(this.curve.n), f3.cmp(this.curve.p) >= 0)
          return false;
        if (o2.redIAdd(p3), this.x.cmp(o2) === 0)
          return true;
      }
    };
    Wt2.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt2.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y22 = T3((Ek, g22) => {
    var qf = ri3(), m22 = Ie(), Gs2 = Oa(), MA = or();
    function If(t) {
      Gs2.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m22(If, Gs2);
    g22.exports = If;
    If.prototype.validate = function(e) {
      var r = e.normalize().x, o2 = r.redSqr(), f3 = o2.redMul(r).redAdd(o2.redMul(this.a)).redAdd(r), p3 = f3.redSqrt();
      return p3.redSqr().cmp(f3) === 0;
    };
    function Ot(t, e, r) {
      Gs2.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m22(Ot, Gs2.BasePoint);
    If.prototype.decodePoint = function(e, r) {
      return this.point(MA.toArray(e, r), 1);
    };
    If.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    If.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o2 = this.x.redSub(this.z), f3 = o2.redSqr(), p3 = r.redSub(f3), m3 = r.redMul(f3), y5 = p3.redMul(f3.redAdd(this.curve.a24.redMul(p3)));
      return this.curve.point(m3, y5);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o2 = this.x.redAdd(this.z), f3 = this.x.redSub(this.z), p3 = e.x.redAdd(e.z), m3 = e.x.redSub(e.z), y5 = m3.redMul(o2), M3 = p3.redMul(f3), x5 = r.z.redMul(y5.redAdd(M3).redSqr()), S3 = r.x.redMul(y5.redISub(M3).redSqr());
      return this.curve.point(x5, S3);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o2 = this, f3 = this.curve.point(null, null), p3 = this, m3 = [];r.cmpn(0) !== 0; r.iushrn(1))
        m3.push(r.andln(1));
      for (var y5 = m3.length - 1;y5 >= 0; y5--)
        m3[y5] === 0 ? (o2 = o2.diffAdd(f3, p3), f3 = f3.dbl()) : (f3 = o2.diffAdd(f3, p3), o2 = o2.dbl());
      return f3;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _22 = T3((Ak, M22) => {
    var _A = or(), Ai3 = ri3(), w22 = Ie(), Ys3 = Oa(), xA = _A.assert;
    function ii2(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys3.call(this, "edwards", t), this.a = new Ai3(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai3(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai3(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w22(ii2, Ys3);
    M22.exports = ii2;
    ii2.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ii2.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ii2.prototype.jpoint = function(e, r, o2, f3) {
      return this.point(e, r, o2, f3);
    };
    ii2.prototype.pointFromX = function(e, r) {
      e = new Ai3(e, 16), e.red || (e = e.toRed(this.red));
      var o2 = e.redSqr(), f3 = this.c2.redSub(this.a.redMul(o2)), p3 = this.one.redSub(this.c2.redMul(this.d).redMul(o2)), m3 = f3.redMul(p3.redInvm()), y5 = m3.redSqrt();
      if (y5.redSqr().redSub(m3).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M3 = y5.fromRed().isOdd();
      return (r && !M3 || !r && M3) && (y5 = y5.redNeg()), this.point(e, y5);
    };
    ii2.prototype.pointFromY = function(e, r) {
      e = new Ai3(e, 16), e.red || (e = e.toRed(this.red));
      var o2 = e.redSqr(), f3 = o2.redSub(this.c2), p3 = o2.redMul(this.d).redMul(this.c2).redSub(this.a), m3 = f3.redMul(p3.redInvm());
      if (m3.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y5 = m3.redSqrt();
      if (y5.redSqr().redSub(m3).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y5.fromRed().isOdd() !== r && (y5 = y5.redNeg()), this.point(y5, e);
    };
    ii2.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o2 = e.y.redSqr(), f3 = r.redMul(this.a).redAdd(o2), p3 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o2)));
      return f3.cmp(p3) === 0;
    };
    function at3(t, e, r, o2, f3) {
      Ys3.BasePoint.call(this, t, "projective"), e === null && r === null && o2 === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai3(e, 16), this.y = new Ai3(r, 16), this.z = o2 ? new Ai3(o2, 16) : this.curve.one, this.t = f3 && new Ai3(f3, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w22(at3, Ys3.BasePoint);
    ii2.prototype.pointFromJSON = function(e) {
      return at3.fromJSON(this, e);
    };
    ii2.prototype.point = function(e, r, o2, f3) {
      return new at3(this, e, r, o2, f3);
    };
    at3.fromJSON = function(e, r) {
      return new at3(e, r[0], r[1], r[2]);
    };
    at3.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at3.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at3.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o2 = this.z.redSqr();
      o2 = o2.redIAdd(o2);
      var f3 = this.curve._mulA(e), p3 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m3 = f3.redAdd(r), y5 = m3.redSub(o2), M3 = f3.redSub(r), x5 = p3.redMul(y5), S3 = m3.redMul(M3), E6 = p3.redMul(M3), B3 = y5.redMul(m3);
      return this.curve.point(x5, S3, B3, E6);
    };
    at3.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o2 = this.y.redSqr(), f3, p3, m3, y5, M3, x5;
      if (this.curve.twisted) {
        y5 = this.curve._mulA(r);
        var S3 = y5.redAdd(o2);
        this.zOne ? (f3 = e.redSub(r).redSub(o2).redMul(S3.redSub(this.curve.two)), p3 = S3.redMul(y5.redSub(o2)), m3 = S3.redSqr().redSub(S3).redSub(S3)) : (M3 = this.z.redSqr(), x5 = S3.redSub(M3).redISub(M3), f3 = e.redSub(r).redISub(o2).redMul(x5), p3 = S3.redMul(y5.redSub(o2)), m3 = S3.redMul(x5));
      } else
        y5 = r.redAdd(o2), M3 = this.curve._mulC(this.z).redSqr(), x5 = y5.redSub(M3).redSub(M3), f3 = this.curve._mulC(e.redISub(y5)).redMul(x5), p3 = this.curve._mulC(y5).redMul(r.redISub(o2)), m3 = y5.redMul(x5);
      return this.curve.point(f3, p3, m3);
    };
    at3.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at3.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o2 = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f3 = this.t.redMul(this.curve.dd).redMul(e.t), p3 = this.z.redMul(e.z.redAdd(e.z)), m3 = o2.redSub(r), y5 = p3.redSub(f3), M3 = p3.redAdd(f3), x5 = o2.redAdd(r), S3 = m3.redMul(y5), E6 = M3.redMul(x5), B3 = m3.redMul(x5), q3 = y5.redMul(M3);
      return this.curve.point(S3, E6, q3, B3);
    };
    at3.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o2 = r.redSqr(), f3 = this.x.redMul(e.x), p3 = this.y.redMul(e.y), m3 = this.curve.d.redMul(f3).redMul(p3), y5 = o2.redSub(m3), M3 = o2.redAdd(m3), x5 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f3).redISub(p3), S3 = r.redMul(y5).redMul(x5), E6, B3;
      return this.curve.twisted ? (E6 = r.redMul(M3).redMul(p3.redSub(this.curve._mulA(f3))), B3 = y5.redMul(M3)) : (E6 = r.redMul(M3).redMul(p3.redSub(f3)), B3 = this.curve._mulC(y5).redMul(M3)), this.curve.point(S3, E6, B3);
    };
    at3.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at3.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at3.prototype.mulAdd = function(e, r, o2) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o2], 2, false);
    };
    at3.prototype.jmulAdd = function(e, r, o2) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o2], 2, true);
    };
    at3.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at3.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at3.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at3.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at3.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at3.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o2 = e.clone(), f3 = this.curve.redN.redMul(this.z);; ) {
        if (o2.iadd(this.curve.n), o2.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f3), this.x.cmp(r) === 0)
          return true;
      }
    };
    at3.prototype.toP = at3.prototype.normalize;
    at3.prototype.mixedAdd = at3.prototype.add;
  });
  Pl = T3((x22) => {
    var Xs2 = x22;
    Xs2.base = Oa();
    Xs2.short = b22();
    Xs2.mont = y22();
    Xs2.edwards = _22();
  });
  Cr3 = T3((it3) => {
    var SA = ar2(), EA2 = Ie();
    it3.inherits = EA2;
    function AA(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function RA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f3 = 0;f3 < t.length; f3 += 2)
              r.push(parseInt(t[f3] + t[f3 + 1], 16));
        } else
          for (var o2 = 0, f3 = 0;f3 < t.length; f3++) {
            var p3 = t.charCodeAt(f3);
            p3 < 128 ? r[o2++] = p3 : p3 < 2048 ? (r[o2++] = p3 >> 6 | 192, r[o2++] = p3 & 63 | 128) : AA(t, f3) ? (p3 = 65536 + ((p3 & 1023) << 10) + (t.charCodeAt(++f3) & 1023), r[o2++] = p3 >> 18 | 240, r[o2++] = p3 >> 12 & 63 | 128, r[o2++] = p3 >> 6 & 63 | 128, r[o2++] = p3 & 63 | 128) : (r[o2++] = p3 >> 12 | 224, r[o2++] = p3 >> 6 & 63 | 128, r[o2++] = p3 & 63 | 128);
          }
      else
        for (f3 = 0;f3 < t.length; f3++)
          r[f3] = t[f3] | 0;
      return r;
    }
    it3.toArray = RA;
    function BA(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += E22(t[r].toString(16));
      return e;
    }
    it3.toHex = BA;
    function S22(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it3.htonl = S22;
    function qA(t, e) {
      for (var r = "", o2 = 0;o2 < t.length; o2++) {
        var f3 = t[o2];
        e === "little" && (f3 = S22(f3)), r += A22(f3.toString(16));
      }
      return r;
    }
    it3.toHex32 = qA;
    function E22(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it3.zero2 = E22;
    function A22(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it3.zero8 = A22;
    function IA(t, e, r, o2) {
      var f3 = r - e;
      SA(f3 % 4 === 0);
      for (var p3 = new Array(f3 / 4), m3 = 0, y5 = e;m3 < p3.length; m3++, y5 += 4) {
        var M3;
        o2 === "big" ? M3 = t[y5] << 24 | t[y5 + 1] << 16 | t[y5 + 2] << 8 | t[y5 + 3] : M3 = t[y5 + 3] << 24 | t[y5 + 2] << 16 | t[y5 + 1] << 8 | t[y5], p3[m3] = M3 >>> 0;
      }
      return p3;
    }
    it3.join32 = IA;
    function TA(t, e) {
      for (var r = new Array(t.length * 4), o2 = 0, f3 = 0;o2 < t.length; o2++, f3 += 4) {
        var p3 = t[o2];
        e === "big" ? (r[f3] = p3 >>> 24, r[f3 + 1] = p3 >>> 16 & 255, r[f3 + 2] = p3 >>> 8 & 255, r[f3 + 3] = p3 & 255) : (r[f3 + 3] = p3 >>> 24, r[f3 + 2] = p3 >>> 16 & 255, r[f3 + 1] = p3 >>> 8 & 255, r[f3] = p3 & 255);
      }
      return r;
    }
    it3.split32 = TA;
    function kA(t, e) {
      return t >>> e | t << 32 - e;
    }
    it3.rotr32 = kA;
    function LA(t, e) {
      return t << e | t >>> 32 - e;
    }
    it3.rotl32 = LA;
    function NA(t, e) {
      return t + e >>> 0;
    }
    it3.sum32 = NA;
    function DA(t, e, r) {
      return t + e + r >>> 0;
    }
    it3.sum32_3 = DA;
    function PA(t, e, r, o2) {
      return t + e + r + o2 >>> 0;
    }
    it3.sum32_4 = PA;
    function CA(t, e, r, o2, f3) {
      return t + e + r + o2 + f3 >>> 0;
    }
    it3.sum32_5 = CA;
    function OA(t, e, r, o2) {
      var f3 = t[e], p3 = t[e + 1], m3 = o2 + p3 >>> 0, y5 = (m3 < o2 ? 1 : 0) + r + f3;
      t[e] = y5 >>> 0, t[e + 1] = m3;
    }
    it3.sum64 = OA;
    function FA(t, e, r, o2) {
      var f3 = e + o2 >>> 0, p3 = (f3 < e ? 1 : 0) + t + r;
      return p3 >>> 0;
    }
    it3.sum64_hi = FA;
    function UA(t, e, r, o2) {
      var f3 = e + o2;
      return f3 >>> 0;
    }
    it3.sum64_lo = UA;
    function zA(t, e, r, o2, f3, p3, m3, y5) {
      var M3 = 0, x5 = e;
      x5 = x5 + o2 >>> 0, M3 += x5 < e ? 1 : 0, x5 = x5 + p3 >>> 0, M3 += x5 < p3 ? 1 : 0, x5 = x5 + y5 >>> 0, M3 += x5 < y5 ? 1 : 0;
      var S3 = t + r + f3 + m3 + M3;
      return S3 >>> 0;
    }
    it3.sum64_4_hi = zA;
    function HA(t, e, r, o2, f3, p3, m3, y5) {
      var M3 = e + o2 + p3 + y5;
      return M3 >>> 0;
    }
    it3.sum64_4_lo = HA;
    function WA(t, e, r, o2, f3, p3, m3, y5, M3, x5) {
      var S3 = 0, E6 = e;
      E6 = E6 + o2 >>> 0, S3 += E6 < e ? 1 : 0, E6 = E6 + p3 >>> 0, S3 += E6 < p3 ? 1 : 0, E6 = E6 + y5 >>> 0, S3 += E6 < y5 ? 1 : 0, E6 = E6 + x5 >>> 0, S3 += E6 < x5 ? 1 : 0;
      var B3 = t + r + f3 + m3 + M3 + S3;
      return B3 >>> 0;
    }
    it3.sum64_5_hi = WA;
    function KA(t, e, r, o2, f3, p3, m3, y5, M3, x5) {
      var S3 = e + o2 + p3 + y5 + x5;
      return S3 >>> 0;
    }
    it3.sum64_5_lo = KA;
    function jA(t, e, r) {
      var o2 = e << 32 - r | t >>> r;
      return o2 >>> 0;
    }
    it3.rotr64_hi = jA;
    function ZA(t, e, r) {
      var o2 = t << 32 - r | e >>> r;
      return o2 >>> 0;
    }
    it3.rotr64_lo = ZA;
    function VA(t, e, r) {
      return t >>> r;
    }
    it3.shr64_hi = VA;
    function $A(t, e, r) {
      var o2 = t << 32 - r | e >>> r;
      return o2 >>> 0;
    }
    it3.shr64_lo = $A;
  });
  Tf = T3((B22) => {
    var R22 = Cr3(), GA = ar2();
    function Js2() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B22.BlockHash = Js2;
    Js2.prototype.update = function(e, r) {
      if (e = R22.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o2 = e.length % this._delta8;
        this.pending = e.slice(e.length - o2, e.length), this.pending.length === 0 && (this.pending = null), e = R22.join32(e, 0, e.length - o2, this.endian);
        for (var f3 = 0;f3 < e.length; f3 += this._delta32)
          this._update(e, f3, f3 + this._delta32);
      }
      return this;
    };
    Js2.prototype.digest = function(e) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e);
    };
    Js2.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o2 = r - (e + this.padLength) % r, f3 = new Array(o2 + this.padLength);
      f3[0] = 128;
      for (var p3 = 1;p3 < o2; p3++)
        f3[p3] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m3 = 8;m3 < this.padLength; m3++)
          f3[p3++] = 0;
        f3[p3++] = 0, f3[p3++] = 0, f3[p3++] = 0, f3[p3++] = 0, f3[p3++] = e >>> 24 & 255, f3[p3++] = e >>> 16 & 255, f3[p3++] = e >>> 8 & 255, f3[p3++] = e & 255;
      } else
        for (f3[p3++] = e & 255, f3[p3++] = e >>> 8 & 255, f3[p3++] = e >>> 16 & 255, f3[p3++] = e >>> 24 & 255, f3[p3++] = 0, f3[p3++] = 0, f3[p3++] = 0, f3[p3++] = 0, m3 = 8;m3 < this.padLength; m3++)
          f3[p3++] = 0;
      return f3;
    };
  });
  Cl = T3((Ri2) => {
    var YA = Cr3(), ni = YA.rotr32;
    function XA(t, e, r, o2) {
      if (t === 0)
        return q22(e, r, o2);
      if (t === 1 || t === 3)
        return T22(e, r, o2);
      if (t === 2)
        return I22(e, r, o2);
    }
    Ri2.ft_1 = XA;
    function q22(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ri2.ch32 = q22;
    function I22(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ri2.maj32 = I22;
    function T22(t, e, r) {
      return t ^ e ^ r;
    }
    Ri2.p32 = T22;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri2.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri2.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri2.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri2.g1_256 = tR;
  });
  N22 = T3((Tk, L22) => {
    var kf = Cr3(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k22 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi2() {
      if (!(this instanceof fi2))
        return new fi2;
      k22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi2, k22);
    L22.exports = fi2;
    fi2.blockSize = 512;
    fi2.outSize = 160;
    fi2.hmacStrength = 80;
    fi2.padLength = 64;
    fi2.prototype._update = function(e, r) {
      for (var o2 = this.W, f3 = 0;f3 < 16; f3++)
        o2[f3] = e[r + f3];
      for (;f3 < o2.length; f3++)
        o2[f3] = Ol(o2[f3 - 3] ^ o2[f3 - 8] ^ o2[f3 - 14] ^ o2[f3 - 16], 1);
      var p3 = this.h[0], m3 = this.h[1], y5 = this.h[2], M3 = this.h[3], x5 = this.h[4];
      for (f3 = 0;f3 < o2.length; f3++) {
        var S3 = ~~(f3 / 20), E6 = nR(Ol(p3, 5), fR(S3, m3, y5, M3), x5, o2[f3], aR[S3]);
        x5 = M3, M3 = y5, y5 = Ol(m3, 30), m3 = p3, p3 = E6;
      }
      this.h[0] = Fa(this.h[0], p3), this.h[1] = Fa(this.h[1], m3), this.h[2] = Fa(this.h[2], y5), this.h[3] = Fa(this.h[3], M3), this.h[4] = Fa(this.h[4], x5);
    };
    fi2.prototype._digest = function(e) {
      return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T3((kk, P22) => {
    var Lf = Cr3(), oR = Tf(), Nf = Cl(), sR = ar2(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D22 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai2() {
      if (!(this instanceof ai2))
        return new ai2;
      D22.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai2, D22);
    P22.exports = ai2;
    ai2.blockSize = 512;
    ai2.outSize = 256;
    ai2.hmacStrength = 192;
    ai2.padLength = 64;
    ai2.prototype._update = function(e, r) {
      for (var o2 = this.W, f3 = 0;f3 < 16; f3++)
        o2[f3] = e[r + f3];
      for (;f3 < o2.length; f3++)
        o2[f3] = hR(bR(o2[f3 - 2]), o2[f3 - 7], vR(o2[f3 - 15]), o2[f3 - 16]);
      var p3 = this.h[0], m3 = this.h[1], y5 = this.h[2], M3 = this.h[3], x5 = this.h[4], S3 = this.h[5], E6 = this.h[6], B3 = this.h[7];
      for (sR(this.k.length === o2.length), f3 = 0;f3 < o2.length; f3++) {
        var q3 = uR(B3, pR(x5), lR(x5, S3, E6), this.k[f3], o2[f3]), L4 = Or(cR(p3), dR(p3, m3, y5));
        B3 = E6, E6 = S3, S3 = x5, x5 = Or(M3, q3), M3 = y5, y5 = m3, m3 = p3, p3 = Or(q3, L4);
      }
      this.h[0] = Or(this.h[0], p3), this.h[1] = Or(this.h[1], m3), this.h[2] = Or(this.h[2], y5), this.h[3] = Or(this.h[3], M3), this.h[4] = Or(this.h[4], x5), this.h[5] = Or(this.h[5], S3), this.h[6] = Or(this.h[6], E6), this.h[7] = Or(this.h[7], B3);
    };
    ai2.prototype._digest = function(e) {
      return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F2 = T3((Lk, O22) => {
    var Ul = Cr3(), C22 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C22.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C22);
    O22.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e) {
      return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T3((Nk, W2) => {
    var ir3 = Cr3(), gR = Tf(), yR = ar2(), oi = ir3.rotr64_hi, si2 = ir3.rotr64_lo, U22 = ir3.shr64_hi, z2 = ir3.shr64_lo, Ji2 = ir3.sum64, zl = ir3.sum64_hi, Hl = ir3.sum64_lo, wR = ir3.sum64_4_hi, MR = ir3.sum64_4_lo, _R = ir3.sum64_5_hi, xR = ir3.sum64_5_lo, H22 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr3() {
      if (!(this instanceof Fr3))
        return new Fr3;
      H22.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir3.inherits(Fr3, H22);
    W2.exports = Fr3;
    Fr3.blockSize = 1024;
    Fr3.outSize = 512;
    Fr3.hmacStrength = 192;
    Fr3.padLength = 128;
    Fr3.prototype._prepareBlock = function(e, r) {
      for (var o2 = this.W, f3 = 0;f3 < 32; f3++)
        o2[f3] = e[r + f3];
      for (;f3 < o2.length; f3 += 2) {
        var p3 = DR(o2[f3 - 4], o2[f3 - 3]), m3 = PR(o2[f3 - 4], o2[f3 - 3]), y5 = o2[f3 - 14], M3 = o2[f3 - 13], x5 = LR(o2[f3 - 30], o2[f3 - 29]), S3 = NR(o2[f3 - 30], o2[f3 - 29]), E6 = o2[f3 - 32], B3 = o2[f3 - 31];
        o2[f3] = wR(p3, m3, y5, M3, x5, S3, E6, B3), o2[f3 + 1] = MR(p3, m3, y5, M3, x5, S3, E6, B3);
      }
    };
    Fr3.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o2 = this.W, f3 = this.h[0], p3 = this.h[1], m3 = this.h[2], y5 = this.h[3], M3 = this.h[4], x5 = this.h[5], S3 = this.h[6], E6 = this.h[7], B3 = this.h[8], q3 = this.h[9], L4 = this.h[10], ge = this.h[11], _e3 = this.h[12], N6 = this.h[13], we = this.h[14], ye2 = this.h[15];
      yR(this.k.length === o2.length);
      for (var xe2 = 0;xe2 < o2.length; xe2 += 2) {
        var Re = we, Ee = ye2, Ae2 = TR(B3, q3), P4 = kR(B3, q3), Se3 = ER(B3, q3, L4, ge, _e3, N6), v4 = AR(B3, q3, L4, ge, _e3, N6), i = this.k[xe2], a3 = this.k[xe2 + 1], h5 = o2[xe2], s3 = o2[xe2 + 1], u3 = _R(Re, Ee, Ae2, P4, Se3, v4, i, a3, h5, s3), c2 = xR(Re, Ee, Ae2, P4, Se3, v4, i, a3, h5, s3);
        Re = qR(f3, p3), Ee = IR(f3, p3), Ae2 = RR(f3, p3, m3, y5, M3, x5), P4 = BR(f3, p3, m3, y5, M3, x5);
        var b6 = zl(Re, Ee, Ae2, P4), l3 = Hl(Re, Ee, Ae2, P4);
        we = _e3, ye2 = N6, _e3 = L4, N6 = ge, L4 = B3, ge = q3, B3 = zl(S3, E6, u3, c2), q3 = Hl(E6, E6, u3, c2), S3 = M3, E6 = x5, M3 = m3, x5 = y5, m3 = f3, y5 = p3, f3 = zl(u3, c2, b6, l3), p3 = Hl(u3, c2, b6, l3);
      }
      Ji2(this.h, 0, f3, p3), Ji2(this.h, 2, m3, y5), Ji2(this.h, 4, M3, x5), Ji2(this.h, 6, S3, E6), Ji2(this.h, 8, B3, q3), Ji2(this.h, 10, L4, ge), Ji2(this.h, 12, _e3, N6), Ji2(this.h, 14, we, ye2);
    };
    Fr3.prototype._digest = function(e) {
      return e === "hex" ? ir3.toHex32(this.h, "big") : ir3.split32(this.h, "big");
    };
    function ER(t, e, r, o2, f3) {
      var p3 = t & r ^ ~t & f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function AR(t, e, r, o2, f3, p3) {
      var m3 = e & o2 ^ ~e & p3;
      return m3 < 0 && (m3 += 4294967296), m3;
    }
    function RR(t, e, r, o2, f3) {
      var p3 = t & r ^ t & f3 ^ r & f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function BR(t, e, r, o2, f3, p3) {
      var m3 = e & o2 ^ e & p3 ^ o2 & p3;
      return m3 < 0 && (m3 += 4294967296), m3;
    }
    function qR(t, e) {
      var r = oi(t, e, 28), o2 = oi(e, t, 2), f3 = oi(e, t, 7), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function IR(t, e) {
      var r = si2(t, e, 28), o2 = si2(e, t, 2), f3 = si2(e, t, 7), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function TR(t, e) {
      var r = oi(t, e, 14), o2 = oi(t, e, 18), f3 = oi(e, t, 9), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function kR(t, e) {
      var r = si2(t, e, 14), o2 = si2(t, e, 18), f3 = si2(e, t, 9), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function LR(t, e) {
      var r = oi(t, e, 1), o2 = oi(t, e, 8), f3 = U22(t, e, 7), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function NR(t, e) {
      var r = si2(t, e, 1), o2 = si2(t, e, 8), f3 = z2(t, e, 7), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function DR(t, e) {
      var r = oi(t, e, 19), o2 = oi(e, t, 29), f3 = U22(t, e, 6), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function PR(t, e) {
      var r = si2(t, e, 19), o2 = si2(e, t, 29), f3 = z2(t, e, 6), p3 = r ^ o2 ^ f3;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
  });
  Z22 = T3((Dk, j22) => {
    var Kl = Cr3(), K22 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K22.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K22);
    j22.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e) {
      return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V22 = T3((Df) => {
    Df.sha1 = N22();
    Df.sha224 = F2();
    Df.sha256 = Fl();
    Df.sha384 = Z22();
    Df.sha512 = Wl();
  });
  Q22 = T3((J22) => {
    var On2 = Cr3(), CR = Tf(), Qs2 = On2.rotl32, $22 = On2.sum32, Ua = On2.sum32_3, G2 = On2.sum32_4, X22 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On2.inherits(hi, X22);
    J22.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o2 = this.h[0], f3 = this.h[1], p3 = this.h[2], m3 = this.h[3], y5 = this.h[4], M3 = o2, x5 = f3, S3 = p3, E6 = m3, B3 = y5, q3 = 0;q3 < 80; q3++) {
        var L4 = $22(Qs2(G2(o2, Y22(q3, f3, p3, m3), e[UR[q3] + r], OR(q3)), HR[q3]), y5);
        o2 = y5, y5 = m3, m3 = Qs2(p3, 10), p3 = f3, f3 = L4, L4 = $22(Qs2(G2(M3, Y22(79 - q3, x5, S3, E6), e[zR[q3] + r], FR(q3)), WR[q3]), B3), M3 = B3, B3 = E6, E6 = Qs2(S3, 10), S3 = x5, x5 = L4;
      }
      L4 = Ua(this.h[1], p3, E6), this.h[1] = Ua(this.h[2], m3, B3), this.h[2] = Ua(this.h[3], y5, M3), this.h[3] = Ua(this.h[4], o2, x5), this.h[4] = Ua(this.h[0], f3, S3), this.h[0] = L4;
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? On2.toHex32(this.h, "little") : On2.split32(this.h, "little");
    };
    function Y22(t, e, r, o2) {
      return t <= 15 ? e ^ r ^ o2 : t <= 31 ? e & r | ~e & o2 : t <= 47 ? (e | ~r) ^ o2 : t <= 63 ? e & o2 | r & ~o2 : e ^ (r | ~o2);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T3((Ok, ey) => {
    var KR = Cr3(), jR = ar2();
    function Pf(t, e, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Pf.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Pf.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  e0 = T3((ry) => {
    var Kt3 = ry;
    Kt3.utils = Cr3();
    Kt3.common = Tf();
    Kt3.sha = V22();
    Kt3.ripemd = Q22();
    Kt3.hmac = ty();
    Kt3.sha1 = Kt3.sha.sha1;
    Kt3.sha256 = Kt3.sha.sha256;
    Kt3.sha224 = Kt3.sha.sha224;
    Kt3.sha384 = Kt3.sha.sha384;
    Kt3.sha512 = Kt3.sha.sha512;
    Kt3.ripemd160 = Kt3.ripemd.ripemd160;
  });
  ny2 = T3((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T3((oy) => {
    var Zl = oy, Qi2 = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi2.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi2.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi2.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi2.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi2.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi2.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi2.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny2();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi2.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T3((Hk, hy) => {
    var VR = e0(), Fn2 = Nl(), sy = ar2();
    function tn3(t) {
      if (!(this instanceof tn3))
        return new tn3(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Fn2.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn2.toArray(t.nonce, t.nonceEnc || "hex"), o2 = Fn2.toArray(t.pers, t.persEnc || "hex");
      sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o2);
    }
    hy.exports = tn3;
    tn3.prototype._init = function(e, r, o2) {
      var f3 = e.concat(r).concat(o2);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p3 = 0;p3 < this.V.length; p3++)
        this.K[p3] = 0, this.V[p3] = 1;
      this._update(f3), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn3.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn3.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn3.prototype.reseed = function(e, r, o2, f3) {
      typeof r != "string" && (f3 = o2, o2 = r, r = null), e = Fn2.toArray(e, r), o2 = Fn2.toArray(o2, f3), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o2 || [])), this._reseed = 1;
    };
    tn3.prototype.generate = function(e, r, o2, f3) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f3 = o2, o2 = r, r = null), o2 && (o2 = Fn2.toArray(o2, f3 || "hex"), this._update(o2));
      for (var p3 = [];p3.length < e; )
        this.V = this._hmac().update(this.V).digest(), p3 = p3.concat(this.V);
      var m3 = p3.slice(0, e);
      return this._update(o2), this._reseed++, Fn2.encode(m3, r);
    };
  });
  dy = T3((Wk, ly) => {
    var $R = ri3(), GR = or(), $l = GR.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e, r, o2) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o2 });
    };
    Gt.fromPrivate = function(e, r, o2) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o2 });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o2) {
      return this.ec.sign(e, this, r, o2);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T3((Kk, py) => {
    var r0 = ri3(), Xl = or(), YR = Xl.assert;
    function i0(t, e) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o2 = r & 15;
      if (o2 === 0 || o2 > 4)
        return false;
      for (var f3 = 0, p3 = 0, m3 = e.place;p3 < o2; p3++, m3++)
        f3 <<= 8, f3 |= t[m3], f3 >>>= 0;
      return f3 <= 127 ? false : (e.place = m3, f3);
    }
    function cy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    i0.prototype._importDER = function(e, r) {
      e = Xl.toArray(e, r);
      var o2 = new XR;
      if (e[o2.place++] !== 48)
        return false;
      var f3 = Gl(e, o2);
      if (f3 === false || f3 + o2.place !== e.length || e[o2.place++] !== 2)
        return false;
      var p3 = Gl(e, o2);
      if (p3 === false)
        return false;
      var m3 = e.slice(o2.place, p3 + o2.place);
      if (o2.place += p3, e[o2.place++] !== 2)
        return false;
      var y5 = Gl(e, o2);
      if (y5 === false || e.length !== y5 + o2.place)
        return false;
      var M3 = e.slice(o2.place, y5 + o2.place);
      if (m3[0] === 0)
        if (m3[1] & 128)
          m3 = m3.slice(1);
        else
          return false;
      if (M3[0] === 0)
        if (M3[1] & 128)
          M3 = M3.slice(1);
        else
          return false;
      return this.r = new r0(m3), this.s = new r0(M3), this.recoveryParam = null, true;
    };
    function Yl(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    i0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o2 = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o2[0] & 128 && (o2 = [0].concat(o2)), r = cy(r), o2 = cy(o2);!o2[0] && !(o2[1] & 128); )
        o2 = o2.slice(1);
      var f3 = [2];
      Yl(f3, r.length), f3 = f3.concat(r), f3.push(2), Yl(f3, o2.length);
      var p3 = f3.concat(o2), m3 = [48];
      return Yl(m3, p3.length), m3 = m3.concat(p3), Xl.encode(m3, e);
    };
  });
  yy = T3((jk, gy) => {
    var Un = ri3(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e) {
      return new Ql(this, e);
    };
    Sr.prototype.keyFromPrivate = function(e, r) {
      return Ql.fromPrivate(this, e, r);
    };
    Sr.prototype.keyFromPublic = function(e, r) {
      return Ql.fromPublic(this, e, r);
    };
    Sr.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o2 = this.n.byteLength(), f3 = this.n.sub(new Un(2));; ) {
        var p3 = new Un(r.generate(o2));
        if (!(p3.cmp(f3) > 0))
          return p3.iaddn(1), this.keyFromPrivate(p3);
      }
    };
    Sr.prototype._truncateToN = function(e, r) {
      var o2 = e.byteLength() * 8 - this.n.bitLength();
      return o2 > 0 && (e = e.ushrn(o2)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Sr.prototype.sign = function(e, r, o2, f3) {
      typeof o2 == "object" && (f3 = o2, o2 = null), f3 || (f3 = {}), r = this.keyFromPrivate(r, o2), e = this._truncateToN(new Un(e, 16));
      for (var p3 = this.n.byteLength(), m3 = r.getPrivate().toArray("be", p3), y5 = e.toArray("be", p3), M3 = new by({ hash: this.hash, entropy: m3, nonce: y5, pers: f3.pers, persEnc: f3.persEnc || "utf8" }), x5 = this.n.sub(new Un(1)), S3 = 0;; S3++) {
        var E6 = f3.k ? f3.k(S3) : new Un(M3.generate(this.n.byteLength()));
        if (E6 = this._truncateToN(E6, true), !(E6.cmpn(1) <= 0 || E6.cmp(x5) >= 0)) {
          var B3 = this.g.mul(E6);
          if (!B3.isInfinity()) {
            var q3 = B3.getX(), L4 = q3.umod(this.n);
            if (L4.cmpn(0) !== 0) {
              var ge = E6.invm(this.n).mul(L4.mul(r.getPrivate()).iadd(e));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e3 = (B3.getY().isOdd() ? 1 : 0) | (q3.cmp(L4) !== 0 ? 2 : 0);
                return f3.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e3 ^= 1), new n0({ r: L4, s: ge, recoveryParam: _e3 });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e, r, o2, f3) {
      e = this._truncateToN(new Un(e, 16)), o2 = this.keyFromPublic(o2, f3), r = new n0(r, "hex");
      var { r: p3, s: m3 } = r;
      if (p3.cmpn(1) < 0 || p3.cmp(this.n) >= 0 || m3.cmpn(1) < 0 || m3.cmp(this.n) >= 0)
        return false;
      var y5 = m3.invm(this.n), M3 = y5.mul(e).umod(this.n), x5 = y5.mul(p3).umod(this.n), S3;
      return this.curve._maxwellTrick ? (S3 = this.g.jmulAdd(M3, o2.getPublic(), x5), S3.isInfinity() ? false : S3.eqXToP(p3)) : (S3 = this.g.mulAdd(M3, o2.getPublic(), x5), S3.isInfinity() ? false : S3.getX().umod(this.n).cmp(p3) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e, r, o2) {
      my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o2);
      var f3 = this.n, p3 = new Un(t), m3 = e.r, y5 = e.s, M3 = r & 1, x5 = r >> 1;
      if (m3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x5)
        throw new Error("Unable to find sencond key candinate");
      x5 ? m3 = this.curve.pointFromX(m3.add(this.curve.n), M3) : m3 = this.curve.pointFromX(m3, M3);
      var S3 = e.r.invm(f3), E6 = f3.sub(p3).mul(S3).umod(f3), B3 = y5.mul(S3).umod(f3);
      return this.g.mulAdd(E6, m3, B3);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e, r, o2) {
      if (e = new n0(e, o2), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f3 = 0;f3 < 4; f3++) {
        var p3;
        try {
          p3 = this.recoverPubKey(t, e, f3);
        } catch {
          continue;
        }
        if (p3.eq(r))
          return f3;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T3((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf3 = za.cachedProperty;
    function Ft2(t, e) {
      this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
    }
    Ft2.fromPublic = function(e, r) {
      return r instanceof Ft2 ? r : new Ft2(e, { pub: r });
    };
    Ft2.fromSecret = function(e, r) {
      return r instanceof Ft2 ? r : new Ft2(e, { secret: r });
    };
    Ft2.prototype.secret = function() {
      return this._secret;
    };
    Cf3(Ft2, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf3(Ft2, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf3(Ft2, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o2 = e.encodingLength - 1, f3 = r.slice(0, e.encodingLength);
      return f3[0] &= 248, f3[o2] &= 127, f3[o2] |= 64, f3;
    });
    Cf3(Ft2, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf3(Ft2, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf3(Ft2, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft2.prototype.sign = function(e) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft2.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft2.prototype.getSecret = function(e) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
    };
    Ft2.prototype.getPublic = function(e) {
      return za.encode(this.pubBytes(), e);
    };
    _y.exports = Ft2;
  });
  Ey = T3((Vk, Sy) => {
    var eB = ri3(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn2(t, e) {
      this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    a0(zn2, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn2, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn2, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn2, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn2.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn2.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn2;
  });
  Iy = T3(($k, qy2) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy2.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = Ry(e);
      var o2 = this.keyFromSecret(r), f3 = this.hashInt(o2.messagePrefix(), e), p3 = this.g.mul(f3), m3 = this.encodePoint(p3), y5 = this.hashInt(m3, o2.pubBytes(), e).mul(o2.priv()), M3 = f3.add(y5).umod(this.curve.n);
      return this.makeSignature({ R: p3, S: M3, Rencoded: m3 });
    };
    nr.prototype.verify = function(e, r, o2) {
      e = Ry(e), r = this.makeSignature(r);
      var f3 = this.keyFromPublic(o2), p3 = this.hashInt(r.Rencoded(), f3.pubBytes(), e), m3 = this.g.mul(r.S()), y5 = r.R().add(f3.pub().mul(p3));
      return y5.eq(m3);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return Of.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return By.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return By.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Ay ? e : new Ay(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = Of.parseBytes(e);
      var r = e.length - 1, o2 = e.slice(0, r).concat(e[r] & -129), f3 = (e[r] & 128) !== 0, p3 = Of.intFromLE(o2);
      return this.curve.pointFromY(p3, f3);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return Of.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  o0 = T3((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T3((ky, ed) => {
    (function(t, e) {
      function r(v4, i) {
        if (!v4)
          throw new Error(i || "Assertion failed");
      }
      function o2(v4, i) {
        v4.super_ = i;
        var a3 = function() {
        };
        a3.prototype = i.prototype, v4.prototype = new a3, v4.prototype.constructor = v4;
      }
      function f3(v4, i, a3) {
        if (f3.isBN(v4))
          return v4;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v4 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v4 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(i) {
        return i instanceof f3 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f3.wordSize && Array.isArray(i.words);
      }, f3.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f3.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f3.prototype._init = function(i, a3, h5) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h5);
        if (typeof i == "object")
          return this._initArray(i, a3, h5);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h5) : (this._parseBase(i, a3, s3), h5 === "le" && this._initArray(this.toArray(), a3, h5)));
      }, f3.prototype._initNumber = function(i, a3, h5) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h5 === "le" && this._initArray(this.toArray(), a3, h5);
      }, f3.prototype._initArray = function(i, a3, h5) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b6 = 0;
        if (h5 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        else if (h5 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        return this.strip();
      };
      function m3(v4, i) {
        var a3 = v4.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y5(v4, i, a3) {
        var h5 = m3(v4, a3);
        return a3 - 1 >= i && (h5 |= m3(v4, a3 - 1) << 4), h5;
      }
      f3.prototype._parseHex = function(i, a3, h5) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b6;
        if (h5 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M3(v4, i, a3, h5) {
        for (var s3 = 0, u3 = Math.min(v4.length, a3), c2 = i;c2 < u3; c2++) {
          var b6 = v4.charCodeAt(c2) - 48;
          s3 *= h5, b6 >= 49 ? s3 += b6 - 49 + 10 : b6 >= 17 ? s3 += b6 - 17 + 10 : s3 += b6;
        }
        return s3;
      }
      f3.prototype._parseBase = function(i, a3, h5) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a3)
          s3++;
        s3--, u3 = u3 / a3 | 0;
        for (var c2 = i.length - h5, b6 = c2 % s3, l3 = Math.min(c2, c2 - b6) + h5, n = 0, d4 = h5;d4 < l3; d4 += s3)
          n = M3(i, d4, d4 + s3, a3), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b6 !== 0) {
          var w3 = 1;
          for (n = M3(i, d4, i.length, a3), d4 = 0;d4 < b6; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f3.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f3.prototype.clone = function() {
        var i = new f3(null);
        return this.copy(i), i;
      }, f3.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f3.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h5;
        if (i === 16 || i === "hex") {
          h5 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b6 = this.words[c2], l3 = ((b6 << s3 | u3) & 16777215).toString(16);
            u3 = b6 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h5 = x5[6 - l3.length] + l3 + h5 : h5 = l3 + h5, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h5 = u3.toString(16) + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S3[i], d4 = E6[i];
          h5 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g5 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h5 = g5 + h5 : h5 = x5[n - g5.length] + g5 + h5;
          }
          for (this.isZero() && (h5 = "0" + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f3.prototype.toJSON = function() {
        return this.toString(16);
      }, f3.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f3.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f3.prototype.toArrayLike = function(i, a3, h5) {
        var s3 = this.byteLength(), u3 = h5 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b6 = new i(u3), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[n] = l3;
          for (;n < u3; n++)
            b6[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b6[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[u3 - n - 1] = l3;
        }
        return b6;
      }, Math.clz32 ? f3.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f3.prototype._countBits = function(i) {
        var a3 = i, h5 = 0;
        return a3 >= 4096 && (h5 += 13, a3 >>>= 13), a3 >= 64 && (h5 += 7, a3 >>>= 7), a3 >= 8 && (h5 += 4, a3 >>>= 4), a3 >= 2 && (h5 += 2, a3 >>>= 2), h5 + a3;
      }, f3.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h5 = 0;
        return (a3 & 8191) === 0 && (h5 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h5 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h5 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h5 += 2, a3 >>>= 2), (a3 & 1) === 0 && h5++, h5;
      }, f3.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v4) {
        for (var i = new Array(v4.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h5 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v4.words[h5] & 1 << s3) >>> s3;
        }
        return i;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h5 = this._zeroBits(this.words[a3]);
          if (i += h5, h5 !== 26)
            break;
        }
        return i;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f3.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f3.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f3.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f3.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h5 = 0;h5 < a3.length; h5++)
          this.words[h5] = this.words[h5] & i.words[h5];
        return this.length = a3.length, this.strip();
      }, f3.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f3.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f3.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f3.prototype.iuxor = function(i) {
        var a3, h5;
        this.length > i.length ? (a3 = this, h5 = i) : (a3 = i, h5 = this);
        for (var s3 = 0;s3 < h5.length; s3++)
          this.words[s3] = a3.words[s3] ^ h5.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f3.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f3.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f3.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f3.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h5 = i % 26;
        this._expand(a3), h5 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h5 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h5), this.strip();
      }, f3.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f3.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h5 = i / 26 | 0, s3 = i % 26;
        return this._expand(h5 + 1), a3 ? this.words[h5] = this.words[h5] | 1 << s3 : this.words[h5] = this.words[h5] & ~(1 << s3), this.strip();
      }, f3.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h5, s3;
        this.length > i.length ? (h5 = this, s3 = i) : (h5 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h5.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        for (;u3 !== 0 && c2 < h5.length; c2++)
          a3 = (h5.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        if (this.length = h5.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h5 !== this)
          for (;c2 < h5.length; c2++)
            this.words[c2] = h5.words[c2];
        return this;
      }, f3.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f3.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h5 = this.cmp(i);
        if (h5 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h5 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b6 = 0;b6 < u3.length; b6++)
          a3 = (s3.words[b6] | 0) - (u3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        for (;c2 !== 0 && b6 < s3.length; b6++)
          a3 = (s3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        if (c2 === 0 && b6 < s3.length && s3 !== this)
          for (;b6 < s3.length; b6++)
            this.words[b6] = s3.words[b6];
        return this.length = Math.max(this.length, b6), s3 !== this && (this.negative = 1), this.strip();
      }, f3.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q3(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative;
        var h5 = v4.length + i.length | 0;
        a3.length = h5, h5 = h5 - 1 | 0;
        var s3 = v4.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b6 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b6;
        for (var n = 1;n < h5; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g5 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v4.length + 1);_4 <= g5; _4++) {
            var A4 = n - _4 | 0;
            s3 = v4.words[A4] | 0, u3 = i.words[_4] | 0, c2 = s3 * u3 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h5) {
        var s3 = i.words, u3 = a3.words, c2 = h5.words, b6 = 0, l3, n, d4, w3 = s3[0] | 0, g5 = w3 & 8191, _4 = w3 >>> 13, A4 = s3[1] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = s3[3] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = s3[4] | 0, F3 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = s3[6] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = s3[7] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u3[0] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = u3[1] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = u3[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = u3[3] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = u3[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = u3[5] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = u3[6] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = u3[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = u3[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u3[9] | 0, ve = It & 8191, be2 = It >>> 13;
        h5.negative = i.negative ^ a3.negative, h5.length = 19, l3 = Math.imul(g5, X4), n = Math.imul(g5, J3), n = n + Math.imul(_4, X4) | 0, d4 = Math.imul(_4, J3);
        var ft2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l3 = Math.imul(R4, X4), n = Math.imul(R4, J3), n = n + Math.imul(I5, X4) | 0, d4 = Math.imul(I5, J3), l3 = l3 + Math.imul(g5, Q5) | 0, n = n + Math.imul(g5, ee) | 0, n = n + Math.imul(_4, Q5) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X4), n = Math.imul(k4, J3), n = n + Math.imul(D3, X4) | 0, d4 = Math.imul(D3, J3), l3 = l3 + Math.imul(R4, Q5) | 0, n = n + Math.imul(R4, ee) | 0, n = n + Math.imul(I5, Q5) | 0, d4 = d4 + Math.imul(I5, ee) | 0, l3 = l3 + Math.imul(g5, te2) | 0, n = n + Math.imul(g5, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C4, X4), n = Math.imul(C4, J3), n = n + Math.imul(O4, X4) | 0, d4 = Math.imul(O4, J3), l3 = l3 + Math.imul(k4, Q5) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D3, Q5) | 0, d4 = d4 + Math.imul(D3, ee) | 0, l3 = l3 + Math.imul(R4, te2) | 0, n = n + Math.imul(R4, re2) | 0, n = n + Math.imul(I5, te2) | 0, d4 = d4 + Math.imul(I5, re2) | 0, l3 = l3 + Math.imul(g5, ie) | 0, n = n + Math.imul(g5, ne2) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne2) | 0;
        var ze = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X4), n = Math.imul(F3, J3), n = n + Math.imul(U3, X4) | 0, d4 = Math.imul(U3, J3), l3 = l3 + Math.imul(C4, Q5) | 0, n = n + Math.imul(C4, ee) | 0, n = n + Math.imul(O4, Q5) | 0, d4 = d4 + Math.imul(O4, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D3, te2) | 0, d4 = d4 + Math.imul(D3, re2) | 0, l3 = l3 + Math.imul(R4, ie) | 0, n = n + Math.imul(R4, ne2) | 0, n = n + Math.imul(I5, ie) | 0, d4 = d4 + Math.imul(I5, ne2) | 0, l3 = l3 + Math.imul(g5, fe3) | 0, n = n + Math.imul(g5, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X4), n = Math.imul(z, J3), n = n + Math.imul(H3, X4) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q5) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U3, Q5) | 0, d4 = d4 + Math.imul(U3, ee) | 0, l3 = l3 + Math.imul(C4, te2) | 0, n = n + Math.imul(C4, re2) | 0, n = n + Math.imul(O4, te2) | 0, d4 = d4 + Math.imul(O4, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne2) | 0, n = n + Math.imul(D3, ie) | 0, d4 = d4 + Math.imul(D3, ne2) | 0, l3 = l3 + Math.imul(R4, fe3) | 0, n = n + Math.imul(R4, ae2) | 0, n = n + Math.imul(I5, fe3) | 0, d4 = d4 + Math.imul(I5, ae2) | 0, l3 = l3 + Math.imul(g5, oe3) | 0, n = n + Math.imul(g5, se3) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se3) | 0;
        var We2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X4), n = Math.imul(W, J3), n = n + Math.imul(K5, X4) | 0, d4 = Math.imul(K5, J3), l3 = l3 + Math.imul(z, Q5) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q5) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U3, te2) | 0, d4 = d4 + Math.imul(U3, re2) | 0, l3 = l3 + Math.imul(C4, ie) | 0, n = n + Math.imul(C4, ne2) | 0, n = n + Math.imul(O4, ie) | 0, d4 = d4 + Math.imul(O4, ne2) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D3, fe3) | 0, d4 = d4 + Math.imul(D3, ae2) | 0, l3 = l3 + Math.imul(R4, oe3) | 0, n = n + Math.imul(R4, se3) | 0, n = n + Math.imul(I5, oe3) | 0, d4 = d4 + Math.imul(I5, se3) | 0, l3 = l3 + Math.imul(g5, he) | 0, n = n + Math.imul(g5, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j5, X4), n = Math.imul(j5, J3), n = n + Math.imul(Z3, X4) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q5) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K5, Q5) | 0, d4 = d4 + Math.imul(K5, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne2) | 0, n = n + Math.imul(U3, ie) | 0, d4 = d4 + Math.imul(U3, ne2) | 0, l3 = l3 + Math.imul(C4, fe3) | 0, n = n + Math.imul(C4, ae2) | 0, n = n + Math.imul(O4, fe3) | 0, d4 = d4 + Math.imul(O4, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se3) | 0, n = n + Math.imul(D3, oe3) | 0, d4 = d4 + Math.imul(D3, se3) | 0, l3 = l3 + Math.imul(R4, he) | 0, n = n + Math.imul(R4, ue4) | 0, n = n + Math.imul(I5, he) | 0, d4 = d4 + Math.imul(I5, ue4) | 0, l3 = l3 + Math.imul(g5, le) | 0, n = n + Math.imul(g5, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V6, X4), n = Math.imul(V6, J3), n = n + Math.imul($3, X4) | 0, d4 = Math.imul($3, J3), l3 = l3 + Math.imul(j5, Q5) | 0, n = n + Math.imul(j5, ee) | 0, n = n + Math.imul(Z3, Q5) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K5, te2) | 0, d4 = d4 + Math.imul(K5, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne2) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne2) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U3, fe3) | 0, d4 = d4 + Math.imul(U3, ae2) | 0, l3 = l3 + Math.imul(C4, oe3) | 0, n = n + Math.imul(C4, se3) | 0, n = n + Math.imul(O4, oe3) | 0, d4 = d4 + Math.imul(O4, se3) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D3, he) | 0, d4 = d4 + Math.imul(D3, ue4) | 0, l3 = l3 + Math.imul(R4, le) | 0, n = n + Math.imul(R4, de) | 0, n = n + Math.imul(I5, le) | 0, d4 = d4 + Math.imul(I5, de) | 0, l3 = l3 + Math.imul(g5, ce3) | 0, n = n + Math.imul(g5, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X4), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X4) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V6, Q5) | 0, n = n + Math.imul(V6, ee) | 0, n = n + Math.imul($3, Q5) | 0, d4 = d4 + Math.imul($3, ee) | 0, l3 = l3 + Math.imul(j5, te2) | 0, n = n + Math.imul(j5, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne2) | 0, n = n + Math.imul(K5, ie) | 0, d4 = d4 + Math.imul(K5, ne2) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se3) | 0, n = n + Math.imul(U3, oe3) | 0, d4 = d4 + Math.imul(U3, se3) | 0, l3 = l3 + Math.imul(C4, he) | 0, n = n + Math.imul(C4, ue4) | 0, n = n + Math.imul(O4, he) | 0, d4 = d4 + Math.imul(O4, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D3, le) | 0, d4 = d4 + Math.imul(D3, de) | 0, l3 = l3 + Math.imul(R4, ce3) | 0, n = n + Math.imul(R4, pe2) | 0, n = n + Math.imul(I5, ce3) | 0, d4 = d4 + Math.imul(I5, pe2) | 0, l3 = l3 + Math.imul(g5, ve) | 0, n = n + Math.imul(g5, be2) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be2) | 0;
        var Ve = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q5), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q5) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V6, te2) | 0, n = n + Math.imul(V6, re2) | 0, n = n + Math.imul($3, te2) | 0, d4 = d4 + Math.imul($3, re2) | 0, l3 = l3 + Math.imul(j5, ie) | 0, n = n + Math.imul(j5, ne2) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne2) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K5, fe3) | 0, d4 = d4 + Math.imul(K5, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se3) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se3) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U3, he) | 0, d4 = d4 + Math.imul(U3, ue4) | 0, l3 = l3 + Math.imul(C4, le) | 0, n = n + Math.imul(C4, de) | 0, n = n + Math.imul(O4, le) | 0, d4 = d4 + Math.imul(O4, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D3, ce3) | 0, d4 = d4 + Math.imul(D3, pe2) | 0, l3 = l3 + Math.imul(R4, ve) | 0, n = n + Math.imul(R4, be2) | 0, n = n + Math.imul(I5, ve) | 0, d4 = d4 + Math.imul(I5, be2) | 0;
        var $e2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V6, ie) | 0, n = n + Math.imul(V6, ne2) | 0, n = n + Math.imul($3, ie) | 0, d4 = d4 + Math.imul($3, ne2) | 0, l3 = l3 + Math.imul(j5, fe3) | 0, n = n + Math.imul(j5, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se3) | 0, n = n + Math.imul(K5, oe3) | 0, d4 = d4 + Math.imul(K5, se3) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U3, le) | 0, d4 = d4 + Math.imul(U3, de) | 0, l3 = l3 + Math.imul(C4, ce3) | 0, n = n + Math.imul(C4, pe2) | 0, n = n + Math.imul(O4, ce3) | 0, d4 = d4 + Math.imul(O4, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be2) | 0, n = n + Math.imul(D3, ve) | 0, d4 = d4 + Math.imul(D3, be2) | 0;
        var Ge = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne2), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne2), l3 = l3 + Math.imul(V6, fe3) | 0, n = n + Math.imul(V6, ae2) | 0, n = n + Math.imul($3, fe3) | 0, d4 = d4 + Math.imul($3, ae2) | 0, l3 = l3 + Math.imul(j5, oe3) | 0, n = n + Math.imul(j5, se3) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se3) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K5, he) | 0, d4 = d4 + Math.imul(K5, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U3, ce3) | 0, d4 = d4 + Math.imul(U3, pe2) | 0, l3 = l3 + Math.imul(C4, ve) | 0, n = n + Math.imul(C4, be2) | 0, n = n + Math.imul(O4, ve) | 0, d4 = d4 + Math.imul(O4, be2) | 0;
        var Ye = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V6, oe3) | 0, n = n + Math.imul(V6, se3) | 0, n = n + Math.imul($3, oe3) | 0, d4 = d4 + Math.imul($3, se3) | 0, l3 = l3 + Math.imul(j5, he) | 0, n = n + Math.imul(j5, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K5, le) | 0, d4 = d4 + Math.imul(K5, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be2) | 0, n = n + Math.imul(U3, ve) | 0, d4 = d4 + Math.imul(U3, be2) | 0;
        var Xe = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se3), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se3), l3 = l3 + Math.imul(V6, he) | 0, n = n + Math.imul(V6, ue4) | 0, n = n + Math.imul($3, he) | 0, d4 = d4 + Math.imul($3, ue4) | 0, l3 = l3 + Math.imul(j5, le) | 0, n = n + Math.imul(j5, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K5, ce3) | 0, d4 = d4 + Math.imul(K5, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be2) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be2) | 0;
        var Je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V6, le) | 0, n = n + Math.imul(V6, de) | 0, n = n + Math.imul($3, le) | 0, d4 = d4 + Math.imul($3, de) | 0, l3 = l3 + Math.imul(j5, ce3) | 0, n = n + Math.imul(j5, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be2) | 0, n = n + Math.imul(K5, ve) | 0, d4 = d4 + Math.imul(K5, be2) | 0;
        var Qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V6, ce3) | 0, n = n + Math.imul(V6, pe2) | 0, n = n + Math.imul($3, ce3) | 0, d4 = d4 + Math.imul($3, pe2) | 0, l3 = l3 + Math.imul(j5, ve) | 0, n = n + Math.imul(j5, be2) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be2) | 0;
        var et3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V6, ve) | 0, n = n + Math.imul(V6, be2) | 0, n = n + Math.imul($3, ve) | 0, d4 = d4 + Math.imul($3, be2) | 0;
        var tt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be2), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be2);
        var rt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b6 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft2, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et3, c2[17] = tt4, c2[18] = rt4, b6 !== 0 && (c2[19] = b6, h5.length++), h5;
      };
      Math.imul || (L4 = q3);
      function ge(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative, a3.length = v4.length + i.length;
        for (var h5 = 0, s3 = 0, u3 = 0;u3 < a3.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b6 = h5 & 67108863, l3 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v4.length + 1);n <= l3; n++) {
            var d4 = u3 - n, w3 = v4.words[d4] | 0, g5 = i.words[n] | 0, _4 = w3 * g5, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b6 | 0, b6 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u3] = b6, h5 = c2, c2 = s3;
        }
        return h5 !== 0 ? a3.words[u3] = h5 : a3.length--, a3.strip();
      }
      function _e3(v4, i, a3) {
        var h5 = new N6;
        return h5.mulp(v4, i, a3);
      }
      f3.prototype.mulTo = function(i, a3) {
        var h5, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h5 = L4(this, i, a3) : s3 < 63 ? h5 = q3(this, i, a3) : s3 < 1024 ? h5 = ge(this, i, a3) : h5 = _e3(this, i, a3), h5;
      };
      function N6(v4, i) {
        this.x = v4, this.y = i;
      }
      N6.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h5 = f3.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h5, i);
        return a3;
      }, N6.prototype.revBin = function(i, a3, h5) {
        if (i === 0 || i === h5 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a3; u3++)
          s3 |= (i & 1) << a3 - u3 - 1, i >>= 1;
        return s3;
      }, N6.prototype.permute = function(i, a3, h5, s3, u3, c2) {
        for (var b6 = 0;b6 < c2; b6++)
          s3[b6] = a3[i[b6]], u3[b6] = h5[i[b6]];
      }, N6.prototype.transform = function(i, a3, h5, s3, u3, c2) {
        this.permute(c2, i, a3, h5, s3, u3);
        for (var b6 = 1;b6 < u3; b6 <<= 1)
          for (var l3 = b6 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u3; w3 += l3)
            for (var g5 = n, _4 = d4, A4 = 0;A4 < b6; A4++) {
              var R4 = h5[w3 + A4], I5 = s3[w3 + A4], Me = h5[w3 + A4 + b6], k4 = s3[w3 + A4 + b6], D3 = g5 * Me - _4 * k4;
              k4 = g5 * k4 + _4 * Me, Me = D3, h5[w3 + A4] = R4 + Me, s3[w3 + A4] = I5 + k4, h5[w3 + A4 + b6] = R4 - Me, s3[w3 + A4 + b6] = I5 - k4, A4 !== l3 && (D3 = n * g5 - d4 * _4, _4 = n * _4 + d4 * g5, g5 = D3);
            }
      }, N6.prototype.guessLen13b = function(i, a3) {
        var h5 = Math.max(a3, i) | 1, s3 = h5 & 1, u3 = 0;
        for (h5 = h5 / 2 | 0;h5; h5 = h5 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N6.prototype.conjugate = function(i, a3, h5) {
        if (!(h5 <= 1))
          for (var s3 = 0;s3 < h5 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h5 - s3 - 1], i[h5 - s3 - 1] = u3, u3 = a3[s3], a3[s3] = -a3[h5 - s3 - 1], a3[h5 - s3 - 1] = -u3;
          }
      }, N6.prototype.normalize13b = function(i, a3) {
        for (var h5 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h5;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h5 = 0 : h5 = u3 / 67108864 | 0;
        }
        return i;
      }, N6.prototype.convert13b = function(i, a3, h5, s3) {
        for (var u3 = 0, c2 = 0;c2 < a3; c2++)
          u3 = u3 + (i[c2] | 0), h5[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h5[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h5[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N6.prototype.stub = function(i) {
        for (var a3 = new Array(i), h5 = 0;h5 < i; h5++)
          a3[h5] = 0;
        return a3;
      }, N6.prototype.mulp = function(i, a3, h5) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b6 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d4 = new Array(s3), w3 = new Array(s3), g5 = new Array(s3), _4 = h5.words;
        _4.length = s3, this.convert13b(i.words, i.length, b6, s3), this.convert13b(a3.words, a3.length, d4, s3), this.transform(b6, c2, l3, n, s3, u3), this.transform(d4, c2, w3, g5, s3, u3);
        for (var A4 = 0;A4 < s3; A4++) {
          var R4 = l3[A4] * w3[A4] - n[A4] * g5[A4];
          n[A4] = l3[A4] * g5[A4] + n[A4] * w3[A4], l3[A4] = R4;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _4, c2, s3, u3), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h5.negative = i.negative ^ a3.negative, h5.length = i.length + a3.length, h5.strip();
      }, f3.prototype.mul = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f3.prototype.mulf = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f3.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f3.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h5 = 0;h5 < this.length; h5++) {
          var s3 = (this.words[h5] | 0) * i, u3 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u3 >>> 26, this.words[h5] = u3 & 67108863;
        }
        return a3 !== 0 && (this.words[h5] = a3, this.length++), this;
      }, f3.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f3(1);
        for (var h5 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h5 = h5.sqr())
          ;
        if (++s3 < a3.length)
          for (var u3 = h5.sqr();s3 < a3.length; s3++, u3 = u3.sqr())
            a3[s3] !== 0 && (h5 = h5.mul(u3));
        return h5;
      }, f3.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u3;
        if (a3 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b6 = this.words[u3] & s3, l3 = (this.words[u3] | 0) - b6 << a3;
            this.words[u3] = l3 | c2, c2 = b6 >>> 26 - a3;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h5 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h5] = this.words[u3];
          for (u3 = 0;u3 < h5; u3++)
            this.words[u3] = 0;
          this.length += h5;
        }
        return this.strip();
      }, f3.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f3.prototype.iushrn = function(i, a3, h5) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b6 = 67108863 ^ 67108863 >>> u3 << u3, l3 = h5;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u3 | w3 >>> u3, d4 = w3 & b6;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f3.prototype.ishrn = function(i, a3, h5) {
        return r(this.negative === 0), this.iushrn(i, a3, h5);
      }, f3.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f3.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f3.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f3.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f3.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return false;
        var u3 = this.words[h5];
        return !!(u3 & s3);
      }, f3.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h5)
          return this;
        if (a3 !== 0 && h5++, this.length = Math.min(h5, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f3.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f3.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f3.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f3.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f3.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f3.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(i, a3, h5) {
        var s3 = i.length + h5, u3;
        this._expand(s3);
        var c2, b6 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h5] | 0) + b6;
          var l3 = (i.words[u3] | 0) * a3;
          c2 -= l3 & 67108863, b6 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u3 + h5] = c2 & 67108863;
        }
        for (;u3 < this.length - h5; u3++)
          c2 = (this.words[u3 + h5] | 0) + b6, b6 = c2 >> 26, this.words[u3 + h5] = c2 & 67108863;
        if (b6 === 0)
          return this.strip();
        for (r(b6 === -1), b6 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b6, b6 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f3.prototype._wordDiv = function(i, a3) {
        var h5 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b6 = this._countBits(c2);
        h5 = 26 - b6, h5 !== 0 && (u3 = u3.ushln(h5), s3.iushln(h5), c2 = u3.words[u3.length - 1] | 0);
        var l3 = s3.length - u3.length, n;
        if (a3 !== "mod") {
          n = new f3(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u3, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g5 = l3 - 1;g5 >= 0; g5--) {
          var _4 = (s3.words[u3.length + g5] | 0) * 67108864 + (s3.words[u3.length + g5 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _4, g5);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g5), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g5] = _4);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h5 !== 0 && s3.iushrn(h5), { div: n || null, mod: s3 };
      }, f3.prototype.divmod = function(i, a3, h5) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f3(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f3(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f3(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f3.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f3.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f3.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f3.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h5 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h5.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f3.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h5 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h5 = (a3 * h5 + (this.words[s3] | 0)) % i;
        return h5;
      }, f3.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = (this.words[h5] | 0) + a3 * 67108864;
          this.words[h5] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f3.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f3.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = new f3(0), b6 = new f3(1), l3 = 0;a3.isEven() && h5.isEven(); )
          a3.iushrn(1), h5.iushrn(1), ++l3;
        for (var n = h5.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g5 = 1;(a3.words[0] & g5) === 0 && w3 < 26; ++w3, g5 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d4)), s3.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A4 = 1;(h5.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h5.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b6.isOdd()) && (c2.iadd(n), b6.isub(d4)), c2.iushrn(1), b6.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(c2), u3.isub(b6)) : (h5.isub(a3), c2.isub(s3), b6.isub(u3));
        }
        return { a: c2, b: b6, gcd: h5.iushln(l3) };
      }, f3.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = h5.clone();a3.cmpn(1) > 0 && h5.cmpn(1) > 0; ) {
          for (var b6 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b6 < 26; ++b6, l3 <<= 1)
            ;
          if (b6 > 0)
            for (a3.iushrn(b6);b6-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d4 = 1;(h5.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h5.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(u3)) : (h5.isub(a3), u3.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u3, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f3.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h5 = i.clone();
        a3.negative = 0, h5.negative = 0;
        for (var s3 = 0;a3.isEven() && h5.isEven(); s3++)
          a3.iushrn(1), h5.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h5.isEven(); )
            h5.iushrn(1);
          var u3 = a3.cmp(h5);
          if (u3 < 0) {
            var c2 = a3;
            a3 = h5, h5 = c2;
          } else if (u3 === 0 || h5.cmpn(1) === 0)
            break;
          a3.isub(h5);
        } while (true);
        return h5.iushln(s3);
      }, f3.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f3.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return this._expand(h5 + 1), this.words[h5] |= s3, this;
        for (var u3 = s3, c2 = h5;u3 !== 0 && c2 < this.length; c2++) {
          var b6 = this.words[c2] | 0;
          b6 += u3, u3 = b6 >>> 26, b6 &= 67108863, this.words[c2] = b6;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h5;
        if (this.length > 1)
          h5 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h5 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h5 | 0 : h5;
      }, f3.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f3.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = this.words[h5] | 0, u3 = i.words[h5] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a3 = -1 : s3 > u3 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f3.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f3.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f3.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f3.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f3.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f3.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f3.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f3.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f3.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f3.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f3.red = function(i) {
        return new P4(i);
      }, f3.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f3.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f3.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f3.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f3.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f3.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f3.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f3.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f3.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye2(v4, i) {
        this.name = v4, this.p = new f3(i, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye2.prototype._tmp = function() {
        var i = new f3(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye2.prototype.ireduce = function(i) {
        var a3 = i, h5;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h5 = a3.bitLength();
        while (h5 > this.n);
        var s3 = h5 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye2.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye2.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe2() {
        ye2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe2, ye2), xe2.prototype.split = function(i, a3) {
        for (var h5 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a3.words[u3] = i.words[u3];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h5, u3 = 10;u3 < i.length; u3++) {
          var b6 = i.words[u3] | 0;
          i.words[u3 - 10] = (b6 & h5) << 4 | c2 >>> 22, c2 = b6;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe2.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = i.words[h5] | 0;
          a3 += s3 * 977, i.words[h5] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye2);
      function Ee() {
        ye2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye2);
      function Ae2() {
        ye2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye2), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = (i.words[h5] | 0) * 19 + a3, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h5] = u3, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f3._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe2;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P4(v4) {
        if (typeof v4 == "string") {
          var i = f3._prime(v4);
          this.m = i.p, this.prime = i;
        } else
          r(v4.gtn(1), "modulus must be greater than 1"), this.m = v4, this.prime = null;
      }
      P4.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P4.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P4.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P4.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P4.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.add(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5._forceRed(this);
      }, P4.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.iadd(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5;
      }, P4.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.sub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5._forceRed(this);
      }, P4.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.isub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5;
      }, P4.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P4.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P4.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P4.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P4.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P4.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h5 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(i, h5);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f3(1).toRed(this), b6 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f3(2 * n * n).toRed(this);this.pow(n, l3).cmp(b6) !== 0; )
          n.redIAdd(b6);
        for (var d4 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g5 = this.pow(i, s3), _4 = u3;g5.cmp(c2) !== 0; ) {
          for (var A4 = g5, R4 = 0;A4.cmp(c2) !== 0; R4++)
            A4 = A4.redSqr();
          r(R4 < _4);
          var I5 = this.pow(d4, new f3(1).iushln(_4 - R4 - 1));
          w3 = w3.redMul(I5), d4 = I5.redSqr(), g5 = g5.redMul(d4), _4 = R4;
        }
        return w3;
      }, P4.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P4.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f3(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h5 = 4, s3 = new Array(1 << h5);
        s3[0] = new f3(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b6 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a3.length - 1;u3 >= 0; u3--) {
          for (var d4 = a3.words[u3], w3 = n - 1;w3 >= 0; w3--) {
            var g5 = d4 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g5 === 0 && b6 === 0) {
              l3 = 0;
              continue;
            }
            b6 <<= 1, b6 |= g5, l3++, !(l3 !== h5 && (u3 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b6]), l3 = 0, b6 = 0);
          }
          n = 26;
        }
        return c2;
      }, P4.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P4.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f3.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v4) {
        P4.call(this, v4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P4), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h5 = i.imul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f3(0)._forceRed(this);
        var h5 = i.mul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T3((Yk, Ly) => {
    var s0 = Ut3(), Ff = s0.Buffer, Er5 = {}, Ar3;
    for (Ar3 in s0)
      !s0.hasOwnProperty(Ar3) || Ar3 === "SlowBuffer" || Ar3 === "Buffer" || (Er5[Ar3] = s0[Ar3]);
    var Uf = Er5.Buffer = {};
    for (Ar3 in Ff)
      !Ff.hasOwnProperty(Ar3) || Ar3 === "allocUnsafe" || Ar3 === "allocUnsafeSlow" || (Uf[Ar3] = Ff[Ar3]);
    Er5.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o2 = Ff(t);
      return !e || e.length === 0 ? o2.fill(0) : typeof r == "string" ? o2.fill(e, r) : o2.fill(e), o2;
    });
    if (!Er5.kStringMaxLength)
      try {
        Er5.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Er5.constants || (Er5.constants = { MAX_LENGTH: Er5.kMaxLength }, Er5.kStringMaxLength && (Er5.constants.MAX_STRING_LENGTH = Er5.kStringMaxLength));
    Ly.exports = Er5;
  });
  u0 = T3((Ny) => {
    var aB = Ie();
    function Rr3(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr3;
    Rr3.prototype.isError = function(e) {
      return e instanceof zf2;
    };
    Rr3.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Rr3.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Rr3.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Rr3.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Rr3.prototype.leaveKey = function(e, r, o2) {
      let f3 = this._reporterState;
      this.exitKey(e), f3.obj !== null && (f3.obj[r] = o2);
    };
    Rr3.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr3.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Rr3.prototype.leaveObject = function(e) {
      let r = this._reporterState, o2 = r.obj;
      return r.obj = e, o2;
    };
    Rr3.prototype.error = function(e) {
      let r, o2 = this._reporterState, f3 = e instanceof zf2;
      if (f3 ? r = e : r = new zf2(o2.path.map(function(p3) {
        return "[" + JSON.stringify(p3) + "]";
      }).join(""), e.message || e, e.stack), !o2.options.partial)
        throw r;
      return f3 || o2.errors.push(r), r;
    };
    Rr3.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function zf2(t, e) {
      this.path = t, this.rethrow(e);
    }
    aB(zf2, Error);
    zf2.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf2), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T3((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br3(t, e) {
      if (l0.call(this, e), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br3, l0);
    rd.DecoderBuffer = Br3;
    Br3.isDecoderBuffer = function(e) {
      return e instanceof Br3 ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    Br3.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br3.prototype.restore = function(e) {
      let r = new Br3(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
    };
    Br3.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br3.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    Br3.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o2 = new Br3(this.base);
      return o2._reporterState = this._reporterState, o2.offset = this.offset, o2.length = this.offset + e, this.offset += e, o2;
    };
    Br3.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Wf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e) {
      return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Wf.prototype.join = function(e, r) {
      return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o2) {
        o2.join(e, r), r += o2.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  d0 = T3((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt2 = ar2(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o2 = {};
      this._baseState = o2, o2.name = r, o2.enc = t, o2.parent = e || null, o2.children = null, o2.tag = null, o2.args = null, o2.reverseArgs = null, o2.choice = null, o2.optional = false, o2.any = false, o2.obj = false, o2.use = null, o2.useDecoder = null, o2.key = null, o2.default = null, o2.explicit = null, o2.implicit = null, o2.contains = null, o2.parent || (o2.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      cB.forEach(function(f3) {
        r[f3] = e[f3];
      });
      let o2 = new this.constructor(r.parent);
      return o2._baseState = r, o2;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f3 = new this.constructor(this);
          return e.children.push(f3), f3[r].apply(f3, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      Qt2(r.parent === null), e.call(this), r.children = r.children.filter(function(o2) {
        return o2._baseState.parent === this;
      }, this), Qt2.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o2 = e.filter(function(f3) {
        return f3 instanceof this.constructor;
      }, this);
      e = e.filter(function(f3) {
        return !(f3 instanceof this.constructor);
      }, this), o2.length !== 0 && (Qt2(r.children === null), r.children = o2, o2.forEach(function(f3) {
        f3._baseState.parent = this;
      }, this)), e.length !== 0 && (Qt2(r.args === null), r.args = e, r.reverseArgs = e.map(function(f3) {
        if (typeof f3 != "object" || f3.constructor !== Object)
          return f3;
        let p3 = {};
        return Object.keys(f3).forEach(function(m3) {
          m3 == (m3 | 0) && (m3 |= 0);
          let y5 = f3[m3];
          p3[y5] = m3;
        }), p3;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o2 = Array.prototype.slice.call(arguments);
        return Qt2(r.tag === null), r.tag = t, this._useArgs(o2), this;
      };
    });
    Ue.prototype.use = function(e) {
      Qt2(e);
      let r = this._baseState;
      return Qt2(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return Qt2(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return Qt2(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return Qt2(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return Qt2(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return Qt2(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o2) {
        return e[o2];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return Qt2(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o2 = this._baseState;
      if (o2.parent === null)
        return e.wrapResult(o2.children[0]._decode(e, r));
      let f3 = o2.default, p3 = true, m3 = null;
      if (o2.key !== null && (m3 = e.enterKey(o2.key)), o2.optional) {
        let M3 = null;
        if (o2.explicit !== null ? M3 = o2.explicit : o2.implicit !== null ? M3 = o2.implicit : o2.tag !== null && (M3 = o2.tag), M3 === null && !o2.any) {
          let x5 = e.save();
          try {
            o2.choice === null ? this._decodeGeneric(o2.tag, e, r) : this._decodeChoice(e, r), p3 = true;
          } catch {
            p3 = false;
          }
          e.restore(x5);
        } else if (p3 = this._peekTag(e, M3, o2.any), e.isError(p3))
          return p3;
      }
      let y5;
      if (o2.obj && p3 && (y5 = e.enterObject()), p3) {
        if (o2.explicit !== null) {
          let x5 = this._decodeTag(e, o2.explicit);
          if (e.isError(x5))
            return x5;
          e = x5;
        }
        let M3 = e.offset;
        if (o2.use === null && o2.choice === null) {
          let x5;
          o2.any && (x5 = e.save());
          let S3 = this._decodeTag(e, o2.implicit !== null ? o2.implicit : o2.tag, o2.any);
          if (e.isError(S3))
            return S3;
          o2.any ? f3 = e.raw(x5) : e = S3;
        }
        if (r && r.track && o2.tag !== null && r.track(e.path(), M3, e.length, "tagged"), r && r.track && o2.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o2.any || (o2.choice === null ? f3 = this._decodeGeneric(o2.tag, e, r) : f3 = this._decodeChoice(e, r)), e.isError(f3))
          return f3;
        if (!o2.any && o2.choice === null && o2.children !== null && o2.children.forEach(function(S3) {
          S3._decode(e, r);
        }), o2.contains && (o2.tag === "octstr" || o2.tag === "bitstr")) {
          let x5 = new uB(f3);
          f3 = this._getUse(o2.contains, e._reporterState.obj)._decode(x5, r);
        }
      }
      return o2.obj && p3 && (f3 = e.leaveObject(y5)), o2.key !== null && (f3 !== null || p3 === true) ? e.leaveKey(m3, o2.key, f3) : m3 !== null && e.exitKey(m3), f3;
    };
    Ue.prototype._decodeGeneric = function(e, r, o2) {
      let f3 = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f3.args[0], o2) : /str$/.test(e) ? this._decodeStr(r, e, o2) : e === "objid" && f3.args ? this._decodeObjid(r, f3.args[0], f3.args[1], o2) : e === "objid" ? this._decodeObjid(r, null, null, o2) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o2) : e === "null_" ? this._decodeNull(r, o2) : e === "bool" ? this._decodeBool(r, o2) : e === "objDesc" ? this._decodeStr(r, e, o2) : e === "int" || e === "enum" ? this._decodeInt(r, f3.args && f3.args[0], o2) : f3.use !== null ? this._getUse(f3.use, r._reporterState.obj)._decode(r, o2) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o2 = this._baseState;
      return o2.useDecoder = this._use(e, r), Qt2(o2.useDecoder._baseState.parent === null), o2.useDecoder = o2.useDecoder._baseState.children[0], o2.implicit !== o2.useDecoder._baseState.implicit && (o2.useDecoder = o2.useDecoder.clone(), o2.useDecoder._baseState.implicit = o2.implicit), o2.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o2 = this._baseState, f3 = null, p3 = false;
      return Object.keys(o2.choice).some(function(m3) {
        let y5 = e.save(), M3 = o2.choice[m3];
        try {
          let x5 = M3._decode(e, r);
          if (e.isError(x5))
            return false;
          f3 = { type: m3, value: x5 }, p3 = true;
        } catch {
          return e.restore(y5), false;
        }
        return true;
      }, this), p3 ? f3 : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new hB(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o2) {
      let f3 = this._baseState;
      if (f3.default !== null && f3.default === e)
        return;
      let p3 = this._encodeValue(e, r, o2);
      if (p3 !== undefined && !this._skipDefault(p3, r, o2))
        return p3;
    };
    Ue.prototype._encodeValue = function(e, r, o2) {
      let f3 = this._baseState;
      if (f3.parent === null)
        return f3.children[0]._encode(e, r || new sB);
      let p3 = null;
      if (this.reporter = r, f3.optional && e === undefined)
        if (f3.default !== null)
          e = f3.default;
        else
          return;
      let m3 = null, y5 = false;
      if (f3.any)
        p3 = this._createEncoderBuffer(e);
      else if (f3.choice)
        p3 = this._encodeChoice(e, r);
      else if (f3.contains)
        m3 = this._getUse(f3.contains, o2)._encode(e, r), y5 = true;
      else if (f3.children)
        m3 = f3.children.map(function(M3) {
          if (M3._baseState.tag === "null_")
            return M3._encode(null, r, e);
          if (M3._baseState.key === null)
            return r.error("Child should have a key");
          let x5 = r.enterKey(M3._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S3 = M3._encode(e[M3._baseState.key], r, e);
          return r.leaveKey(x5), S3;
        }, this).filter(function(M3) {
          return M3;
        }), m3 = this._createEncoderBuffer(m3);
      else if (f3.tag === "seqof" || f3.tag === "setof") {
        if (!(f3.args && f3.args.length === 1))
          return r.error("Too many args for : " + f3.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M3 = this.clone();
        M3._baseState.implicit = null, m3 = this._createEncoderBuffer(e.map(function(x5) {
          let S3 = this._baseState;
          return this._getUse(S3.args[0], e)._encode(x5, r);
        }, M3));
      } else
        f3.use !== null ? p3 = this._getUse(f3.use, o2)._encode(e, r) : (m3 = this._encodePrimitive(f3.tag, e), y5 = true);
      if (!f3.any && f3.choice === null) {
        let M3 = f3.implicit !== null ? f3.implicit : f3.tag, x5 = f3.implicit === null ? "universal" : "context";
        M3 === null ? f3.use === null && r.error("Tag could be omitted only for .use()") : f3.use === null && (p3 = this._encodeComposite(M3, y5, x5, m3));
      }
      return f3.explicit !== null && (p3 = this._encodeComposite(f3.explicit, false, "context", p3)), p3;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o2 = this._baseState, f3 = o2.choice[e.type];
      return f3 || Qt2(false, e.type + " not found in " + JSON.stringify(Object.keys(o2.choice))), f3._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o2 = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o2.args)
        return this._encodeObjid(r, o2.reverseArgs[0], o2.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o2.args && o2.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  c0 = T3((Wn) => {
    function Cy(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o2 = t[r];
        e[o2] = r;
      }), e;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T3((tL, Uy) => {
    var pB = Ie(), Ii2 = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur4, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur4(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur4, Oy);
    Ur4.prototype._encodeComposite = function(e, r, o2, f3) {
      let p3 = vB(e, r, o2, this.reporter);
      if (f3.length < 128) {
        let M3 = Ii2.alloc(2);
        return M3[0] = p3, M3[1] = f3.length, this._createEncoderBuffer([M3, f3]);
      }
      let m3 = 1;
      for (let M3 = f3.length;M3 >= 256; M3 >>= 8)
        m3++;
      let y5 = Ii2.alloc(1 + 1 + m3);
      y5[0] = p3, y5[1] = 128 | m3;
      for (let M3 = 1 + m3, x5 = f3.length;x5 > 0; M3--, x5 >>= 8)
        y5[M3] = x5 & 255;
      return this._createEncoderBuffer([y5, f3]);
    };
    Ur4.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o2 = Ii2.alloc(e.length * 2);
        for (let f3 = 0;f3 < e.length; f3++)
          o2.writeUInt16BE(e.charCodeAt(f3), f3 * 2);
        return this._createEncoderBuffer(o2);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur4.prototype._encodeObjid = function(e, r, o2) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y5 = 0;y5 < e.length; y5++)
          e[y5] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y5 = 0;y5 < e.length; y5++)
          e[y5] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o2) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f3 = 0;
      for (let y5 = 0;y5 < e.length; y5++) {
        let M3 = e[y5];
        for (f3++;M3 >= 128; M3 >>= 7)
          f3++;
      }
      let p3 = Ii2.alloc(f3), m3 = p3.length - 1;
      for (let y5 = e.length - 1;y5 >= 0; y5--) {
        let M3 = e[y5];
        for (p3[m3--] = M3 & 127;(M3 >>= 7) > 0; )
          p3[m3--] = 128 | M3 & 127;
      }
      return this._createEncoderBuffer(p3);
    };
    function qr3(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur4.prototype._encodeTime = function(e, r) {
      let o2, f3 = new Date(e);
      return r === "gentime" ? o2 = [qr3(f3.getUTCFullYear()), qr3(f3.getUTCMonth() + 1), qr3(f3.getUTCDate()), qr3(f3.getUTCHours()), qr3(f3.getUTCMinutes()), qr3(f3.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o2 = [qr3(f3.getUTCFullYear() % 100), qr3(f3.getUTCMonth() + 1), qr3(f3.getUTCDate()), qr3(f3.getUTCHours()), qr3(f3.getUTCMinutes()), qr3(f3.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o2, "octstr");
    };
    Ur4.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur4.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ii2.isBuffer(e)) {
        let p3 = e.toArray();
        !e.sign && p3[0] & 128 && p3.unshift(0), e = Ii2.from(p3);
      }
      if (Ii2.isBuffer(e)) {
        let p3 = e.length;
        e.length === 0 && p3++;
        let m3 = Ii2.alloc(p3);
        return e.copy(m3), e.length === 0 && (m3[0] = 0), this._createEncoderBuffer(m3);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o2 = 1;
      for (let p3 = e;p3 >= 256; p3 >>= 8)
        o2++;
      let f3 = new Array(o2);
      for (let p3 = f3.length - 1;p3 >= 0; p3--)
        f3[p3] = e & 255, e >>= 8;
      return f3[0] & 128 && f3.unshift(0), this._createEncoderBuffer(Ii2.from(f3));
    };
    Ur4.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur4.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur4.prototype._skipDefault = function(e, r, o2) {
      let f3 = this._baseState, p3;
      if (f3.default === null)
        return false;
      let m3 = e.join();
      if (f3.defaultBuffer === undefined && (f3.defaultBuffer = this._encodeValue(f3.default, r, o2).join()), m3.length !== f3.defaultBuffer.length)
        return false;
      for (p3 = 0;p3 < m3.length; p3++)
        if (m3[p3] !== f3.defaultBuffer[p3])
          return false;
      return true;
    };
    function vB(t, e, r, o2) {
      let f3;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f3 = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f3 = t;
      else
        return o2.error("Unknown tag: " + t);
      return f3 >= 31 ? o2.error("Multi-octet tag encoding unsupported") : (e || (f3 |= 32), f3 |= id.tagClassByName[r || "universal"] << 6, f3);
    }
  });
  Hy = T3((rL, zy2) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy2.exports = ad;
    ad.prototype.encode = function(e, r) {
      let f3 = fd.prototype.encode.call(this, e).toString("base64"), p3 = ["-----BEGIN " + r.label + "-----"];
      for (let m3 = 0;m3 < f3.length; m3 += 64)
        p3.push(f3.slice(m3, m3 + 64));
      return p3.push("-----END " + r.label + "-----"), p3.join(`
`);
    };
  });
  od = T3((Ky2) => {
    var Wy = Ky2;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T3((nL, Yy2) => {
    var mB = Ie(), gB = td(), jy2 = Kf().DecoderBuffer, Vy2 = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy2.exports = $y;
    $y.prototype.decode = function(e, r) {
      return jy2.isDecoderBuffer(e) || (e = new jy2(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      Vy2.call(this, "der", t);
    }
    mB(sr, Vy2);
    sr.prototype._peekTag = function(e, r, o2) {
      if (e.isEmpty())
        return false;
      let f3 = e.save(), p3 = sd(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p3) ? p3 : (e.restore(f3), p3.tag === r || p3.tagStr === r || p3.tagStr + "of" === r || o2);
    };
    sr.prototype._decodeTag = function(e, r, o2) {
      let f3 = sd(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f3))
        return f3;
      let p3 = Gy(e, f3.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p3))
        return p3;
      if (!o2 && f3.tag !== r && f3.tagStr !== r && f3.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f3.primitive || p3 !== null)
        return e.skip(p3, 'Failed to match body of: "' + r + '"');
      let m3 = e.save(), y5 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y5) ? y5 : (p3 = e.offset - m3.offset, e.restore(m3), e.skip(p3, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o2 = sd(e, r);
        if (e.isError(o2))
          return o2;
        let f3 = Gy(e, o2.primitive, r);
        if (e.isError(f3))
          return f3;
        let p3;
        if (o2.primitive || f3 !== null ? p3 = e.skip(f3) : p3 = this._skipUntilEnd(e, r), e.isError(p3))
          return p3;
        if (o2.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o2, f3) {
      let p3 = [];
      for (;!e.isEmpty(); ) {
        let m3 = this._peekTag(e, "end");
        if (e.isError(m3))
          return m3;
        let y5 = o2.decode(e, "der", f3);
        if (e.isError(y5) && m3)
          break;
        p3.push(y5);
      }
      return p3;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o2 = e.readUInt8();
        return e.isError(o2) ? o2 : { unused: o2, data: e.raw() };
      } else if (r === "bmpstr") {
        let o2 = e.raw();
        if (o2.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f3 = "";
        for (let p3 = 0;p3 < o2.length / 2; p3++)
          f3 += String.fromCharCode(o2.readUInt16BE(p3 * 2));
        return f3;
      } else if (r === "numstr") {
        let o2 = e.raw().toString("ascii");
        return this._isNumstr(o2) ? o2 : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o2 = e.raw().toString("ascii");
          return this._isPrintstr(o2) ? o2 : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o2) {
      let f3, p3 = [], m3 = 0, y5 = 0;
      for (;!e.isEmpty(); )
        y5 = e.readUInt8(), m3 <<= 7, m3 |= y5 & 127, (y5 & 128) === 0 && (p3.push(m3), m3 = 0);
      y5 & 128 && p3.push(m3);
      let M3 = p3[0] / 40 | 0, x5 = p3[0] % 40;
      if (o2 ? f3 = p3 : f3 = [M3, x5].concat(p3.slice(1)), r) {
        let S3 = r[f3.join(" ")];
        S3 === undefined && (S3 = r[f3.join(".")]), S3 !== undefined && (f3 = S3);
      }
      return f3;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o2 = e.raw().toString(), f3, p3, m3, y5, M3, x5;
      if (r === "gentime")
        f3 = o2.slice(0, 4) | 0, p3 = o2.slice(4, 6) | 0, m3 = o2.slice(6, 8) | 0, y5 = o2.slice(8, 10) | 0, M3 = o2.slice(10, 12) | 0, x5 = o2.slice(12, 14) | 0;
      else if (r === "utctime")
        f3 = o2.slice(0, 2) | 0, p3 = o2.slice(2, 4) | 0, m3 = o2.slice(4, 6) | 0, y5 = o2.slice(6, 8) | 0, M3 = o2.slice(8, 10) | 0, x5 = o2.slice(10, 12) | 0, f3 < 70 ? f3 = 2000 + f3 : f3 = 1900 + f3;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f3, p3 - 1, m3, y5, M3, x5, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o2 = e.raw(), f3 = new gB(o2);
      return r && (f3 = r[f3.toString(10)] || f3), f3;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function sd(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o2 = Zy.tagClass[r >> 6], f3 = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m3 = r;
        for (r = 0;(m3 & 128) === 128; ) {
          if (m3 = t.readUInt8(e), t.isError(m3))
            return m3;
          r <<= 7, r |= m3 & 127;
        }
      } else
        r &= 31;
      let p3 = Zy.tag[r];
      return { cls: o2, primitive: f3, tag: r, tagStr: p3 };
    }
    function Gy(t, e, r) {
      let o2 = t.readUInt8(r);
      if (t.isError(o2))
        return o2;
      if (!e && o2 === 128)
        return null;
      if ((o2 & 128) === 0)
        return o2;
      let f3 = o2 & 127;
      if (f3 > 4)
        return t.error("length octect is too long");
      o2 = 0;
      for (let p3 = 0;p3 < f3; p3++) {
        o2 <<= 8;
        let m3 = t.readUInt8(r);
        if (t.isError(m3))
          return m3;
        o2 |= m3;
      }
      return o2;
    }
  });
  Jy2 = T3((fL, Xy2) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy2.exports = ld;
    ld.prototype.decode = function(e, r) {
      let o2 = e.toString().split(/[\r\n]+/g), f3 = r.label.toUpperCase(), p3 = /^-----(BEGIN|END) ([^-]+)-----$/, m3 = -1, y5 = -1;
      for (let S3 = 0;S3 < o2.length; S3++) {
        let E6 = o2[S3].match(p3);
        if (E6 !== null && E6[2] === f3)
          if (m3 === -1) {
            if (E6[1] !== "BEGIN")
              break;
            m3 = S3;
          } else {
            if (E6[1] !== "END")
              break;
            y5 = S3;
            break;
          }
      }
      if (m3 === -1 || y5 === -1)
        throw new Error("PEM section not found for: " + f3);
      let M3 = o2.slice(m3 + 1, y5).join("");
      M3.replace(/[^a-z0-9+/=]+/gi, "");
      let x5 = wB.from(M3, "base64");
      return ud.prototype.decode.call(this, x5, r);
    };
  });
  dd = T3((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy2();
  });
  r3 = T3((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e, r) {
      return new jf(e, r);
    };
    function jf(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e) {
      let r = this.name;
      function o2(f3) {
        this._initNamed(f3, r);
      }
      return xB(o2, e), o2.prototype._initNamed = function(p3, m3) {
        e.call(this, p3, m3);
      }, new o2(this);
    };
    jf.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
    };
    jf.prototype.decode = function(e, r, o2) {
      return this._getDecoder(r).decode(e, o2);
    };
    jf.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
    };
    jf.prototype.encode = function(e, r, o2) {
      return this._getEncoder(r).encode(e, o2);
    };
  });
  n3 = T3((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T3((a3) => {
    var f3 = a3;
    f3._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o2) {
        (o2 | 0) == o2 && (o2 = o2 | 0);
        let f4 = e[o2];
        r[f4] = o2;
      }), r;
    };
    f3.der = c0();
  });
  cd2 = T3((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d32 = T3((lL, l3) => {
    var zr2 = cd2(), h32 = zr2.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr2.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr2.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr2.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr2.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr2.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr2.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr2.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h32), this.key("notAfter").use(h32));
    }), IB = zr2.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr2.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr2.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T3((Wr) => {
    var Hr2 = cd2();
    Wr.certificate = d32();
    var LB = Hr2.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr2.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr2.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr2.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr2.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr2.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr2.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr2.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr2.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr2.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr2.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v32 = T3((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m3 = T3((pL, b32) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b32.exports = function(t, e) {
      var r = t.toString(), o2 = r.match(HB), f3;
      if (o2) {
        var m4 = "aes" + o2[1], y5 = v0.from(o2[2], "hex"), M3 = v0.from(o2[3].replace(/[\r\n]/g, ""), "base64"), x5 = jB(e, y5.slice(0, 8), parseInt(o2[1], 10)).key, S3 = [], E6 = ZB.createDecipheriv(m4, x5, y5);
        S3.push(E6.update(M3)), S3.push(E6.final()), f3 = v0.concat(S3);
      } else {
        var p4 = r.match(KB);
        f3 = v0.from(p4[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B3 = r.match(WB)[1];
      return { tag: B3, data: f3 };
    };
  });
  Ha = T3((vL, y32) => {
    var fr = p3(), VB = v32(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y32.exports = g32;
    function g32(t) {
      var e;
      typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e), o2 = r.tag, f3 = r.data, p4, m4;
      switch (o2) {
        case "CERTIFICATE":
          m4 = fr.certificate.decode(f3, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m4 || (m4 = fr.PublicKey.decode(f3, "der")), p4 = m4.algorithm.algorithm.join("."), p4) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m4.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m4.subjectPrivateKey = m4.subjectPublicKey, { type: "ec", data: m4 };
            case "1.2.840.10040.4.1":
              return m4.algorithm.params.pub_key = fr.DSAparam.decode(m4.subjectPublicKey.data, "der"), { type: "dsa", data: m4.algorithm.params };
            default:
              throw new Error("unknown key id " + p4);
          }
        case "ENCRYPTED PRIVATE KEY":
          f3 = fr.EncryptedPrivateKey.decode(f3, "der"), f3 = XB(f3, e);
        case "PRIVATE KEY":
          switch (m4 = fr.PrivateKey.decode(f3, "der"), p4 = m4.algorithm.algorithm.join("."), p4) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m4.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m4.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m4.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m4.algorithm.params.priv_key = fr.DSAparam.decode(m4.subjectPrivateKey, "der"), { type: "dsa", params: m4.algorithm.params };
            default:
              throw new Error("unknown key id " + p4);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f3, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f3, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f3, "der") };
        case "EC PRIVATE KEY":
          return f3 = fr.ECPrivateKey.decode(f3, "der"), { curve: f3.parameters.value, privateKey: f3.privateKey };
        default:
          throw new Error("unknown key type " + o2);
      }
    }
    g32.signature = fr.signature;
    function XB(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o2 = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f3 = VB[t.algorithm.decrypt.cipher.algo.join(".")], p4 = t.algorithm.decrypt.cipher.iv, m4 = t.subjectPrivateKey, y5 = parseInt(f3.split("-")[1], 10) / 8, M3 = YB.pbkdf2Sync(e, r, o2, y5, "sha1"), x5 = GB.createDecipheriv(f3, M3, p4), S3 = [];
      return S3.push(x5.update(m4)), S3.push(x5.final()), vd.concat(S3);
    }
  });
  bd = T3((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _32 = T3((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks2(), eq = o0().ec, b0 = Ws2(), tq = Ha(), rq = bd();
    function iq(t, e, r, o2, f3) {
      var p4 = tq(e);
      if (p4.curve) {
        if (o2 !== "ecdsa" && o2 !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p4);
      } else if (p4.type === "dsa") {
        if (o2 !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p4, r);
      } else if (o2 !== "rsa" && o2 !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f3, t]);
      for (var m4 = p4.modulus.byteLength(), y5 = [0, 1];t.length + y5.length + 1 < m4; )
        y5.push(255);
      y5.push(0);
      for (var M4 = -1;++M4 < t.length; )
        y5.push(t[M4]);
      var x5 = QB(y5, p4);
      return x5;
    }
    function nq(t, e) {
      var r = rq[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o2 = new eq(r), f3 = o2.keyFromPrivate(e.privateKey), p4 = f3.sign(t);
      return Yt.from(p4.toDER());
    }
    function fq(t, e, r) {
      for (var o2 = e.params.priv_key, f3 = e.params.p, p4 = e.params.q, m4 = e.params.g, y5 = new b0(0), M4, x5 = md(t, p4).mod(p4), S3 = false, E6 = w3(o2, p4, t, r);S3 === false; )
        M4 = M3(p4, E6, r), y5 = sq(m4, M4, f3, p4), S3 = M4.invm(p4).imul(x5.add(o2.mul(y5))).mod(p4), S3.cmpn(0) === 0 && (S3 = false, y5 = new b0(0));
      return aq(y5, S3);
    }
    function aq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o2 = [48, r, 2, t.length];
      return o2 = o2.concat(t, [2, e.length], e), Yt.from(o2);
    }
    function w3(t, e, r, o2) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f3 = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f3, t]);
      }
      var p4 = r.length, m4 = oq(r, e), y5 = Yt.alloc(p4);
      y5.fill(1);
      var M4 = Yt.alloc(p4);
      return M4 = Kn(o2, M4).update(y5).update(Yt.from([0])).update(t).update(m4).digest(), y5 = Kn(o2, M4).update(y5).digest(), M4 = Kn(o2, M4).update(y5).update(Yt.from([1])).update(t).update(m4).digest(), y5 = Kn(o2, M4).update(y5).digest(), { k: M4, v: y5 };
    }
    function md(t, e) {
      var r = new b0(t), o2 = (t.length << 3) - e.bitLength();
      return o2 > 0 && r.ishrn(o2), r;
    }
    function oq(t, e) {
      t = md(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o2 = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o2, r]);
      }
      return r;
    }
    function M3(t, e, r) {
      var o2, f3;
      do {
        for (o2 = Yt.alloc(0);o2.length * 8 < t.bitLength(); )
          e.v = Kn(r, e.k).update(e.v).digest(), o2 = Yt.concat([o2, e.v]);
        f3 = md(o2, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
      } while (f3.cmp(t) !== -1);
      return f3;
    }
    function sq(t, e, r, o2) {
      return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o2);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M3;
  });
  A32 = T3((gL, E32) => {
    var gd = Te().Buffer, Wa2 = Ws2(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e, r, o2, f3) {
      var p4 = S3(r);
      if (p4.type === "ec") {
        if (o2 !== "ecdsa" && o2 !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e, p4);
      } else if (p4.type === "dsa") {
        if (o2 !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e, p4);
      } else if (o2 !== "rsa" && o2 !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = gd.concat([f3, e]);
      for (var m4 = p4.modulus.byteLength(), y5 = [1], M3 = 0;e.length + y5.length + 2 < m4; )
        y5.push(255), M3++;
      y5.push(0);
      for (var x5 = -1;++x5 < e.length; )
        y5.push(e[x5]);
      y5 = gd.from(y5);
      var S4 = Wa2.mont(p4.modulus);
      t = new Wa2(t).toRed(S4), t = t.redPow(new Wa2(p4.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E6 = M3 < 8 ? 1 : 0;
      for (m4 = Math.min(t.length, y5.length), t.length !== y5.length && (E6 = 1), x5 = -1;++x5 < m4; )
        E6 |= t[x5] ^ y5[x5];
      return E6 === 0;
    }
    function dq(t, e, r) {
      var o2 = uq[r.data.algorithm.curve.join(".")];
      if (!o2)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f3 = new hq(o2), p4 = r.data.subjectPrivateKey.data;
      return f3.verify(e, t, p4);
    }
    function cq(t, e, r) {
      var o2 = r.data.p, f3 = r.data.q, p4 = r.data.g, m4 = r.data.pub_key, y5 = S3.signature.decode(t, "der"), M3 = y5.s, x5 = y5.r;
      x32(M3, f3), x32(x5, f3);
      var S4 = Wa2.mont(o2), E6 = M3.invm(f3), B3 = p4.toRed(S4).redPow(new Wa2(e).mul(E6).mod(f3)).fromRed().mul(m4.toRed(S4).redPow(x5.mul(E6).mod(f3)).fromRed()).mod(o2).mod(f3);
      return B3.cmp(x5) === 0;
    }
    function x32(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    E32.exports = lq;
  });
  k32 = T3((yL, T32) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I32 = Ie(), pq = _32(), vq = A32(), jn2 = Mu();
    Object.keys(jn2).forEach(function(t) {
      jn2[t].id = g0.from(jn2[t].id, "hex"), jn2[t.toLowerCase()] = jn2[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e = jn2[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I32(Ka, y0.Writable);
    Ka.prototype._write = function(e, r, o2) {
      this._hash.update(e), o2();
    };
    Ka.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    Ka.prototype.sign = function(e, r) {
      this.end();
      var o2 = this._hash.digest(), f3 = pq(o2, e, this._hashType, this._signType, this._tag);
      return r ? f3.toString(r) : f3;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e = jn2[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I32(ja, y0.Writable);
    ja.prototype._write = function(e, r, o2) {
      this._hash.update(e), o2();
    };
    ja.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    ja.prototype.verify = function(e, r, o2) {
      typeof r == "string" && (r = g0.from(r, o2)), this.end();
      var f3 = this._hash.digest();
      return vq(r, f3, e, this._signType, this._tag);
    };
    function R32(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T32.exports = { Sign: R32, Verify: B3, createSign: R32, createVerify: B3 };
  });
  N32 = T3((L32, yd) => {
    (function(t, e) {
      function r(v4, i) {
        if (!v4)
          throw new Error(i || "Assertion failed");
      }
      function o2(v4, i) {
        v4.super_ = i;
        var a3 = function() {
        };
        a3.prototype = i.prototype, v4.prototype = new a3, v4.prototype.constructor = v4;
      }
      function f3(v4, i, a3) {
        if (f3.isBN(v4))
          return v4;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v4 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v4 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p4;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p4 = window.Buffer : p4 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(i) {
        return i instanceof f3 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f3.wordSize && Array.isArray(i.words);
      }, f3.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f3.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f3.prototype._init = function(i, a3, h5) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h5);
        if (typeof i == "object")
          return this._initArray(i, a3, h5);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h5) : (this._parseBase(i, a3, s3), h5 === "le" && this._initArray(this.toArray(), a3, h5)));
      }, f3.prototype._initNumber = function(i, a3, h5) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h5 === "le" && this._initArray(this.toArray(), a3, h5);
      }, f3.prototype._initArray = function(i, a3, h5) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b6 = 0;
        if (h5 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        else if (h5 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        return this.strip();
      };
      function m4(v4, i) {
        var a3 = v4.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y5(v4, i, a3) {
        var h5 = m4(v4, a3);
        return a3 - 1 >= i && (h5 |= m4(v4, a3 - 1) << 4), h5;
      }
      f3.prototype._parseHex = function(i, a3, h5) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b6;
        if (h5 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M3(v4, i, a3, h5) {
        for (var s3 = 0, u3 = Math.min(v4.length, a3), c2 = i;c2 < u3; c2++) {
          var b6 = v4.charCodeAt(c2) - 48;
          s3 *= h5, b6 >= 49 ? s3 += b6 - 49 + 10 : b6 >= 17 ? s3 += b6 - 17 + 10 : s3 += b6;
        }
        return s3;
      }
      f3.prototype._parseBase = function(i, a3, h5) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a3)
          s3++;
        s3--, u3 = u3 / a3 | 0;
        for (var c2 = i.length - h5, b6 = c2 % s3, l3 = Math.min(c2, c2 - b6) + h5, n = 0, d4 = h5;d4 < l3; d4 += s3)
          n = M3(i, d4, d4 + s3, a3), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b6 !== 0) {
          var w3 = 1;
          for (n = M3(i, d4, i.length, a3), d4 = 0;d4 < b6; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f3.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f3.prototype.clone = function() {
        var i = new f3(null);
        return this.copy(i), i;
      }, f3.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f3.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h5;
        if (i === 16 || i === "hex") {
          h5 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b6 = this.words[c2], l3 = ((b6 << s3 | u3) & 16777215).toString(16);
            u3 = b6 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h5 = x5[6 - l3.length] + l3 + h5 : h5 = l3 + h5, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h5 = u3.toString(16) + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S3[i], d4 = E6[i];
          h5 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g5 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h5 = g5 + h5 : h5 = x5[n - g5.length] + g5 + h5;
          }
          for (this.isZero() && (h5 = "0" + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f3.prototype.toJSON = function() {
        return this.toString(16);
      }, f3.prototype.toBuffer = function(i, a3) {
        return r(typeof p4 < "u"), this.toArrayLike(p4, i, a3);
      }, f3.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f3.prototype.toArrayLike = function(i, a3, h5) {
        var s3 = this.byteLength(), u3 = h5 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b6 = new i(u3), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[n] = l3;
          for (;n < u3; n++)
            b6[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b6[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[u3 - n - 1] = l3;
        }
        return b6;
      }, Math.clz32 ? f3.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f3.prototype._countBits = function(i) {
        var a3 = i, h5 = 0;
        return a3 >= 4096 && (h5 += 13, a3 >>>= 13), a3 >= 64 && (h5 += 7, a3 >>>= 7), a3 >= 8 && (h5 += 4, a3 >>>= 4), a3 >= 2 && (h5 += 2, a3 >>>= 2), h5 + a3;
      }, f3.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h5 = 0;
        return (a3 & 8191) === 0 && (h5 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h5 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h5 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h5 += 2, a3 >>>= 2), (a3 & 1) === 0 && h5++, h5;
      }, f3.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v4) {
        for (var i = new Array(v4.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h5 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v4.words[h5] & 1 << s3) >>> s3;
        }
        return i;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h5 = this._zeroBits(this.words[a3]);
          if (i += h5, h5 !== 26)
            break;
        }
        return i;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f3.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f3.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f3.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f3.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h5 = 0;h5 < a3.length; h5++)
          this.words[h5] = this.words[h5] & i.words[h5];
        return this.length = a3.length, this.strip();
      }, f3.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f3.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f3.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f3.prototype.iuxor = function(i) {
        var a3, h5;
        this.length > i.length ? (a3 = this, h5 = i) : (a3 = i, h5 = this);
        for (var s3 = 0;s3 < h5.length; s3++)
          this.words[s3] = a3.words[s3] ^ h5.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f3.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f3.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f3.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f3.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h5 = i % 26;
        this._expand(a3), h5 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h5 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h5), this.strip();
      }, f3.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f3.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h5 = i / 26 | 0, s3 = i % 26;
        return this._expand(h5 + 1), a3 ? this.words[h5] = this.words[h5] | 1 << s3 : this.words[h5] = this.words[h5] & ~(1 << s3), this.strip();
      }, f3.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h5, s3;
        this.length > i.length ? (h5 = this, s3 = i) : (h5 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h5.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        for (;u3 !== 0 && c2 < h5.length; c2++)
          a3 = (h5.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        if (this.length = h5.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h5 !== this)
          for (;c2 < h5.length; c2++)
            this.words[c2] = h5.words[c2];
        return this;
      }, f3.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f3.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h5 = this.cmp(i);
        if (h5 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h5 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b6 = 0;b6 < u3.length; b6++)
          a3 = (s3.words[b6] | 0) - (u3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        for (;c2 !== 0 && b6 < s3.length; b6++)
          a3 = (s3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        if (c2 === 0 && b6 < s3.length && s3 !== this)
          for (;b6 < s3.length; b6++)
            this.words[b6] = s3.words[b6];
        return this.length = Math.max(this.length, b6), s3 !== this && (this.negative = 1), this.strip();
      }, f3.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q3(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative;
        var h5 = v4.length + i.length | 0;
        a3.length = h5, h5 = h5 - 1 | 0;
        var s3 = v4.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b6 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b6;
        for (var n = 1;n < h5; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g5 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v4.length + 1);_4 <= g5; _4++) {
            var A4 = n - _4 | 0;
            s3 = v4.words[A4] | 0, u3 = i.words[_4] | 0, c2 = s3 * u3 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h5) {
        var s3 = i.words, u3 = a3.words, c2 = h5.words, b6 = 0, l3, n, d4, w3 = s3[0] | 0, g5 = w3 & 8191, _4 = w3 >>> 13, A4 = s3[1] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = s3[3] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = s3[4] | 0, F3 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = s3[6] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = s3[7] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u3[0] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = u3[1] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = u3[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = u3[3] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = u3[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = u3[5] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = u3[6] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = u3[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = u3[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u3[9] | 0, ve = It & 8191, be2 = It >>> 13;
        h5.negative = i.negative ^ a3.negative, h5.length = 19, l3 = Math.imul(g5, X4), n = Math.imul(g5, J3), n = n + Math.imul(_4, X4) | 0, d4 = Math.imul(_4, J3);
        var ft2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l3 = Math.imul(R4, X4), n = Math.imul(R4, J3), n = n + Math.imul(I5, X4) | 0, d4 = Math.imul(I5, J3), l3 = l3 + Math.imul(g5, Q5) | 0, n = n + Math.imul(g5, ee) | 0, n = n + Math.imul(_4, Q5) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X4), n = Math.imul(k4, J3), n = n + Math.imul(D3, X4) | 0, d4 = Math.imul(D3, J3), l3 = l3 + Math.imul(R4, Q5) | 0, n = n + Math.imul(R4, ee) | 0, n = n + Math.imul(I5, Q5) | 0, d4 = d4 + Math.imul(I5, ee) | 0, l3 = l3 + Math.imul(g5, te2) | 0, n = n + Math.imul(g5, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C4, X4), n = Math.imul(C4, J3), n = n + Math.imul(O4, X4) | 0, d4 = Math.imul(O4, J3), l3 = l3 + Math.imul(k4, Q5) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D3, Q5) | 0, d4 = d4 + Math.imul(D3, ee) | 0, l3 = l3 + Math.imul(R4, te2) | 0, n = n + Math.imul(R4, re2) | 0, n = n + Math.imul(I5, te2) | 0, d4 = d4 + Math.imul(I5, re2) | 0, l3 = l3 + Math.imul(g5, ie) | 0, n = n + Math.imul(g5, ne2) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne2) | 0;
        var ze = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X4), n = Math.imul(F3, J3), n = n + Math.imul(U3, X4) | 0, d4 = Math.imul(U3, J3), l3 = l3 + Math.imul(C4, Q5) | 0, n = n + Math.imul(C4, ee) | 0, n = n + Math.imul(O4, Q5) | 0, d4 = d4 + Math.imul(O4, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D3, te2) | 0, d4 = d4 + Math.imul(D3, re2) | 0, l3 = l3 + Math.imul(R4, ie) | 0, n = n + Math.imul(R4, ne2) | 0, n = n + Math.imul(I5, ie) | 0, d4 = d4 + Math.imul(I5, ne2) | 0, l3 = l3 + Math.imul(g5, fe3) | 0, n = n + Math.imul(g5, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X4), n = Math.imul(z, J3), n = n + Math.imul(H3, X4) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q5) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U3, Q5) | 0, d4 = d4 + Math.imul(U3, ee) | 0, l3 = l3 + Math.imul(C4, te2) | 0, n = n + Math.imul(C4, re2) | 0, n = n + Math.imul(O4, te2) | 0, d4 = d4 + Math.imul(O4, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne2) | 0, n = n + Math.imul(D3, ie) | 0, d4 = d4 + Math.imul(D3, ne2) | 0, l3 = l3 + Math.imul(R4, fe3) | 0, n = n + Math.imul(R4, ae2) | 0, n = n + Math.imul(I5, fe3) | 0, d4 = d4 + Math.imul(I5, ae2) | 0, l3 = l3 + Math.imul(g5, oe3) | 0, n = n + Math.imul(g5, se3) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se3) | 0;
        var We2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X4), n = Math.imul(W, J3), n = n + Math.imul(K5, X4) | 0, d4 = Math.imul(K5, J3), l3 = l3 + Math.imul(z, Q5) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q5) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U3, te2) | 0, d4 = d4 + Math.imul(U3, re2) | 0, l3 = l3 + Math.imul(C4, ie) | 0, n = n + Math.imul(C4, ne2) | 0, n = n + Math.imul(O4, ie) | 0, d4 = d4 + Math.imul(O4, ne2) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D3, fe3) | 0, d4 = d4 + Math.imul(D3, ae2) | 0, l3 = l3 + Math.imul(R4, oe3) | 0, n = n + Math.imul(R4, se3) | 0, n = n + Math.imul(I5, oe3) | 0, d4 = d4 + Math.imul(I5, se3) | 0, l3 = l3 + Math.imul(g5, he) | 0, n = n + Math.imul(g5, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j5, X4), n = Math.imul(j5, J3), n = n + Math.imul(Z3, X4) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q5) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K5, Q5) | 0, d4 = d4 + Math.imul(K5, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne2) | 0, n = n + Math.imul(U3, ie) | 0, d4 = d4 + Math.imul(U3, ne2) | 0, l3 = l3 + Math.imul(C4, fe3) | 0, n = n + Math.imul(C4, ae2) | 0, n = n + Math.imul(O4, fe3) | 0, d4 = d4 + Math.imul(O4, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se3) | 0, n = n + Math.imul(D3, oe3) | 0, d4 = d4 + Math.imul(D3, se3) | 0, l3 = l3 + Math.imul(R4, he) | 0, n = n + Math.imul(R4, ue4) | 0, n = n + Math.imul(I5, he) | 0, d4 = d4 + Math.imul(I5, ue4) | 0, l3 = l3 + Math.imul(g5, le) | 0, n = n + Math.imul(g5, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V6, X4), n = Math.imul(V6, J3), n = n + Math.imul($3, X4) | 0, d4 = Math.imul($3, J3), l3 = l3 + Math.imul(j5, Q5) | 0, n = n + Math.imul(j5, ee) | 0, n = n + Math.imul(Z3, Q5) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K5, te2) | 0, d4 = d4 + Math.imul(K5, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne2) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne2) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U3, fe3) | 0, d4 = d4 + Math.imul(U3, ae2) | 0, l3 = l3 + Math.imul(C4, oe3) | 0, n = n + Math.imul(C4, se3) | 0, n = n + Math.imul(O4, oe3) | 0, d4 = d4 + Math.imul(O4, se3) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D3, he) | 0, d4 = d4 + Math.imul(D3, ue4) | 0, l3 = l3 + Math.imul(R4, le) | 0, n = n + Math.imul(R4, de) | 0, n = n + Math.imul(I5, le) | 0, d4 = d4 + Math.imul(I5, de) | 0, l3 = l3 + Math.imul(g5, ce3) | 0, n = n + Math.imul(g5, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X4), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X4) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V6, Q5) | 0, n = n + Math.imul(V6, ee) | 0, n = n + Math.imul($3, Q5) | 0, d4 = d4 + Math.imul($3, ee) | 0, l3 = l3 + Math.imul(j5, te2) | 0, n = n + Math.imul(j5, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne2) | 0, n = n + Math.imul(K5, ie) | 0, d4 = d4 + Math.imul(K5, ne2) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se3) | 0, n = n + Math.imul(U3, oe3) | 0, d4 = d4 + Math.imul(U3, se3) | 0, l3 = l3 + Math.imul(C4, he) | 0, n = n + Math.imul(C4, ue4) | 0, n = n + Math.imul(O4, he) | 0, d4 = d4 + Math.imul(O4, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D3, le) | 0, d4 = d4 + Math.imul(D3, de) | 0, l3 = l3 + Math.imul(R4, ce3) | 0, n = n + Math.imul(R4, pe2) | 0, n = n + Math.imul(I5, ce3) | 0, d4 = d4 + Math.imul(I5, pe2) | 0, l3 = l3 + Math.imul(g5, ve) | 0, n = n + Math.imul(g5, be2) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be2) | 0;
        var Ve = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q5), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q5) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V6, te2) | 0, n = n + Math.imul(V6, re2) | 0, n = n + Math.imul($3, te2) | 0, d4 = d4 + Math.imul($3, re2) | 0, l3 = l3 + Math.imul(j5, ie) | 0, n = n + Math.imul(j5, ne2) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne2) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K5, fe3) | 0, d4 = d4 + Math.imul(K5, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se3) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se3) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U3, he) | 0, d4 = d4 + Math.imul(U3, ue4) | 0, l3 = l3 + Math.imul(C4, le) | 0, n = n + Math.imul(C4, de) | 0, n = n + Math.imul(O4, le) | 0, d4 = d4 + Math.imul(O4, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D3, ce3) | 0, d4 = d4 + Math.imul(D3, pe2) | 0, l3 = l3 + Math.imul(R4, ve) | 0, n = n + Math.imul(R4, be2) | 0, n = n + Math.imul(I5, ve) | 0, d4 = d4 + Math.imul(I5, be2) | 0;
        var $e2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V6, ie) | 0, n = n + Math.imul(V6, ne2) | 0, n = n + Math.imul($3, ie) | 0, d4 = d4 + Math.imul($3, ne2) | 0, l3 = l3 + Math.imul(j5, fe3) | 0, n = n + Math.imul(j5, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se3) | 0, n = n + Math.imul(K5, oe3) | 0, d4 = d4 + Math.imul(K5, se3) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U3, le) | 0, d4 = d4 + Math.imul(U3, de) | 0, l3 = l3 + Math.imul(C4, ce3) | 0, n = n + Math.imul(C4, pe2) | 0, n = n + Math.imul(O4, ce3) | 0, d4 = d4 + Math.imul(O4, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be2) | 0, n = n + Math.imul(D3, ve) | 0, d4 = d4 + Math.imul(D3, be2) | 0;
        var Ge = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne2), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne2), l3 = l3 + Math.imul(V6, fe3) | 0, n = n + Math.imul(V6, ae2) | 0, n = n + Math.imul($3, fe3) | 0, d4 = d4 + Math.imul($3, ae2) | 0, l3 = l3 + Math.imul(j5, oe3) | 0, n = n + Math.imul(j5, se3) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se3) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K5, he) | 0, d4 = d4 + Math.imul(K5, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U3, ce3) | 0, d4 = d4 + Math.imul(U3, pe2) | 0, l3 = l3 + Math.imul(C4, ve) | 0, n = n + Math.imul(C4, be2) | 0, n = n + Math.imul(O4, ve) | 0, d4 = d4 + Math.imul(O4, be2) | 0;
        var Ye = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V6, oe3) | 0, n = n + Math.imul(V6, se3) | 0, n = n + Math.imul($3, oe3) | 0, d4 = d4 + Math.imul($3, se3) | 0, l3 = l3 + Math.imul(j5, he) | 0, n = n + Math.imul(j5, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K5, le) | 0, d4 = d4 + Math.imul(K5, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be2) | 0, n = n + Math.imul(U3, ve) | 0, d4 = d4 + Math.imul(U3, be2) | 0;
        var Xe = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se3), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se3), l3 = l3 + Math.imul(V6, he) | 0, n = n + Math.imul(V6, ue4) | 0, n = n + Math.imul($3, he) | 0, d4 = d4 + Math.imul($3, ue4) | 0, l3 = l3 + Math.imul(j5, le) | 0, n = n + Math.imul(j5, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K5, ce3) | 0, d4 = d4 + Math.imul(K5, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be2) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be2) | 0;
        var Je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V6, le) | 0, n = n + Math.imul(V6, de) | 0, n = n + Math.imul($3, le) | 0, d4 = d4 + Math.imul($3, de) | 0, l3 = l3 + Math.imul(j5, ce3) | 0, n = n + Math.imul(j5, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be2) | 0, n = n + Math.imul(K5, ve) | 0, d4 = d4 + Math.imul(K5, be2) | 0;
        var Qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V6, ce3) | 0, n = n + Math.imul(V6, pe2) | 0, n = n + Math.imul($3, ce3) | 0, d4 = d4 + Math.imul($3, pe2) | 0, l3 = l3 + Math.imul(j5, ve) | 0, n = n + Math.imul(j5, be2) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be2) | 0;
        var et3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V6, ve) | 0, n = n + Math.imul(V6, be2) | 0, n = n + Math.imul($3, ve) | 0, d4 = d4 + Math.imul($3, be2) | 0;
        var tt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be2), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be2);
        var rt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b6 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft2, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et3, c2[17] = tt4, c2[18] = rt4, b6 !== 0 && (c2[19] = b6, h5.length++), h5;
      };
      Math.imul || (L4 = q3);
      function ge(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative, a3.length = v4.length + i.length;
        for (var h5 = 0, s3 = 0, u3 = 0;u3 < a3.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b6 = h5 & 67108863, l3 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v4.length + 1);n <= l3; n++) {
            var d4 = u3 - n, w3 = v4.words[d4] | 0, g5 = i.words[n] | 0, _4 = w3 * g5, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b6 | 0, b6 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u3] = b6, h5 = c2, c2 = s3;
        }
        return h5 !== 0 ? a3.words[u3] = h5 : a3.length--, a3.strip();
      }
      function _e3(v4, i, a3) {
        var h5 = new N6;
        return h5.mulp(v4, i, a3);
      }
      f3.prototype.mulTo = function(i, a3) {
        var h5, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h5 = L4(this, i, a3) : s3 < 63 ? h5 = q3(this, i, a3) : s3 < 1024 ? h5 = ge(this, i, a3) : h5 = _e3(this, i, a3), h5;
      };
      function N6(v4, i) {
        this.x = v4, this.y = i;
      }
      N6.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h5 = f3.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h5, i);
        return a3;
      }, N6.prototype.revBin = function(i, a3, h5) {
        if (i === 0 || i === h5 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a3; u3++)
          s3 |= (i & 1) << a3 - u3 - 1, i >>= 1;
        return s3;
      }, N6.prototype.permute = function(i, a3, h5, s3, u3, c2) {
        for (var b6 = 0;b6 < c2; b6++)
          s3[b6] = a3[i[b6]], u3[b6] = h5[i[b6]];
      }, N6.prototype.transform = function(i, a3, h5, s3, u3, c2) {
        this.permute(c2, i, a3, h5, s3, u3);
        for (var b6 = 1;b6 < u3; b6 <<= 1)
          for (var l3 = b6 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u3; w3 += l3)
            for (var g5 = n, _4 = d4, A4 = 0;A4 < b6; A4++) {
              var R4 = h5[w3 + A4], I5 = s3[w3 + A4], Me = h5[w3 + A4 + b6], k4 = s3[w3 + A4 + b6], D3 = g5 * Me - _4 * k4;
              k4 = g5 * k4 + _4 * Me, Me = D3, h5[w3 + A4] = R4 + Me, s3[w3 + A4] = I5 + k4, h5[w3 + A4 + b6] = R4 - Me, s3[w3 + A4 + b6] = I5 - k4, A4 !== l3 && (D3 = n * g5 - d4 * _4, _4 = n * _4 + d4 * g5, g5 = D3);
            }
      }, N6.prototype.guessLen13b = function(i, a3) {
        var h5 = Math.max(a3, i) | 1, s3 = h5 & 1, u3 = 0;
        for (h5 = h5 / 2 | 0;h5; h5 = h5 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N6.prototype.conjugate = function(i, a3, h5) {
        if (!(h5 <= 1))
          for (var s3 = 0;s3 < h5 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h5 - s3 - 1], i[h5 - s3 - 1] = u3, u3 = a3[s3], a3[s3] = -a3[h5 - s3 - 1], a3[h5 - s3 - 1] = -u3;
          }
      }, N6.prototype.normalize13b = function(i, a3) {
        for (var h5 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h5;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h5 = 0 : h5 = u3 / 67108864 | 0;
        }
        return i;
      }, N6.prototype.convert13b = function(i, a3, h5, s3) {
        for (var u3 = 0, c2 = 0;c2 < a3; c2++)
          u3 = u3 + (i[c2] | 0), h5[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h5[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h5[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N6.prototype.stub = function(i) {
        for (var a3 = new Array(i), h5 = 0;h5 < i; h5++)
          a3[h5] = 0;
        return a3;
      }, N6.prototype.mulp = function(i, a3, h5) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b6 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d4 = new Array(s3), w3 = new Array(s3), g5 = new Array(s3), _4 = h5.words;
        _4.length = s3, this.convert13b(i.words, i.length, b6, s3), this.convert13b(a3.words, a3.length, d4, s3), this.transform(b6, c2, l3, n, s3, u3), this.transform(d4, c2, w3, g5, s3, u3);
        for (var A4 = 0;A4 < s3; A4++) {
          var R4 = l3[A4] * w3[A4] - n[A4] * g5[A4];
          n[A4] = l3[A4] * g5[A4] + n[A4] * w3[A4], l3[A4] = R4;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _4, c2, s3, u3), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h5.negative = i.negative ^ a3.negative, h5.length = i.length + a3.length, h5.strip();
      }, f3.prototype.mul = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f3.prototype.mulf = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f3.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f3.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h5 = 0;h5 < this.length; h5++) {
          var s3 = (this.words[h5] | 0) * i, u3 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u3 >>> 26, this.words[h5] = u3 & 67108863;
        }
        return a3 !== 0 && (this.words[h5] = a3, this.length++), this;
      }, f3.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f3(1);
        for (var h5 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h5 = h5.sqr())
          ;
        if (++s3 < a3.length)
          for (var u3 = h5.sqr();s3 < a3.length; s3++, u3 = u3.sqr())
            a3[s3] !== 0 && (h5 = h5.mul(u3));
        return h5;
      }, f3.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u3;
        if (a3 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b6 = this.words[u3] & s3, l3 = (this.words[u3] | 0) - b6 << a3;
            this.words[u3] = l3 | c2, c2 = b6 >>> 26 - a3;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h5 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h5] = this.words[u3];
          for (u3 = 0;u3 < h5; u3++)
            this.words[u3] = 0;
          this.length += h5;
        }
        return this.strip();
      }, f3.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f3.prototype.iushrn = function(i, a3, h5) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b6 = 67108863 ^ 67108863 >>> u3 << u3, l3 = h5;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u3 | w3 >>> u3, d4 = w3 & b6;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f3.prototype.ishrn = function(i, a3, h5) {
        return r(this.negative === 0), this.iushrn(i, a3, h5);
      }, f3.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f3.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f3.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f3.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f3.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return false;
        var u3 = this.words[h5];
        return !!(u3 & s3);
      }, f3.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h5)
          return this;
        if (a3 !== 0 && h5++, this.length = Math.min(h5, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f3.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f3.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f3.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f3.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f3.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f3.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(i, a3, h5) {
        var s3 = i.length + h5, u3;
        this._expand(s3);
        var c2, b6 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h5] | 0) + b6;
          var l3 = (i.words[u3] | 0) * a3;
          c2 -= l3 & 67108863, b6 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u3 + h5] = c2 & 67108863;
        }
        for (;u3 < this.length - h5; u3++)
          c2 = (this.words[u3 + h5] | 0) + b6, b6 = c2 >> 26, this.words[u3 + h5] = c2 & 67108863;
        if (b6 === 0)
          return this.strip();
        for (r(b6 === -1), b6 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b6, b6 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f3.prototype._wordDiv = function(i, a3) {
        var h5 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b6 = this._countBits(c2);
        h5 = 26 - b6, h5 !== 0 && (u3 = u3.ushln(h5), s3.iushln(h5), c2 = u3.words[u3.length - 1] | 0);
        var l3 = s3.length - u3.length, n;
        if (a3 !== "mod") {
          n = new f3(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u3, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g5 = l3 - 1;g5 >= 0; g5--) {
          var _4 = (s3.words[u3.length + g5] | 0) * 67108864 + (s3.words[u3.length + g5 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _4, g5);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g5), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g5] = _4);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h5 !== 0 && s3.iushrn(h5), { div: n || null, mod: s3 };
      }, f3.prototype.divmod = function(i, a3, h5) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f3(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f3(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f3(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f3.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f3.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f3.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f3.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h5 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h5.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f3.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h5 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h5 = (a3 * h5 + (this.words[s3] | 0)) % i;
        return h5;
      }, f3.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = (this.words[h5] | 0) + a3 * 67108864;
          this.words[h5] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f3.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f3.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = new f3(0), b6 = new f3(1), l3 = 0;a3.isEven() && h5.isEven(); )
          a3.iushrn(1), h5.iushrn(1), ++l3;
        for (var n = h5.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g5 = 1;(a3.words[0] & g5) === 0 && w3 < 26; ++w3, g5 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d4)), s3.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A4 = 1;(h5.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h5.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b6.isOdd()) && (c2.iadd(n), b6.isub(d4)), c2.iushrn(1), b6.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(c2), u3.isub(b6)) : (h5.isub(a3), c2.isub(s3), b6.isub(u3));
        }
        return { a: c2, b: b6, gcd: h5.iushln(l3) };
      }, f3.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = h5.clone();a3.cmpn(1) > 0 && h5.cmpn(1) > 0; ) {
          for (var b6 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b6 < 26; ++b6, l3 <<= 1)
            ;
          if (b6 > 0)
            for (a3.iushrn(b6);b6-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d4 = 1;(h5.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h5.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(u3)) : (h5.isub(a3), u3.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u3, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f3.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h5 = i.clone();
        a3.negative = 0, h5.negative = 0;
        for (var s3 = 0;a3.isEven() && h5.isEven(); s3++)
          a3.iushrn(1), h5.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h5.isEven(); )
            h5.iushrn(1);
          var u3 = a3.cmp(h5);
          if (u3 < 0) {
            var c2 = a3;
            a3 = h5, h5 = c2;
          } else if (u3 === 0 || h5.cmpn(1) === 0)
            break;
          a3.isub(h5);
        } while (true);
        return h5.iushln(s3);
      }, f3.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f3.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return this._expand(h5 + 1), this.words[h5] |= s3, this;
        for (var u3 = s3, c2 = h5;u3 !== 0 && c2 < this.length; c2++) {
          var b6 = this.words[c2] | 0;
          b6 += u3, u3 = b6 >>> 26, b6 &= 67108863, this.words[c2] = b6;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h5;
        if (this.length > 1)
          h5 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h5 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h5 | 0 : h5;
      }, f3.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f3.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = this.words[h5] | 0, u3 = i.words[h5] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a3 = -1 : s3 > u3 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f3.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f3.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f3.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f3.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f3.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f3.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f3.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f3.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f3.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f3.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f3.red = function(i) {
        return new P4(i);
      }, f3.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f3.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f3.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f3.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f3.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f3.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f3.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f3.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f3.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye2(v4, i) {
        this.name = v4, this.p = new f3(i, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye2.prototype._tmp = function() {
        var i = new f3(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye2.prototype.ireduce = function(i) {
        var a3 = i, h5;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h5 = a3.bitLength();
        while (h5 > this.n);
        var s3 = h5 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye2.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye2.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe2() {
        ye2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe2, ye2), xe2.prototype.split = function(i, a3) {
        for (var h5 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a3.words[u3] = i.words[u3];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h5, u3 = 10;u3 < i.length; u3++) {
          var b6 = i.words[u3] | 0;
          i.words[u3 - 10] = (b6 & h5) << 4 | c2 >>> 22, c2 = b6;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe2.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = i.words[h5] | 0;
          a3 += s3 * 977, i.words[h5] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye2);
      function Ee() {
        ye2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye2);
      function Ae2() {
        ye2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye2), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = (i.words[h5] | 0) * 19 + a3, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h5] = u3, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f3._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe2;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P4(v4) {
        if (typeof v4 == "string") {
          var i = f3._prime(v4);
          this.m = i.p, this.prime = i;
        } else
          r(v4.gtn(1), "modulus must be greater than 1"), this.m = v4, this.prime = null;
      }
      P4.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P4.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P4.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P4.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P4.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.add(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5._forceRed(this);
      }, P4.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.iadd(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5;
      }, P4.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.sub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5._forceRed(this);
      }, P4.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.isub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5;
      }, P4.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P4.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P4.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P4.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P4.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P4.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h5 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(i, h5);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f3(1).toRed(this), b6 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f3(2 * n * n).toRed(this);this.pow(n, l3).cmp(b6) !== 0; )
          n.redIAdd(b6);
        for (var d4 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g5 = this.pow(i, s3), _4 = u3;g5.cmp(c2) !== 0; ) {
          for (var A4 = g5, R4 = 0;A4.cmp(c2) !== 0; R4++)
            A4 = A4.redSqr();
          r(R4 < _4);
          var I5 = this.pow(d4, new f3(1).iushln(_4 - R4 - 1));
          w3 = w3.redMul(I5), d4 = I5.redSqr(), g5 = g5.redMul(d4), _4 = R4;
        }
        return w3;
      }, P4.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P4.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f3(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h5 = 4, s3 = new Array(1 << h5);
        s3[0] = new f3(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b6 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a3.length - 1;u3 >= 0; u3--) {
          for (var d4 = a3.words[u3], w3 = n - 1;w3 >= 0; w3--) {
            var g5 = d4 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g5 === 0 && b6 === 0) {
              l3 = 0;
              continue;
            }
            b6 <<= 1, b6 |= g5, l3++, !(l3 !== h5 && (u3 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b6]), l3 = 0, b6 = 0);
          }
          n = 26;
        }
        return c2;
      }, P4.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P4.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f3.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v4) {
        P4.call(this, v4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P4), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h5 = i.imul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f3(0)._forceRed(this);
        var h5 = i.mul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof yd > "u" || yd, L32);
  });
  P32 = T3((wL, D3) => {
    var bq = o0(), mq = N32();
    D3.exports = function(e) {
      return new Zn(e);
    };
    var hr3 = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr3.p224 = hr3.secp224r1;
    hr3.p256 = hr3.secp256r1 = hr3.prime256v1;
    hr3.p192 = hr3.secp192r1 = hr3.prime192v1;
    hr3.p384 = hr3.secp384r1;
    hr3.p521 = hr3.secp521r1;
    function Zn(t) {
      this.curveType = hr3[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Zn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o2 = this.curve.keyFromPublic(t).getPublic(), f3 = o2.mul(this.keys.getPrivate()).getX();
      return wd(f3, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o2 = new Buffer(t);
      if (r && o2.length < r) {
        var f3 = new Buffer(r - o2.length);
        f3.fill(0), o2 = Buffer.concat([f3, o2]);
      }
      return e ? o2.toString(e) : o2;
    }
  });
  _d = T3((ML, C32) => {
    var gq = bf(), Md = Te().Buffer;
    C32.exports = function(t, e) {
      for (var r = Md.alloc(0), o2 = 0, f3;r.length < e; )
        f3 = yq(o2++), r = Md.concat([r, gq("sha1").update(t).update(f3).digest()]);
      return r.slice(0, e);
    };
    function yq(t) {
      var e = Md.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  xd2 = T3((_L, O32) => {
    O32.exports = function(e, r) {
      for (var o2 = e.length, f3 = -1;++f3 < o2; )
        e[f3] ^= r[f3];
      return e;
    };
  });
  w0 = T3((F3, Sd) => {
    (function(t, e) {
      function r(v4, i) {
        if (!v4)
          throw new Error(i || "Assertion failed");
      }
      function o2(v4, i) {
        v4.super_ = i;
        var a3 = function() {
        };
        a3.prototype = i.prototype, v4.prototype = new a3, v4.prototype.constructor = v4;
      }
      function f3(v4, i, a3) {
        if (f3.isBN(v4))
          return v4;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v4 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v4 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f3 : e.BN = f3, f3.BN = f3, f3.wordSize = 26;
      var p4;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p4 = window.Buffer : p4 = ji2().Buffer;
      } catch {
      }
      f3.isBN = function(i) {
        return i instanceof f3 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f3.wordSize && Array.isArray(i.words);
      }, f3.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f3.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f3.prototype._init = function(i, a3, h5) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h5);
        if (typeof i == "object")
          return this._initArray(i, a3, h5);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h5) : (this._parseBase(i, a3, s3), h5 === "le" && this._initArray(this.toArray(), a3, h5)));
      }, f3.prototype._initNumber = function(i, a3, h5) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h5 === "le" && this._initArray(this.toArray(), a3, h5);
      }, f3.prototype._initArray = function(i, a3, h5) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b6 = 0;
        if (h5 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        else if (h5 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b6 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b6 & 67108863, b6 += 24, b6 >= 26 && (b6 -= 26, u3++);
        return this.strip();
      };
      function m4(v4, i) {
        var a3 = v4.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y5(v4, i, a3) {
        var h5 = m4(v4, a3);
        return a3 - 1 >= i && (h5 |= m4(v4, a3 - 1) << 4), h5;
      }
      f3.prototype._parseHex = function(i, a3, h5) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b6;
        if (h5 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b6 = y5(i, a3, s3) << u3, this.words[c2] |= b6 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b6 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M3(v4, i, a3, h5) {
        for (var s3 = 0, u3 = Math.min(v4.length, a3), c2 = i;c2 < u3; c2++) {
          var b6 = v4.charCodeAt(c2) - 48;
          s3 *= h5, b6 >= 49 ? s3 += b6 - 49 + 10 : b6 >= 17 ? s3 += b6 - 17 + 10 : s3 += b6;
        }
        return s3;
      }
      f3.prototype._parseBase = function(i, a3, h5) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a3)
          s3++;
        s3--, u3 = u3 / a3 | 0;
        for (var c2 = i.length - h5, b6 = c2 % s3, l3 = Math.min(c2, c2 - b6) + h5, n = 0, d4 = h5;d4 < l3; d4 += s3)
          n = M3(i, d4, d4 + s3, a3), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b6 !== 0) {
          var w3 = 1;
          for (n = M3(i, d4, i.length, a3), d4 = 0;d4 < b6; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f3.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f3.prototype.clone = function() {
        var i = new f3(null);
        return this.copy(i), i;
      }, f3.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f3.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f3.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f3.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f3.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h5;
        if (i === 16 || i === "hex") {
          h5 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b6 = this.words[c2], l3 = ((b6 << s3 | u3) & 16777215).toString(16);
            u3 = b6 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h5 = x5[6 - l3.length] + l3 + h5 : h5 = l3 + h5, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h5 = u3.toString(16) + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S3[i], d4 = E6[i];
          h5 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g5 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h5 = g5 + h5 : h5 = x5[n - g5.length] + g5 + h5;
          }
          for (this.isZero() && (h5 = "0" + h5);h5.length % a3 !== 0; )
            h5 = "0" + h5;
          return this.negative !== 0 && (h5 = "-" + h5), h5;
        }
        r(false, "Base should be between 2 and 36");
      }, f3.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f3.prototype.toJSON = function() {
        return this.toString(16);
      }, f3.prototype.toBuffer = function(i, a3) {
        return r(typeof p4 < "u"), this.toArrayLike(p4, i, a3);
      }, f3.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f3.prototype.toArrayLike = function(i, a3, h5) {
        var s3 = this.byteLength(), u3 = h5 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b6 = new i(u3), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[n] = l3;
          for (;n < u3; n++)
            b6[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b6[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b6[u3 - n - 1] = l3;
        }
        return b6;
      }, Math.clz32 ? f3.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f3.prototype._countBits = function(i) {
        var a3 = i, h5 = 0;
        return a3 >= 4096 && (h5 += 13, a3 >>>= 13), a3 >= 64 && (h5 += 7, a3 >>>= 7), a3 >= 8 && (h5 += 4, a3 >>>= 4), a3 >= 2 && (h5 += 2, a3 >>>= 2), h5 + a3;
      }, f3.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h5 = 0;
        return (a3 & 8191) === 0 && (h5 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h5 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h5 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h5 += 2, a3 >>>= 2), (a3 & 1) === 0 && h5++, h5;
      }, f3.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v4) {
        for (var i = new Array(v4.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h5 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v4.words[h5] & 1 << s3) >>> s3;
        }
        return i;
      }
      f3.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h5 = this._zeroBits(this.words[a3]);
          if (i += h5, h5 !== 26)
            break;
        }
        return i;
      }, f3.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f3.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f3.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f3.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f3.prototype.neg = function() {
        return this.clone().ineg();
      }, f3.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f3.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f3.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f3.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f3.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f3.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h5 = 0;h5 < a3.length; h5++)
          this.words[h5] = this.words[h5] & i.words[h5];
        return this.length = a3.length, this.strip();
      }, f3.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f3.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f3.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f3.prototype.iuxor = function(i) {
        var a3, h5;
        this.length > i.length ? (a3 = this, h5 = i) : (a3 = i, h5 = this);
        for (var s3 = 0;s3 < h5.length; s3++)
          this.words[s3] = a3.words[s3] ^ h5.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f3.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f3.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f3.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f3.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h5 = i % 26;
        this._expand(a3), h5 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h5 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h5), this.strip();
      }, f3.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f3.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h5 = i / 26 | 0, s3 = i % 26;
        return this._expand(h5 + 1), a3 ? this.words[h5] = this.words[h5] | 1 << s3 : this.words[h5] = this.words[h5] & ~(1 << s3), this.strip();
      }, f3.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h5, s3;
        this.length > i.length ? (h5 = this, s3 = i) : (h5 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h5.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        for (;u3 !== 0 && c2 < h5.length; c2++)
          a3 = (h5.words[c2] | 0) + u3, this.words[c2] = a3 & 67108863, u3 = a3 >>> 26;
        if (this.length = h5.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h5 !== this)
          for (;c2 < h5.length; c2++)
            this.words[c2] = h5.words[c2];
        return this;
      }, f3.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f3.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h5 = this.cmp(i);
        if (h5 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h5 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b6 = 0;b6 < u3.length; b6++)
          a3 = (s3.words[b6] | 0) - (u3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        for (;c2 !== 0 && b6 < s3.length; b6++)
          a3 = (s3.words[b6] | 0) + c2, c2 = a3 >> 26, this.words[b6] = a3 & 67108863;
        if (c2 === 0 && b6 < s3.length && s3 !== this)
          for (;b6 < s3.length; b6++)
            this.words[b6] = s3.words[b6];
        return this.length = Math.max(this.length, b6), s3 !== this && (this.negative = 1), this.strip();
      }, f3.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q3(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative;
        var h5 = v4.length + i.length | 0;
        a3.length = h5, h5 = h5 - 1 | 0;
        var s3 = v4.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b6 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b6;
        for (var n = 1;n < h5; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g5 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v4.length + 1);_4 <= g5; _4++) {
            var A4 = n - _4 | 0;
            s3 = v4.words[A4] | 0, u3 = i.words[_4] | 0, c2 = s3 * u3 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h5) {
        var s3 = i.words, u3 = a3.words, c2 = h5.words, b6 = 0, l3, n, d4, w3 = s3[0] | 0, g5 = w3 & 8191, _4 = w3 >>> 13, A4 = s3[1] | 0, R4 = A4 & 8191, I5 = A4 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D3 = Me >>> 13, nt4 = s3[3] | 0, C4 = nt4 & 8191, O4 = nt4 >>> 13, vt2 = s3[4] | 0, F4 = vt2 & 8191, U3 = vt2 >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt4 = s3[6] | 0, W = mt4 & 8191, K5 = mt4 >>> 13, gt3 = s3[7] | 0, j5 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V6 = yt2 & 8191, $3 = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u3[0] | 0, X4 = Mt & 8191, J3 = Mt >>> 13, _t4 = u3[1] | 0, Q5 = _t4 & 8191, ee = _t4 >>> 13, xt3 = u3[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St2 = u3[3] | 0, ie = St2 & 8191, ne2 = St2 >>> 13, Et2 = u3[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At5 = u3[5] | 0, oe3 = At5 & 8191, se3 = At5 >>> 13, Rt2 = u3[6] | 0, he = Rt2 & 8191, ue4 = Rt2 >>> 13, Bt2 = u3[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt2 = u3[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u3[9] | 0, ve = It & 8191, be2 = It >>> 13;
        h5.negative = i.negative ^ a3.negative, h5.length = 19, l3 = Math.imul(g5, X4), n = Math.imul(g5, J3), n = n + Math.imul(_4, X4) | 0, d4 = Math.imul(_4, J3);
        var ft2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l3 = Math.imul(R4, X4), n = Math.imul(R4, J3), n = n + Math.imul(I5, X4) | 0, d4 = Math.imul(I5, J3), l3 = l3 + Math.imul(g5, Q5) | 0, n = n + Math.imul(g5, ee) | 0, n = n + Math.imul(_4, Q5) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X4), n = Math.imul(k4, J3), n = n + Math.imul(D3, X4) | 0, d4 = Math.imul(D3, J3), l3 = l3 + Math.imul(R4, Q5) | 0, n = n + Math.imul(R4, ee) | 0, n = n + Math.imul(I5, Q5) | 0, d4 = d4 + Math.imul(I5, ee) | 0, l3 = l3 + Math.imul(g5, te2) | 0, n = n + Math.imul(g5, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C4, X4), n = Math.imul(C4, J3), n = n + Math.imul(O4, X4) | 0, d4 = Math.imul(O4, J3), l3 = l3 + Math.imul(k4, Q5) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D3, Q5) | 0, d4 = d4 + Math.imul(D3, ee) | 0, l3 = l3 + Math.imul(R4, te2) | 0, n = n + Math.imul(R4, re2) | 0, n = n + Math.imul(I5, te2) | 0, d4 = d4 + Math.imul(I5, re2) | 0, l3 = l3 + Math.imul(g5, ie) | 0, n = n + Math.imul(g5, ne2) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne2) | 0;
        var ze = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F4, X4), n = Math.imul(F4, J3), n = n + Math.imul(U3, X4) | 0, d4 = Math.imul(U3, J3), l3 = l3 + Math.imul(C4, Q5) | 0, n = n + Math.imul(C4, ee) | 0, n = n + Math.imul(O4, Q5) | 0, d4 = d4 + Math.imul(O4, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D3, te2) | 0, d4 = d4 + Math.imul(D3, re2) | 0, l3 = l3 + Math.imul(R4, ie) | 0, n = n + Math.imul(R4, ne2) | 0, n = n + Math.imul(I5, ie) | 0, d4 = d4 + Math.imul(I5, ne2) | 0, l3 = l3 + Math.imul(g5, fe3) | 0, n = n + Math.imul(g5, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X4), n = Math.imul(z, J3), n = n + Math.imul(H3, X4) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F4, Q5) | 0, n = n + Math.imul(F4, ee) | 0, n = n + Math.imul(U3, Q5) | 0, d4 = d4 + Math.imul(U3, ee) | 0, l3 = l3 + Math.imul(C4, te2) | 0, n = n + Math.imul(C4, re2) | 0, n = n + Math.imul(O4, te2) | 0, d4 = d4 + Math.imul(O4, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne2) | 0, n = n + Math.imul(D3, ie) | 0, d4 = d4 + Math.imul(D3, ne2) | 0, l3 = l3 + Math.imul(R4, fe3) | 0, n = n + Math.imul(R4, ae2) | 0, n = n + Math.imul(I5, fe3) | 0, d4 = d4 + Math.imul(I5, ae2) | 0, l3 = l3 + Math.imul(g5, oe3) | 0, n = n + Math.imul(g5, se3) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se3) | 0;
        var We2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X4), n = Math.imul(W, J3), n = n + Math.imul(K5, X4) | 0, d4 = Math.imul(K5, J3), l3 = l3 + Math.imul(z, Q5) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q5) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F4, te2) | 0, n = n + Math.imul(F4, re2) | 0, n = n + Math.imul(U3, te2) | 0, d4 = d4 + Math.imul(U3, re2) | 0, l3 = l3 + Math.imul(C4, ie) | 0, n = n + Math.imul(C4, ne2) | 0, n = n + Math.imul(O4, ie) | 0, d4 = d4 + Math.imul(O4, ne2) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D3, fe3) | 0, d4 = d4 + Math.imul(D3, ae2) | 0, l3 = l3 + Math.imul(R4, oe3) | 0, n = n + Math.imul(R4, se3) | 0, n = n + Math.imul(I5, oe3) | 0, d4 = d4 + Math.imul(I5, se3) | 0, l3 = l3 + Math.imul(g5, he) | 0, n = n + Math.imul(g5, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j5, X4), n = Math.imul(j5, J3), n = n + Math.imul(Z3, X4) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q5) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K5, Q5) | 0, d4 = d4 + Math.imul(K5, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F4, ie) | 0, n = n + Math.imul(F4, ne2) | 0, n = n + Math.imul(U3, ie) | 0, d4 = d4 + Math.imul(U3, ne2) | 0, l3 = l3 + Math.imul(C4, fe3) | 0, n = n + Math.imul(C4, ae2) | 0, n = n + Math.imul(O4, fe3) | 0, d4 = d4 + Math.imul(O4, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se3) | 0, n = n + Math.imul(D3, oe3) | 0, d4 = d4 + Math.imul(D3, se3) | 0, l3 = l3 + Math.imul(R4, he) | 0, n = n + Math.imul(R4, ue4) | 0, n = n + Math.imul(I5, he) | 0, d4 = d4 + Math.imul(I5, ue4) | 0, l3 = l3 + Math.imul(g5, le) | 0, n = n + Math.imul(g5, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V6, X4), n = Math.imul(V6, J3), n = n + Math.imul($3, X4) | 0, d4 = Math.imul($3, J3), l3 = l3 + Math.imul(j5, Q5) | 0, n = n + Math.imul(j5, ee) | 0, n = n + Math.imul(Z3, Q5) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K5, te2) | 0, d4 = d4 + Math.imul(K5, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne2) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne2) | 0, l3 = l3 + Math.imul(F4, fe3) | 0, n = n + Math.imul(F4, ae2) | 0, n = n + Math.imul(U3, fe3) | 0, d4 = d4 + Math.imul(U3, ae2) | 0, l3 = l3 + Math.imul(C4, oe3) | 0, n = n + Math.imul(C4, se3) | 0, n = n + Math.imul(O4, oe3) | 0, d4 = d4 + Math.imul(O4, se3) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D3, he) | 0, d4 = d4 + Math.imul(D3, ue4) | 0, l3 = l3 + Math.imul(R4, le) | 0, n = n + Math.imul(R4, de) | 0, n = n + Math.imul(I5, le) | 0, d4 = d4 + Math.imul(I5, de) | 0, l3 = l3 + Math.imul(g5, ce3) | 0, n = n + Math.imul(g5, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X4), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X4) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V6, Q5) | 0, n = n + Math.imul(V6, ee) | 0, n = n + Math.imul($3, Q5) | 0, d4 = d4 + Math.imul($3, ee) | 0, l3 = l3 + Math.imul(j5, te2) | 0, n = n + Math.imul(j5, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne2) | 0, n = n + Math.imul(K5, ie) | 0, d4 = d4 + Math.imul(K5, ne2) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F4, oe3) | 0, n = n + Math.imul(F4, se3) | 0, n = n + Math.imul(U3, oe3) | 0, d4 = d4 + Math.imul(U3, se3) | 0, l3 = l3 + Math.imul(C4, he) | 0, n = n + Math.imul(C4, ue4) | 0, n = n + Math.imul(O4, he) | 0, d4 = d4 + Math.imul(O4, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D3, le) | 0, d4 = d4 + Math.imul(D3, de) | 0, l3 = l3 + Math.imul(R4, ce3) | 0, n = n + Math.imul(R4, pe2) | 0, n = n + Math.imul(I5, ce3) | 0, d4 = d4 + Math.imul(I5, pe2) | 0, l3 = l3 + Math.imul(g5, ve) | 0, n = n + Math.imul(g5, be2) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be2) | 0;
        var Ve = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q5), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q5) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V6, te2) | 0, n = n + Math.imul(V6, re2) | 0, n = n + Math.imul($3, te2) | 0, d4 = d4 + Math.imul($3, re2) | 0, l3 = l3 + Math.imul(j5, ie) | 0, n = n + Math.imul(j5, ne2) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne2) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K5, fe3) | 0, d4 = d4 + Math.imul(K5, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se3) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se3) | 0, l3 = l3 + Math.imul(F4, he) | 0, n = n + Math.imul(F4, ue4) | 0, n = n + Math.imul(U3, he) | 0, d4 = d4 + Math.imul(U3, ue4) | 0, l3 = l3 + Math.imul(C4, le) | 0, n = n + Math.imul(C4, de) | 0, n = n + Math.imul(O4, le) | 0, d4 = d4 + Math.imul(O4, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D3, ce3) | 0, d4 = d4 + Math.imul(D3, pe2) | 0, l3 = l3 + Math.imul(R4, ve) | 0, n = n + Math.imul(R4, be2) | 0, n = n + Math.imul(I5, ve) | 0, d4 = d4 + Math.imul(I5, be2) | 0;
        var $e2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V6, ie) | 0, n = n + Math.imul(V6, ne2) | 0, n = n + Math.imul($3, ie) | 0, d4 = d4 + Math.imul($3, ne2) | 0, l3 = l3 + Math.imul(j5, fe3) | 0, n = n + Math.imul(j5, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se3) | 0, n = n + Math.imul(K5, oe3) | 0, d4 = d4 + Math.imul(K5, se3) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F4, le) | 0, n = n + Math.imul(F4, de) | 0, n = n + Math.imul(U3, le) | 0, d4 = d4 + Math.imul(U3, de) | 0, l3 = l3 + Math.imul(C4, ce3) | 0, n = n + Math.imul(C4, pe2) | 0, n = n + Math.imul(O4, ce3) | 0, d4 = d4 + Math.imul(O4, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be2) | 0, n = n + Math.imul(D3, ve) | 0, d4 = d4 + Math.imul(D3, be2) | 0;
        var Ge = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne2), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne2), l3 = l3 + Math.imul(V6, fe3) | 0, n = n + Math.imul(V6, ae2) | 0, n = n + Math.imul($3, fe3) | 0, d4 = d4 + Math.imul($3, ae2) | 0, l3 = l3 + Math.imul(j5, oe3) | 0, n = n + Math.imul(j5, se3) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se3) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K5, he) | 0, d4 = d4 + Math.imul(K5, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F4, ce3) | 0, n = n + Math.imul(F4, pe2) | 0, n = n + Math.imul(U3, ce3) | 0, d4 = d4 + Math.imul(U3, pe2) | 0, l3 = l3 + Math.imul(C4, ve) | 0, n = n + Math.imul(C4, be2) | 0, n = n + Math.imul(O4, ve) | 0, d4 = d4 + Math.imul(O4, be2) | 0;
        var Ye = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V6, oe3) | 0, n = n + Math.imul(V6, se3) | 0, n = n + Math.imul($3, oe3) | 0, d4 = d4 + Math.imul($3, se3) | 0, l3 = l3 + Math.imul(j5, he) | 0, n = n + Math.imul(j5, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K5, le) | 0, d4 = d4 + Math.imul(K5, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F4, ve) | 0, n = n + Math.imul(F4, be2) | 0, n = n + Math.imul(U3, ve) | 0, d4 = d4 + Math.imul(U3, be2) | 0;
        var Xe = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se3), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se3), l3 = l3 + Math.imul(V6, he) | 0, n = n + Math.imul(V6, ue4) | 0, n = n + Math.imul($3, he) | 0, d4 = d4 + Math.imul($3, ue4) | 0, l3 = l3 + Math.imul(j5, le) | 0, n = n + Math.imul(j5, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K5, ce3) | 0, d4 = d4 + Math.imul(K5, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be2) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be2) | 0;
        var Je = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V6, le) | 0, n = n + Math.imul(V6, de) | 0, n = n + Math.imul($3, le) | 0, d4 = d4 + Math.imul($3, de) | 0, l3 = l3 + Math.imul(j5, ce3) | 0, n = n + Math.imul(j5, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be2) | 0, n = n + Math.imul(K5, ve) | 0, d4 = d4 + Math.imul(K5, be2) | 0;
        var Qe2 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V6, ce3) | 0, n = n + Math.imul(V6, pe2) | 0, n = n + Math.imul($3, ce3) | 0, d4 = d4 + Math.imul($3, pe2) | 0, l3 = l3 + Math.imul(j5, ve) | 0, n = n + Math.imul(j5, be2) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be2) | 0;
        var et3 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (et3 >>> 26) | 0, et3 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V6, ve) | 0, n = n + Math.imul(V6, be2) | 0, n = n + Math.imul($3, ve) | 0, d4 = d4 + Math.imul($3, be2) | 0;
        var tt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        b6 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be2), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be2);
        var rt4 = (b6 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b6 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft2, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et3, c2[17] = tt4, c2[18] = rt4, b6 !== 0 && (c2[19] = b6, h5.length++), h5;
      };
      Math.imul || (L4 = q3);
      function ge(v4, i, a3) {
        a3.negative = i.negative ^ v4.negative, a3.length = v4.length + i.length;
        for (var h5 = 0, s3 = 0, u3 = 0;u3 < a3.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b6 = h5 & 67108863, l3 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v4.length + 1);n <= l3; n++) {
            var d4 = u3 - n, w3 = v4.words[d4] | 0, g5 = i.words[n] | 0, _4 = w3 * g5, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b6 | 0, b6 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u3] = b6, h5 = c2, c2 = s3;
        }
        return h5 !== 0 ? a3.words[u3] = h5 : a3.length--, a3.strip();
      }
      function _e3(v4, i, a3) {
        var h5 = new N6;
        return h5.mulp(v4, i, a3);
      }
      f3.prototype.mulTo = function(i, a3) {
        var h5, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h5 = L4(this, i, a3) : s3 < 63 ? h5 = q3(this, i, a3) : s3 < 1024 ? h5 = ge(this, i, a3) : h5 = _e3(this, i, a3), h5;
      };
      function N6(v4, i) {
        this.x = v4, this.y = i;
      }
      N6.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h5 = f3.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h5, i);
        return a3;
      }, N6.prototype.revBin = function(i, a3, h5) {
        if (i === 0 || i === h5 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a3; u3++)
          s3 |= (i & 1) << a3 - u3 - 1, i >>= 1;
        return s3;
      }, N6.prototype.permute = function(i, a3, h5, s3, u3, c2) {
        for (var b6 = 0;b6 < c2; b6++)
          s3[b6] = a3[i[b6]], u3[b6] = h5[i[b6]];
      }, N6.prototype.transform = function(i, a3, h5, s3, u3, c2) {
        this.permute(c2, i, a3, h5, s3, u3);
        for (var b6 = 1;b6 < u3; b6 <<= 1)
          for (var l3 = b6 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u3; w3 += l3)
            for (var g5 = n, _4 = d4, A4 = 0;A4 < b6; A4++) {
              var R4 = h5[w3 + A4], I5 = s3[w3 + A4], Me = h5[w3 + A4 + b6], k4 = s3[w3 + A4 + b6], D3 = g5 * Me - _4 * k4;
              k4 = g5 * k4 + _4 * Me, Me = D3, h5[w3 + A4] = R4 + Me, s3[w3 + A4] = I5 + k4, h5[w3 + A4 + b6] = R4 - Me, s3[w3 + A4 + b6] = I5 - k4, A4 !== l3 && (D3 = n * g5 - d4 * _4, _4 = n * _4 + d4 * g5, g5 = D3);
            }
      }, N6.prototype.guessLen13b = function(i, a3) {
        var h5 = Math.max(a3, i) | 1, s3 = h5 & 1, u3 = 0;
        for (h5 = h5 / 2 | 0;h5; h5 = h5 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N6.prototype.conjugate = function(i, a3, h5) {
        if (!(h5 <= 1))
          for (var s3 = 0;s3 < h5 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h5 - s3 - 1], i[h5 - s3 - 1] = u3, u3 = a3[s3], a3[s3] = -a3[h5 - s3 - 1], a3[h5 - s3 - 1] = -u3;
          }
      }, N6.prototype.normalize13b = function(i, a3) {
        for (var h5 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h5;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h5 = 0 : h5 = u3 / 67108864 | 0;
        }
        return i;
      }, N6.prototype.convert13b = function(i, a3, h5, s3) {
        for (var u3 = 0, c2 = 0;c2 < a3; c2++)
          u3 = u3 + (i[c2] | 0), h5[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h5[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h5[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N6.prototype.stub = function(i) {
        for (var a3 = new Array(i), h5 = 0;h5 < i; h5++)
          a3[h5] = 0;
        return a3;
      }, N6.prototype.mulp = function(i, a3, h5) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b6 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d4 = new Array(s3), w3 = new Array(s3), g5 = new Array(s3), _4 = h5.words;
        _4.length = s3, this.convert13b(i.words, i.length, b6, s3), this.convert13b(a3.words, a3.length, d4, s3), this.transform(b6, c2, l3, n, s3, u3), this.transform(d4, c2, w3, g5, s3, u3);
        for (var A4 = 0;A4 < s3; A4++) {
          var R4 = l3[A4] * w3[A4] - n[A4] * g5[A4];
          n[A4] = l3[A4] * g5[A4] + n[A4] * w3[A4], l3[A4] = R4;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _4, c2, s3, u3), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h5.negative = i.negative ^ a3.negative, h5.length = i.length + a3.length, h5.strip();
      }, f3.prototype.mul = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f3.prototype.mulf = function(i) {
        var a3 = new f3(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f3.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f3.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h5 = 0;h5 < this.length; h5++) {
          var s3 = (this.words[h5] | 0) * i, u3 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u3 >>> 26, this.words[h5] = u3 & 67108863;
        }
        return a3 !== 0 && (this.words[h5] = a3, this.length++), this;
      }, f3.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f3.prototype.sqr = function() {
        return this.mul(this);
      }, f3.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f3.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f3(1);
        for (var h5 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h5 = h5.sqr())
          ;
        if (++s3 < a3.length)
          for (var u3 = h5.sqr();s3 < a3.length; s3++, u3 = u3.sqr())
            a3[s3] !== 0 && (h5 = h5.mul(u3));
        return h5;
      }, f3.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u3;
        if (a3 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b6 = this.words[u3] & s3, l3 = (this.words[u3] | 0) - b6 << a3;
            this.words[u3] = l3 | c2, c2 = b6 >>> 26 - a3;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h5 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h5] = this.words[u3];
          for (u3 = 0;u3 < h5; u3++)
            this.words[u3] = 0;
          this.length += h5;
        }
        return this.strip();
      }, f3.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f3.prototype.iushrn = function(i, a3, h5) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b6 = 67108863 ^ 67108863 >>> u3 << u3, l3 = h5;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u3 | w3 >>> u3, d4 = w3 & b6;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f3.prototype.ishrn = function(i, a3, h5) {
        return r(this.negative === 0), this.iushrn(i, a3, h5);
      }, f3.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f3.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f3.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f3.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f3.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return false;
        var u3 = this.words[h5];
        return !!(u3 & s3);
      }, f3.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h5 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h5)
          return this;
        if (a3 !== 0 && h5++, this.length = Math.min(h5, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f3.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f3.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f3.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f3.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f3.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f3.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f3.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f3.prototype.abs = function() {
        return this.clone().iabs();
      }, f3.prototype._ishlnsubmul = function(i, a3, h5) {
        var s3 = i.length + h5, u3;
        this._expand(s3);
        var c2, b6 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h5] | 0) + b6;
          var l3 = (i.words[u3] | 0) * a3;
          c2 -= l3 & 67108863, b6 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u3 + h5] = c2 & 67108863;
        }
        for (;u3 < this.length - h5; u3++)
          c2 = (this.words[u3 + h5] | 0) + b6, b6 = c2 >> 26, this.words[u3 + h5] = c2 & 67108863;
        if (b6 === 0)
          return this.strip();
        for (r(b6 === -1), b6 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b6, b6 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f3.prototype._wordDiv = function(i, a3) {
        var h5 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b6 = this._countBits(c2);
        h5 = 26 - b6, h5 !== 0 && (u3 = u3.ushln(h5), s3.iushln(h5), c2 = u3.words[u3.length - 1] | 0);
        var l3 = s3.length - u3.length, n;
        if (a3 !== "mod") {
          n = new f3(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u3, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g5 = l3 - 1;g5 >= 0; g5--) {
          var _4 = (s3.words[u3.length + g5] | 0) * 67108864 + (s3.words[u3.length + g5 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _4, g5);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g5), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g5] = _4);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h5 !== 0 && s3.iushrn(h5), { div: n || null, mod: s3 };
      }, f3.prototype.divmod = function(i, a3, h5) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f3(0), mod: new f3(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u3 = c2.mod.neg(), h5 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f3(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f3(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f3(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f3.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f3.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f3.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f3.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h5 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h5.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f3.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h5 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h5 = (a3 * h5 + (this.words[s3] | 0)) % i;
        return h5;
      }, f3.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = (this.words[h5] | 0) + a3 * 67108864;
          this.words[h5] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f3.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f3.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = new f3(0), b6 = new f3(1), l3 = 0;a3.isEven() && h5.isEven(); )
          a3.iushrn(1), h5.iushrn(1), ++l3;
        for (var n = h5.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g5 = 1;(a3.words[0] & g5) === 0 && w3 < 26; ++w3, g5 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d4)), s3.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A4 = 1;(h5.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h5.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b6.isOdd()) && (c2.iadd(n), b6.isub(d4)), c2.iushrn(1), b6.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(c2), u3.isub(b6)) : (h5.isub(a3), c2.isub(s3), b6.isub(u3));
        }
        return { a: c2, b: b6, gcd: h5.iushln(l3) };
      }, f3.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h5 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f3(1), u3 = new f3(0), c2 = h5.clone();a3.cmpn(1) > 0 && h5.cmpn(1) > 0; ) {
          for (var b6 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b6 < 26; ++b6, l3 <<= 1)
            ;
          if (b6 > 0)
            for (a3.iushrn(b6);b6-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d4 = 1;(h5.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h5.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a3.cmp(h5) >= 0 ? (a3.isub(h5), s3.isub(u3)) : (h5.isub(a3), u3.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u3, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f3.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h5 = i.clone();
        a3.negative = 0, h5.negative = 0;
        for (var s3 = 0;a3.isEven() && h5.isEven(); s3++)
          a3.iushrn(1), h5.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h5.isEven(); )
            h5.iushrn(1);
          var u3 = a3.cmp(h5);
          if (u3 < 0) {
            var c2 = a3;
            a3 = h5, h5 = c2;
          } else if (u3 === 0 || h5.cmpn(1) === 0)
            break;
          a3.isub(h5);
        } while (true);
        return h5.iushln(s3);
      }, f3.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f3.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f3.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f3.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f3.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h5 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h5)
          return this._expand(h5 + 1), this.words[h5] |= s3, this;
        for (var u3 = s3, c2 = h5;u3 !== 0 && c2 < this.length; c2++) {
          var b6 = this.words[c2] | 0;
          b6 += u3, u3 = b6 >>> 26, b6 &= 67108863, this.words[c2] = b6;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f3.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f3.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h5;
        if (this.length > 1)
          h5 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h5 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h5 | 0 : h5;
      }, f3.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f3.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h5 = this.length - 1;h5 >= 0; h5--) {
          var s3 = this.words[h5] | 0, u3 = i.words[h5] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a3 = -1 : s3 > u3 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f3.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f3.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f3.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f3.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f3.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f3.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f3.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f3.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f3.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f3.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f3.red = function(i) {
        return new P4(i);
      }, f3.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f3.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f3.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f3.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f3.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f3.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f3.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f3.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f3.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f3.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f3.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f3.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f3.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f3.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f3.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f3.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f3.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye2(v4, i) {
        this.name = v4, this.p = new f3(i, 16), this.n = this.p.bitLength(), this.k = new f3(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye2.prototype._tmp = function() {
        var i = new f3(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye2.prototype.ireduce = function(i) {
        var a3 = i, h5;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h5 = a3.bitLength();
        while (h5 > this.n);
        var s3 = h5 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye2.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye2.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe2() {
        ye2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe2, ye2), xe2.prototype.split = function(i, a3) {
        for (var h5 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a3.words[u3] = i.words[u3];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h5, u3 = 10;u3 < i.length; u3++) {
          var b6 = i.words[u3] | 0;
          i.words[u3 - 10] = (b6 & h5) << 4 | c2 >>> 22, c2 = b6;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe2.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = i.words[h5] | 0;
          a3 += s3 * 977, i.words[h5] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye2);
      function Ee() {
        ye2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye2);
      function Ae2() {
        ye2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye2), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h5 = 0;h5 < i.length; h5++) {
          var s3 = (i.words[h5] | 0) * 19 + a3, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h5] = u3, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f3._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe2;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P4(v4) {
        if (typeof v4 == "string") {
          var i = f3._prime(v4);
          this.m = i.p, this.prime = i;
        } else
          r(v4.gtn(1), "modulus must be greater than 1"), this.m = v4, this.prime = null;
      }
      P4.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P4.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P4.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P4.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P4.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.add(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5._forceRed(this);
      }, P4.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.iadd(a3);
        return h5.cmp(this.m) >= 0 && h5.isub(this.m), h5;
      }, P4.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.sub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5._forceRed(this);
      }, P4.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h5 = i.isub(a3);
        return h5.cmpn(0) < 0 && h5.iadd(this.m), h5;
      }, P4.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P4.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P4.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P4.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P4.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P4.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h5 = this.m.add(new f3(1)).iushrn(2);
          return this.pow(i, h5);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f3(1).toRed(this), b6 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f3(2 * n * n).toRed(this);this.pow(n, l3).cmp(b6) !== 0; )
          n.redIAdd(b6);
        for (var d4 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g5 = this.pow(i, s3), _4 = u3;g5.cmp(c2) !== 0; ) {
          for (var A4 = g5, R4 = 0;A4.cmp(c2) !== 0; R4++)
            A4 = A4.redSqr();
          r(R4 < _4);
          var I5 = this.pow(d4, new f3(1).iushln(_4 - R4 - 1));
          w3 = w3.redMul(I5), d4 = I5.redSqr(), g5 = g5.redMul(d4), _4 = R4;
        }
        return w3;
      }, P4.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P4.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f3(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h5 = 4, s3 = new Array(1 << h5);
        s3[0] = new f3(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b6 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a3.length - 1;u3 >= 0; u3--) {
          for (var d4 = a3.words[u3], w3 = n - 1;w3 >= 0; w3--) {
            var g5 = d4 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g5 === 0 && b6 === 0) {
              l3 = 0;
              continue;
            }
            b6 <<= 1, b6 |= g5, l3++, !(l3 !== h5 && (u3 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b6]), l3 = 0, b6 = 0);
          }
          n = 26;
        }
        return c2;
      }, P4.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P4.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f3.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v4) {
        P4.call(this, v4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f3(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P4), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h5 = i.imul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f3(0)._forceRed(this);
        var h5 = i.mul(a3), s3 = h5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h5.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T3((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e) {
      return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j32 = T3((SL, K32) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd2(), Rd = w0(), Sq = Ed(), Eq = Ks2(), Kr3 = Te().Buffer;
    K32.exports = function(e, r, o2) {
      var f3;
      e.padding ? f3 = e.padding : o2 ? f3 = 1 : f3 = 4;
      var p4 = _q(e), m4;
      if (f3 === 4)
        m4 = Aq(p4, r);
      else if (f3 === 1)
        m4 = Rq(p4, r, o2);
      else if (f3 === 3) {
        if (m4 = new Rd(r), m4.cmp(p4.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o2 ? Eq(m4, p4) : Sq(m4, p4);
    };
    function Aq(t, e) {
      var r = t.modulus.byteLength(), o2 = e.length, f3 = xq("sha1").update(Kr3.alloc(0)).digest(), p4 = f3.length, m4 = 2 * p4;
      if (o2 > r - m4 - 2)
        throw new Error("message too long");
      var y5 = Kr3.alloc(r - o2 - m4 - 2), M3 = r - p4 - 1, x5 = Ad(p4), S3 = W3(Kr3.concat([f3, y5, Kr3.alloc(1, 1), e], M3), H3(x5, M3)), E6 = W3(x5, H3(S3, p4));
      return new Rd(Kr3.concat([Kr3.alloc(1), E6, S3], r));
    }
    function Rq(t, e, r) {
      var o2 = e.length, f3 = t.modulus.byteLength();
      if (o2 > f3 - 11)
        throw new Error("message too long");
      var p4;
      return r ? p4 = Kr3.alloc(f3 - o2 - 3, 255) : p4 = Bq(f3 - o2 - 3), new Rd(Kr3.concat([Kr3.from([0, r ? 1 : 2]), p4, Kr3.alloc(1), e], f3));
    }
    function Bq(t) {
      for (var e = Kr3.allocUnsafe(t), r = 0, o2 = Ad(t * 2), f3 = 0, p4;r < t; )
        f3 === o2.length && (o2 = Ad(t * 2), f3 = 0), p4 = o2[f3++], p4 && (e[r++] = p4);
      return e;
    }
  });
  Y3 = T3((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V32 = xd2(), $3 = w0(), Iq = Ks2(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e, r, o2) {
      var f3;
      e.padding ? f3 = e.padding : o2 ? f3 = 1 : f3 = 4;
      var p4 = qq(e), m4 = p4.modulus.byteLength();
      if (r.length > m4 || new $3(r).cmp(p4.modulus) >= 0)
        throw new Error("decryption error");
      var y5;
      o2 ? y5 = kq(new $3(r), p4) : y5 = Iq(r, p4);
      var M3 = Za.alloc(m4 - y5.length);
      if (y5 = Za.concat([M3, y5], m4), f3 === 4)
        return Lq(p4, y5);
      if (f3 === 1)
        return Nq(p4, y5, o2);
      if (f3 === 3)
        return y5;
      throw new Error("unknown padding");
    };
    function Lq(t, e) {
      var r = t.modulus.byteLength(), o2 = Tq("sha1").update(Za.alloc(0)).digest(), f3 = o2.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p4 = e.slice(1, f3 + 1), m4 = e.slice(f3 + 1), y5 = V32(p4, Z3(m4, f3)), M3 = V32(m4, Z3(y5, r - f3 - 1));
      if (Dq(o2, M3.slice(0, f3)))
        throw new Error("decryption error");
      for (var x5 = f3;M3[x5] === 0; )
        x5++;
      if (M3[x5++] !== 1)
        throw new Error("decryption error");
      return M3.slice(x5);
    }
    function Nq(t, e, r) {
      for (var o2 = e.slice(0, 2), f3 = 2, p4 = 0;e[f3++] !== 0; )
        if (f3 >= e.length) {
          p4++;
          break;
        }
      var m4 = e.slice(2, f3 - 1);
      if ((o2.toString("hex") !== "0002" && !r || o2.toString("hex") !== "0001" && r) && p4++, m4.length < 8 && p4++, p4)
        throw new Error("decryption error");
      return e.slice(f3);
    }
    function Dq(t, e) {
      t = Za.from(t), e = Za.from(e);
      var r = 0, o2 = t.length;
      t.length !== e.length && (r++, o2 = Math.min(t.length, e.length));
      for (var f3 = -1;++f3 < o2; )
        r += t[f3] ^ e[f3];
      return r;
    }
  });
  X32 = T3((Vn) => {
    Vn.publicEncrypt = j32();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e, r) {
      return Vn.publicEncrypt(e, r, true);
    };
    Vn.publicDecrypt = function(e, r) {
      return Vn.privateDecrypt(e, r, true);
    };
  });
  ow = T3((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q32 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd2 = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e)
        throw new RangeError("offset out of range");
    }
    function fw(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd2 && Bd2.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e, r, o2) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o2 = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o2 = r, r = t.length - e;
      else if (typeof o2 != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o2);
    }
    function aw(t, e, r, o2) {
      if (true) {
        var f3 = t.buffer, p4 = new Uint8Array(f3, e, r);
        if (Bd2.getRandomValues(p4), o2) {
          process.nextTick(function() {
            o2(null, t);
          });
          return;
        }
        return t;
      }
      if (o2) {
        Q32(r, function(y5, M3) {
          if (y5)
            return o2(y5);
          M3.copy(t, e), o2(null, t);
        });
        return;
      }
      var m4 = Q32(r);
      return m4.copy(t, e), t;
    }
    function Cq(t, e, r) {
      if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
    }
  });
  qd = T3((ke3) => {
    ke3.randomBytes = ke3.rng = ke3.pseudoRandomBytes = ke3.prng = on();
    ke3.createHash = ke3.Hash = bf();
    ke3.createHmac = ke3.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke3.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke3.pbkdf2 = sw.pbkdf2;
    ke3.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke3.Cipher = ui.Cipher;
    ke3.createCipher = ui.createCipher;
    ke3.Cipheriv = ui.Cipheriv;
    ke3.createCipheriv = ui.createCipheriv;
    ke3.Decipher = ui.Decipher;
    ke3.createDecipher = ui.createDecipher;
    ke3.Decipheriv = ui.Decipheriv;
    ke3.createDecipheriv = ui.createDecipheriv;
    ke3.getCiphers = ui.getCiphers;
    ke3.listCiphers = ui.listCiphers;
    var $a2 = hg();
    ke3.DiffieHellmanGroup = $a2.DiffieHellmanGroup;
    ke3.createDiffieHellmanGroup = $a2.createDiffieHellmanGroup;
    ke3.getDiffieHellman = $a2.getDiffieHellman;
    ke3.createDiffieHellman = $a2.createDiffieHellman;
    ke3.DiffieHellman = $a2.DiffieHellman;
    var M0 = k32();
    ke3.createSign = M0.createSign;
    ke3.Sign = M0.Sign;
    ke3.createVerify = M0.createVerify;
    ke3.Verify = M0.Verify;
    ke3.createECDH = P32();
    var _0 = X32();
    ke3.publicEncrypt = _0.publicEncrypt;
    ke3.privateEncrypt = _0.privateEncrypt;
    ke3.publicDecrypt = _0.publicDecrypt;
    ke3.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke3.randomFill = hw.randomFill;
    ke3.randomFillSync = hw.randomFillSync;
    ke3.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke3.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt2 = {};
  Ja(Xt2, { DEFAULT_ENCODING: () => Ga2, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td2, scryptSync: () => Id2, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot3(Xt2, rn2(qd()));
  zq = rn2(qd());
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o2 } = e;
    if (typeof r != "number" || typeof o2 != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o2)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Id2 = "scryptSync" in crypto ? (t, e, r, o2) => {
    let f3 = crypto.scryptSync(t, e, r, o2);
    return Ga2 !== "buffer" ? new Buffer(f3).toString(Ga2) : new Buffer(f3);
  } : undefined;
  Td2 = "scryptSync" in crypto ? function(t, e, r, o2, f3) {
    if (typeof o2 == "function" && (f3 = o2, o2 = undefined), typeof f3 != "function") {
      var p4 = new TypeError("callback must be a function");
      throw p4.code = "ERR_INVALID_CALLBACK", p4;
    }
    try {
      let m4 = crypto.scryptSync(t, e, r, o2);
      process.nextTick(f3, null, Ga2 !== "buffer" ? new Buffer(m4).toString(Ga2) : new Buffer(m4));
    } catch (m4) {
      throw m4;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td2, "name", { value: "::bunternal::" }), Object.defineProperty(Id2, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id2, scrypt: Td2, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/file-stream-rotator/FileStreamRotator.js
var require_FileStreamRotator = __commonJS((exports, module) => {
  /*!
   * FileStreamRotator
   * Copyright(c) 2012-2017 Holiday Extras.
   * Copyright(c) 2017 Roger C.
   * MIT Licensed
   */
  var fs = (() => ({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var moment = (init_moment(), __toCommonJS(exports_moment));
  var crypto3 = (init_crypto2(), __toCommonJS(exports_crypto));
  var EventEmitter = (init_events(), __toCommonJS(exports_events));
  var FileStreamRotator = {};
  module.exports = FileStreamRotator;
  var staticFrequency = ["daily", "test", "m", "h", "custom"];
  var DATE_FORMAT = "YYYYMMDDHHmm";
  var _checkNumAndType = function(type, num2) {
    if (typeof num2 == "number") {
      switch (type) {
        case "m":
          if (num2 < 0 || num2 > 60) {
            return false;
          }
          break;
        case "h":
          if (num2 < 0 || num2 > 24) {
            return false;
          }
          break;
      }
      return { type, digit: num2 };
    }
  };
  var _checkDailyAndTest = function(freqType) {
    switch (freqType) {
      case "custom":
      case "daily":
        return { type: freqType, digit: undefined };
        break;
      case "test":
        return { type: freqType, digit: 0 };
    }
    return false;
  };
  FileStreamRotator.getFrequency = function(frequency) {
    var _f = frequency.toLowerCase().match(/^(\d+)([mh])$/);
    if (_f) {
      return _checkNumAndType(_f[2], parseInt(_f[1]));
    }
    var dailyOrTest = _checkDailyAndTest(frequency);
    if (dailyOrTest) {
      return dailyOrTest;
    }
    return false;
  };
  FileStreamRotator.parseFileSize = function(size4) {
    if (size4 && typeof size4 == "string") {
      var _s = size4.toLowerCase().match(/^((?:0\.)?\d+)([kmg])$/);
      if (_s) {
        switch (_s[2]) {
          case "k":
            return _s[1] * 1024;
          case "m":
            return _s[1] * 1024 * 1024;
          case "g":
            return _s[1] * 1024 * 1024 * 1024;
        }
      }
    }
    return null;
  };
  FileStreamRotator.getDate = function(format2, date_format, utc) {
    date_format = date_format || DATE_FORMAT;
    let currentMoment = utc ? moment.utc() : moment().local();
    if (format2 && staticFrequency.indexOf(format2.type) !== -1) {
      switch (format2.type) {
        case "m":
          var minute = Math.floor(currentMoment.minutes() / format2.digit) * format2.digit;
          return currentMoment.minutes(minute).format(date_format);
          break;
        case "h":
          var hour = Math.floor(currentMoment.hour() / format2.digit) * format2.digit;
          return currentMoment.hour(hour).format(date_format);
          break;
        case "daily":
        case "custom":
        case "test":
          return currentMoment.format(date_format);
      }
    }
    return currentMoment.format(date_format);
  };
  FileStreamRotator.setAuditLog = function(max_logs, audit_file, log_file) {
    var _rtn = null;
    if (max_logs) {
      var use_days = max_logs.toString().substr(-1);
      var _num = max_logs.toString().match(/^(\d+)/);
      if (Number(_num[1]) > 0) {
        var baseLog = path.dirname(log_file.replace(/%DATE%.+/, "_filename"));
        try {
          if (audit_file) {
            var full_path = path.resolve(audit_file);
            _rtn = JSON.parse(fs.readFileSync(full_path, { encoding: "utf-8" }));
          } else {
            var full_path = path.resolve(baseLog + "/" + ".audit.json");
            _rtn = JSON.parse(fs.readFileSync(full_path, { encoding: "utf-8" }));
          }
        } catch (e) {
          if (e.code !== "ENOENT") {
            return null;
          }
          _rtn = {
            keep: {
              days: false,
              amount: Number(_num[1])
            },
            auditLog: audit_file || baseLog + "/" + ".audit.json",
            files: []
          };
        }
        _rtn.keep = {
          days: use_days === "d",
          amount: Number(_num[1])
        };
      }
    }
    return _rtn;
  };
  FileStreamRotator.writeAuditLog = function(audit, verbose) {
    try {
      mkDirForFile(audit.auditLog);
      fs.writeFileSync(audit.auditLog, JSON.stringify(audit, null, 4));
    } catch (e) {
      if (verbose) {
        console.error(new Date, "[FileStreamRotator] Failed to store log audit at:", audit.auditLog, "Error:", e);
      }
    }
  };
  function removeFile(file, verbose) {
    if (file.hash === crypto3.createHash(file.hashType).update(file.name + "LOG_FILE" + file.date).digest("hex")) {
      try {
        if (fs.existsSync(file.name)) {
          fs.unlinkSync(file.name);
        }
      } catch (e) {
        if (verbose) {
          console.error(new Date, "[FileStreamRotator] Could not remove old log file: ", file.name);
        }
      }
    }
  }
  function createCurrentSymLink(logfile, name, verbose) {
    let symLinkName = name || "current.log";
    let logPath = path.dirname(logfile);
    let logfileName = path.basename(logfile);
    let current = logPath + "/" + symLinkName;
    try {
      let stats = fs.lstatSync(current);
      if (stats.isSymbolicLink()) {
        fs.unlinkSync(current);
        fs.symlinkSync(logfileName, current);
      }
    } catch (err) {
      if (err && err.code == "ENOENT") {
        try {
          fs.symlinkSync(logfileName, current);
        } catch (e) {
          if (verbose) {
            console.error(new Date, "[FileStreamRotator] Could not create symlink file: ", current, " -> ", logfileName);
          }
        }
      }
    }
  }
  function createLogWatcher(logfile, verbose, cb) {
    if (!logfile)
      return null;
    try {
      let stats = fs.lstatSync(logfile);
      return fs.watch(logfile, function(event, filename) {
        if (event == "rename") {
          try {
            let stats2 = fs.lstatSync(logfile);
          } catch (err) {
            cb(err, logfile);
          }
        }
      });
    } catch (err) {
      if (verbose) {
        console.log(new Date, "[FileStreamRotator] Could not add watcher for " + logfile);
      }
    }
  }
  FileStreamRotator.addLogToAudit = function(logfile, audit, stream, verbose) {
    if (audit && audit.files) {
      var index2 = audit.files.findIndex(function(file) {
        return file.name === logfile;
      });
      if (index2 !== -1) {
        return audit;
      }
      var time = Date.now();
      audit.files.push({
        date: time,
        name: logfile,
        hash: crypto3.createHash(audit.hashType).update(logfile + "LOG_FILE" + time).digest("hex")
      });
      if (audit.keep.days) {
        var oldestDate = moment().subtract(audit.keep.amount, "days").valueOf();
        var recentFiles = audit.files.filter(function(file) {
          if (file.date > oldestDate) {
            return true;
          }
          file.hashType = audit.hashType;
          removeFile(file, verbose);
          stream.emit("logRemoved", file);
          return false;
        });
        audit.files = recentFiles;
      } else {
        var filesToKeep = audit.files.splice(-audit.keep.amount);
        if (audit.files.length > 0) {
          audit.files.filter(function(file) {
            file.hashType = audit.hashType;
            removeFile(file, verbose);
            stream.emit("logRemoved", file);
            return false;
          });
        }
        audit.files = filesToKeep;
      }
      FileStreamRotator.writeAuditLog(audit, verbose);
    }
    return audit;
  };
  FileStreamRotator.getStream = function(options) {
    var frequencyMetaData = null;
    var curDate = null;
    var self2 = this;
    if (!options.filename) {
      console.error(new Date, "[FileStreamRotator] No filename supplied. Defaulting to STDOUT");
      return process.stdout;
    }
    if (options.frequency) {
      frequencyMetaData = self2.getFrequency(options.frequency);
    }
    let auditLog = self2.setAuditLog(options.max_logs, options.audit_file, options.filename);
    if (auditLog != null) {
      auditLog.hashType = options.audit_hash_type !== undefined ? options.audit_hash_type : "md5";
    }
    self2.verbose = options.verbose !== undefined ? options.verbose : true;
    var fileSize = null;
    var fileCount = 0;
    var curSize = 0;
    if (options.size) {
      fileSize = FileStreamRotator.parseFileSize(options.size);
    }
    var dateFormat = options.date_format || DATE_FORMAT;
    if (frequencyMetaData && frequencyMetaData.type == "daily") {
      if (!options.date_format) {
        dateFormat = "YYYY-MM-DD";
      }
      if (moment().format(dateFormat) != moment().endOf("day").format(dateFormat) || moment().format(dateFormat) == moment().add(1, "day").format(dateFormat)) {
        if (self2.verbose) {
          console.log(new Date, "[FileStreamRotator] Changing type to custom as date format changes more often than once a day or not every day");
        }
        frequencyMetaData.type = "custom";
      }
    }
    if (frequencyMetaData) {
      curDate = options.frequency ? self2.getDate(frequencyMetaData, dateFormat, options.utc) : "";
    }
    options.create_symlink = options.create_symlink || false;
    options.extension = options.extension || "";
    var filename = options.filename;
    var oldFile = null;
    var logfile = filename + (curDate ? "." + curDate : "");
    if (filename.match(/%DATE%/)) {
      logfile = filename.replace(/%DATE%/g, curDate ? curDate : self2.getDate(null, dateFormat, options.utc));
    }
    if (fileSize) {
      var lastLogFile = null;
      var t_log = logfile;
      var f3 = null;
      if (auditLog && auditLog.files && auditLog.files instanceof Array && auditLog.files.length > 0) {
        var lastEntry = auditLog.files[auditLog.files.length - 1].name;
        if (lastEntry.match(t_log)) {
          var lastCount = lastEntry.match(t_log + "\\.(\\d+)");
          if (lastCount) {
            t_log = lastEntry;
            fileCount = lastCount[1];
          }
        }
      }
      if (fileCount == 0 && t_log == logfile) {
        t_log += options.extension;
      }
      while (f3 = fs.existsSync(t_log)) {
        lastLogFile = t_log;
        fileCount++;
        t_log = logfile + "." + fileCount + options.extension;
      }
      if (lastLogFile) {
        var lastLogFileStats = fs.statSync(lastLogFile);
        if (lastLogFileStats.size < fileSize) {
          t_log = lastLogFile;
          fileCount--;
          curSize = lastLogFileStats.size;
        }
      }
      logfile = t_log;
    } else {
      logfile += options.extension;
    }
    if (self2.verbose) {
      console.log(new Date, "[FileStreamRotator] Logging to: ", logfile);
    }
    mkDirForFile(logfile);
    var file_options = options.file_options || { flags: "a" };
    var rotateStream = fs.createWriteStream(logfile, file_options);
    if (curDate && frequencyMetaData && staticFrequency.indexOf(frequencyMetaData.type) > -1 || fileSize > 0) {
      if (self2.verbose) {
        console.log(new Date, "[FileStreamRotator] Rotating file: ", frequencyMetaData ? frequencyMetaData.type : "", fileSize ? "size: " + fileSize : "");
      }
      var stream = new EventEmitter;
      stream.auditLog = auditLog;
      stream.end = function() {
        rotateStream.end.apply(rotateStream, arguments);
      };
      BubbleEvents(rotateStream, stream);
      stream.on("close", function() {
        if (logWatcher) {
          logWatcher.close();
        }
      });
      stream.on("new", function(newLog) {
        stream.auditLog = self2.addLogToAudit(newLog, stream.auditLog, stream, self2.verbose);
        if (options.create_symlink) {
          createCurrentSymLink(newLog, options.symlink_name, self2.verbose);
        }
        if (options.watch_log) {
          stream.emit("addWatcher", newLog);
        }
      });
      var logWatcher;
      stream.on("addWatcher", function(newLog) {
        if (logWatcher) {
          logWatcher.close();
        }
        if (!options.watch_log) {
          return;
        }
        logWatcher = createLogWatcher(newLog, self2.verbose, function(err, newLog2) {
          stream.emit("createLog", newLog2);
        });
      });
      stream.on("createLog", function(file) {
        try {
          let stats = fs.lstatSync(file);
        } catch (err) {
          if (rotateStream && rotateStream.end == "function") {
            rotateStream.end();
          }
          rotateStream = fs.createWriteStream(file, file_options);
          stream.emit("new", file);
          BubbleEvents(rotateStream, stream);
        }
      });
      stream.write = function(str, encoding) {
        var newDate = frequencyMetaData ? this.getDate(frequencyMetaData, dateFormat, options.utc) : curDate;
        if (newDate != curDate || fileSize && curSize > fileSize) {
          var newLogfile = filename + (curDate && frequencyMetaData ? "." + newDate : "");
          if (filename.match(/%DATE%/) && curDate) {
            newLogfile = filename.replace(/%DATE%/g, newDate);
          }
          if (fileSize && curSize > fileSize) {
            fileCount++;
            newLogfile += "." + fileCount + options.extension;
          } else {
            fileCount = 0;
            newLogfile += options.extension;
          }
          curSize = 0;
          if (self2.verbose) {
            console.log(new Date, (init_util(), __toCommonJS(exports_util)).format("[FileStreamRotator] Changing logs from %s to %s", logfile, newLogfile));
          }
          curDate = newDate;
          oldFile = logfile;
          logfile = newLogfile;
          if (options.end_stream === true) {
            rotateStream.end();
          } else {
            rotateStream.destroy();
          }
          mkDirForFile(logfile);
          rotateStream = fs.createWriteStream(newLogfile, file_options);
          stream.emit("new", newLogfile);
          stream.emit("rotate", oldFile, newLogfile);
          BubbleEvents(rotateStream, stream);
        }
        rotateStream.write(str, encoding);
        curSize += Buffer.byteLength(str, encoding);
      }.bind(this);
      process.nextTick(function() {
        stream.emit("new", logfile);
      });
      stream.emit("new", logfile);
      return stream;
    } else {
      if (self2.verbose) {
        console.log(new Date, "[FileStreamRotator] File won't be rotated: ", options.frequency, options.size);
      }
      process.nextTick(function() {
        rotateStream.emit("new", logfile);
      });
      return rotateStream;
    }
  };
  var mkDirForFile = function(pathWithFile) {
    var _path = path.dirname(pathWithFile);
    _path.split(path.sep).reduce(function(fullPath, folder) {
      fullPath += folder + path.sep;
      if (!fs.existsSync(fullPath)) {
        try {
          fs.mkdirSync(fullPath);
        } catch (e) {
          if (e.code !== "EEXIST") {
            throw e;
          }
        }
      }
      return fullPath;
    }, "");
  };
  var BubbleEvents = function BubbleEvents(emitter, proxy) {
    emitter.on("close", function() {
      proxy.emit("close");
    });
    emitter.on("finish", function() {
      proxy.emit("finish");
    });
    emitter.on("error", function(err) {
      proxy.emit("error", err);
    });
    emitter.on("open", function(fd) {
      proxy.emit("open", fd);
    });
  };
});

// node_modules/winston-daily-rotate-file/daily-rotate-file.js
var require_daily_rotate_file = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var os2 = (init_os(), __toCommonJS(exports_os));
  var path = (init_path(), __toCommonJS(exports_path));
  var util = (init_util(), __toCommonJS(exports_util));
  var zlib = (init_zlib(), __toCommonJS(exports_zlib));
  var hash2 = require_object_hash();
  var MESSAGE = require_triple_beam().MESSAGE;
  var PassThrough = (init_stream(), __toCommonJS(exports_stream)).PassThrough;
  var Transport = require_dist2();
  var loggerDefaults = {
    json: false,
    colorize: false,
    eol: os2.EOL,
    logstash: null,
    prettyPrint: false,
    label: null,
    stringify: false,
    depth: null,
    showLevel: true,
    timestamp: () => {
      return new Date().toISOString();
    }
  };
  var DailyRotateFile = function(options) {
    options = options || {};
    Transport.call(this, options);
    function throwIf(target) {
      Array.prototype.slice.call(arguments, 1).forEach((name) => {
        if (options[name]) {
          throw new Error("Cannot set " + name + " and " + target + " together");
        }
      });
    }
    function getMaxSize(size4) {
      if (size4 && typeof size4 === "string") {
        if (size4.toLowerCase().match(/^((?:0\.)?\d+)([kmg])$/)) {
          return size4;
        }
      } else if (size4 && Number.isInteger(size4)) {
        const sizeK = Math.round(size4 / 1024);
        return sizeK === 0 ? "1k" : sizeK + "k";
      }
      return null;
    }
    function isValidFileName(filename) {
      return !/["<>|:*?\\/\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]/g.test(filename);
    }
    function isValidDirName(dirname) {
      return !/["<>|\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]/g.test(dirname);
    }
    this.options = Object.assign({}, loggerDefaults, options);
    if (options.stream) {
      throwIf("stream", "filename", "maxsize");
      this.logStream = new PassThrough;
      this.logStream.pipe(options.stream);
    } else {
      this.filename = options.filename ? path.basename(options.filename) : "winston.log";
      this.dirname = options.dirname || path.dirname(options.filename);
      if (!isValidFileName(this.filename) || !isValidDirName(this.dirname)) {
        throw new Error("Your path or filename contain an invalid character.");
      }
      this.logStream = require_FileStreamRotator().getStream({
        filename: path.join(this.dirname, this.filename),
        frequency: options.frequency ? options.frequency : "custom",
        date_format: options.datePattern ? options.datePattern : "YYYY-MM-DD",
        verbose: false,
        size: getMaxSize(options.maxSize),
        max_logs: options.maxFiles,
        end_stream: true,
        audit_file: options.auditFile ? options.auditFile : path.join(this.dirname, "." + hash2(options) + "-audit.json"),
        file_options: options.options ? options.options : { flags: "a" },
        utc: options.utc ? options.utc : false,
        extension: options.extension ? options.extension : "",
        create_symlink: options.createSymlink ? options.createSymlink : false,
        symlink_name: options.symlinkName ? options.symlinkName : "current.log",
        watch_log: options.watchLog ? options.watchLog : false,
        audit_hash_type: options.auditHashType ? options.auditHashType : "sha256"
      });
      this.logStream.on("new", (newFile) => {
        this.emit("new", newFile);
      });
      this.logStream.on("rotate", (oldFile, newFile) => {
        this.emit("rotate", oldFile, newFile);
      });
      this.logStream.on("logRemoved", (params) => {
        if (options.zippedArchive) {
          const gzName = params.name + ".gz";
          try {
            fs.unlinkSync(gzName);
          } catch (err) {
            if (err.code !== "ENOENT") {
              err.message = `Error occurred while removing ${gzName}: ${err.message}`;
              this.emit("error", err);
              return;
            }
          }
          this.emit("logRemoved", gzName);
          return;
        }
        this.emit("logRemoved", params.name);
      });
      if (options.zippedArchive) {
        this.logStream.on("rotate", (oldFile) => {
          try {
            if (!fs.existsSync(oldFile)) {
              return;
            }
          } catch (err) {
            err.message = `Error occurred while checking existence of ${oldFile}: ${err.message}`;
            this.emit("error", err);
            return;
          }
          try {
            if (fs.existsSync(`${oldFile}.gz`)) {
              return;
            }
          } catch (err) {
            err.message = `Error occurred while checking existence of ${oldFile}.gz: ${err.message}`;
            this.emit("error", err);
            return;
          }
          const gzip = zlib.createGzip();
          const inp = fs.createReadStream(oldFile);
          inp.on("error", (err) => {
            err.message = `Error occurred while reading ${oldFile}: ${err.message}`;
            this.emit("error", err);
          });
          const out = fs.createWriteStream(oldFile + ".gz");
          out.on("error", (err) => {
            err.message = `Error occurred while writing ${oldFile}.gz: ${err.message}`;
            this.emit("error", err);
          });
          inp.pipe(gzip).pipe(out).on("finish", () => {
            try {
              fs.unlinkSync(oldFile);
            } catch (err) {
              if (err.code !== "ENOENT") {
                err.message = `Error occurred while removing ${oldFile}: ${err.message}`;
                this.emit("error", err);
                return;
              }
            }
            this.emit("archive", oldFile + ".gz");
          });
        });
      }
      if (options.watchLog) {
        this.logStream.on("addWatcher", (newFile) => {
          this.emit("addWatcher", newFile);
        });
      }
    }
  };
  module.exports = DailyRotateFile;
  util.inherits(DailyRotateFile, Transport);
  DailyRotateFile.prototype.name = "dailyRotateFile";
  var noop = function() {
  };
  DailyRotateFile.prototype.log = function(info, callback) {
    callback = callback || noop;
    this.logStream.write(info[MESSAGE] + this.options.eol);
    this.emit("logged", info);
    callback(null, true);
  };
  DailyRotateFile.prototype.close = function() {
    if (this.logStream) {
      this.logStream.end(() => {
        this.emit("finish");
      });
    }
  };
  DailyRotateFile.prototype.query = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.options.json) {
      throw new Error("query() may not be used without the json option being set to true");
    }
    if (!this.filename) {
      throw new Error("query() may not be used when initializing with a stream");
    }
    let results = [];
    options = options || {};
    options.rows = options.rows || options.limit || 10;
    options.start = options.start || 0;
    options.until = options.until || new Date;
    if (typeof options.until !== "object") {
      options.until = new Date(options.until);
    }
    options.from = options.from || options.until - 24 * 60 * 60 * 1000;
    if (typeof options.from !== "object") {
      options.from = new Date(options.from);
    }
    options.order = options.order || "desc";
    const logFiles = (() => {
      const fileRegex = new RegExp(this.filename.replace("%DATE%", ".*"), "i");
      return fs.readdirSync(this.dirname).filter((file) => path.basename(file).match(fileRegex));
    })();
    if (logFiles.length === 0 && callback) {
      callback(null, results);
    }
    const processLogFile = (file) => {
      if (!file) {
        return;
      }
      const logFile = path.join(this.dirname, file);
      let buff = "";
      let stream;
      if (file.endsWith(".gz")) {
        stream = new PassThrough;
        const inp = fs.createReadStream(logFile);
        inp.on("error", (err) => {
          err.message = `Error occurred while reading ${logFile}: ${err.message}`;
          stream.emit("error", err);
        });
        inp.pipe(zlib.createGunzip()).pipe(stream);
      } else {
        stream = fs.createReadStream(logFile, {
          encoding: "utf8"
        });
      }
      stream.on("error", (err) => {
        if (stream.readable) {
          stream.destroy();
        }
        if (!callback) {
          return;
        }
        return err.code === "ENOENT" ? callback(null, results) : callback(err);
      });
      stream.on("data", (data) => {
        data = (buff + data).split(/\n+/);
        const l3 = data.length - 1;
        for (let i = 0;i < l3; i++) {
          add2(data[i]);
        }
        buff = data[l3];
      });
      stream.on("end", () => {
        if (buff) {
          add2(buff, true);
        }
        if (logFiles.length) {
          processLogFile(logFiles.shift());
        } else if (callback) {
          results.sort((a3, b6) => {
            const d1 = new Date(a3.timestamp).getTime();
            const d22 = new Date(b6.timestamp).getTime();
            return d1 > d22 ? 1 : d1 < d22 ? -1 : 0;
          });
          if (options.order === "desc") {
            results = results.reverse();
          }
          const start = options.start || 0;
          const limit = options.limit || results.length;
          results = results.slice(start, start + limit);
          if (options.fields) {
            results = results.map((log) => {
              const obj = {};
              options.fields.forEach((key) => {
                obj[key] = log[key];
              });
              return obj;
            });
          }
          callback(null, results);
        }
      });
      function add2(buff2, attempt) {
        try {
          const log = JSON.parse(buff2);
          if (!log || typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          results.push(log);
        } catch (e) {
          if (!attempt) {
            stream.emit("error", e);
          }
        }
      }
    };
    processLogFile(logFiles.shift());
  };
});

// node_modules/winston-daily-rotate-file/index.js
var require_winston_daily_rotate_file = __commonJS((exports, module) => {
  var winston = require_winston();
  var DailyRotateFile = require_daily_rotate_file();
  winston.transports.DailyRotateFile = DailyRotateFile;
  module.exports = DailyRotateFile;
});

// node_modules/dotenv/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.7",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var os2 = (init_os(), __toCommonJS(exports_os));
  var crypto3 = (init_crypto2(), __toCommonJS(exports_crypto));
  var packageJson = require_package2();
  var version4 = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys2 = _dotenvKey(options).split(",");
    const length = keys2.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys2[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _log(message) {
    console.log(`[dotenv@${version4}][INFO] ${message}`);
  }
  function _warn(message) {
    console.log(`[dotenv@${version4}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version4}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os2.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// src/constants/appErrors.ts
var AppErrorEnum;
((AppErrorEnum2) => {
  AppErrorEnum2["ViemCreateClientFailed"] = "ViemCreateClientFailed";
  AppErrorEnum2["FailedHTTPRequest"] = "FailedHTTPRequest";
  AppErrorEnum2["UnknownError"] = "UnknownError";
  AppErrorEnum2["UnhandledRejection"] = "UnhandledRejection";
  AppErrorEnum2["UncaughtException"] = "UncaughtException";
  AppErrorEnum2["EnvKeyMissing"] = "EnvKeyMissing";
  AppErrorEnum2["ChainNotFound"] = "ChainNotFound";
  AppErrorEnum2["InsufficientGas"] = "InsufficientGas";
  AppErrorEnum2["InvalidNetworkMode"] = "InvalidNetworkMode";
  AppErrorEnum2["ContractCallError"] = "ContractCallError";
  AppErrorEnum2["LogDecodingFailed"] = "LogDecodingFailed";
})(AppErrorEnum ||= {});
var appErrors = {
  ["ViemCreateClientFailed" /* ViemCreateClientFailed */]: {
    message: "Failed to create viem client",
    isOperational: false
  },
  ["FailedHTTPRequest" /* FailedHTTPRequest */]: {
    message: "Failed to make HTTP request",
    isOperational: true
  },
  ["UnknownError" /* UnknownError */]: {
    message: "An unknown error occurred",
    isOperational: false
  },
  ["UnhandledRejection" /* UnhandledRejection */]: {
    message: "Unhandled promise rejection",
    isOperational: false
  },
  ["UncaughtException" /* UncaughtException */]: {
    message: "Uncaught exception",
    isOperational: false
  },
  ["EnvKeyMissing" /* EnvKeyMissing */]: {
    message: "Missing or empty required environment variable",
    isOperational: false
  },
  ["ChainNotFound" /* ChainNotFound */]: {
    message: "Chain not found",
    isOperational: false
  },
  ["InsufficientGas" /* InsufficientGas */]: {
    message: "Insufficient gas",
    isOperational: false
  },
  ["InvalidNetworkMode" /* InvalidNetworkMode */]: {
    message: "Invalid network mode",
    isOperational: false
  },
  ["ContractCallError" /* ContractCallError */]: {
    message: "Failed to call contract",
    isOperational: true
  },
  ["LogDecodingFailed" /* LogDecodingFailed */]: {
    message: "Failed to decode log",
    isOperational: true
  }
};
// node_modules/viem/_esm/utils/chain/defineChain.js
function defineChain(chain) {
  return {
    formatters: undefined,
    fees: undefined,
    serializers: undefined,
    ...chain
  };
}
// node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
    gas: transaction.gas ? BigInt(transaction.gas) : undefined,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : undefined,
    typeHex: transaction.type ? transaction.type : undefined,
    value: transaction.value ? BigInt(transaction.value) : undefined,
    v: transaction.v ? BigInt(transaction.v) : undefined
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);

// node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_fromHex();
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/viem/_esm/utils/encoding/toRlp.js
init_base();
init_cursor2();
init_toBytes();
init_toHex();
function toRlp(bytes, to = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
}

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
init_transaction();

// node_modules/viem/_esm/utils/blob/blobsToCommitments.js
init_toBytes();
init_toHex();
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/blobsToProofs.js
init_toBytes();
init_toHex();
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0;i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
init_toHex();

// node_modules/viem/_esm/utils/hash/sha256.js
init_sha256();
init_toBytes();
init_toHex();
function sha2562(value, to_) {
  const to = to_ || "hex";
  const bytes = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version2 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version2], 0);
  return to === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version2 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version2
    }));
  }
  return hashes;
}

// node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/constants/kzg.js
var versionedHashVersionKzg = 1;

// node_modules/viem/_esm/errors/blob.js
init_base();

class BlobSizeTooLargeError extends BaseError {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}

class EmptyBlobError extends BaseError {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}

class InvalidVersionedHashSizeError extends BaseError {
  constructor({ hash, size: size2 }) {
    super(`Versioned hash "${hash}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size2}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}

class InvalidVersionedHashVersionError extends BaseError {
  constructor({ hash, version: version2 }) {
    super(`Versioned hash "${hash}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${version2}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}

// node_modules/viem/_esm/utils/blob/toBlobs.js
init_cursor2();
init_size();
init_toBytes();
init_toHex();
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError;
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));
}

// node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i = 0;i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
init_toHex();

// node_modules/viem/_esm/experimental/eip7702/utils/serializeAuthorizationList.js
init_toHex();
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0)
    return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const { contractAddress, chainId, nonce, ...signature } = authorization;
    serializedAuthorizationList.push([
      chainId ? toHex(chainId) : "0x",
      contractAddress,
      nonce ? toHex(nonce) : "0x",
      ...toYParitySignatureArray({}, signature)
    ]);
  }
  return serializedAuthorizationList;
}

// node_modules/viem/_esm/utils/transaction/assertTransaction.js
init_number();
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
init_size();
init_slice();
init_fromHex();
function assertTransactionEIP7702(transaction) {
  const { authorizationList } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { contractAddress, chainId } = authorization;
      if (!isAddress(contractAddress))
        throw new InvalidAddressError({ address: contractAddress });
      if (chainId < 0)
        throw new InvalidChainIdError({ chainId });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const { blobVersionedHashes } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobError;
    for (const hash of blobVersionedHashes) {
      const size_ = size(hash);
      const version2 = hexToNumber(slice(hash, 0, 1));
      if (size_ !== 32)
        throw new InvalidVersionedHashSizeError({ hash, size: size_ });
      if (version2 !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash,
          version: version2
        });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/viem/_esm/utils/transaction/serializeAccessList.js
init_address();
init_transaction();
init_isAddress();
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0;i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i];
    for (let j = 0;j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress(address, { strict: false })) {
      throw new InvalidAddressError({ address });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
function serializeTransaction(transaction, signature) {
  const type = getTransactionType(transaction);
  if (type === "eip1559")
    return serializeTransactionEIP1559(transaction, signature);
  if (type === "eip2930")
    return serializeTransactionEIP2930(transaction, signature);
  if (type === "eip4844")
    return serializeTransactionEIP4844(transaction, signature);
  if (type === "eip7702")
    return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex([
    "0x04",
    toRlp([
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      serializedAuthorizationList,
      ...toYParitySignatureArray(transaction, signature)
    ])
  ]);
}
function serializeTransactionEIP4844(transaction, signature) {
  const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
    const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex(x));
    const kzg = transaction.kzg;
    const commitments2 = blobsToCommitments({
      blobs: blobs2,
      kzg
    });
    if (typeof blobVersionedHashes === "undefined")
      blobVersionedHashes = commitmentsToVersionedHashes({
        commitments: commitments2
      });
    if (typeof sidecars === "undefined") {
      const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
      sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...toYParitySignatureArray(transaction, signature)
  ];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0;i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concatHex([
    "0x03",
    sidecars ? toRlp([serializedTransaction, blobs, commitments, proofs]) : toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionLegacy(transaction, signature) {
  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x"
  ];
  if (signature) {
    const v = (() => {
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0)
          return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      const v2 = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v2)
        throw new InvalidLegacyVError({ v: signature.v });
      return v2;
    })();
    const r = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [
      ...serializedTransaction,
      toHex(v),
      r === "0x00" ? "0x" : r,
      s === "0x00" ? "0x" : s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ ?? transaction;
  const { v, yParity } = signature;
  if (typeof signature.r === "undefined")
    return [];
  if (typeof signature.s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === "number")
      return yParity ? toHex(1) : "0x";
    if (v === 0n)
      return "0x";
    if (v === 1n)
      return toHex(1);
    return v === 27n ? "0x" : toHex(1);
  })();
  return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
}

// node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// node_modules/viem/_esm/op-stack/formatters.js
init_fromHex();
var formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : undefined;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : undefined;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// node_modules/viem/_esm/op-stack/serializers.js
init_address();
init_isAddress();
init_toHex();
function serializeTransaction2(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction2
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from, gas, isSystemTx, mint, to, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from,
    to ?? "0x",
    mint ? toHex(mint) : "0x",
    value ? toHex(value) : "0x",
    gas ? toHex(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from, to } = transaction;
  if (from && !isAddress(from))
    throw new InvalidAddressError({ address: from });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
}

// node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig = {
  contracts,
  formatters,
  serializers
};

// node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = /* @__PURE__ */ defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = /* @__PURE__ */ defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});
// node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = /* @__PURE__ */ defineChain({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});
// node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = /* @__PURE__ */ defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});
// node_modules/viem/_esm/chains/definitions/base.js
var sourceId = 1;
var base = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId
});
// node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId2 = 11155111;
var baseSepolia = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId2]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId2
});
// node_modules/viem/_esm/actions/public/getCode.js
init_toHex();
async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex === "0x")
    return;
  return hex;
}

// node_modules/viem/_esm/utils/chain/assertCurrentChain.js
init_chain();
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError;
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}

// node_modules/viem/_esm/errors/account.js
init_base();

class AccountNotFoundError extends BaseError {
  constructor({ docsPath } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}

class AccountTypeNotSupportedError extends BaseError {
  constructor({ docsPath, metaMessages, type }) {
    super(`Account type "${type}" is not supported.`, {
      docsPath,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
}

// node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
// node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId3 = 1;
var optimism = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId3]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId3]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId3]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId3]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId3
});
// node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId4 = 11155111;
var optimismSepolia = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId4]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId4]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId4]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId4]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId4
});
// node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = /* @__PURE__ */ defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
// node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = /* @__PURE__ */ defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});
// node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = /* @__PURE__ */ defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});
// node:process
var C = Object.create;
var T = Object.defineProperty;
var q = Object.getOwnPropertyDescriptor;
var A = Object.getOwnPropertyNames;
var I = Object.getPrototypeOf;
var Q = Object.prototype.hasOwnProperty;
var S = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var N = (e, t) => {
  for (var n in t)
    T(e, n, { get: t[n], enumerable: true });
};
var d = (e, t, n, w) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let l of A(t))
      !Q.call(e, l) && l !== n && T(e, l, { get: () => t[l], enumerable: !(w = q(t, l)) || w.enumerable });
  return e;
};
var h = (e, t, n) => (d(e, t, "default"), n && d(n, t, "default"));
var y = (e, t, n) => (n = e != null ? C(I(e)) : {}, d(t || !e || !e.__esModule ? T(n, "default", { value: e, enumerable: true }) : n, e));
var v = S((B, E) => {
  var r = E.exports = {}, i, u;
  function p() {
    throw new Error("setTimeout has not been defined");
  }
  function g() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? i = setTimeout : i = p;
    } catch {
      i = p;
    }
    try {
      typeof clearTimeout == "function" ? u = clearTimeout : u = g;
    } catch {
      u = g;
    }
  })();
  function b(e) {
    if (i === setTimeout)
      return setTimeout(e, 0);
    if ((i === p || !i) && setTimeout)
      return i = setTimeout, setTimeout(e, 0);
    try {
      return i(e, 0);
    } catch {
      try {
        return i.call(null, e, 0);
      } catch {
        return i.call(this, e, 0);
      }
    }
  }
  function O(e) {
    if (u === clearTimeout)
      return clearTimeout(e);
    if ((u === g || !u) && clearTimeout)
      return u = clearTimeout, clearTimeout(e);
    try {
      return u(e);
    } catch {
      try {
        return u.call(null, e);
      } catch {
        return u.call(this, e);
      }
    }
  }
  var o = [], s = false, a, m = -1;
  function U() {
    !s || !a || (s = false, a.length ? o = a.concat(o) : m = -1, o.length && x());
  }
  function x() {
    if (!s) {
      var e = b(U);
      s = true;
      for (var t = o.length;t; ) {
        for (a = o, o = [];++m < t; )
          a && a[m].run();
        m = -1, t = o.length;
      }
      a = null, s = false, O(e);
    }
  }
  r.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n = 1;n < arguments.length; n++)
        t[n - 1] = arguments[n];
    o.push(new L(e, t)), o.length === 1 && !s && b(x);
  };
  function L(e, t) {
    this.fun = e, this.array = t;
  }
  L.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  r.title = "browser";
  r.browser = true;
  r.env = {};
  r.argv = [];
  r.version = "";
  r.versions = {};
  function c() {
  }
  r.on = c;
  r.addListener = c;
  r.once = c;
  r.off = c;
  r.removeListener = c;
  r.removeAllListeners = c;
  r.emit = c;
  r.prependListener = c;
  r.prependOnceListener = c;
  r.listeners = function(e) {
    return [];
  };
  r.binding = function(e) {
    throw new Error("process.binding is not supported");
  };
  r.cwd = function() {
    return "/";
  };
  r.chdir = function(e) {
    throw new Error("process.chdir is not supported");
  };
  r.umask = function() {
    return 0;
  };
});
var f = {};
N(f, { default: () => j });
h(f, y(v()));
var j = y(v());

// src/relayer/common/utils/formatting.ts
function shorten(address) {
  return `${address.slice(0, 6)}...${address.slice(-4)}`;
}

// src/relayer/common/utils/getEnvVar.ts
function getEnvVar(key) {
  const value = j.env[key];
  if (value === undefined || value === "")
    throw new Error(AppErrorEnum.ENV_KEY_MISSING, `Missing or empty required environment variable ${key}`);
  return value;
}
function getEnvAddress(prefix, networkName) {
  const searchKey = networkName ? `${envPrefixes[prefix]}_${networkEnvKeys[networkName]}` : envPrefixes[prefix];
  const value = getEnvVar(searchKey);
  const friendlyName = `${prefix}(${shorten(value)})`;
  return [value, friendlyName];
}

// node_modules/viem/_esm/index.js
init_exports();

// node_modules/viem/_esm/utils/getAction.js
function getAction(client, actionFn, name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client, params);
}

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_abi();

// node_modules/viem/_esm/errors/log.js
init_base();

class FilterTypeNotSupportedError extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_toBytes();
init_keccak256();
init_toEventSelector();
init_encodeAbiParameters();
init_formatAbiItem();
init_getAbiItem();
var docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  const { abi, eventName, args } = parameters;
  let abiItem = abi[0];
  if (eventName) {
    const item = getAbiItem({ abi, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(undefined, { docsPath });
  const definition = formatAbiItem(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => ("indexed" in param) && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j2) => encodeArg({ param, value: args_[i][j2] }));
        return typeof args_[i] !== "undefined" && args_[i] !== null ? encodeArg({ param, value: args_[i] }) : null;
      }) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_toHex();

// node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : undefined;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
init_encodeFunctionData();

// node_modules/viem/_esm/utils/errors/getContractError.js
init_abi();
init_base();
init_contract();
init_request();
init_rpc();
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath: docsPath3, functionName, sender }) {
  const error = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => ("data" in err2)) || err.walk() : {};
  const { code, data, details, message, shortMessage } = error;
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: error instanceof RpcRequestError ? details : shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_base();

// node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
init_getAddress();
init_keccak256();
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/viem/_esm/utils/signature/recoverPublicKey.js
init_fromHex();
init_toHex();
async function recoverPublicKey({ hash: hash2, signature }) {
  const hashHex = isHex(hash2) ? hash2 : toHex(hash2);
  const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), exports_secp256k1));
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r, s, v: v2, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v2);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash2, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature }));
}

// node_modules/viem/_esm/experimental/eip7702/utils/hashAuthorization.js
init_toBytes();
init_toHex();
init_keccak256();
function hashAuthorization(parameters) {
  const { chainId, contractAddress, nonce, to } = parameters;
  const hash2 = keccak256(concatHex([
    "0x05",
    toRlp([
      chainId ? numberToHex(chainId) : "0x",
      contractAddress,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes(hash2);
  return hash2;
}

// node_modules/viem/_esm/experimental/eip7702/utils/recoverAuthorizationAddress.js
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature ?? authorization
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_toHex();

// node_modules/viem/_esm/errors/estimateGas.js
init_formatEther();
init_formatGwei();
init_base();
init_transaction();

class EstimateGasExecutionError extends BaseError {
  constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath3,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.cause = cause;
  }
}

// node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_node();
init_getNodeError();
function getEstimateGasError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// node_modules/viem/_esm/actions/public/estimateGas.js
init_transactionRequest();
init_stateOverride2();
init_assertRequest();
// node_modules/viem/_esm/errors/fee.js
init_formatGwei();
init_base();

class BaseFeeScalarError extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}

class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}

class MaxFeePerGasTooLowError extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_fromHex();

// node_modules/viem/_esm/errors/block.js
init_base();

class BlockNotFoundError extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
  }
}

// node_modules/viem/_esm/actions/public/getBlock.js
init_toHex();
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

// node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args) {
  return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request } = args || {};
  try {
    const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction(client, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error;
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError;
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base2) => base2 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/viem/_esm/actions/public/getTransactionCount.js
init_fromHex();
init_toHex();
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_assertRequest();

// node_modules/viem/_esm/actions/public/getChainId.js
init_fromHex();
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
var defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
var eip1559NetworkCache = /* @__PURE__ */ new Map;
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = args;
  const account = account_ ? parseAccount(account_) : account_;
  const request = { ...args, ...account ? { from: account?.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain)
      return chain.id;
    if (typeof args.chainId !== "undefined")
      return args.chainId;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      let isEip1559Network = eip1559NetworkCache.get(client.uid);
      if (typeof isEip1559Network === "undefined") {
        const block2 = await getBlock2();
        isEip1559Network = typeof block2?.baseFeePerGas === "bigint";
        eip1559NetworkCache.set(client.uid, isEip1559Network);
      }
      request.type = isEip1559Network ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError;
      if (typeof args.gasPrice === "undefined") {
        const block2 = await getBlock2();
        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : account
    });
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
    if (nonceManager) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager.consume({
        address: account.address,
        chainId: chainId2,
        client
      });
    } else {
      request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  assertRequest(request);
  delete request.parameters;
  return request;
}

// node_modules/viem/_esm/actions/public/getBalance.js
init_toHex();
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const { account: account_ = client.account } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : block2 ? [request2, block2] : [request2]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
      ...args,
      parameters: account?.type === "local" ? undefined : ["blobVersionedHashes"]
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`");
        });
      return;
    })();
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance(client, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { contractAddress } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: undefined,
            data,
            from: account?.address,
            to: contractAddress,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi, address, args, functionName, dataSuffix, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : undefined;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
init_getAbiItem();

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
init_abi();
init_isAddressEqual();
init_toBytes();
init_keccak256();
init_toEventSelector();

// node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_abi();
init_size();
init_toEventSelector();
init_cursor();
init_decodeAbiParameters();
init_formatAbiItem();
var docsPath3 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });
  const abiItem = (() => {
    if (abi.length === 1)
      return abi[0];
    return abi.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem(x)));
  })();
  if (!(abiItem && ("name" in abiItem)) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !(("name" in x) && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => ("indexed" in x) && x.indexed);
  for (let i = 0;i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !(("indexed" in x) && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0;i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : undefined
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs(parameters) {
  const { abi, args, logs, strict = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log) => {
    try {
      const abiItem = abi.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log,
        abi: [abiItem],
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArgs({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args
      }))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArgs(parameters) {
  const { args, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args)
    return false;
  function isEqual(input, value, arg) {
    try {
      if (input.type === "address")
        return isAddressEqual(value, arg);
      if (input.type === "string" || input.type === "bytes")
        return keccak256(toBytes(value)) === arg;
      return value === arg;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    return matchArgs.every((value, index) => {
      if (value === null || value === undefined)
        return true;
      const input = inputs[index];
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[index]));
    });
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value]) => {
      if (value === null || value === undefined)
        return true;
      const input = inputs.find((input2) => input2.name === key);
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[key]));
    });
  return false;
}

// node_modules/viem/_esm/actions/public/getLogs.js
init_toHex();
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : undefined);
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? undefined : args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    args,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi, name: eventName }) : undefined;
  const events = !event ? abi.filter((x) => x.type === "event") : undefined;
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// node_modules/viem/_esm/actions/public/readContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function readContract(client, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/viem/_esm/actions/public/simulateContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function simulateContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi.filter((abiItem) => ("name" in abiItem) && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
init_abi();
init_rpc();

// node_modules/viem/_esm/utils/observe.js
var listenersCache = /* @__PURE__ */ new Map;
var cleanupCache = /* @__PURE__ */ new Map;
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const listeners2 = getListeners();
    if (!listeners2.some((cb) => cb.id === callbackId))
      return;
    const cleanup2 = cleanupCache.get(observerId);
    if (listeners2.length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = undefined;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
// node_modules/viem/_esm/utils/promise/withCache.js
var promiseCache = /* @__PURE__ */ new Map;
var responseCache = /* @__PURE__ */ new Map;
function getCache(cacheKey) {
  const buildCache = (cacheKey2, cache) => ({
    clear: () => cache.delete(cacheKey2),
    get: () => cache.get(cacheKey2),
    set: (data) => cache.set(cacheKey2, data)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date, data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter) || !filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber < blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
// node_modules/viem/_esm/actions/wallet/writeContract.js
init_encodeFunctionData();
// node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_base();

// node_modules/viem/_esm/utils/errors/getTransactionError.js
init_node();
init_transaction();
init_getNodeError();
function getTransactionError(err, { docsPath: docsPath6, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath6,
    ...args
  });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_transactionRequest();
init_lru();
init_assertRequest();

// node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);
async function sendTransaction(client, parameters) {
  const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = account_ ? parseAccount(account_) : null;
  try {
    assertRequest(parameters);
    const to = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`.");
        });
      return;
    })();
    if (account?.type === "json-rpc" || account === null) {
      let chainId;
      if (chain !== null) {
        chainId = await getAction(client, getChainId, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain
        });
      }
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account?.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
      const method = isWalletNamespaceSupported ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await client.request({
          method,
          params: [request]
        }, { retryCount: 0 });
      } catch (e) {
        if (isWalletNamespaceSupported === false)
          throw e;
        const error = e;
        if (error.name === "InvalidInputRpcError" || error.name === "InvalidParamsRpcError" || error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError") {
          return await client.request({
            method: "wallet_sendTransaction",
            params: [request]
          }, { retryCount: 0 }).then((hash2) => {
            supportsWalletNamespace.set(client.uid, true);
            return hash2;
          }).catch((e2) => {
            const walletNamespaceError = e2;
            if (walletNamespaceError.name === "MethodNotFoundRpcError" || walletNamespaceError.name === "MethodNotSupportedRpcError") {
              supportsWalletNamespace.set(client.uid, false);
              throw error;
            }
            throw walletNamespaceError;
          });
        }
        throw error;
      }
    }
    if (account?.type === "local") {
      const request = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        authorizationList,
        blobs,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        value,
        ...rest,
        to
      });
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction(request, {
        serializer
      });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if (account?.type === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account?.type
    });
  } catch (err) {
    if (err instanceof AccountTypeNotSupportedError)
      throw err;
    throw getTransactionError(err, {
      ...parameters,
      account,
      chain: parameters.chain || undefined
    });
  }
}

// node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, parameters) {
  const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account = account_ ? parseAccount(account_) : null;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    return await getAction(client, sendTransaction, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account,
      ...request
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/viem/_esm/errors/eip712.js
init_base();

class Eip712DomainNotFoundError extends BaseError {
  constructor({ address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${address}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}

// node_modules/viem/_esm/actions/public/getEip712Domain.js
async function getEip712Domain(client, parameters) {
  const { address, factory, factoryData } = parameters;
  try {
    const [fields, name, version3, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
      abi,
      address,
      functionName: "eip712Domain",
      factory,
      factoryData
    });
    return {
      domain: {
        name,
        version: version3,
        chainId: Number(chainId),
        verifyingContract,
        salt
      },
      extensions,
      fields
    };
  } catch (e) {
    const error = e;
    if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
      throw new Eip712DomainNotFoundError({ address });
    }
    throw error;
  }
}
var abi = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/viem/_esm/actions/wallet/addChain.js
init_toHex();
async function addChain(client, { chain }) {
  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : undefined
      }
    ]
  }, { dedupe: true, retryCount: 0 });
}
// node_modules/viem/_esm/utils/uid.js
var size2 = 256;
var index = size2;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0;i < size2; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4000, ccipRead, key = "base", name = "Base Client", pollingInterval = 4000, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : undefined;
  const { config, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid()
  };
  function extend(base2) {
    return (extendFn) => {
      const extended = extendFn(base2);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base2, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}

// node_modules/viem/_esm/utils/buildRequest.js
init_base();
init_request();
init_rpc();
init_toHex();

// node_modules/viem/_esm/utils/promise/withDedupe.js
init_lru();
var promiseCache2 = /* @__PURE__ */ new LruMap(8192);
function withDedupe(fn, { enabled = true, id }) {
  if (!enabled || !id)
    return fn();
  if (promiseCache2.get(id))
    return promiseCache2.get(id);
  const promise = fn().finally(() => promiseCache2.delete(id));
  promiseCache2.set(id, promise);
  return promise;
}

// node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = args;
    if (methods?.exclude?.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if (methods?.include && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe ? stringToHex(`${uid2}.${stringify(args)}`) : undefined;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5000:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return Number.parseInt(retryAfter) * 1000;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}

// node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid();
  return {
    config: {
      key,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),
    value
  };
}

// node_modules/viem/_esm/clients/transports/fallback.js
init_node();
init_rpc();
function fallback(transports_, config = {}) {
  const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
  return ({ chain, pollingInterval = 4000, timeout, ...rest }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key,
      name,
      async request({ method, params }) {
        const fetch2 = async (i = 0) => {
          const transport2 = transports[i]({
            ...rest,
            chain,
            retryCount: 0,
            timeout
          });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (shouldThrow(err))
              throw err;
            if (i === transports.length - 1)
              throw err;
            return fetch2(i + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn) => onResponse = fn,
      transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        ping: rankOptions.ping,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function shouldThrow(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5000)
      return true;
  }
  return false;
}
function rankTransports({ chain, interval = 4000, onTransports, ping, sampleCount = 10, timeout = 1000, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_, i) => {
      const latencies = samples.map((sample2) => sample2[i].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i
      ];
    }).sort((a, b) => b[0] - a[0]);
    onTransports(scores.map(([, i]) => transports[i]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}
// node_modules/viem/_esm/clients/transports/http.js
init_request();

// node_modules/viem/_esm/errors/transport.js
init_base();

class UrlRequiredError extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}

// node_modules/viem/_esm/clients/transports/http.js
init_createBatchScheduler();

// node_modules/viem/_esm/utils/rpc/http.js
init_request();

// node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController;
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: controller?.signal || null }));
      } catch (err) {
        if (err?.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
// node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = /* @__PURE__ */ createIdStore();

// node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          const args = await onRequest?.(request, init) ?? { ...init, url };
          const response2 = await fetch(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (err) {
            if (response.ok)
              throw err;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body,
          cause: err,
          url
        });
      }
    }
  };
}

// node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchOptions, key = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1000, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError;
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      methods,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b) => a.id - b.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
// node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();

// node_modules/viem/_esm/utils/ens/errors.js
init_solidity();
init_base();
init_contract();
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError))
    return false;
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.data?.errorName === "ResolverNotContract")
    return true;
  if (cause.data?.errorName === "ResolverError")
    return true;
  if (cause.data?.errorName === "HttpError")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// node_modules/viem/_esm/utils/ens/namehash.js
init_toBytes();
init_toHex();
init_keccak256();

// node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}

// node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1;i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/viem/_esm/utils/ens/packetToBytes.js
init_toBytes();

// node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}

// node_modules/viem/_esm/utils/ens/labelhash.js
init_toBytes();
init_toHex();
init_keccak256();
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}

// node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0;i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1)
    return bytes.slice(0, offset + 1);
  return bytes;
}

// node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// node_modules/viem/_esm/errors/ens.js
init_base();

class EnsAvatarInvalidMetadataError extends BaseError {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}

class EnsAvatarInvalidNftUriError extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}

class EnsAvatarUriResolutionError extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}

class EnsAvatarUnsupportedNamespaceError extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}

// node_modules/viem/_esm/utils/ens/avatar/utils.js
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image;
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom, defaultGateway) {
  if (!custom)
    return defaultGateway;
  if (custom.endsWith("/"))
    return custom.slice(0, -1);
  return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// node_modules/viem/_esm/actions/ens/getEnsText.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();
async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        })
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsName.js
init_abis();
init_getChainContractAddress();
init_toHex();
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsResolver.js
init_getChainContractAddress();
init_toHex();
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// node_modules/viem/_esm/clients/decorators/public.js
init_call();

// node_modules/viem/_esm/actions/public/createAccessList.js
init_toHex();
init_getCallError();
init_transactionRequest();
init_assertRequest();
async function createAccessList(client, args) {
  const { account: account_ = client.account, blockNumber, blockTag = "latest", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      to,
      value
    });
    const response = await client.request({
      method: "eth_createAccessList",
      params: [request, block]
    });
    return {
      accessList: response.accessList,
      gasUsed: BigInt(response.gasUsed)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id, request: getRequest(id), type: "block" };
}

// node_modules/viem/_esm/actions/public/createEventFilter.js
init_toHex();
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : undefined);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : undefined,
    fromBlock,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id, request: getRequest(id), type: "transaction" };
}

// node_modules/viem/_esm/actions/public/getBlobBaseFee.js
async function getBlobBaseFee(client) {
  const baseFee = await client.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}

// node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
init_fromHex();
init_toHex();
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    }, { dedupe: true });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  return hexToNumber(count);
}

// node_modules/viem/_esm/actions/public/getFeeHistory.js
init_toHex();

// node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}

// node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  }, { dedupe: Boolean(blockNumberHex) });
  return formatFeeHistory(feeHistory);
}

// node_modules/viem/_esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/viem/_esm/actions/public/getProof.js
init_toHex();

// node_modules/viem/_esm/utils/typedData.js
init_abi();
init_address();

// node_modules/viem/_esm/errors/typedData.js
init_base();

class InvalidDomainError extends BaseError {
  constructor({ domain }) {
    super(`Invalid domain "${stringify(domain)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}

class InvalidPrimaryTypeError extends BaseError {
  constructor({ primaryType, types }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}

class InvalidStructTypeError extends BaseError {
  constructor({ type }) {
    super(`Struct type "${type}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}

// node_modules/viem/_esm/utils/typedData.js
init_isAddress();
init_size();
init_toHex();
init_regex2();

// node_modules/viem/_esm/utils/signature/hashTypedData.js
init_encodeAbiParameters();
init_toHex();
init_keccak256();
function hashTypedData(parameters) {
  const { domain = {}, message, primaryType } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = new Set) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === undefined) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type, value }) {
  if (types[type] !== undefined) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v2]) => v2)))
    ];
  }
  return [{ type }, value];
}

// node_modules/viem/_esm/utils/typedData.js
function serializeTypedData(parameters) {
  const { domain: domain_, message: message_, primaryType, types } = parameters;
  const normalizeData = (struct, data_) => {
    const data = { ...data_ };
    for (const param of struct) {
      const { name, type } = param;
      if (type === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!types.EIP712Domain)
      return {};
    if (!domain_)
      return {};
    return normalizeData(types.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return;
    return normalizeData(types[primaryType], message_);
  })();
  return stringify({ domain, message, primaryType, types });
}
function validateTypedData(parameters) {
  const { domain, message, primaryType, types } = parameters;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const { name, type } = param;
      const value = data[name];
      const integerMatch = type.match(integerRegex2);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base2, size_] = integerMatch;
        numberToHex(value, {
          signed: base2 === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex2);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2) {
        validateReference(type);
        validateData(struct2, value);
      }
    }
  };
  if (types.EIP712Domain && domain) {
    if (typeof domain !== "object")
      throw new InvalidDomainError({ domain });
    validateData(types.EIP712Domain, domain);
  }
  if (primaryType !== "EIP712Domain") {
    if (types[primaryType])
      validateData(types[primaryType], message);
    else
      throw new InvalidPrimaryTypeError({ primaryType, types });
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    (typeof domain?.chainId === "number" || typeof domain?.chainId === "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function validateReference(type) {
  if (type === "address" || type === "bool" || type === "string" || type.startsWith("bytes") || type.startsWith("uint") || type.startsWith("int"))
    throw new InvalidStructTypeError({ type });
}

// node_modules/viem/_esm/utils/index.js
init_encodeFunctionData();
init_fromHex();

// node_modules/viem/_esm/utils/signature/hashMessage.js
init_keccak256();

// node_modules/viem/_esm/constants/strings.js
var presignMessagePrefix = `\x19Ethereum Signed Message:
`;

// node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
init_size();
init_toHex();
function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === "string")
      return stringToHex(message_);
    if (typeof message_.raw === "string")
      return message_.raw;
    return bytesToHex(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
  return concat([prefix, message]);
}

// node_modules/viem/_esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  return keccak256(toPrefixedMessage(message), to_);
}

// node_modules/viem/_esm/constants/bytes.js
var erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";

// node_modules/viem/_esm/utils/signature/isErc6492Signature.js
init_slice();
function isErc6492Signature(signature) {
  return sliceHex(signature, -32) === erc6492MagicBytes;
}

// node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
init_encodeAbiParameters();
init_toBytes();
function serializeErc6492Signature(parameters) {
  const { address, data, signature, to = "hex" } = parameters;
  const signature_ = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
    erc6492MagicBytes
  ]);
  if (to === "hex")
    return signature_;
  return hexToBytes(signature_);
}

// node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : undefined,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : undefined
  };
}

// node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// node_modules/viem/_esm/actions/public/getStorageAt.js
init_toHex();
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// node_modules/viem/_esm/actions/public/getTransaction.js
init_transaction();
init_toHex();
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let transaction = null;
  if (hash2) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    }, { dedupe: true });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}

// node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction(client, getTransaction, "getTransaction")({ hash: hash2 }) : undefined
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// node_modules/viem/_esm/actions/public/getTransactionReceipt.js
init_transaction();
async function getTransactionReceipt(client, { hash: hash2 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}

// node_modules/viem/_esm/actions/public/multicall.js
init_abis();
init_abi();
init_base();
init_contract();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
async function multicall(client, parameters) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts2 = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0;i < contracts2.length; i++) {
    const { abi: abi2, address, args, functionName } = contracts2[i];
    try {
      const callData = encodeFunctionData({ abi: abi2, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (let i = 0;i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0;j2 < chunkedCalls[i].length; j2++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: undefined
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0;j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i][j2];
      const { abi: abi2, address, functionName, args } = contracts2[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError;
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi2,
          args,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: undefined, status: "failure" });
      }
    }
  }
  if (results.length !== contracts2.length)
    throw new BaseError("multicall results mismatch");
  return results;
}

// node_modules/ox/_esm/core/version.js
var version3 = "0.1.1";

// node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version3;
}

// node_modules/ox/_esm/core/Errors.js
class BaseError3 extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      if (options.cause instanceof BaseError3) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if (options.cause?.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath6 = (() => {
      if (options.cause instanceof BaseError3)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath6 ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath6 ? [
        "",
        details ? `Details: ${details}` : undefined,
        docsPath6 ? `See: ${docs}` : undefined
      ] : []
    ].filter((x) => typeof x === "string").join(`
`);
    super(message, options.cause ? { cause: options.cause } : undefined);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath6;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk2(this, fn);
  }
}
function walk2(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk2(err.cause, fn);
  return fn ? null : err;
}

// node_modules/ox/_esm/core/internal/hex.js
function pad2(hex_, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}

// node_modules/ox/_esm/core/Hex.js
function fromNumber(value, options = {}) {
  const { signed, size: size4 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError2({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size4)
    return padLeft(hex, size4);
  return hex;
}
function padLeft(value, size4) {
  return pad2(value, { dir: "left", size: size4 });
}
class IntegerOutOfRangeError2 extends BaseError3 {
  constructor({ max, min, signed, size: size4, value }) {
    super(`Number \`${value}\` is not in safe${size4 ? ` ${size4 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class SizeExceedsPaddingSizeError2 extends BaseError3 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}

// node_modules/ox/_esm/core/Withdrawal.js
function toRpc(withdrawal) {
  return {
    address: withdrawal.address,
    amount: fromNumber(withdrawal.amount),
    index: fromNumber(withdrawal.index),
    validatorIndex: fromNumber(withdrawal.validatorIndex)
  };
}

// node_modules/ox/_esm/core/BlockOverrides.js
function toRpc2(blockOverrides) {
  return {
    ...typeof blockOverrides.baseFeePerGas === "bigint" && {
      baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)
    },
    ...typeof blockOverrides.blobBaseFee === "bigint" && {
      blobBaseFee: fromNumber(blockOverrides.blobBaseFee)
    },
    ...typeof blockOverrides.feeRecipient === "string" && {
      feeRecipient: blockOverrides.feeRecipient
    },
    ...typeof blockOverrides.gasLimit === "bigint" && {
      gasLimit: fromNumber(blockOverrides.gasLimit)
    },
    ...typeof blockOverrides.number === "bigint" && {
      number: fromNumber(blockOverrides.number)
    },
    ...typeof blockOverrides.prevRandao === "bigint" && {
      prevRandao: fromNumber(blockOverrides.prevRandao)
    },
    ...typeof blockOverrides.time === "bigint" && {
      time: fromNumber(blockOverrides.time)
    },
    ...blockOverrides.withdrawals && {
      withdrawals: blockOverrides.withdrawals.map(toRpc)
    }
  };
}

// node_modules/viem/_esm/actions/public/simulate.js
init_abi();
init_contract();
init_node();
init_decodeFunctionResult();
init_encodeFunctionData();
init_toHex();
init_getNodeError();
init_transactionRequest();
init_stateOverride2();
init_assertRequest();
async function simulate(client, parameters) {
  const { blockNumber, blockTag = "latest", blocks, returnFullTransactions, traceTransfers, validation } = parameters;
  try {
    const blockStateCalls = [];
    for (const block2 of blocks) {
      const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : undefined;
      const calls = block2.calls.map((call_) => {
        const call2 = call_;
        const account = call2.account ? parseAccount(call2.account) : undefined;
        const request = {
          ...call2,
          data: call2.abi ? encodeFunctionData(call2) : call2.data,
          from: call2.from ?? account?.address
        };
        assertRequest(request);
        return formatTransactionRequest(request);
      });
      const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : undefined;
      blockStateCalls.push({
        blockOverrides,
        calls,
        stateOverrides
      });
    }
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const result = await client.request({
      method: "eth_simulateV1",
      params: [
        { blockStateCalls, returnFullTransactions, traceTransfers, validation },
        block
      ]
    });
    return result.map((block2, i) => ({
      ...formatBlock(block2),
      calls: block2.calls.map((call2, j2) => {
        const { abi: abi2, args, functionName, to } = blocks[i].calls[j2];
        const data = call2.error?.data ?? call2.returnData;
        const gasUsed = BigInt(call2.gasUsed);
        const logs = call2.logs?.map((log) => formatLog(log));
        const status = call2.status === "0x1" ? "success" : "failure";
        const result2 = abi2 ? decodeFunctionResult({
          abi: abi2,
          data,
          functionName
        }) : null;
        const error = (() => {
          if (status === "success")
            return;
          let error2 = undefined;
          if (call2.error?.data === "0x")
            error2 = new AbiDecodingZeroDataError;
          else if (call2.error)
            error2 = new RawContractError(call2.error);
          if (!error2)
            return;
          return getContractError(error2, {
            abi: abi2 ?? [],
            address: to,
            args,
            functionName: functionName ?? "<unknown>"
          });
        })();
        return {
          data,
          gasUsed,
          logs,
          status,
          ...status === "success" ? {
            result: result2
          } : {
            error
          }
        };
      })
    }));
  } catch (e) {
    const cause = e;
    const error = getNodeError(cause, {});
    if (error instanceof UnknownNodeError)
      throw cause;
    throw error;
  }
}

// node_modules/viem/_esm/actions/public/verifyHash.js
init_abis();
init_contract();
init_encodeDeployData();
init_getAddress();
init_isAddressEqual();
init_toHex();

// node_modules/viem/_esm/utils/signature/serializeSignature.js
init_secp256k1();
init_fromHex();
init_toBytes();
function serializeSignature({ r, s, to = "hex", v: v2, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v2 && (v2 === 27n || v2 === 28n || v2 >= 35n))
      return v2 % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to === "hex")
    return signature;
  return hexToBytes(signature);
}

// node_modules/viem/_esm/actions/public/verifyHash.js
init_call();
async function verifyHash(client, parameters) {
  const { address, factory, factoryData, hash: hash2, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;
  const signatureHex = (() => {
    if (isHex(signature))
      return signature;
    if (typeof signature === "object" && "r" in signature && "s" in signature)
      return serializeSignature(signature);
    return bytesToHex(signature);
  })();
  const wrappedSignature = await (async () => {
    if (!factory && !factoryData)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: factory,
      data: factoryData,
      signature: signatureHex
    });
  })();
  try {
    const args = universalSignatureVerifierAddress ? {
      to: universalSignatureVerifierAddress,
      data: encodeFunctionData({
        abi: universalSignatureValidatorAbi,
        functionName: "isValidSig",
        args: [address, hash2, wrappedSignature]
      }),
      ...rest
    } : {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, wrappedSignature],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...rest
    };
    const { data } = await getAction(client, call, "call")(args);
    return hexToBool(data ?? "0x0");
  } catch (error) {
    try {
      const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash2, signature }));
      if (verified)
        return true;
    } catch {
    }
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address,
    factory,
    factoryData,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData(client, parameters) {
  const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
  const hash2 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address,
    factory,
    factoryData,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
init_transaction();
// node_modules/viem/_esm/actions/public/watchBlockNumber.js
init_fromHex();
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n;i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data.result?.number);
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count }) => ~~(1 << count) * 200,
  timeout = 180000
}) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash2]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  const { promise, resolve, reject } = withResolvers();
  const timer = timeout ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout) : undefined;
  const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
    const _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
      emitMissed: true,
      emitOnBegin: true,
      poll: true,
      pollingInterval,
      async onBlockNumber(blockNumber_) {
        const done = (fn) => {
          clearTimeout(timer);
          _unwatch();
          fn();
          _unobserve();
        };
        let blockNumber = blockNumber_;
        if (retrying)
          return;
        try {
          if (receipt) {
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
            return;
          }
          if (!transaction) {
            retrying = true;
            await withRetry(async () => {
              transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash2 });
              if (transaction.blockNumber)
                blockNumber = transaction.blockNumber;
            }, {
              delay: retryDelay,
              retryCount
            });
            retrying = false;
          }
          receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
            return;
          done(() => emit.resolve(receipt));
        } catch (err) {
          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
            if (!transaction) {
              retrying = false;
              return;
            }
            try {
              replacedTransaction = transaction;
              retrying = true;
              const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                blockNumber,
                includeTransactions: true
              }), {
                delay: retryDelay,
                retryCount,
                shouldRetry: ({ error }) => error instanceof BlockNotFoundError
              });
              retrying = false;
              const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
              if (!replacementTransaction)
                return;
              receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                hash: replacementTransaction.hash
              });
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              let reason = "replaced";
              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                reason = "repriced";
              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                reason = "cancelled";
              }
              done(() => {
                emit.onReplaced?.({
                  reason,
                  replacedTransaction,
                  transaction: replacementTransaction,
                  transactionReceipt: receipt
                });
                emit.resolve(receipt);
              });
            } catch (err_) {
              done(() => emit.reject(err_));
            }
          } else {
            done(() => emit.reject(err));
          }
        }
      }
    });
  });
  return promise;
}
// node_modules/viem/_esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number && prevBlock?.number) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = prevBlock?.number + 1n;i < block.number; i++) {
              const block2 = await getAction(client, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let emitFetched = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        if (emitOnBegin) {
          getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          }).then((block) => {
            if (!active)
              return;
            if (!emitFetched)
              return;
            onBlock(block, undefined);
            emitFetched = false;
          });
        }
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          async onData(data) {
            if (!active)
              return;
            const block = await getAction(client, getBlock, "getBlock")({
              blockNumber: data.blockNumber,
              includeTransactions
            }).catch(() => {
            });
            if (!active)
              return;
            onBlock(block, prevBlock);
            emitFetched = false;
            prevBlock = block;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// node_modules/viem/_esm/actions/public/watchEvent.js
init_abi();
init_rpc();
function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getLogs, "getLogs")({
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const events_ = events ?? (event ? [event] : undefined);
        let topics = [];
        if (events_) {
          const encoded = events_.flatMap((event2) => encodeEventTopics({
            abi: [event2],
            eventName: event2.name,
            args
          }));
          topics = [encoded];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, { args: args2, eventName });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
// node_modules/viem/_esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit.onTransactions([hash2]);
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
function parseSiweMessage(message) {
  const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};
  const resources = message.split("Resources:")[1]?.split(`
- `).slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

// node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
init_isAddressEqual();
function validateSiweMessage(parameters) {
  const { address, domain, message, nonce, scheme, time = new Date } = parameters;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time >= message.expirationTime)
    return false;
  if (message.notBefore && time < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}

// node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
async function verifySiweMessage(client, parameters) {
  const { address, domain, message, nonce, scheme, signature, time = new Date, ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid = validateSiweMessage({
    address,
    domain,
    message: parsed,
    nonce,
    scheme,
    time
  });
  if (!isValid)
    return false;
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address: parsed.address,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call(client, args),
    createAccessList: (args) => createAccessList(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getCode(client, args),
    getChainId: () => getChainId(client),
    getCode: (args) => getCode(client, args),
    getContractEvents: (args) => getContractEvents(client, args),
    getEip712Domain: (args) => getEip712Domain(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulate: (args) => simulate(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage(client, args),
    verifySiweMessage: (args) => verifySiweMessage(client, args),
    verifyTypedData: (args) => verifyTypedData(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}

// node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}
// node_modules/viem/_esm/actions/wallet/deployContract.js
init_encodeDeployData();
function deployContract(walletClient, parameters) {
  const { abi: abi2, args, bytecode, ...request } = parameters;
  const calldata = encodeDeployData({ abi: abi2, args, bytecode });
  return sendTransaction(walletClient, {
    ...request,
    data: calldata
  });
}

// node_modules/viem/_esm/actions/wallet/getAddresses.js
init_getAddress();
async function getAddresses(client) {
  if (client.account?.type === "local")
    return [client.account.address];
  const addresses = await client.request({ method: "eth_accounts" }, { dedupe: true });
  return addresses.map((address) => checksumAddress(address));
}

// node_modules/viem/_esm/actions/wallet/getPermissions.js
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" }, { dedupe: true });
  return permissions;
}

// node_modules/viem/_esm/actions/wallet/requestAddresses.js
init_getAddress();
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
  return addresses.map((address) => getAddress(address));
}

// node_modules/viem/_esm/actions/wallet/requestPermissions.js
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  }, { retryCount: 0 });
}
// node_modules/viem/_esm/actions/wallet/signMessage.js
init_toHex();
async function signMessage(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.signMessage)
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account.address]
  }, { retryCount: 0 });
}
// node_modules/viem/_esm/actions/wallet/signTransaction.js
init_toHex();
init_transactionRequest();
init_assertRequest();
async function signTransaction(client, parameters) {
  const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account = parseAccount(account_);
  assertRequest({
    account,
    ...parameters
  });
  const chainId = await getAction(client, getChainId, "getChainId")({});
  if (chain !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain
    });
  const formatters2 = chain?.formatters || client.chain?.formatters;
  const format = formatters2?.transactionRequest?.format || formatTransactionRequest;
  if (account.signTransaction)
    return account.signTransaction({
      ...transaction,
      chainId
    }, { serializer: client.chain?.serializers?.transaction });
  return await client.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format(transaction),
        chainId: numberToHex(chainId),
        from: account.address
      }
    ]
  }, { retryCount: 0 });
}
// node_modules/viem/_esm/actions/wallet/signTypedData.js
async function signTypedData(client, parameters) {
  const { account: account_ = client.account, domain, message, primaryType } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account = parseAccount(account_);
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({ domain, message, primaryType, types });
  if (account.signTypedData)
    return account.signTypedData({ domain, message, primaryType, types });
  const typedData = serializeTypedData({ domain, message, primaryType, types });
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/switchChain.js
init_toHex();
async function switchChain(client, { id }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id)
      }
    ]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/watchAsset.js
async function watchAsset(client, params) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params
  }, { retryCount: 0 });
  return added;
}

// node_modules/viem/_esm/clients/decorators/wallet.js
function walletActions(client) {
  return {
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    signMessage: (args) => signMessage(client, args),
    signTransaction: (args) => signTransaction(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args)
  };
}

// node_modules/viem/_esm/clients/createWalletClient.js
function createWalletClient(parameters) {
  const { key = "wallet", name = "Wallet Client", transport } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    transport,
    type: "walletClient"
  });
  return client.extend(walletActions);
}
// node_modules/viem/_esm/index.js
init_abi();
init_decodeAbiParameters();
init_getAbiItem();
// src/relayer/common/utils/localhostViemChain.ts
var localhostViemChain = defineChain({
  id: 1,
  name: "localhost",
  nativeCurrency: {
    decimals: 18,
    name: "eth",
    symbol: "eth"
  },
  rpcUrls: {
    default: { http: [process.env.LOCALHOST_RPC_URL] }
  },
  blockExplorers: [
    {
      name: "localhost",
      url: process.env.LOCALHOST_RPC_URL
    }
  ],
  testnet: true
});
// src/abi/ConceroRouter.json
var abi2 = [
  {
    inputs: [
      {
        internalType: "uint24",
        name: "chainSelector",
        type: "uint24"
      },
      {
        internalType: "address",
        name: "USDC",
        type: "address"
      },
      {
        internalType: "address[4]",
        name: "clfSigners",
        type: "address[4]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "DuplicateSignatureDetected",
    type: "error"
  },
  {
    inputs: [],
    name: "IncorrectNumberOfSignatures",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "provided",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "required",
        type: "uint256"
      }
    ],
    name: "InsufficientFee",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidAmount",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "enum Message.MessageConfigErrorType",
        name: "error",
        type: "uint8"
      }
    ],
    name: "InvalidClientMessageConfig",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidDstChainData",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMessageHashSum",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidNamespace",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidReceiver",
    type: "error"
  },
  {
    inputs: [],
    name: "LengthMismatch",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "messageId",
        type: "bytes32"
      }
    ],
    name: "MessageAlreadyProcessed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "messageId",
        type: "bytes32"
      }
    ],
    name: "MessageDeliveryFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "MessageTooLarge",
    type: "error"
  },
  {
    inputs: [],
    name: "NotOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "enum CommonErrors.RequiredVariableUnsetType",
        name: "variableType",
        type: "uint8"
      }
    ],
    name: "RequiredVariableUnset",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    inputs: [],
    name: "TransferFailed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "UnauthorizedSigner",
    type: "error"
  },
  {
    inputs: [],
    name: "UnsupportedFeeTokenType",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ConceroMessageDelivered",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "ConceroMessageReceived",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "messageId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "internalMessageConfig",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "dstChainData",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "ConceroMessageSent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "OperatorFeeWithdrawn",
    type: "event"
  },
  {
    stateMutability: "payable",
    type: "fallback"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "config",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "dstChainData",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "conceroSend",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "getCohort",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "clientMessageConfig",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "dstChainData",
        type: "bytes"
      }
    ],
    name: "getMessageFeeNative",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "clientMessageConfig",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "dstChainData",
        type: "bytes"
      }
    ],
    name: "getMessageFeeUSDC",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "namespace",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "offset",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "mappingKey",
        type: "bytes32"
      }
    ],
    name: "getStorage",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWithdrawableConceroFee",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "i_owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint24",
        name: "chainSelector",
        type: "uint24"
      }
    ],
    name: "isChainSupported",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint24[]",
        name: "dstChainSelectors",
        type: "uint24[]"
      },
      {
        internalType: "uint256[]",
        name: "gasPrices",
        type: "uint256[]"
      }
    ],
    name: "setLastGasPrices",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint24[]",
        name: "dstChainSelectors",
        type: "uint24[]"
      },
      {
        internalType: "uint256[]",
        name: "rates",
        type: "uint256[]"
      }
    ],
    name: "setNativeNativeRates",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "setNativeUsdRate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "namespace",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "offset",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "mappingKey",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "setStorage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32[]",
        name: "namespaces",
        type: "bytes32[]"
      },
      {
        internalType: "uint256[]",
        name: "offsets",
        type: "uint256[]"
      },
      {
        internalType: "bytes32[]",
        name: "mappingKeys",
        type: "bytes32[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "setStorageBulk",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32[3]",
            name: "context",
            type: "bytes32[3]"
          },
          {
            internalType: "bytes",
            name: "report",
            type: "bytes"
          },
          {
            internalType: "bytes32[]",
            name: "rs",
            type: "bytes32[]"
          },
          {
            internalType: "bytes32[]",
            name: "ss",
            type: "bytes32[]"
          },
          {
            internalType: "bytes",
            name: "rawVs",
            type: "bytes"
          }
        ],
        internalType: "struct Types.ClfDonReportSubmission",
        name: "reportSubmission",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "submitMessageReport",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "withdrawConceroFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "withdrawOperatorFee",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/constants/globalConfig.ts
var import_ConceroVerifier = __toESM(require_ConceroVerifier(), 1);
var globalConfig = {
  NETWORK_MODE: getEnvVar("NETWORK_MODE"),
  OPERATOR_ADDRESS: getEnvVar("OPERATOR_ADDRESS"),
  WHITELISTED_NETWORK_IDS: {
    mainnet: [1, 137],
    testnet: [84532, 80002],
    localhost: [1]
  },
  POLLING_INTERVAL_MS: 5000,
  LOG_LEVEL: getEnvVar("LOG_LEVEL") || "info",
  LOG_DIR: "logs",
  URLS: {
    CONCERO_RPCS: "https://raw.githubusercontent.com/concero/rpcs/refs/heads/master/output/"
  },
  LOG_MAX_FILES: "7d",
  VIEM: {
    RECEIPT: {
      timeout: 0,
      confirmations: 1
    },
    WRITE_CONTRACT: {
      gas: 3000000n
    },
    FALLBACK_TRANSPORT_OPTIONS: {
      rank: true,
      retryCount: 3,
      retryDelay: 1000
    },
    CLIENT_ROTATION_INTERVAL_MS: 1000 * 60 * 60 * 1
  },
  HTTPCLIENT: {
    DEFAULT_TIMEOUT: 5000,
    MAX_RETRIES: 3,
    RETRY_DELAY: 1000
  },
  ABI: {
    CONCERO_VERIFIER: import_ConceroVerifier.abi,
    CONCERO_ROUTER: abi2
  }
};

// src/constants/conceroNetworks.ts
var DEFAULT_BLOCK_CONFIRMATIONS = 2;
var operatorPK = getEnvVar("OPERATOR_PRIVATE_KEY");
var networkTypes = {
  mainnet: "mainnet",
  testnet: "testnet"
};
var testingNetworks = {
  localhost: {
    name: "localhost",
    type: networkTypes.testnet,
    id: 1,
    accounts: [operatorPK],
    chainSelector: "1",
    confirmations: 1,
    viemChain: localhostViemChain,
    addresses: {
      conceroVerifier: getEnvVar("CONCERO_VERIFIER_ADDRESS_LOCALHOST"),
      conceroRouter: getEnvVar("CONCERO_ROUTER_ADDRESS_LOCALHOST")
    }
  }
};
var testnetNetworks = {
  sepolia: {
    name: "sepolia",
    type: networkTypes.testnet,
    id: 11155111,
    accounts: [operatorPK],
    chainSelector: "11155111",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: sepolia
  },
  avalancheFuji: {
    name: "avalancheFuji",
    type: networkTypes.testnet,
    id: 43113,
    accounts: [operatorPK],
    chainSelector: "43113",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: avalancheFuji
  },
  optimismSepolia: {
    name: "optimismSepolia",
    type: networkTypes.testnet,
    id: 11155420,
    accounts: [operatorPK],
    chainSelector: "11155420",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: optimismSepolia
  },
  arbitrumSepolia: {
    name: "arbitrumSepolia",
    type: networkTypes.testnet,
    id: 421614,
    accounts: [operatorPK],
    chainSelector: "421614",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: arbitrumSepolia
  },
  baseSepolia: {
    name: "baseSepolia",
    type: networkTypes.testnet,
    id: 84532,
    accounts: [operatorPK],
    chainSelector: "84532",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: baseSepolia
  },
  polygonAmoy: {
    name: "polygonAmoy",
    type: networkTypes.testnet,
    id: 80002,
    accounts: [operatorPK],
    chainSelector: "80002",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: polygonAmoy
  }
};
var mainnetNetworks = {
  ethereum: {
    name: "ethereum",
    type: networkTypes.mainnet,
    id: 1,
    accounts: [operatorPK],
    chainSelector: "1",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: mainnet
  },
  base: {
    name: "base",
    type: networkTypes.mainnet,
    id: 8453,
    accounts: [operatorPK],
    chainSelector: "8453",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: base
  },
  arbitrum: {
    name: "arbitrum",
    type: networkTypes.mainnet,
    id: 42161,
    accounts: [operatorPK],
    chainSelector: "42161",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: arbitrum
  },
  polygon: {
    name: "polygon",
    type: networkTypes.mainnet,
    id: 137,
    accounts: [operatorPK],
    chainSelector: "137",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: polygon
  },
  avalanche: {
    name: "avalanche",
    type: networkTypes.mainnet,
    id: 43114,
    accounts: [operatorPK],
    chainSelector: "43114",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: avalanche
  },
  optimism: {
    name: "optimism",
    type: networkTypes.mainnet,
    id: 10,
    accounts: [operatorPK],
    chainSelector: "10",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: optimism
  },
  polygonZkEvm: {
    name: "polygonZkEvm",
    type: networkTypes.mainnet,
    id: 137,
    accounts: [operatorPK],
    chainSelector: "1101",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: polygon
  }
};
var conceroNetworks = {
  ...testingNetworks,
  ...testnetNetworks,
  ...mainnetNetworks
};
var filterWhitelistedNetworks = (networkType) => {
  let filteredNetworks = [];
  const whitelistedIds = globalConfig.WHITELISTED_NETWORK_IDS[networkType];
  switch (networkType) {
    case "localhost": {
      filteredNetworks = Object.values(testingNetworks);
      break;
    }
    case "testnet": {
      filteredNetworks = Object.values(testnetNetworks).filter((network) => whitelistedIds.includes(network.id));
      break;
    }
    case "mainnet": {
      filteredNetworks = Object.values(mainnetNetworks).filter((network) => whitelistedIds.includes(network.id));
      break;
    }
  }
  return filteredNetworks;
};
var activeNetworks = filterWhitelistedNetworks(globalConfig.NETWORK_MODE);
// src/constants/envPrefixes.ts
var envPrefixes = {
  nodeEnv: "NODE_ENV",
  logLevel: "LOG_LEVEL",
  router: "CONCERO_ROUTER",
  verifier: "CONCERO_CLF_ROUTER",
  routerProxy: "CONCERO_ROUTER_PROXY",
  routerProxyAdmin: "CONCERO_ROUTER_PROXY_ADMIN",
  verifierProxy: "CONCERO_VERIFIER_PROXY",
  verifierProxyAdmin: "CONCERO_VERIFIER_PROXY_ADMIN",
  operatorAddress: "OPERATOR_ADDRESS",
  operatorPrivateKey: "OPERATOR_PRIVATE_KEY"
};
// src/constants/networkEnvKeys.ts
var networkEnvKeys = {
  ethereum: "ETHEREUM",
  arbitrum: "ARBITRUM",
  optimism: "OPTIMISM",
  polygon: "POLYGON",
  polygonZkEvm: "POLYGON_ZKEVM",
  avalanche: "AVALANCHE",
  base: "BASE",
  sepolia: "ETHEREUM_SEPOLIA",
  optimismSepolia: "OPTIMISM_SEPOLIA",
  arbitrumSepolia: "ARBITRUM_SEPOLIA",
  avalancheFuji: "AVALANCHE_FUJI",
  baseSepolia: "BASE_SEPOLIA",
  polygonAmoy: "POLYGON_AMOY",
  localhost: "LOCALHOST"
};
// src/relayer/common/utils/logger.ts
var import_winston = __toESM(require_winston(), 1);
var import_winston_daily_rotate_file = __toESM(require_winston_daily_rotate_file(), 1);
var logLevel = globalConfig.LOG_LEVEL;
var logFormat = import_winston.default.format.combine(import_winston.default.format.colorize({ level: true }), import_winston.default.format.timestamp({
  format: "YYYY-MM-DD HH:mm:ss"
}), import_winston.default.format.printf(({ level, message, timestamp, ...meta }) => {
  const formattedMessage = typeof message === "object" ? JSON.stringify(message, null, 2) : message;
  const formattedMeta = meta && Object.keys(meta).length ? JSON.stringify(meta, null, 2) : "";
  return `${formattedMeta} ${timestamp} [${level}]: ${formattedMessage}`;
}));
var logger = import_winston.default.createLogger({
  level: logLevel,
  format: import_winston.default.format.json(),
  transports: [
    new import_winston_daily_rotate_file.default({
      filename: "logs/log-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      maxSize: "20m",
      maxFiles: "14d"
    }),
    new import_winston_daily_rotate_file.default({
      level: "error",
      filename: "logs/error-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      maxSize: "20m",
      maxFiles: "14d"
    })
  ]
});
if (true) {
  logger.add(new import_winston.default.transports.Console({
    level: logLevel,
    format: logFormat
  }));
}
logger.level = logLevel;

// src/relayer/common/utils/AppError.ts
class AppError extends Error {
  isOperational;
  constructor(errorType, originalError) {
    const { message, isOperational } = appErrors[errorType];
    super(originalError ? `${message}: ${originalError.message}` : message);
    Object.setPrototypeOf(this, new.target.prototype);
    this.name = this.constructor.name;
    this.isOperational = isOperational;
    Error.captureStackTrace(this);
    this.logError();
  }
  logError() {
    logger.error({
      name: this.name,
      message: this.message,
      stack: this.stack,
      isOperational: this.isOperational
    });
    if (!this.isOperational) {
      process.exit(1);
    }
  }
}
// src/relayer/common/utils/callContract.ts
async function callContract(publicClient, walletClient, simulateContractParams) {
  try {
    const { request } = await publicClient.simulateContract(simulateContractParams);
    const hash2 = await walletClient.writeContract(request);
    const { cumulativeGasUsed } = await publicClient.waitForTransactionReceipt({
      ...globalConfig.VIEM.RECEIPT,
      hash: hash2
    });
    return hash2;
  } catch (error) {
    throw new AppError("ContractCallError" /* ContractCallError */, error);
  }
}
// src/relayer/common/utils/checkGas.ts
var MINIMUM_NATIVE_VALUE = 1e6;
async function checkGas() {
  const networkIds = globalConfig.WHITELISTED_NETWORK_IDS[globalConfig.NETWORK_MODE];
  const operatorAddress = globalConfig.OPERATOR_ADDRESS;
  try {
    const balancePromises = networkIds.map(async (networkId) => {
      const chain = activeNetworks.find((network) => network.id === networkId);
      if (!chain) {
        throw new AppError("ChainNotFound" /* ChainNotFound */);
      }
      const { publicClient } = await getFallbackClients(chain);
      const balance = await publicClient.getBalance({
        address: operatorAddress
      });
      return { networkId, balance };
    });
    const balances = await Promise.all(balancePromises);
    balances.forEach(({ networkId, balance }) => {
      if (balance < MINIMUM_NATIVE_VALUE) {
        throw new AppError("InsufficientGas" /* InsufficientGas */, Error(`Insufficient gas on ${networkId}. Minimum required: ${MINIMUM_NATIVE_VALUE}, actual: ${balance}`));
      }
    });
    logger.info("All chains have sufficient gas.");
  } catch (error) {
    logger.error("Error checking gas balances:", error);
    throw error;
  }
}
// src/relayer/common/utils/configureDotEnv.ts
var dotenv = __toESM(require_main(), 1);
var ENV_FILES = [".env", ".env.wallets", ".env.deployments.testnet", ".env.deployments.mainnet"];
function configureDotEnv(basePath = "./") {
  const normalizedBasePath = basePath.endsWith("/") ? basePath : `${basePath}/`;
  ENV_FILES.forEach((file) => {
    dotenv.config({ path: `${normalizedBasePath}${file}` });
  });
}
// src/relayer/common/utils/decodeCLFReport.ts
var abiParameters = parseAbiParameters([
  "bytes32[3] reportContext",
  "bytes report",
  "bytes32[] rs",
  "bytes32[] ss",
  "bytes32 rawVs"
]);
var reportAbiParameters = parseAbiParameters([
  "bytes32[] requestIds",
  "bytes[] results",
  "bytes[] errors",
  "bytes[] onchainMetadata",
  "bytes[] offchainMetadata"
]);
function decodeCLFReport(tx) {
  const inputData = tx.input.slice(10);
  const decodedData = decodeAbiParameters(abiParameters, `0x${inputData}`);
  const reportBytes = decodedData[1];
  const decodedReport = decodeAbiParameters(reportAbiParameters, reportBytes);
  const report = {
    reportContext: decodedData[0],
    report: {
      requestIds: decodedReport[0],
      results: decodedReport[1],
      errors: decodedReport[2],
      onchainMetadata: decodedReport[3],
      offchainMetadata: decodedReport[4]
    },
    rs: decodedData[2],
    ss: decodedData[3],
    rawVs: decodedData[4],
    reportBytes
  };
  return report;
}
function decodeCLFReportResult(results) {
  const response = [];
  results.forEach((bytes, i) => {
    const buffer2 = Buffer.from(bytes.slice(2), "hex");
    let offset2 = 0;
    const _uint8 = buffer2.readUInt8(offset2);
    offset2 += 1;
    const messageId = "0x" + buffer2.slice(offset2, offset2 + 32).toString("hex");
    offset2 += 32;
    const messageHash = "0x" + buffer2.slice(offset2, offset2 + 32).toString("hex");
    offset2 += 32;
    const srcChainSelector = buffer2.readBigUInt64BE(offset2);
    offset2 += 8;
    const srcBlockNumber = buffer2.readBigUInt64BE(offset2);
    offset2 += 8;
    const decodedResult = {
      _: _uint8,
      messageId,
      messageHash,
      srcChainSelector: srcChainSelector.toString(),
      srcBlockNumber: srcBlockNumber.toString()
    };
    response.push(decodedResult);
  });
  return response[0];
}
// src/relayer/common/utils/httpClient.ts
var { RETRY_DELAY, MAX_RETRIES, DEFAULT_TIMEOUT } = globalConfig.HTTPCLIENT;

class HttpClient {
  async fetchWithTimeout(resource, options, timeout) {
    const controller = new AbortController;
    const id = setTimeout(() => controller.abort(), timeout);
    try {
      const response = await fetch(resource, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(id);
      return response;
    } catch (error) {
      clearTimeout(id);
      throw new AppError("FailedHTTPRequest" /* FailedHTTPRequest */, error);
    }
  }
  async retryFetch(resource, options, retries, timeout) {
    try {
      const response = await this.fetchWithTimeout(resource, options, timeout);
      if (!response.ok) {
        throw new AppError("FailedHTTPRequest" /* FailedHTTPRequest */, new Error(`HTTP error! status: ${response.status}`));
      }
      return response;
    } catch (error) {
      if (retries > 0) {
        logger.debug(`Retrying HTTP request (${MAX_RETRIES - retries + 1}/${MAX_RETRIES})`);
        await new Promise((res) => setTimeout(res, RETRY_DELAY));
        return this.retryFetch(resource, options, retries - 1, timeout);
      } else {
        throw new AppError("FailedHTTPRequest" /* FailedHTTPRequest */, error);
      }
    }
  }
  async get(url, options = {}, timeout = DEFAULT_TIMEOUT) {
    logger.debug(`GET request to ${url} with options: ${JSON.stringify(options)}`);
    const response = await this.retryFetch(url, { ...options, method: "GET" }, MAX_RETRIES, timeout);
    return response.json();
  }
  async post(url, body, options = {}, timeout = DEFAULT_TIMEOUT) {
    logger.debug(`POST request to ${url} with body: ${JSON.stringify(body)} and options: ${JSON.stringify(options)}`);
    const response = await this.retryFetch(url, { ...options, method: "POST", body: JSON.stringify(body) }, MAX_RETRIES, timeout);
    return response.json();
  }
}
var httpClient = new HttpClient;

// src/relayer/common/utils/fetchers.ts
var fetchRpcUrls = async (chainId) => {
  if (globalConfig.NETWORK_MODE === "localhost") {
    return [process.env.LOCALHOST_RPC_URL];
  }
  const urls = await httpClient.get(`${globalConfig.URLS.CONCERO_RPCS}${chainId}.json`);
  return urls.map((url) => `https://${url}`);
};
// src/relayer/common/utils/getChainBySelector.ts
function getChainBySelector(selector) {
  for (const chain in conceroNetworks) {
    if (conceroNetworks[chain].chainSelector === selector) {
      return conceroNetworks[chain];
    }
  }
  throw new Error(`Chain with selector ${selector} not found`);
}
// node_modules/viem/_esm/accounts/privateKeyToAccount.js
init_secp256k1();
init_toHex();

// node_modules/viem/_esm/accounts/toAccount.js
init_address();
init_isAddress();
function toAccount(source) {
  if (typeof source === "string") {
    if (!isAddress(source, { strict: false }))
      throw new InvalidAddressError({ address: source });
    return {
      address: source,
      type: "json-rpc"
    };
  }
  if (!isAddress(source.address, { strict: false }))
    throw new InvalidAddressError({ address: source.address });
  return {
    address: source.address,
    nonceManager: source.nonceManager,
    sign: source.sign,
    experimental_signAuthorization: source.experimental_signAuthorization,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: "custom",
    type: "local"
  };
}

// node_modules/viem/_esm/accounts/utils/sign.js
init_secp256k1();
init_toHex();
var extraEntropy = false;
async function sign2({ hash: hash2, privateKey, to: to3 = "object" }) {
  const { r, s: s3, recovery } = secp256k1.sign(hash2.slice(2), privateKey.slice(2), { lowS: true, extraEntropy });
  const signature = {
    r: numberToHex(r, { size: 32 }),
    s: numberToHex(s3, { size: 32 }),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
  return (() => {
    if (to3 === "bytes" || to3 === "hex")
      return serializeSignature({ ...signature, to: to3 });
    return signature;
  })();
}

// node_modules/viem/_esm/accounts/utils/signAuthorization.js
async function experimental_signAuthorization(parameters) {
  const { contractAddress, chainId, nonce, privateKey, to: to3 = "object" } = parameters;
  const signature = await sign2({
    hash: hashAuthorization({ contractAddress, chainId, nonce }),
    privateKey,
    to: to3
  });
  if (to3 === "object")
    return {
      contractAddress,
      chainId,
      nonce,
      ...signature
    };
  return signature;
}

// node_modules/viem/_esm/accounts/utils/signMessage.js
async function signMessage2({ message, privateKey }) {
  return await sign2({ hash: hashMessage(message), privateKey, to: "hex" });
}

// node_modules/viem/_esm/accounts/utils/signTransaction.js
init_keccak256();
async function signTransaction2(parameters) {
  const { privateKey, transaction, serializer = serializeTransaction } = parameters;
  const signableTransaction = (() => {
    if (transaction.type === "eip4844")
      return {
        ...transaction,
        sidecars: false
      };
    return transaction;
  })();
  const signature = await sign2({
    hash: keccak256(serializer(signableTransaction)),
    privateKey
  });
  return serializer(transaction, signature);
}

// node_modules/viem/_esm/accounts/utils/signTypedData.js
async function signTypedData2(parameters) {
  const { privateKey, ...typedData } = parameters;
  return await sign2({
    hash: hashTypedData(typedData),
    privateKey,
    to: "hex"
  });
}

// node_modules/viem/_esm/accounts/privateKeyToAccount.js
function privateKeyToAccount(privateKey, options = {}) {
  const { nonceManager } = options;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = toAccount({
    address,
    nonceManager,
    async sign({ hash: hash2 }) {
      return sign2({ hash: hash2, privateKey, to: "hex" });
    },
    async experimental_signAuthorization(authorization) {
      return experimental_signAuthorization({ ...authorization, privateKey });
    },
    async signMessage({ message }) {
      return signMessage2({ message, privateKey });
    },
    async signTransaction(transaction, { serializer } = {}) {
      return signTransaction2({ privateKey, transaction, serializer });
    },
    async signTypedData(typedData) {
      return signTypedData2({ ...typedData, privateKey });
    }
  });
  return {
    ...account,
    publicKey,
    source: "privateKey"
  };
}
// src/relayer/common/utils/getViemClients.ts
class ViemClientManager {
  clients = new Map;
  rpcUrls = {};
  constructor() {
    this.setupUpdateLoop(activeNetworks);
  }
  createTransport(chain) {
    return fallback(this.rpcUrls[chain.name].map((url) => http(url)), globalConfig.VIEM.FALLBACK_TRANSPORT_OPTIONS);
  }
  initializeClients(chain) {
    const privateKey = getEnvVar("OPERATOR_PRIVATE_KEY");
    const account = privateKeyToAccount(`0x${privateKey}`);
    const transport = this.createTransport(chain);
    const publicClient = createPublicClient({ transport, chain: chain.viemChain });
    const walletClient = createWalletClient({ transport, chain: chain.viemChain, account });
    return {
      publicClient,
      walletClient,
      account,
      lastRotation: Date.now()
    };
  }
  rotateClients(chain) {
    const newClients = this.initializeClients(chain);
    this.clients.set(chain.name, newClients);
    return newClients;
  }
  async getClients(chain) {
    if (Object.keys(this.rpcUrls).length === 0) {
      await this.initializeRpcUrls(activeNetworks);
    }
    const cachedClients = this.clients.get(chain.name);
    if (cachedClients) {
      return cachedClients;
    }
    const newClients = this.initializeClients(chain);
    this.clients.set(chain.name, newClients);
    return newClients;
  }
  rotateViemClients(chain) {
    setTimeout(() => {
      this.rotateClients(chain);
      logger.debug(`Clients rotated for chain: ${chain.name}`);
    }, 0);
  }
  async updateRpcUrls(chains) {
    for (const chain of chains) {
      const newUrls = await fetchRpcUrls(chain.viemChain.id);
      this.rpcUrls[chain.name] = newUrls;
      this.rotateViemClients(chain);
    }
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async setupUpdateLoop(chains) {
    while (true) {
      await this.updateRpcUrls(chains);
      await this.sleep(globalConfig.VIEM.CLIENT_ROTATION_INTERVAL_MS);
    }
  }
  async initializeRpcUrls(chains) {
    for (const chain of chains) {
      const urls = await fetchRpcUrls(chain.viemChain.id);
      this.rpcUrls[chain.name] = urls;
    }
  }
  async getFallbackClients(chain) {
    const clients = await this.getClients(chain);
    return clients;
  }
}
var viemClientManager = new ViemClientManager;
async function getFallbackClients(chain) {
  const clients = await viemClientManager.getFallbackClients(chain);
  return clients;
}
// src/relayer/a/constants/config.ts
var conceroRouterNetworks;
var conceroVerifierNetwork;
switch (globalConfig.NETWORK_MODE) {
  case "testnet":
    conceroRouterNetworks = testnetNetworks;
    conceroVerifierNetwork = conceroNetworks.baseSepolia;
    break;
  case "localhost":
    conceroRouterNetworks = [conceroNetworks.localhost];
    conceroVerifierNetwork = conceroNetworks.localhost;
    break;
  case "mainnet":
    conceroRouterNetworks = mainnetNetworks;
    conceroVerifierNetwork = conceroNetworks.base;
    break;
  default:
    throw new AppError("InvalidNetworkMode" /* InvalidNetworkMode */);
}
var config2 = {
  networks: {
    conceroRouter: conceroRouterNetworks,
    conceroVerifier: conceroVerifierNetwork
  }
};
// src/relayer/a/constants/eventNames.ts
var eventNames = {
  ConceroMessageSent: "ConceroMessageSent",
  CLFMessageReport: "CLFMessageReport"
};
// src/relayer/a/contractCaller/ensureDeposit.ts
async function getMinimumDeposit() {
  const conceroVerifierNetwork2 = config2.networks.conceroVerifier;
  const { publicClient } = await getFallbackClients(conceroVerifierNetwork2);
  const depositAmount = await publicClient.readContract({
    chain: conceroVerifierNetwork2.viemChain,
    address: conceroNetworks[conceroVerifierNetwork2.name].addresses.conceroVerifier,
    abi: globalConfig.ABI.CONCERO_VERIFIER,
    functionName: "getCLFDeposit",
    args: []
  });
  return BigInt(depositAmount);
}
async function getCurrentOperatorDeposit() {
  const conceroVerifierNetwork2 = config2.networks.conceroVerifier;
  const { publicClient } = await getFallbackClients(conceroVerifierNetwork2);
  const currentDeposit = await publicClient.readContract({
    chain: conceroVerifierNetwork2.viemChain,
    address: conceroNetworks[conceroVerifierNetwork2.name].addresses.conceroVerifier,
    abi: globalConfig.ABI.CONCERO_VERIFIER,
    functionName: "getOperatorDeposit",
    args: [globalConfig.OPERATOR_ADDRESS]
  });
  return BigInt(currentDeposit);
}
async function ensureDeposit() {
  const conceroVerifierNetwork2 = config2.networks.conceroVerifier;
  const { publicClient, walletClient, account } = await getFallbackClients(conceroVerifierNetwork2);
  const requiredDeposit = await getMinimumDeposit();
  const currentDeposit = await getCurrentOperatorDeposit();
  if (currentDeposit >= requiredDeposit) {
    logger.info(`Sufficient deposit of ${currentDeposit} already exists`);
    return;
  }
  const txHash = await callContract(publicClient, walletClient, {
    chain: conceroVerifierNetwork2.viemChain,
    address: conceroNetworks[conceroVerifierNetwork2.name].addresses.conceroVerifier,
    abi: globalConfig.ABI.CONCERO_VERIFIER,
    functionName: "operatorDeposit",
    args: [globalConfig.OPERATOR_ADDRESS],
    value: requiredDeposit,
    account
  });
  logger.info(`Deposited ${requiredDeposit} to ConceroVerifier with hash ${txHash}`);
  return txHash;
}

// src/relayer/common/eventListener/setupEventListener.ts
async function setupEventListener(network, contractAddress, onLogs, pollingIntervalMs) {
  const { publicClient } = await getFallbackClients(network);
  let lastBlockNumber = await publicClient.getBlockNumber();
  logger.info(`[${network.name}] Monitoring contract: ${contractAddress} from block ${lastBlockNumber}`);
  let cancelled = false;
  let timerId;
  async function pollLogs() {
    if (cancelled)
      return;
    try {
      const { publicClient: publicClient2 } = await getFallbackClients(network);
      const latestBlockNumber = await publicClient2.getBlockNumber();
      if (latestBlockNumber > lastBlockNumber) {
        const logs = await publicClient2.getLogs({
          address: contractAddress,
          fromBlock: lastBlockNumber + 1n,
          toBlock: latestBlockNumber
        });
        if (logs.length > 0) {
          onLogs(logs, network);
        }
        lastBlockNumber = latestBlockNumber;
      }
    } catch (error) {
      logger.error(`[${network.name}] Error in polling loop for contract ${contractAddress}:`, error);
    } finally {
      if (!cancelled) {
        timerId = setTimeout(pollLogs, pollingIntervalMs);
      }
    }
  }
  pollLogs();
  const stop = () => {
    cancelled = true;
    if (timerId)
      clearTimeout(timerId);
  };
  return { stop };
}

// src/relayer/a/contractCaller/ensureOperatorIsRegistered.ts
var ChainType = {
  EVM: 0,
  NON_EVM: 1
};
var OperatorRegistrationAction = {
  Deregister: 0,
  Register: 1
};
async function isOperatorRegistered(publicClient) {
  const conceroVerifierNetwork2 = config2.networks.conceroVerifier;
  const isRegistered = await publicClient.readContract({
    chain: conceroVerifierNetwork2.viemChain,
    address: conceroNetworks[conceroVerifierNetwork2.name].addresses.conceroVerifier,
    abi: globalConfig.ABI.CONCERO_VERIFIER,
    functionName: "isOperatorRegistered",
    args: [globalConfig.OPERATOR_ADDRESS]
  });
  return isRegistered;
}
async function requestOperatorRegistration(publicClient, walletClient, account) {
  const conceroVerifierNetwork2 = config2.networks.conceroVerifier;
  const chainTypes = [BigInt(ChainType.EVM)];
  const operatorActions = [BigInt(OperatorRegistrationAction.Register)];
  const operatorAddresses = [globalConfig.OPERATOR_ADDRESS];
  const txHash = await callContract(publicClient, walletClient, {
    chain: conceroVerifierNetwork2.viemChain,
    address: conceroNetworks[conceroVerifierNetwork2.name].addresses.conceroVerifier,
    abi: globalConfig.ABI.CONCERO_VERIFIER,
    functionName: "requestOperatorRegistration",
    args: [chainTypes, operatorActions, operatorAddresses],
    account
  });
  return txHash;
}
async function waitForOperatorRegistration(network, contractAddress, fromBlockNumber, operatorAddress) {
  const conceroVerifierAbi2 = await Promise.resolve().then(() => __toESM(require_ConceroVerifier(), 1));
  return new Promise((resolve, reject) => {
    let listenerHandle;
    const onLogs = (_chain, _address, logs) => {
      for (const log of logs) {
        try {
          const decoded = decodeEventLog({
            abi: conceroVerifierAbi2,
            eventName: "operatorRegistered",
            data: log.data,
            topics: log.topics
          });
          if (decoded && decoded.operatorAddress && decoded.operatorAddress.toLowerCase() === operatorAddress.toLowerCase() && BigInt(log.blockNumber) >= fromBlockNumber) {
            listenerHandle.stop();
            resolve();
            break;
          }
        } catch (error) {
        }
      }
    };
    setupEventListener(network, contractAddress, onLogs, globalConfig.POLLING_INTERVAL_MS).then((handle) => {
      listenerHandle = handle;
    }).catch(reject);
  });
}
async function ensureOperatorIsRegistered() {
  const conceroVerifierNetwork2 = config2.networks.conceroVerifier;
  const { publicClient, walletClient, account } = await getFallbackClients(conceroVerifierNetwork2);
  const registered = await isOperatorRegistered(publicClient);
  if (registered) {
    logger.info("Operator already registered");
    return;
  }
  const txHash = await requestOperatorRegistration(publicClient, walletClient, account);
  logger.info(`Requested operator registration with txHash ${txHash}`);
  const transaction = await publicClient.getTransaction({ hash: txHash });
  const confirmedTxHash = await waitForOperatorRegistration(conceroVerifierNetwork2, conceroNetworks[conceroVerifierNetwork2.name].addresses.conceroVerifier, transaction.blockNumber, globalConfig.OPERATOR_ADDRESS);
  logger.info(`Operator registration confirmed with txHash ${confirmedTxHash}`);
}

// src/relayer/common/eventListener/decodeLogs.ts
function decodeLogs(logs, abi3) {
  const decodedLogs = [];
  logs.forEach((log) => {
    try {
      const decodedLog = decodeEventLog({
        abi: abi3,
        data: log.data,
        topics: log.topics,
        strict: false
      });
      decodedLogs.push({ ...log, ...decodedLog });
    } catch (error) {
      if (error instanceof AbiEventSignatureNotFoundError)
        return;
      throw new AppError("LogDecodingFailed" /* LogDecodingFailed */, error);
    }
  });
  return decodedLogs;
}

// src/relayer/a/contractCaller/requestCLFMessageReport.ts
async function requestCLFMessageReport(log) {
  const { chainName: chainName2, decodedLog } = log;
  const { id, message } = decodedLog.args;
  try {
    const [address] = getEnvAddress("verifierProxy", chainName2);
    const hash2 = await callContract({
      chain: config2.networks.conceroVerifier,
      address,
      abi: globalConfig.ABI.CONCERO_VERIFIER,
      functionName: "requestCLFMessageReport",
      args: [id, message]
    });
    logger.info(`[${chainName2}] CLF message report requested with hash: ${hash2}`);
  } catch (error) {
    logger.error(`[${chainName2}] Error requesting CLF message report:`, error);
  }
}

// src/relayer/a/contractCaller/submitCLFMessageReport.ts
async function submitCLFMessageReport(log) {
  const { address, transactionHash, args } = log;
  const { conceroId } = args;
  const { publicClient: verifierPublicClient } = await getFallbackClients(config2.networks.conceroVerifier);
  const messageReportTx = await verifierPublicClient.getTransaction({ hash: transactionHash });
  const decodedCLFReport = decodeCLFReport(messageReportTx);
  const decodedCLFResult = decodeCLFReportResult(decodedCLFReport.report.results);
  const srcChain = getChainBySelector(decodedCLFResult.srcChainSelector);
  const { publicClient: srcPublicClient } = await getFallbackClients(srcChain);
  const [srcContractAddress] = getEnvAddress("routerProxy", srcChain.name);
  const logs = await srcPublicClient.getLogs({
    address: srcContractAddress,
    topics: [null, decodedCLFResult.messageId],
    fromBlock: BigInt(decodedCLFResult.srcBlockNumber),
    toBlock: BigInt(decodedCLFResult.srcBlockNumber)
  });
  const decodedLogs = [];
  logs.forEach((log2) => {
    try {
      const decodedLog = decodeEventLog({
        abi: globalConfig.ABI.CONCERO_ROUTER,
        data: log2.data,
        topics: log2.topics,
        strict: false
      });
      decodedLogs.push({ ...log2, decodedLog, chainName });
    } catch (error) {
      console.error(`[${chainName}] Error decoding log:`, error);
    }
  });
  const [conceroMessageSentLog] = decodedLogs.filter((log2) => log2.decodedLog.eventName === eventNames.ConceroMessageSent);
  const { message } = conceroMessageSentLog.decodedLog.args;
  const dstChain = getChainBySelector(message.dstChainSelector.toString());
  const [dstConceroRouter] = getEnvAddress("routerProxy", dstChain.name);
  const { publicClient: dstPublicClient } = getFallbackClients(dstChain);
  const reportSubmission = {
    context: decodedCLFReport.reportContext,
    report: decodedCLFReport.reportBytes,
    rs: decodedCLFReport.rs,
    ss: decodedCLFReport.ss,
    rawVs: decodedCLFReport.rawVs
  };
  const hash2 = await callContract({
    chain: dstChain,
    address: dstConceroRouter,
    abi: globalConfig.ABI.CONCERO_ROUTER,
    functionName: "submitMessageReport",
    args: [reportSubmission, message]
  });
  logger.info(`[${chainName}] CLF message report submitted with hash: ${hash2}`);
}

// src/relayer/a/eventListener/onLogs.ts
var logsAbi = {
  conceroRouter: [
    getAbiItem({
      abi: globalConfig.ABI.CONCERO_ROUTER,
      name: eventNames.ConceroMessageSent
    })
  ],
  conceroVerifier: [
    getAbiItem({
      abi: globalConfig.ABI.CONCERO_VERIFIER,
      name: eventNames.CLFMessageReport
    })
  ]
};
async function onRouterLogs(logs) {
  const decodedLogs = decodeLogs(logs, logsAbi.conceroRouter);
  for (const log of decodedLogs) {
    if (log.eventName === eventNames.ConceroMessageSent) {
      await requestCLFMessageReport(log);
    }
  }
}
async function onVerifierLogs(logs) {
  const decodedLogs = decodeLogs(logs, logsAbi.conceroVerifier);
  for (const log of decodedLogs) {
    if (log.eventName === eventNames.CLFMessageReport) {
      await submitCLFMessageReport(log);
    }
  }
}

// src/relayer/a/eventListener/setupEventListeners.ts
async function setupEventListeners() {
  for (const [networkKey, network] of Object.entries(config2.networks.conceroRouter)) {
    const [contractAddress2] = getEnvAddress("routerProxy", network.name);
    await setupEventListener(network, contractAddress2, onRouterLogs, globalConfig.POLLING_INTERVAL_MS);
  }
  const verifierNetwork = config2.networks.conceroVerifier;
  const [contractAddress] = getEnvAddress("verifierProxy", verifierNetwork.name);
  await setupEventListener(verifierNetwork, contractAddress, onVerifierLogs, globalConfig.POLLING_INTERVAL_MS);
}

// src/relayer/a/index.ts
var globalErrorHandler = (error) => {
  if (error instanceof AppError) {
    if (!error.isOperational) {
      process.exit(1);
    }
  } else {
    const appError = new AppError("UnknownError" /* UnknownError */, error);
    if (!appError.isOperational) {
      process.exit(1);
    }
  }
};
process.on("unhandledRejection", (reason) => {
  globalErrorHandler(new AppError("UnhandledRejection" /* UnhandledRejection */, reason instanceof Error ? reason : new Error(String(reason))));
});
process.on("uncaughtException", (error) => {
  globalErrorHandler(new AppError("UncaughtException" /* UncaughtException */, error));
});
async function main() {
  configureDotEnv();
  await checkGas();
  await ensureDeposit();
  await ensureOperatorIsRegistered();
  await setupEventListeners();
}
main();
